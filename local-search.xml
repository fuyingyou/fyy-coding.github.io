<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git基本操作</title>
    <link href="/2024/03/18/Git/"/>
    <url>/2024/03/18/Git/</url>
    
    <content type="html"><![CDATA[<p>两棵树<br>树有分支 分支有结点<br>保持分支同步</p><h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><h5 id="克隆代码到本地仓库"><a href="#克隆代码到本地仓库" class="headerlink" title="克隆代码到本地仓库"></a>克隆代码到本地仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone http://xxx.git<br></code></pre></td></tr></table></figure><h5 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch<br></code></pre></td></tr></table></figure><h5 id="切换到本地主分支"><a href="#切换到本地主分支" class="headerlink" title="切换到本地主分支"></a>切换到本地主分支</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout 分支名<br></code></pre></td></tr></table></figure><h5 id="下拉代码到主分支，保证主分支是最新代码"><a href="#下拉代码到主分支，保证主分支是最新代码" class="headerlink" title="下拉代码到主分支，保证主分支是最新代码"></a>下拉代码到主分支，保证主分支是最新代码</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull origin 分支名<br></code></pre></td></tr></table></figure><h5 id="从本地主分支切换自己分支"><a href="#从本地主分支切换自己分支" class="headerlink" title="从本地主分支切换自己分支"></a>从本地主分支切换自己分支</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b 自己分支名<br></code></pre></td></tr></table></figure><h3 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h3><h5 id="查看修改的内容，确认修改的内容"><a href="#查看修改的内容，确认修改的内容" class="headerlink" title="查看修改的内容，确认修改的内容"></a>查看修改的内容，确认修改的内容</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git status -s<br></code></pre></td></tr></table></figure><h5 id="同步分支"><a href="#同步分支" class="headerlink" title="同步分支"></a>同步分支</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull origin 分支名<br></code></pre></td></tr></table></figure><h5 id="所有文件，git-status-s-查出，添加到暂存区（索引区）"><a href="#所有文件，git-status-s-查出，添加到暂存区（索引区）" class="headerlink" title="所有文件，git status -s 查出，添加到暂存区（索引区）"></a>所有文件，git status -s 查出，添加到暂存区（索引区）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br></code></pre></td></tr></table></figure><h5 id="指定文件，git-status-s-得出"><a href="#指定文件，git-status-s-得出" class="headerlink" title="指定文件，git status -s 得出"></a>指定文件，git status -s 得出</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add 文件全路径<br></code></pre></td></tr></table></figure><h5 id="提交到本地分支"><a href="#提交到本地分支" class="headerlink" title="提交到本地分支"></a>提交到本地分支</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m&#x27;本次提交注释&#x27;<br></code></pre></td></tr></table></figure><h5 id="第一次push，推送并创建远程分支"><a href="#第一次push，推送并创建远程分支" class="headerlink" title="第一次push，推送并创建远程分支"></a>第一次push，推送并创建远程分支</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push --set-upstream origin 远程分支名<br></code></pre></td></tr></table></figure><h5 id="非第一次push，推送"><a href="#非第一次push，推送" class="headerlink" title="非第一次push，推送"></a>非第一次push，推送</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB高可用.md</title>
    <link href="/2024/03/18/DB/MongoDB/7.%20MongoDB%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <url>/2024/03/18/DB/MongoDB/7.%20MongoDB%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB索引.md</title>
    <link href="/2024/03/18/DB/MongoDB/6.%20MongoDB%E7%B4%A2%E5%BC%95/"/>
    <url>/2024/03/18/DB/MongoDB/6.%20MongoDB%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="MongoDB-索引"><a href="#MongoDB-索引" class="headerlink" title="MongoDB 索引"></a>MongoDB 索引</h2><h3 id="MongoDB-索引有什么用"><a href="#MongoDB-索引有什么用" class="headerlink" title="#MongoDB 索引有什么用?"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#mongodb-%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">#</a>MongoDB 索引有什么用?</h3><p>和关系型数据库类似，MongoDB 中也有索引。索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须执行 <strong>集合扫描</strong> ，即扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量。并且，MongoDB 可以使用索引中的排序返回排序后的结果。</p><p>虽然索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。在执行写入操作时，除了要更新文档之外，还必须更新索引，这必然会影响写入的性能。因此，当有大量写操作而读操作少时，或者不考虑读操作的性能时，都不推荐建立索引。</p><h3 id="MongoDB-支持哪些类型的索引？"><a href="#MongoDB-支持哪些类型的索引？" class="headerlink" title="#MongoDB 支持哪些类型的索引？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#mongodb-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B4%A2%E5%BC%95">#</a>MongoDB 支持哪些类型的索引？</h3><p><strong>MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</strong></p><ul><li><strong>单字段索引：</strong> 建立在单个字段上的索引，索引创建的排序顺序无所谓，MongoDB 可以头&#x2F;尾开始遍历。</li><li><strong>复合索引：</strong> 建立在多个字段上的索引，也可以称之为组合索引、联合索引。</li><li><strong>多键索引</strong>：MongoDB 的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。</li><li><strong>哈希索引</strong>：按数据的哈希值索引，用在哈希分片集群上。</li><li><strong>文本索引：</strong> 支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。</li><li><strong>地理位置索引：</strong> 基于经纬度的索引，适合 2D 和 3D 的位置查询。</li><li><strong>唯一索引</strong>：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。</li><li><strong>TTL 索引</strong>：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除。</li><li>……</li></ul><h3 id="复合索引中字段的顺序有影响吗？"><a href="#复合索引中字段的顺序有影响吗？" class="headerlink" title="#复合索引中字段的顺序有影响吗？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E5%AD%97%E6%AE%B5%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9C%89%E5%BD%B1%E5%93%8D%E5%90%97">#</a>复合索引中字段的顺序有影响吗？</h3><p>复合索引中字段的顺序非常重要，例如下图中的复合索引由<code>&#123;userid:1, score:-1&#125;</code>组成，则该复合索引首先按照<code>userid</code>升序排序；然后再每个<code>userid</code>的值内，再按照<code>score</code>降序排序。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/mongodb-composite-index.png" alt="复合索引">复合索引</p><p>在复合索引中，按照何种方式排序，决定了该索引在查询中是否能被应用到。</p><p>走复合索引的排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.s2.find().sort(&#123;&quot;userid&quot;: <span class="hljs-number">1</span>, &quot;score&quot;: <span class="hljs-number">-1</span>&#125;)<br>db.s2.find().sort(&#123;&quot;userid&quot;: <span class="hljs-number">-1</span>, &quot;score&quot;: <span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><p>不走复合索引的排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.s2.find().sort(&#123;&quot;userid&quot;: <span class="hljs-number">1</span>, &quot;score&quot;: <span class="hljs-number">1</span>&#125;)<br>db.s2.find().sort(&#123;&quot;userid&quot;: <span class="hljs-number">-1</span>, &quot;score&quot;: <span class="hljs-number">-1</span>&#125;)<br>db.s2.find().sort(&#123;&quot;score&quot;: <span class="hljs-number">1</span>, &quot;userid&quot;: <span class="hljs-number">-1</span>&#125;)<br>db.s2.find().sort(&#123;&quot;score&quot;: <span class="hljs-number">1</span>, &quot;userid&quot;: <span class="hljs-number">1</span>&#125;)<br>db.s2.find().sort(&#123;&quot;score&quot;: <span class="hljs-number">-1</span>, &quot;userid&quot;: <span class="hljs-number">-1</span>&#125;)<br>db.s2.find().sort(&#123;&quot;score&quot;: <span class="hljs-number">-1</span>, &quot;userid&quot;: <span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><p>我们可以通过 explain 进行分析：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.s2.find().sort(&#123;&quot;score&quot;: <span class="hljs-number">-1</span>, &quot;userid&quot;: <span class="hljs-number">1</span>&#125;).explain()<br></code></pre></td></tr></table></figure><h3 id="复合索引遵循左前缀原则吗？"><a href="#复合索引遵循左前缀原则吗？" class="headerlink" title="#复合索引遵循左前缀原则吗？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E9%81%B5%E5%BE%AA%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E5%90%97">#</a>复合索引遵循左前缀原则吗？</h3><p><strong>MongoDB 的复合索引遵循左前缀原则</strong>：拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。比如说，有一个类似 <code>&#123;a: 1, b: 1, c: 1, ..., z: 1&#125;</code> 这样的索引，那么实际上也等于有了 <code>&#123;a: 1&#125;</code>、<code>&#123;a: 1, b: 1&#125;</code>、<code>&#123;a: 1, b: 1, c: 1&#125;</code> 等一系列索引，但是不会有 <code>&#123;b: 1&#125;</code> 这样的非左前缀的索引。</p><h3 id="什么是-TTL-索引？"><a href="#什么是-TTL-索引？" class="headerlink" title="#什么是 TTL 索引？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF-ttl-%E7%B4%A2%E5%BC%95">#</a>什么是 TTL 索引？</h3><p>TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间 <code>expireAfterSeconds</code> ，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 <code>expireAfterSeconds</code> 属性外，和普通索引一样。</p><p>数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。</p><p><strong>TTL 索引运行原理</strong>：</p><ul><li>MongoDB 会开启一个后台线程读取该 TTL 索引的值来判断文档是否过期，但不会保证已过期的数据会立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。</li><li>对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除是由主库删除后产生的 oplog 来做同步。</li></ul><p><strong>TTL 索引限制</strong>：</p><ul><li>TTL 索引是单字段索引。复合索引不支持 TTL</li><li><code>_id</code>字段不支持 TTL 索引。</li><li>无法在上限集合(Capped Collection)上创建 TTL 索引，因为 MongoDB 无法从上限集合中删除文档。</li><li>如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。</li></ul><h3 id="什么是覆盖索引查询？"><a href="#什么是覆盖索引查询？" class="headerlink" title="#什么是覆盖索引查询？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2">#</a>什么是覆盖索引查询？</h3><p>根据官方文档介绍，覆盖查询是以下的查询：</p><ul><li>所有的查询字段是索引的一部分。</li><li>结果中返回的所有字段都在同一索引中。</li><li>查询中没有字段等于<code>null</code>。</li></ul><p>由于所有出现在查询中的字段是索引的一部分， MongoDB 无需在整个数据文档中检索匹配查询条件和返回使用相同索引的查询结果。因为索引存在于内存中，从索引中获取数据比通过扫描文档读取数据要快得多。</p><p>举个例子：我们有如下 <code>users</code> 集合:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> ObjectId(<span class="hljs-string">&quot;53402597d852426020000002&quot;</span>)<span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;contact&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;987654321&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;dob&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01-01-1991&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;gender&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;M&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Tom Benzamin&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;user_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tombenzamin&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我们在 <code>users</code> 集合中创建联合索引，字段为 <code>gender</code> 和 <code>user_name</code> :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.users.ensureIndex(&#123;gender:<span class="hljs-number">1</span>,user_name:<span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><p>现在，该索引会覆盖以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.users.find(&#123;gender:&quot;M&quot;&#125;,&#123;user_name:<span class="hljs-number">1</span>,_id:<span class="hljs-number">0</span>&#125;)<br></code></pre></td></tr></table></figure><p>为了让指定的索引覆盖查询，必须显式地指定 <code>_id: 0</code> 来从结果中排除 <code>_id</code> 字段，因为索引不包括 <code>_id</code> 字段。</p><h2 id="MongoDB-高可用"><a href="#MongoDB-高可用" class="headerlink" title="#MongoDB 高可用"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#mongodb-%E9%AB%98%E5%8F%AF%E7%94%A8">#</a>MongoDB 高可用</h2><h3 id="复制集群"><a href="#复制集群" class="headerlink" title="#复制集群"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4">#</a>复制集群</h3><h4 id="什么是复制集群？"><a href="#什么是复制集群？" class="headerlink" title="#什么是复制集群？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4">#</a>什么是复制集群？</h4><p>MongoDB 的复制集群又称为副本集群，是一组维护相同数据集合的 mongod 进程。</p><p>客户端连接到整个 Mongodb 复制集群，主节点机负责整个复制集群的写，从节点可以进行读操作，但默认还是主节点负责整个复制集群的读。主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</p><p>通常来说，一个复制集群包含 1 个主节点（Primary），多个从节点（Secondary）以及零个或 1 个仲裁节点（Arbiter）。</p><ul><li><strong>主节点</strong>：整个集群的写操作入口，接收所有的写操作，并将集合所有的变化记录到操作日志中，即 oplog。主节点挂掉之后会自动选出新的主节点。</li><li><strong>从节点</strong>：从主节点同步数据，在主节点挂掉之后选举新节点。不过，从节点可以配置成 0 优先级，阻止它在选举中成为主节点。</li><li><strong>仲裁节点</strong>：这个是为了节约资源或者多机房容灾用，只负责主节点选举时投票不存数据，保证能有节点获得多数赞成票。</li></ul><p>下图是一个典型的三成员副本集群：</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/replica-set-read-write-operations-primary.png" alt="img"></p><p>主节点与备节点之间是通过 <strong>oplog（操作日志）</strong> 来同步数据的。oplog 是 local 库下的一个特殊的 <strong>上限集合(Capped Collection)</strong> ，用来保存写操作所产生的增量日志，类似于 MySQL 中 的 Binlog。</p><blockquote><p>  上限集合类似于定长的循环队列，数据顺序追加到集合的尾部，当集合空间达到上限时，它会覆盖集合中最旧的文档。上限集合的数据将会被顺序写入到磁盘的固定空间内，所以，I&#x2F;O 速度非常快，如果不建立索引，性能更好。</p></blockquote><p><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/replica-set-primary-with-two-secondaries.png" alt="img"></p><p>当主节点上的一个写操作完成后，会向 oplog 集合写入一条对应的日志，而从节点则通过这个 oplog 不断拉取到新的日志，在本地进行回放以达到数据同步的目的。</p><p>副本集最多有一个主节点。 如果当前主节点不可用，一个选举会抉择出新的主节点。MongoDB 的节点选举规则能够保证在 Primary 挂掉之后选取的新节点一定是集群中数据最全的一个。</p><h4 id="为什么要用复制集群？"><a href="#为什么要用复制集群？" class="headerlink" title="#为什么要用复制集群？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4">#</a>为什么要用复制集群？</h4><ul><li><strong>实现 failover</strong>：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li><li><strong>实现读写分离</strong>：我们可以设置从节点上可以读取数据，主节点负责写入数据，这样的话就实现了读写分离，减轻了主节点读写压力过大的问题。MongoDB 4.0 之前版本如果主库压力不大,不建议读写分离，因为写会阻塞读，除非业务对响应时间不是非常关注以及读取历史数据接受一定时间延迟。</li></ul><h3 id="分片集群"><a href="#分片集群" class="headerlink" title="#分片集群"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4">#</a>分片集群</h3><h4 id="什么是分片集群？"><a href="#什么是分片集群？" class="headerlink" title="#什么是分片集群？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4">#</a>什么是分片集群？</h4><p>分片集群是 MongoDB 的分布式版本，相较副本集，分片集群数据被均衡的分布在不同分片中， 不仅大幅提升了整个集群的数据容量上限，也将读写的压力分散到不同分片，以解决副本集性能瓶颈的难题。</p><p>MongoDB 的分片集群由如下三个部分组成（下图来源于<a href="https://www.mongodb.com/docs/manual/sharding/">官方文档对分片集群的介绍open in new window</a>）：</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/sharded-cluster-production-architecture.png" alt="img"></p><ul><li><strong>Config Servers</strong>：配置服务器，本质上是一个 MongoDB 的副本集，负责存储集群的各种元数据和配置，如分片地址、Chunks 等</li><li><strong>Mongos</strong>：路由服务，不存具体数据，从 Config 获取集群配置讲请求转发到特定的分片，并且整合分片结果返回给客户端。</li><li><strong>Shard</strong>：每个分片是整体数据的一部分子集，从 MongoDB3.6 版本开始，每个 Shard 必须部署为副本集（replica set）架构</li></ul><h4 id="为什么要用分片集群？"><a href="#为什么要用分片集群？" class="headerlink" title="#为什么要用分片集群？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4">#</a>为什么要用分片集群？</h4><p>随着系统数据量以及吞吐量的增长，常见的解决办法有两种：垂直扩展和水平扩展。</p><p>垂直扩展通过增加单个服务器的能力来实现，比如磁盘空间、内存容量、CPU 数量等；水平扩展则通过将数据存储到多个服务器上来实现，根据需要添加额外的服务器以增加容量。</p><p>类似于 Redis Cluster，MongoDB 也可以通过分片实现 <strong>水平扩展</strong> 。水平扩展这种方式更灵活，可以满足更大数据量的存储需求，支持更高吞吐量。并且，水平扩展所需的整体成本更低，仅仅需要相对较低配置的单机服务器即可，代价是增加了部署的基础设施和维护的复杂性。</p><p>也就是说当你遇到如下问题时，可以使用分片集群解决：</p><ul><li>存储容量受单机限制，即磁盘资源遭遇瓶颈。</li><li>读写能力受单机限制，可能是 CPU、内存或者网卡等资源遭遇瓶颈，导致读写能力无法扩展。</li></ul><h4 id="什么是分片键？"><a href="#什么是分片键？" class="headerlink" title="#什么是分片键？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E7%89%87%E9%94%AE">#</a>什么是分片键？</h4><p><strong>分片键（Shard Key）</strong> 是数据分区的前提， 从而实现数据分发到不同服务器上，减轻服务器的负担。也就是说，分片键决定了集合内的文档如何在集群的多个分片间的分布状况。</p><p>分片键就是文档里面的一个字段，但是这个字段不是普通的字段，有一定的要求：</p><ul><li>它必须在所有文档中都出现。</li><li>它必须是集合的一个索引，可以是单索引或复合索引的前缀索引，不能是多索引、文本索引或地理空间位置索引。</li><li>MongoDB 4.2 之前的版本，文档的分片键字段值不可变。MongoDB 4.2 版本开始，除非分片键字段是不可变的 <code>_id</code> 字段，否则您可以更新文档的分片键值。MongoDB 5.0 版本开始，实现了实时重新分片（live resharding），可以实现分片键的完全重新选择。</li><li>它的大小不能超过 512 字节。</li></ul><h4 id="如何选择分片键？"><a href="#如何选择分片键？" class="headerlink" title="#如何选择分片键？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%88%86%E7%89%87%E9%94%AE">#</a>如何选择分片键？</h4><p>选择合适的片键对 sharding 效率影响很大，主要基于如下四个因素（摘自<a href="https://cloud.tencent.com/document/product/240/44611">分片集群使用注意事项 - - 腾讯云文档open in new window</a>）：</p><ul><li><strong>取值基数</strong> 取值基数建议尽可能大，如果用小基数的片键，因为备选值有限，那么块的总数量就有限，随着数据增多，块的大小会越来越大，导致水平扩展时移动块会非常困难。 例如：选择年龄做一个基数，范围最多只有 100 个，随着数据量增多，同一个值分布过多时，导致 chunck 的增长超出 chuncksize 的范围，引起 jumbo chunk，从而无法迁移，导致数据分布不均匀，性能瓶颈。</li><li><strong>取值分布</strong> 取值分布建议尽量均匀，分布不均匀的片键会造成某些块的数据量非常大，同样有上面数据分布不均匀，性能瓶颈的问题。</li><li><strong>查询带分片</strong> 查询时建议带上分片，使用分片键进行条件查询时，mongos 可以直接定位到具体分片，否则 mongos 需要将查询分发到所有分片，再等待响应返回。</li><li><strong>避免单调递增或递减</strong> 单调递增的 sharding key，数据文件挪动小，但写入会集中，导致最后一篇的数据量持续增大，不断发生迁移，递减同理。</li></ul><p>综上，在选择片键时要考虑以上 4 个条件，尽可能满足更多的条件，才能降低 MoveChunks 对性能的影响，从而获得最优的性能体验。</p><h4 id="分片策略有哪些？"><a href="#分片策略有哪些？" class="headerlink" title="#分片策略有哪些？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E5%88%86%E7%89%87%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>分片策略有哪些？</h4><p>MongoDB 支持两种分片算法来满足不同的查询需求（摘自<a href="https://help.aliyun.com/document_detail/64561.html?spm=a2c4g.11186623.0.0.3121565eQhUGGB#h2--shard-key-3">MongoDB 分片集群介绍 - 阿里云文档open in new window</a>）：</p><p><strong>1、基于范围的分片</strong>：</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/example-of-scope-based-sharding.png" alt="img"></p><p>MongoDB 按照分片键（Shard Key）的值的范围将数据拆分为不同的块（Chunk），每个块包含了一段范围内的数据。当分片键的基数大、频率低且值非单调变更时，范围分片更高效。</p><ul><li>优点：Mongos 可以快速定位请求需要的数据，并将请求转发到相应的 Shard 节点中。</li><li>缺点：可能导致数据在 Shard 节点上分布不均衡，容易造成读写热点，且不具备写分散性。</li><li>适用场景：分片键的值不是单调递增或单调递减、分片键的值基数大且重复的频率低、需要范围查询等业务场景。</li></ul><p><strong>2、基于 Hash 值的分片</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/example-of-hash-based-sharding.png" alt="img"></p><p>MongoDB 计算单个字段的哈希值作为索引值，并以哈希值的范围将数据拆分为不同的块（Chunk）。</p><ul><li>优点：可以将数据更加均衡地分布在各 Shard 节点中，具备写分散性。</li><li>缺点：不适合进行范围查询，进行范围查询时，需要将读请求分发到所有的 Shard 节点。</li><li>适用场景：分片键的值存在单调递增或递减、片键的值基数大且重复的频率低、需要写入的数据随机分发、数据读取随机性较大等业务场景。</li></ul><p>除了上述两种分片策略，您还可以配置 <strong>复合片键</strong> ，例如由一个低基数的键和一个单调递增的键组成。</p><h4 id="分片数据如何存储？"><a href="#分片数据如何存储？" class="headerlink" title="#分片数据如何存储？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E5%88%86%E7%89%87%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8">#</a>分片数据如何存储？</h4><p><strong>Chunk（块）</strong> 是 MongoDB 分片集群的一个核心概念，其本质上就是由一组 Document 组成的逻辑数据单元。每个 Chunk 包含一定范围片键的数据，互不相交且并集为全部数据，即离散数学中<strong>划分</strong>的概念。</p><p>分片集群不会记录每条数据在哪个分片上，而是记录 Chunk 在哪个分片上一级这个 Chunk 包含哪些数据。</p><p>默认情况下，一个 Chunk 的最大值默认为 64MB（可调整，取值范围为 1~1024 MB。如无特殊需求，建议保持默认值），进行数据插入、更新、删除时，如果此时 Mongos 感知到了目标 Chunk 的大小或者其中的数据量超过上限，则会触发 <strong>Chunk 分裂</strong>。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/chunk-splitting-shard-a.png" alt="Chunk 分裂">Chunk 分裂</p><p>数据的增长会让 Chunk 分裂得越来越多。这个时候，各个分片上的 Chunk 数量可能会不平衡。Mongos 中的 <strong>均衡器(Balancer)</strong> 组件就会执行自动平衡，尝试使各个 Shard 上 Chunk 的数量保持均衡，这个过程就是 <strong>再平衡（Rebalance）</strong>。默认情况下，数据库和集合的 Rebalance 是开启的。</p><p>如下图所示，随着数据插入，导致 Chunk 分裂，让 AB 两个分片有 3 个 Chunk，C 分片只有一个，这个时候就会把 B 分配的迁移一个到 C 分片实现集群数据均衡。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/mongo-reblance-three-shards.png" alt="Chunk 迁移">Chunk 迁移</p><blockquote><p>  Balancer 是 MongoDB 的一个运行在 Config Server 的 Primary 节点上(自 MongoDB 3.4 版本起)的后台进程，它监控每个分片上 Chunk 数量，并在某个分片上 Chunk 数量达到阈值进行迁移。</p></blockquote><p>Chunk 只会分裂，不会合并，即使 chunkSize 的值变大。</p><p>Rebalance 操作是比较耗费系统资源的，我们可以通过在业务低峰期执行、预分片或者设置 Rebalance 时间窗等方式来减少其对 MongoDB 正常使用所带来的影响。</p><h4 id="Chunk-迁移原理是什么？"><a href="#Chunk-迁移原理是什么？" class="headerlink" title="#Chunk 迁移原理是什么？"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#chunk-%E8%BF%81%E7%A7%BB%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">#</a>Chunk 迁移原理是什么？</h4><p>关于 Chunk 迁移原理的详细介绍，推荐阅读 MongoDB 中文社区的<a href="https://mongoing.com/archives/77479">一文读懂 MongoDB chunk 迁移open in new window</a>这篇文章。</p><h2 id="学习资料推荐"><a href="#学习资料推荐" class="headerlink" title="#学习资料推荐"></a><a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%8E%A8%E8%8D%90">#</a>学习资料推荐</h2><ul><li><a href="https://docs.mongoing.com/">MongoDB 中文手册|官方文档中文版open in new window</a>（推荐）：基于 4.2 版本，不断与官方最新版保持同步。</li><li><a href="https://mongoing.com/archives/docs/mongodb%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%99%E7%A8%8B/mongodb%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9B%86%E5%90%88">MongoDB 初学者教程——7 天学习 MongoDBopen in new window</a>：快速入门。</li><li><a href="https://www.cnblogs.com/dxflqm/p/16643981.html">SpringBoot 整合 MongoDB 实战 - 2022open in new window</a>：很不错的一篇 MongoDB 入门文章，主要围绕 MongoDB 的 Java 客户端使用进行基本的增删改查操作介绍。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB数据压缩.md</title>
    <link href="/2024/03/18/DB/MongoDB/5.%20MongoDB%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"/>
    <url>/2024/03/18/DB/MongoDB/5.%20MongoDB%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB事务.md</title>
    <link href="/2024/03/18/DB/MongoDB/4.%20MongoDB%E4%BA%8B%E5%8A%A1/"/>
    <url>/2024/03/18/DB/MongoDB/4.%20MongoDB%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB聚合.md</title>
    <link href="/2024/03/18/DB/MongoDB/3.%20MongoDB%E8%81%9A%E5%90%88/"/>
    <url>/2024/03/18/DB/MongoDB/3.%20MongoDB%E8%81%9A%E5%90%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB存储引擎.md</title>
    <link href="/2024/03/18/DB/MongoDB/2.%20MongoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2024/03/18/DB/MongoDB/2.%20MongoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB基础.md</title>
    <link href="/2024/03/18/DB/MongoDB/1.%20MongoDB%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/18/DB/MongoDB/1.%20MongoDB%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="MongoDB-基础"><a href="#MongoDB-基础" class="headerlink" title="MongoDB 基础"></a>MongoDB 基础</h2><h3 id="MongoDB-是什么？"><a href="#MongoDB-是什么？" class="headerlink" title="MongoDB 是什么？"></a>MongoDB 是什么？</h3><p>MongoDB 是一个基于 <strong>分布式文件存储</strong> 的开源 NoSQL 数据库系统，由 <strong>C++</strong> 编写的。MongoDB 提供了 <strong>面向文档</strong> 的存储方式，操作起来比较简单和容易，支持“<strong>无模式</strong>”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 <strong>文档类型数据库</strong> 。</p><p>在高负载的情况下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点&#x2F;实例，以保证服务性能和可用性。在许多场景下，MongoDB 可以用于代替传统的关系型数据库或键&#x2F;值存储方式，皆在为 Web 应用提供可扩展的高可用高性能数据存储解决方案。</p><h3 id="MongoDB-的存储结构是什么？"><a href="#MongoDB-的存储结构是什么？" class="headerlink" title="MongoDB 的存储结构是什么？"></a>MongoDB 的存储结构是什么？</h3><p>MongoDB 的存储结构区别于传统的关系型数据库，主要由如下三个单元组成：</p><ul><li><p><strong>文档（Document）</strong>：MongoDB 中最基本的单元，由 BSON 键值对（key-value）组成，类似于关系型数据库中的行（Row）。</p></li><li><p><strong>集合（Collection）</strong>：一个集合可以包含多个文档，类似于关系型数据库中的表（Table）。</p></li><li><p><strong>数据库（Database）</strong>：一个数据库中可以包含多个集合，可以在 MongoDB 中创建多个数据库，类似于关系型数据库中的数据库（Database）。</p></li></ul><p><strong>SQL 与 MongoDB 常见术语对比</strong>：</p><table><thead><tr><th>SQL</th><th>MongoDB</th></tr></thead><tbody><tr><td>表（Table）</td><td>集合（Collection）</td></tr><tr><td>行（Row）</td><td>文档（Document）</td></tr><tr><td>列（Col）</td><td>字段（Field）</td></tr><tr><td>主键（Primary Key）</td><td>对象 ID（Objectid）</td></tr><tr><td>索引（Index）</td><td>索引（Index）</td></tr><tr><td>嵌套表（Embedded Table）</td><td>嵌入式文档（Embedded Document）</td></tr><tr><td>数组（Array）</td><td>数组（Array）</td></tr></tbody></table><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。字段的值可能包括其他文档、数组和文档数组。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231122123417341.png" alt="image-20231122123417341"></p><p>文档的键是字符串。除了少数例外情况，键可以使用任意 UTF-8 字符。</p><ul><li>键不能含有 <code>\0</code>(空字符）。这个字符用来表示键的结尾。</li><li><code>.</code> 和 <code>$</code> 有特别的意义，只有在特定环境下才能使用。</li><li>以下划线<code>_</code>开头的键是保留的(不是严格要求的)。</li></ul><p><strong>BSON [bee·sahn]</strong> 是 Binary <a href="http://json.org/">JSONopen in new window</a>的简称，是 JSON 文档的二进制表示，支持将文档和数组嵌入到其他文档和数组中，还包含允许表示不属于 JSON 规范的数据类型的扩展。</p><p>根据维基百科对 BJSON 的介绍，BJSON 的遍历速度优于 JSON，这也是 MongoDB 选择 BSON 的主要原因，但 BJSON 需要更多的存储空间。</p><blockquote><p>  与 JSON 相比，BSON 着眼于提高存储和扫描效率。BSON 文档中的大型元素以长度字段为前缀以便于扫描。在某些情况下，由于长度前缀和显式数组索引的存在，BSON 使用的空间会多于 JSON。</p></blockquote><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>MongoDB 集合存在于数据库中，<strong>没有固定的结构</strong>，也就是 <strong>无模式</strong> 的，这意味着可以往集合插入不同格式和类型的数据。不过，通常情况下，插入集合中的数据都会有一定的关联性。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231122123610747.png" alt="image-20231122123610747"></p><p><strong>集合不需要事先创建</strong>，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。</p><p>集合名可以是满足下列条件的任意 UTF-8 字符串：</p><ul><li>集合名不能是空字符串<code>&quot;&quot;</code>。</li><li>集合名不能含有 <code>\0</code> （空字符)，这个字符表示集合名的结尾。</li><li>集合名不能以”system.”开头，这是为系统集合保留的前缀。例如 <code>system.users</code> 这个集合保存着数据库的用户信息，<code>system.namespaces</code> 集合保存着所有数据库集合的信息。</li><li>集合名必须以下划线或者字母符号开始，并且不能包含 <code>$</code>。</li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>数据库用于存储所有集合，而集合又用于存储所有文档。一个 MongoDB 中可以创建多个数据库，每一个数据库都有自己的集合和权限。</p><p>MongoDB 预留了几个特殊的数据库。</p><ul><li><strong>admin</strong> : admin 数据库主要是保存 root 用户和角色。例如，system.users 表存储用户，system.roles 表存储角色。一般不建议用户直接操作这个数据库。将一个用户添加到这个数据库，且使它拥有 admin 库上的名为 dbAdminAnyDatabase 的角色权限，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如关闭服务器。</li><li><strong>local</strong> : <strong>local 数据库是不会被复制到其他分片的</strong>，因此可以用来存储本地单台服务器的任意 collection。一般<strong>不建议用户直接使用 local 库存储任何数据，也不建议进行 CRUD 操作，因为数据无法被正常备份与恢复</strong>。</li><li><strong>config</strong> : 当 MongoDB 使用分片设置时，config 数据库可用来保存分片的相关信息。</li><li><strong>test</strong> : 默认创建的测试库，连接 <a href="https://mongoing.com/docs/reference/program/mongod.html">mongodopen in new window</a> 服务时，如果不指定连接的具体数据库，默认就会连接到 test 数据库。</li></ul><p>数据库名可以是满足以下条件的任意 UTF-8 字符串：</p><ul><li>不能是空字符串<code>&quot;&quot;</code>。</li><li>不得含有<code>&#39; &#39;</code>（空格)、<code>.</code>、<code>$</code>、<code>/</code>、<code>\</code>和 <code>\0</code> (空字符)。</li><li>应全部小写。</li><li>最多 64 字节。</li></ul><p>数据库名最终会变成文件系统里的文件，这也就是有如此多限制的原因。</p><h3 id="MongoDB-有什么特点？"><a href="#MongoDB-有什么特点？" class="headerlink" title="MongoDB 有什么特点？"></a>MongoDB 有什么特点？</h3><ul><li><p><strong>数据记录被存储为文档</strong>：MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。</p></li><li><p><strong>模式自由</strong>：集合的概念类似 MySQL 里的表，但它不需要定义任何模式，能够用更少的数据对象表现复杂的领域模型对象。</p></li><li><p><strong>支持多种查询方式</strong>：MongoDB 查询 API 支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。</p></li><li><p><strong>支持 ACID 事务</strong>：NoSQL 数据库通常不支持事务，为了可扩展和高性能。但也有例外，MongoDB 就支持事务。与关系型数据库一样，MongoDB 事务同样具有 ACID 特性。MongoDB 单文档原生支持原子性，也具备事务的特性。</p><ul><li>MongoDB 4.0 加入了对多文档事务的支持，但只支持复制集部署模式下的事务，也就是说<strong>事务的作用域限制为一个副本集内</strong>。</li><li>MongoDB 4.2 引入了分布式事务，<strong>增加了对分片集群上多文档事务的支持</strong>，并合并了对副本集上多文档事务的现有支持。</li></ul></li><li><p><strong>高效的二进制存储</strong>：存储在集合中的文档，是以键值对的形式存在的。键用于唯一标识一个文档，一般是 ObjectId 类型，值是以 BSON 形式存在的。、</p></li><li><p><strong>自带数据压缩功能</strong>：存储同样的数据所需的资源更少。</p></li><li><p><strong>支持 mapreduce</strong>：通过分治的方式完成复杂的聚合任务。从 MongoDB 5.0 开始，map-reduce 已经不被官方推荐使用了，替代方案是聚合管道，提供比 map-reduce 更好的性能和可用性。</p></li><li><p><strong>支持多种类型的索引</strong>：MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、地理位置索引等，每种类型的索引有不同的使用场合。</p></li><li><p><strong>支持 failover</strong>：提供自动故障恢复的功能，主节点发生故障时，自动从<strong>从节点</strong>中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</p></li><li><p><strong>支持分片集群</strong>：MongoDB 支持集群自动切分数据，让集群存储更多的数据，具备更强的性能。在数据插入和更新时，能够自动路由和存储。</p></li><li><p><strong>支持存储大文件</strong>：MongoDB 的<strong>单文档存储空间要求不超过 16MB</strong>。对于超过 16MB 的大文件，MongoDB 提供了 GridFS 来进行存储，通过 GridFS，可以将大型数据进行<strong>分块处理</strong>，然后将这些切分后的小文档保存在数据库中。</p></li></ul><h3 id="MongoDB-适合什么应用场景？"><a href="#MongoDB-适合什么应用场景？" class="headerlink" title="MongoDB 适合什么应用场景？"></a>MongoDB 适合什么应用场景？</h3><p><strong>MongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及强大的索引支持。</strong></p><p>选用 MongoDB 应该充分考虑 MongoDB 的优势，结合实际项目的需求来决定：</p><ul><li>随着项目的发展，使用类 JSON 格式（BSON）保存数据是否满足项目需求？</li><li>是否需要大数据量的存储？是否需要快速水平扩展？（MongoDB 支持分片集群，可以很方便地添加更多的节点（实例），让集群存储更多的数据，具备更强的性能）。</li><li>是否需要更多类型索引来满足更多应用场景？（MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等）。</li></ul><h2 id="MongoDB-存储引擎"><a href="#MongoDB-存储引擎" class="headerlink" title="MongoDB 存储引擎"></a>MongoDB 存储引擎</h2><h3 id="MongoDB-支持哪些存储引擎？"><a href="#MongoDB-支持哪些存储引擎？" class="headerlink" title="MongoDB 支持哪些存储引擎？"></a>MongoDB 支持哪些存储引擎？</h3><p>存储引擎（Storage Engine）是数据库的核心组件，负责管理数据在内存和磁盘中的存储方式。</p><p>与 MySQL 一样，MongoDB 采用的也是 <strong>插件式的存储引擎架构</strong> ，支持不同类型的存储引擎，不同的存储引擎解决不同场景的问题。在创建数据库或集合时，可以指定存储引擎。</p><blockquote><p>  插件式的存储引擎架构可以实现 Server 层和存储引擎层的解耦，可以支持多种存储引擎，如 MySQL 既可以支持 B-Tree 结构的 InnoDB 存储引擎，还可以支持 LSM 结构的 RocksDB 存储引擎。</p></blockquote><p>在存储引擎刚出来的时候，默认是使用 MMAPV1 存储引擎，MongoDB4.x 版本不再支持 MMAPv1 存储引擎。</p><p>现在主要有下面这两种存储引擎：</p><ul><li><strong>WiredTiger 存储引擎</strong>：自 MongoDB 3.2 以后，默认的存储引擎为WiredTiger 存储引擎。非常适合大多数工作负载，建议用于新部署。WiredTiger 提供文档级并发模型、检查点和数据压缩等功能。</li><li><strong>In-Memory 存储引擎</strong>：在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是将它们保留在内存中以获得更可预测的数据延迟。</li></ul><p>此外，MongoDB 3.0 提供了 <strong>可插拔的存储引擎 API</strong> ，允许第三方为 MongoDB 开发存储引擎，这点和 MySQL 也比较类似。</p><h3 id="WiredTiger-基于-LSM-Tree-还是-B-Tree？"><a href="#WiredTiger-基于-LSM-Tree-还是-B-Tree？" class="headerlink" title="WiredTiger 基于 LSM Tree 还是 B+ Tree？"></a>WiredTiger 基于 LSM Tree 还是 B+ Tree？</h3><p>目前绝大部分流行的数据库存储引擎都是基于 B&#x2F;B+ Tree 或者 LSM(Log Structured Merge) Tree 来实现的。对于 NoSQL 数据库来说，绝大部分（比如 HBase、Cassandra、RocksDB）都是基于 LSM 树，MongoDB 不太一样。</p><p>在 WiredTiger 引擎官网上，我们发现 WiredTiger 使用的是 B+ 树作为其存储结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">WiredTiger maintains a table&#x27;s data in memory using a data structure called a B-Tree ( B+ Tree to be specific), referring to the nodes of a B-Tree as pages. Internal pages carry only keys. The leaf pages store both keys and values.<br></code></pre></td></tr></table></figure><p>此外，WiredTiger 还支持 LSM树作为存储结构，MongoDB 在使用 WiredTiger 作为存储引擎时，默认使用的是 B+ 树。</p><p><a href="https://mp.weixin.qq.com/s/mMWdpbYRiT6LQcdaj4hgXQ">为什么 MongoDB 使用 B 树？</a></p><p>使用 B+ 树时，WiredTiger 以 <strong>page</strong> 为基本单位往磁盘读写数据。B+ 树的每个节点为一个 page，共有三种类型的 page：</p><ul><li><strong>root page（根节点）</strong>：B+ 树的根节点。</li><li><strong>internal page（内部节点）</strong>：不实际存储数据的中间索引节点。</li><li><strong>leaf page（叶子节点）</strong>：真正存储数据的叶子节点，包含一个页头（page header）、块头（block header）和真正的数据（key&#x2F;value），其中页头定义了页的类型、页中实际载荷数据的大小、页中记录条数等信息；块头定义了此页的 checksum（Checksum值使用CRC-32C算法计算，用于检测存储介质的位错误和块数据的损坏。在读取数据时，WiredTiger会计算Checksum值并与保存在块头中的Checksum值进行比较，以确保读取的数据是正确的。）、块在磁盘上的寻址位置等信息。</li></ul><p>其整体结构如下图所示：</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231122125206946.png" alt="image-20231122125206946"></p><h2 id="MongoDB-聚合"><a href="#MongoDB-聚合" class="headerlink" title="MongoDB 聚合"></a>MongoDB 聚合</h2><h3 id="MongoDB-聚合有什么用？"><a href="#MongoDB-聚合有什么用？" class="headerlink" title="MongoDB 聚合有什么用？"></a>MongoDB 聚合有什么用？</h3><p>实际项目中，我们经常需要将多个文档甚至是多个集合汇总到一起计算分析（比如求和、取最大值）并返回计算后的结果，这个过程被称为 <strong>聚合操作</strong> 。</p><p>根据官方文档介绍，我们可以使用聚合操作来：</p><ul><li>将来自多个文档的值组合在一起。</li><li>对集合中的数据进行的一系列运算。</li><li>分析数据随时间的变化。</li></ul><h3 id="MongoDB-提供了哪几种执行聚合的方法？"><a href="#MongoDB-提供了哪几种执行聚合的方法？" class="headerlink" title="MongoDB 提供了哪几种执行聚合的方法？"></a>MongoDB 提供了哪几种执行聚合的方法？</h3><p>MongoDB 提供了两种执行聚合的方法：</p><ul><li><strong>聚合管道</strong>（Aggregation Pipeline）：执行聚合操作的首选方法。</li><li><strong>单一目的聚合方法（Single purpose aggregation methods）</strong>：也就是单一作用的聚合函数比如 <code>count()</code>、<code>distinct()</code>、<code>estimatedDocumentCount()</code>。</li></ul><p>从 MongoDB 5.0 开始，map-reduce 已经不被官方推荐使用了，聚合管道提供比 map-reduce 更好的性能和可用性。</p><p>MongoDB 聚合管道由多个阶段组成，每个阶段在文档通过管道时转换文档。每个阶段接收前一个阶段的输出，进一步处理数据，并将其作为输入数据发送到下一个阶段。</p><p>每个管道的工作流程是：</p><ol><li>接受一系列原始数据文档</li><li>对这些文档进行一系列运算</li><li>结果文档输出给下一个阶段</li></ol><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231122130044938.png" alt="image-20231122130044938"><center>管道的工作流程</center></p><p><strong>常用阶段操作符</strong>：</p><table><thead><tr><th>操作符</th><th>简述</th></tr></thead><tbody><tr><td>$match</td><td>匹配操作符，用于对文档集合进行筛选</td></tr><tr><td>$project</td><td>投射操作符，用于重构每一个文档的字段，可以提取字段，重命名字段，甚至可以对原有字段进行操作后新增字段</td></tr><tr><td>$sort</td><td>排序操作符，用于根据一个或多个字段对文档进行排序</td></tr><tr><td>$limit</td><td>限制操作符，用于限制返回文档的数量</td></tr><tr><td>$skip</td><td>跳过操作符，用于跳过指定数量的文档</td></tr><tr><td>$count</td><td>统计操作符，用于统计文档的数量</td></tr><tr><td>$group</td><td>分组操作符，用于对文档集合进行分组</td></tr><tr><td>$unwind</td><td>拆分操作符，用于将数组中的每一个值拆分为单独的文档</td></tr><tr><td>$lookup</td><td>连接操作符，用于连接同一个数据库中另一个集合，并获取指定的文档，类似于 populate</td></tr></tbody></table><p>阶段操作符用于 <code>db.collection.aggregate</code> 方法里面，数组参数中的第一层。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.collection.aggregate( [ &#123; 阶段操作符：表述 &#125;, &#123; 阶段操作符：表述 &#125;, ... ] )<br></code></pre></td></tr></table></figure><p>下面是 MongoDB 官方文档中的一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.orders.aggregate([<br>   # 第一阶段：$<span class="hljs-keyword">match</span>阶段按status字段过滤文档，并将status等于&quot;A&quot;的文档传递到下一阶段。<br>    &#123; $<span class="hljs-keyword">match</span>: &#123; status: &quot;A&quot; &#125; &#125;,<br>  # 第二阶段：$<span class="hljs-keyword">group</span>阶段按cust_id字段将文档分组，以计算每个cust_id唯一值的金额总和。<br>    &#123; $<span class="hljs-keyword">group</span>: &#123; _id: &quot;$cust_id&quot;, total: &#123; $sum: &quot;$amount&quot; &#125; &#125; &#125;<br>])<br></code></pre></td></tr></table></figure><h2 id="MongoDB-事务"><a href="#MongoDB-事务" class="headerlink" title="MongoDB 事务"></a>MongoDB 事务</h2><blockquote><ul><li><a href="https://mongoing.com/archives/82187">技术干货| MongoDB 事务原理open in new window</a></li><li><a href="https://developer.aliyun.com/article/782494">MongoDB 一致性模型设计与实现open in new window</a></li><li><a href="https://www.mongodb.com/docs/upcoming/core/transactions/">MongoDB 官方文档对事务的介绍open in new window</a></li></ul></blockquote><p>与关系型数据库一样，MongoDB 事务同样具有 ACID 特性：</p><ul><li><p><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p></li><li><p><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。WiredTiger 存储引擎支持读未提交（ read-uncommitted ）、读已提交（ read-committed ）和快照（ snapshot ）隔离，MongoDB 启动时默认选快照隔离。在不同隔离级别下，一个事务的生命周期内，可能出现脏读、不可重复读、幻读等现象。</p></li><li><p><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><p>MongoDB 单文档原生支持原子性，也具备事务的特性。当谈论 MongoDB 事务的时候，通常指的是 <strong>多文档</strong> 。</p><ul><li>MongoDB 4.0 加入了对多文档 ACID 事务的支持，但只支持复制集部署模式下的 ACID 事务，也就是说事务的作用域限制为一个副本集内。</li><li>MongoDB 4.2 引入了 <strong>分布式事务</strong> ，增加了对分片集群上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。</li></ul><p>根据官方文档介绍：</p><blockquote><p>  从 MongoDB 4.2 开始，分布式事务和多文档事务在 MongoDB 中是一个意思。分布式事务是指分片集群和副本集上的多文档事务。从 MongoDB 4.2 开始，多文档事务（无论是在分片集群还是副本集上）也称为分布式事务。</p></blockquote><p>在大多数情况下，多文档事务比单文档写入会产生更大的性能成本。对于大部分场景来说， <a href="https://www.mongodb.com/docs/upcoming/core/data-model-design/#std-label-data-modeling-embedding">非规范化数据模型（嵌入式文档和数组）open in new window</a> 依然是最佳选择。也就是说，<strong>适当地对数据进行建模可以最大限度地减少对多文档事务的需求</strong>。</p><p><strong>注意</strong>：</p><ul><li>从 MongoDB 4.2 开始，多文档事务支持副本集和分片集群，其中：主节点使用 WiredTiger 存储引擎，同时从节点使用 WiredTiger 存储引擎或 In-Memory 存储引擎。在 MongoDB 4.0 中，只有使用 WiredTiger 存储引擎的副本集支持事务。</li><li>在 MongoDB 4.2 及更早版本中，你无法在事务中创建集合。从 MongoDB 4.4 开始，您可以在事务中创建集合和索引。 <a href="https://www.mongodb.com/docs/upcoming/core/transactions/#std-label-transactions-create-collections-indexes">在事务中创建集合和索引open in new window</a>。</li></ul><h2 id="MongoDB-数据压缩"><a href="#MongoDB-数据压缩" class="headerlink" title="MongoDB 数据压缩"></a>MongoDB 数据压缩</h2><p>借助 WiredTiger 存储引擎（ MongoDB 3.2 后的默认存储引擎），MongoDB 支持对所有集合和索引进行压缩。压缩以额外的 CPU 为代价 最大限度地减少存储使用。</p><p>默认情况下，WiredTiger 使用 <a href="https://github.com/google/snappy">Snappyopen in new window</a> 压缩算法（谷歌开源，旨在实现非常高的速度和合理的压缩，压缩比 3 ～ 5 倍）对所有集合使用块压缩，对所有索引使用前缀压缩。</p><p>除了 Snappy 之外，对于集合还有下面这些压缩算法：</p><ul><li><a href="https://github.com/madler/zlib">zlibopen in new window</a>：高度压缩算法，压缩比 5 ～ 7 倍</li><li><a href="https://github.com/facebook/zstd">Zstandardopen in new window</a>（简称 zstd）：Facebook 开源的一种快速无损压缩算法，针对 zlib 级别的实时压缩场景和更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。</li></ul><p>WiredTiger 日志也会被压缩，默认使用的也是 Snappy 压缩算法。<strong>如果日志记录小于或等于 128 字节，WiredTiger 不会压缩该记录。</strong></p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL语法基础知识.md</title>
    <link href="/2024/02/27/DB/basic_knowledge/SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/02/27/DB/basic_knowledge/SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h3><ul><li><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li><li><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</li><li><code>模式（schema）</code> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。<code>// 模式到底是什么？？？</code></li><li><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</li><li><code>行（row）</code> - 表中的一个记录。</li><li><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</li></ul><h3 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h3><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL&#x2F;SQL、Transact-SQL 等。</p><h4 id="SQL-语法结构"><a href="#SQL-语法结构" class="headerlink" title="SQL 语法结构"></a>SQL 语法结构</h4><p><img src="https://oss.javaguide.cn/p3-juejin/cb684d4c75fc430e92aaee226069c7da~tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p><p>SQL 语法结构包括：</p><ul><li><strong><code>子句</code></strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li><li><strong><code>表达式</code></strong> - 可以产生任何标量值，或由列和行的数据库表</li><li><strong><code>谓词</code></strong> - 给需要评估的 SQL 三值逻辑（3VL）（true&#x2F;false&#x2F;unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li><li><strong><code>查询</code></strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li><li><strong><code>语句</code></strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li></ul><h4 id="SQL-语法要点"><a href="#SQL-语法要点" class="headerlink" title="SQL 语法要点"></a>SQL 语法要点</h4><ul><li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如：<code>SELECT</code> 与 <code>select</code>、<code>Select</code> 是相同的。</li><li><strong>多条 SQL 语句必须以分号（<code>;</code>）分隔</strong>。</li><li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li></ul><p>SQL 语句可以写成一行，也可以分写为多行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 一行 SQL 语句</span><br><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span>, password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br><br><span class="hljs-comment">-- 多行 SQL 语句</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">SET</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span>, password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span><br><span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><p>SQL 支持三种注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">## 注释<span class="hljs-number">1</span><br><span class="hljs-comment">-- 注释2</span><br><span class="hljs-comment">/* 注释3 */</span><br></code></pre></td></tr></table></figure><h3 id="SQL-分类"><a href="#SQL-分类" class="headerlink" title="SQL 分类"></a>SQL 分类</h3><h4 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h4><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p><p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p><p>DDL 的核心指令是 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>。</p><h4 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h4><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p><p>DML 的主要功能是 <strong>访问数据</strong>，因此其语法都是以<strong>读写数据库</strong>为主。</p><p>DML 的核心指令是 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</p><h4 id="事务控制语言（TCL）"><a href="#事务控制语言（TCL）" class="headerlink" title="事务控制语言（TCL）"></a>事务控制语言（TCL）</h4><p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p><p>TCL 的核心指令是 <code>COMMIT</code>、<code>ROLLBACK</code>。</p><h4 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="#数据控制语言（DCL）"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80-dcl">#</a>数据控制语言（DCL）</h4><p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p><p>DCL 的核心指令是 <code>GRANT</code>、<code>REVOKE</code>。</p><p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：<code>CONNECT</code>、<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>EXECUTE</code>、<code>USAGE</code>、<code>REFERENCES</code>。</p><p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p><p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="#增删改查"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">#</a>增删改查</h2><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="#插入数据"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">#</a>插入数据</h3><p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p><p><strong>插入完整的行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 插入一行<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br># 插入多行<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>), (<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>), (<span class="hljs-number">18</span>, <span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>插入行的一部分</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span>(username, password, email)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>插入查询出来的数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span>(username)<br><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> account;<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="#更新数据"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE">#</a>更新数据</h3><p><code>UPDATE</code> 语句用于更新表中的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">SET</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span>, password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span><br><span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="#删除数据"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">#</a>删除数据</h3><ul><li><code>DELETE</code> 语句用于删除表中的记录。</li><li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li></ul><p><strong>删除表中的指定数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;robot&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>清空表中的数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="#查询数据"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">#</a>查询数据</h3><p><code>SELECT</code> 语句用于从数据库中查询数据。</p><p><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</p><p><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><ul><li><code>ASC</code>：升序（默认）</li><li><code>DESC</code>：降序</li></ul><p><strong>查询单列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name<br><span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>查询多列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>查询所有列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>查询不同的值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><br>vend_id <span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>限制查询结果</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 返回前 5 行</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> mytable LIMIT <span class="hljs-number">5</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> mytable LIMIT <span class="hljs-number">0</span>, <span class="hljs-number">5</span>;<br><span class="hljs-comment">-- 返回第 3 ~ 5 行</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> mytable LIMIT <span class="hljs-number">2</span>, <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="#排序"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%8E%92%E5%BA%8F">#</a>排序</h2><p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p><p><code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_price <span class="hljs-keyword">DESC</span>, prod_name <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="#分组"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%86%E7%BB%84">#</a>分组</h2><p>**<code>group by</code>**：</p><ul><li><code>group by</code> 子句将记录分组到汇总行中。</li><li><code>group by</code> 为每个组返回一个记录。</li><li><code>group by</code> 通常还涉及聚合<code>count</code>，<code>max</code>，<code>sum</code>，<code>avg</code> 等。</li><li><code>group by</code> 可以按一列或多列进行分组。</li><li><code>group by</code> 按分组字段进行排序后，<code>order by</code> 可以以汇总字段来进行排序。</li></ul><p><strong>分组</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <span class="hljs-built_in">COUNT</span>(cust_address) <span class="hljs-keyword">AS</span> addr_num<br><span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cust_name;<br></code></pre></td></tr></table></figure><p><strong>分组后排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <span class="hljs-built_in">COUNT</span>(cust_address) <span class="hljs-keyword">AS</span> addr_num<br><span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cust_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cust_name <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p>**<code>having</code>**：</p><ul><li><code>having</code> 用于对汇总的 <code>group by</code> 结果进行过滤。</li><li><code>having</code> 一般都是和 <code>group by</code> 连用。</li><li><code>where</code> 和 <code>having</code> 可以在相同的查询中。</li></ul><p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num<br><span class="hljs-keyword">FROM</span> Customers<br><span class="hljs-keyword">WHERE</span> cust_email <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cust_name<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>**<code>having</code> vs <code>where</code>**：</p><ul><li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。<code>where</code> 在<code>group by</code> 前。</li><li><code>having</code>：过滤分组，一般都是和 <code>group by</code> 连用，不能单独使用。<code>having</code> 在 <code>group by</code> 之后。</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="#子查询"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%AD%90%E6%9F%A5%E8%AF%A2">#</a>子查询</h2><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p><p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p><p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p><ul><li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。</li><li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</li></ul><blockquote><p>  注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p></blockquote><p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> column_name [, column_name ]<br><span class="hljs-keyword">from</span>   table1 [, table2 ]<br><span class="hljs-keyword">where</span>  column_name operator<br>    (<span class="hljs-keyword">select</span> column_name [, column_name ]<br>    <span class="hljs-keyword">from</span> table1 [, table2 ]<br>    [<span class="hljs-keyword">where</span>])<br></code></pre></td></tr></table></figure><ul><li>子查询需要放在括号<code>( )</code>内。</li><li><code>operator</code> 表示用于 where 子句的运算符。</li></ul><p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> column_name [, column_name ]<br><span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> column_name [, column_name ]<br>      <span class="hljs-keyword">from</span> table1 [, table2 ]<br>      [<span class="hljs-keyword">where</span>]) <span class="hljs-keyword">as</span> temp_table_name<br><span class="hljs-keyword">where</span>  <span class="hljs-keyword">condition</span><br></code></pre></td></tr></table></figure><p>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</p><p><strong>子查询的子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, cust_contact<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> cust_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> cust_id<br>                  <span class="hljs-keyword">FROM</span> orders<br>                  <span class="hljs-keyword">WHERE</span> order_num <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> order_num<br>                                      <span class="hljs-keyword">FROM</span> orderitems<br>                                      <span class="hljs-keyword">WHERE</span> prod_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;RGAN01&#x27;</span>));<br></code></pre></td></tr></table></figure><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p><p><img src="https://oss.javaguide.cn/p3-juejin/c439da1f5d4e4b00bdfa4316b933d764~tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="#WHERE"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#where">#</a>WHERE</h3><ul><li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li><li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li><li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。</li><li>可以在 <code>WHERE</code> 子句中使用的操作符。</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr><tr><td>IN</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><p><strong><code>SELECT</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">SELECT * FROM Customers<br>WHERE <span class="hljs-attr">cust_name</span> = <span class="hljs-string">&#x27;Kids Place&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong><code>UPDATE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">UPDATE Customers<br>SET <span class="hljs-attr">cust_name</span> = <span class="hljs-string">&#x27;Jack Jones&#x27;</span><br>WHERE <span class="hljs-attr">cust_name</span> = <span class="hljs-string">&#x27;Kids Place&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong><code>DELETE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">DELETE FROM Customers<br>WHERE <span class="hljs-attr">cust_name</span> = <span class="hljs-string">&#x27;Kids Place&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="IN-和-BETWEEN"><a href="#IN-和-BETWEEN" class="headerlink" title="#IN 和 BETWEEN"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#in-%E5%92%8C-between">#</a>IN 和 BETWEEN</h3><ul><li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li><li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li></ul><p><strong>IN 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;DLL01&#x27;</span>, <span class="hljs-string">&#x27;BRS01&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>BETWEEN 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h3 id="AND、OR、NOT"><a href="#AND、OR、NOT" class="headerlink" title="#AND、OR、NOT"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#and%E3%80%81or%E3%80%81not">#</a>AND、OR、NOT</h3><ul><li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li><li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li><li><code>AND</code> 操作符表示左右条件都要满足。</li><li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li><li><code>NOT</code> 操作符用于否定一个条件。</li></ul><p><strong>AND 示例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">SELECT prod_id, prod_name, prod_price<br>FROM products<br>WHERE <span class="hljs-attr">vend_id</span> = <span class="hljs-string">&#x27;DLL01&#x27;</span> AND prod_price &lt;= <span class="hljs-number">4</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>OR 示例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">SELECT prod_id, prod_name, prod_price<br>FROM products<br>WHERE <span class="hljs-attr">vend_id</span> = <span class="hljs-string">&#x27;DLL01&#x27;</span> OR vend_id = <span class="hljs-string">&#x27;BRS01&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>NOT 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="#LIKE"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#like">#</a>LIKE</h3><ul><li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li><li>只有字段是文本值时才使用 <code>LIKE</code>。</li><li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li><li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li><li><code>%</code> 表示任何字符出现任意次数。</li><li><code>_</code> 表示任何字符出现一次。</li></ul><p><strong>% 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%bean bag%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>_ 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;__ inch teddy bear&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="#连接"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E8%BF%9E%E6%8E%A5">#</a>连接</h2><p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p><p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p><p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> table1.column1, table2.column2...<br><span class="hljs-keyword">from</span> table1<br><span class="hljs-keyword">join</span> table2<br><span class="hljs-keyword">on</span> table1.common_column1 <span class="hljs-operator">=</span> table2.common_column2;<br></code></pre></td></tr></table></figure><p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 &#x3D;、&gt;、&lt;、&lt;&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 &#x3D;。</p><p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p><p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># join....on<br><span class="hljs-keyword">select</span> c.cust_name, o.order_num<br><span class="hljs-keyword">from</span> Customers c<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> Orders o<br><span class="hljs-keyword">on</span> c.cust_id <span class="hljs-operator">=</span> o.cust_id<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c.cust_name;<br><br># 如果两张表的关联字段名相同，也可以使用<span class="hljs-keyword">USING</span>子句：join....using()<br><span class="hljs-keyword">select</span> c.cust_name, o.order_num<br><span class="hljs-keyword">from</span> Customers c<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> Orders o<br><span class="hljs-keyword">using</span>(cust_id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c.cust_name;<br></code></pre></td></tr></table></figure><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p><ul><li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li><li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li></ul><p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p><p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p><table><thead><tr><th>连接类型</th><th>说明</th></tr></thead><tbody><tr><td>INNER JOIN 内连接</td><td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td></tr><tr><td>LEFT JOIN &#x2F; LEFT OUTER JOIN 左(外)连接</td><td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td></tr><tr><td>RIGHT JOIN &#x2F; RIGHT OUTER JOIN 右(外)连接</td><td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td></tr><tr><td>FULL JOIN &#x2F; FULL OUTER JOIN 全(外)连接</td><td>只要其中有一个表存在满足条件的记录，就返回行。</td></tr><tr><td>SELF JOIN</td><td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td></tr><tr><td>CROSS JOIN</td><td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td></tr></tbody></table><p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><p><img src="https://oss.javaguide.cn/p3-juejin/701670942f0f45d3a3a2187cd04a12ad~tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p><p>如果不加任何修饰词，只写 <code>JOIN</code>，那么默认为 <code>INNER JOIN</code></p><p>对于 <code>INNER JOIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>INNER JOIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 隐式内连接<br><span class="hljs-keyword">select</span> c.cust_name, o.order_num<br><span class="hljs-keyword">from</span> Customers c, Orders o<br><span class="hljs-keyword">where</span> c.cust_id <span class="hljs-operator">=</span> o.cust_id<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c.cust_name;<br><br># 显式内连接<br><span class="hljs-keyword">select</span> c.cust_name, o.order_num<br><span class="hljs-keyword">from</span> Customers c <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> Orders o<br><span class="hljs-keyword">using</span>(cust_id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c.cust_name;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="#组合"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E7%BB%84%E5%90%88">#</a>组合</h2><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p><p><code>UNION</code> 基本规则：</p><ul><li>所有查询的列数和列顺序必须相同。</li><li>每个查询中涉及表的列的数据类型必须相同或兼容。</li><li>通常返回的列名取自第一个查询。</li></ul><p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name(s) <span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> column_name(s) <span class="hljs-keyword">FROM</span> table2;<br></code></pre></td></tr></table></figure><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p><p><code>JOIN</code> vs <code>UNION</code>：</p><ul><li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li><li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="#函数"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%87%BD%E6%95%B0">#</a>函数</h2><p>不同数据库的函数往往各不相同，因此不可移植。本节主要以 MySQL 的函数为例。</p><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="#文本处理"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86">#</a>文本处理</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>LEFT()</code>、<code>RIGHT()</code></td><td>左边或者右边的字符</td></tr><tr><td><code>LOWER()</code>、<code>UPPER()</code></td><td>转换为小写或者大写</td></tr><tr><td><code>LTRIM()</code>、<code>RTRIM()</code></td><td>去除左边或者右边的空格</td></tr><tr><td><code>LENGTH()</code></td><td>长度，以字节为单位</td></tr><tr><td><code>SOUNDEX()</code></td><td>转换为语音值</td></tr></tbody></table><p>其中， <strong><code>SOUNDEX()</code></strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> mytable<br><span class="hljs-keyword">WHERE</span> SOUNDEX(col1) <span class="hljs-operator">=</span> SOUNDEX(<span class="hljs-string">&#x27;apple&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="#日期和时间处理"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86">#</a>日期和时间处理</h3><ul><li>日期格式：<code>YYYY-MM-DD</code></li><li>时间格式：<code>HH:MM:SS</code></li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AddDate()</code></td><td>增加一个日期（天、周等）</td></tr><tr><td><code>AddTime()</code></td><td>增加一个时间（时、分等）</td></tr><tr><td><code>CurDate()</code></td><td>返回当前日期</td></tr><tr><td><code>CurTime()</code></td><td>返回当前时间</td></tr><tr><td><code>Date()</code></td><td>返回日期时间的日期部分</td></tr><tr><td><code>DateDiff()</code></td><td>计算两个日期之差</td></tr><tr><td><code>Date_Add()</code></td><td>高度灵活的日期运算函数</td></tr><tr><td><code>Date_Format()</code></td><td>返回一个格式化的日期或时间串</td></tr><tr><td><code>Day()</code></td><td>返回一个日期的天数部分</td></tr><tr><td><code>DayOfWeek()</code></td><td>对于一个日期，返回对应的星期几</td></tr><tr><td><code>Hour()</code></td><td>返回一个时间的小时部分</td></tr><tr><td><code>Minute()</code></td><td>返回一个时间的分钟部分</td></tr><tr><td><code>Month()</code></td><td>返回一个日期的月份部分</td></tr><tr><td><code>Now()</code></td><td>返回当前日期和时间</td></tr><tr><td><code>Second()</code></td><td>返回一个时间的秒部分</td></tr><tr><td><code>Time()</code></td><td>返回一个日期时间的时间部分</td></tr><tr><td><code>Year()</code></td><td>返回一个日期的年份部分</td></tr></tbody></table><h3 id="数值处理"><a href="#数值处理" class="headerlink" title="#数值处理"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86">#</a>数值处理</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h3 id="汇总"><a href="#汇总" class="headerlink" title="#汇总"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%B1%87%E6%80%BB">#</a>汇总</h3><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AVG()</code></td><td>返回某列的平均值</td></tr><tr><td><code>COUNT()</code></td><td>返回某列的行数</td></tr><tr><td><code>MAX()</code></td><td>返回某列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回某列的最小值</td></tr><tr><td><code>SUM()</code></td><td>返回某列值之和</td></tr></tbody></table><p><code>AVG()</code> 会忽略 NULL 行。</p><p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(<span class="hljs-keyword">DISTINCT</span> col1) <span class="hljs-keyword">AS</span> avg_col<br><span class="hljs-keyword">FROM</span> mytable<br></code></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）</strong></p><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="#数据定义"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89">#</a>数据定义</h2><h3 id="数据库（DATABASE）"><a href="#数据库（DATABASE）" class="headerlink" title="#数据库（DATABASE）"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%95%B0%E6%8D%AE%E5%BA%93-database">#</a>数据库（DATABASE）</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="#创建数据库"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">#</a>创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE test;<br></code></pre></td></tr></table></figure><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="#删除数据库"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">#</a>删除数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE test;<br></code></pre></td></tr></table></figure><h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="#选择数据库"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93">#</a>选择数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE test;<br></code></pre></td></tr></table></figure><h3 id="数据表（TABLE）"><a href="#数据表（TABLE）" class="headerlink" title="#数据表（TABLE）"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%95%B0%E6%8D%AE%E8%A1%A8-table">#</a>数据表（TABLE）</h3><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="#创建数据表"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8">#</a>创建数据表</h4><p><strong>普通创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;Id&#x27;</span>,<br>  username <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>  password <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;密码&#x27;</span>,<br>  email <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;邮箱&#x27;</span><br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>根据已有的表创建新表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> vip_user <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="#删除数据表"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%A1%A8">#</a>删除数据表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h4 id="修改数据表"><a href="#修改数据表" class="headerlink" title="#修改数据表"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8">#</a>修改数据表</h4><p><strong>添加列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">ADD</span> age <span class="hljs-type">int</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><strong>删除列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> age;<br></code></pre></td></tr></table></figure><p><strong>修改列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>`<br>MODIFY <span class="hljs-keyword">COLUMN</span> age tinyint;<br></code></pre></td></tr></table></figure><p><strong>添加主键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (id);<br></code></pre></td></tr></table></figure><p><strong>删除主键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br></code></pre></td></tr></table></figure><h3 id="视图（VIEW）"><a href="#视图（VIEW）" class="headerlink" title="#视图（VIEW）"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E8%A7%86%E5%9B%BE-view">#</a>视图（VIEW）</h3><p>定义：</p><ul><li>视图是基于 SQL 语句的结果集的可视化的表。</li><li>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li></ul><p>作用：</p><ul><li>简化复杂的 SQL 操作，比如复杂的联结；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><p><img src="https://oss.javaguide.cn/p3-juejin/ec4c975296ea4a7097879dac7c353878~tplv-k3u1fbpfcp-zoom-1.jpeg" alt="mysql视图">mysql视图</p><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="#创建视图"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE">#</a>创建视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> top_10_user_view <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> id, username<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="#删除视图"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE">#</a>删除视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> top_10_user_view;<br></code></pre></td></tr></table></figure><h3 id="索引（INDEX）"><a href="#索引（INDEX）" class="headerlink" title="#索引（INDEX）"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E7%B4%A2%E5%BC%95-index">#</a>索引（INDEX）</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><p><strong>优点</strong>：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong>：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><p>关于索引的详细介绍，请看我写的 <a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解open in new window</a> 这篇文章。</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="#创建索引"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">#</a>创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX user_index<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span> (id);<br></code></pre></td></tr></table></figure><h4 id="添加索引"><a href="#添加索引" class="headerlink" title="#添加索引"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95">#</a>添加索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ADD</span> INDEX user_index(id)<br></code></pre></td></tr></table></figure><h4 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="#创建唯一索引"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95">#</a>创建唯一索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX user_index<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span> (id);<br></code></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="#删除索引"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95">#</a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">DROP</span> INDEX user_index;<br></code></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="#约束"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E7%BA%A6%E6%9D%9F">#</a>约束</h3><p>SQL 约束用于规定表中的数据规则。</p><p>如果存在违反约束的数据行为，行为会被约束终止。</p><p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p><p>约束类型：</p><ul><li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li><li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li><li><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li><li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li><code>CHECK</code> - 保证列中的值符合指定的条件。</li><li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li></ul><p>创建表时使用约束条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Users (<br>  Id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;自增Id&#x27;</span>,<br>  Username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>  Password <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;密码&#x27;</span>,<br>  Email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;邮箱地址&#x27;</span>,<br>  Enabled TINYINT(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;是否有效&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (Id)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。</strong></p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="#事务处理"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86">#</a>事务处理</h2><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p><p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p><p>指令：</p><ul><li><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</li><li><code>SAVEPOINT</code> - 指令用于创建保留点。</li><li><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li><li><code>COMMIT</code> - 提交事务。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开始事务</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><br><span class="hljs-comment">-- 插入操作 A</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;root1&#x27;</span>, <span class="hljs-string">&#x27;root1&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br><br><span class="hljs-comment">-- 创建保留点 updateA</span><br><span class="hljs-keyword">SAVEPOINT</span> updateA;<br><br><span class="hljs-comment">-- 插入操作 B</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;root2&#x27;</span>, <span class="hljs-string">&#x27;root2&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br><br><span class="hljs-comment">-- 回滚到保留点 updateA</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> updateA;<br><br><span class="hljs-comment">-- 提交事务，只有操作 A 生效</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。</strong></p><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="#权限控制"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">#</a>权限控制</h2><p>要授予用户帐户权限，可以用<code>GRANT</code>命令。有撤销用户的权限，可以用<code>REVOKE</code>命令。这里以 MySQl 为例，介绍权限控制实际应用。</p><p><code>GRANT</code>授予权限语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> privilege,[privilege],.. <span class="hljs-keyword">ON</span> privilege_level<br><span class="hljs-keyword">TO</span> <span class="hljs-keyword">user</span> [IDENTIFIED <span class="hljs-keyword">BY</span> password]<br>[REQUIRE tsl_option]<br>[<span class="hljs-keyword">WITH</span> [GRANT_OPTION <span class="hljs-operator">|</span> resource_option]];<br></code></pre></td></tr></table></figure><p>简单解释一下：</p><ol><li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li><li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global（<code>*.*</code>），database（<code>database.*</code>），table（<code>database.table</code>）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。</li><li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li><li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li><li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li></ol><p><code>REVOKE</code> 撤销权限语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span>   privilege_type [(column_list)]<br>        [, priv_type [(column_list)]]...<br><span class="hljs-keyword">ON</span> [object_type] privilege_level<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> [, <span class="hljs-keyword">user</span>]...<br></code></pre></td></tr></table></figure><p>简单解释一下：</p><ol><li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li><li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li><li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li></ol><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li><li>整个数据库，使用 <code>ON database.*</code>；</li><li>特定的表，使用 <code>ON database.table</code>；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p>新创建的账户没有任何权限。账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE mysql;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p>下表说明了可用于<code>GRANT</code>和<code>REVOKE</code>语句的所有允许权限：</p><table><thead><tr><th><strong>特权</strong></th><th><strong>说明</strong></th><th><strong>级别</strong></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>全局</strong></td><td>数据库</td><td><strong>表</strong></td><td><strong>列</strong></td><td><strong>程序</strong></td><td><strong>代理</strong></td><td></td><td></td></tr><tr><td>ALL [PRIVILEGES]</td><td>授予除 GRANT OPTION 之外的指定访问级别的所有权限</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALTER</td><td>允许用户使用 ALTER TABLE 语句</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>ALTER ROUTINE</td><td>允许用户更改或删除存储的例程</td><td>X</td><td>X</td><td></td><td></td><td>X</td><td></td></tr><tr><td>CREATE</td><td>允许用户创建数据库和表</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>CREATE ROUTINE</td><td>允许用户创建存储的例程</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE TABLESPACE</td><td>允许用户创建，更改或删除表空间和日志文件组</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE TEMPORARY TABLES</td><td>允许用户使用 CREATE TEMPORARY TABLE 创建临时表</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE USER</td><td>允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE VIEW</td><td>允许用户创建或修改视图。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>DELETE</td><td>允许用户使用 DELETE</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>DROP</td><td>允许用户删除数据库，表和视图</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>EVENT</td><td>启用事件计划程序的事件使用。</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>EXECUTE</td><td>允许用户执行存储的例程</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>FILE</td><td>允许用户读取数据库目录中的任何文件。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>GRANT OPTION</td><td>允许用户拥有授予或撤消其他帐户权限的权限。</td><td>X</td><td>X</td><td>X</td><td></td><td>X</td><td>X</td></tr><tr><td>INDEX</td><td>允许用户创建或删除索引。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>INSERT</td><td>允许用户使用 INSERT 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>LOCK TABLES</td><td>允许用户对具有 SELECT 权限的表使用 LOCK TABLES</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>PROCESS</td><td>允许用户使用 SHOW PROCESSLIST 语句查看所有进程。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>PROXY</td><td>启用用户代理。</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REFERENCES</td><td>允许用户创建外键</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>RELOAD</td><td>允许用户使用 FLUSH 操作</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REPLICATION CLIENT</td><td>允许用户查询以查看主服务器或从属服务器的位置</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REPLICATION SLAVE</td><td>允许用户使用复制从属从主服务器读取二进制日志事件。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SELECT</td><td>允许用户使用 SELECT 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>SHOW DATABASES</td><td>允许用户显示所有数据库</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SHOW VIEW</td><td>允许用户使用 SHOW CREATE VIEW 语句</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>SHUTDOWN</td><td>允许用户使用 mysqladmin shutdown 命令</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SUPER</td><td>允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>TRIGGER</td><td>允许用户使用 TRIGGER 操作。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>UPDATE</td><td>允许用户使用 UPDATE 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>USAGE</td><td>相当于“没有特权”</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="创建账户"><a href="#创建账户" class="headerlink" title="#创建账户"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7">#</a>创建账户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> myuser IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;mypassword&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="修改账户名"><a href="#修改账户名" class="headerlink" title="#修改账户名"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E4%BF%AE%E6%94%B9%E8%B4%A6%E6%88%B7%E5%90%8D">#</a>修改账户名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;newuser&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;myuser&#x27;</span>;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><h3 id="删除账户"><a href="#删除账户" class="headerlink" title="#删除账户"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E8%B4%A6%E6%88%B7">#</a>删除账户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="#查看权限"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90">#</a>查看权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="授予权限"><a href="#授予权限" class="headerlink" title="#授予权限"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90">#</a>授予权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="删除权限"><a href="#删除权限" class="headerlink" title="#删除权限"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E6%9D%83%E9%99%90">#</a>删除权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="更改密码"><a href="#更改密码" class="headerlink" title="#更改密码"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9B%B4%E6%94%B9%E5%AF%86%E7%A0%81">#</a>更改密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-keyword">FOR</span> myuser <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;mypass&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="#存储过程"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">#</a>存储过程</h2><p>存储过程可以看成是对一系列 SQL 操作的批处理。存储过程可以由触发器，其他存储过程以及 Java， Python，PHP 等应用程序调用。</p><p><img src="https://oss.javaguide.cn/p3-juejin/60afdc9c9a594f079727ec64a2e698a3~tplv-k3u1fbpfcp-zoom-1.jpeg" alt="mysql存储过程">mysql存储过程</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>创建存储过程：</p><ul><li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 <code>;</code> 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li><li>包含 <code>in</code>、<code>out</code> 和 <code>inout</code> 三种参数。</li><li>给变量赋值都需要用 <code>select into</code> 语句。</li><li>每次只能给一个变量赋值，不支持集合的操作。</li></ul><p>需要注意的是：<strong>阿里巴巴《Java 开发手册》强制禁止使用存储过程。因为存储过程难以调试和扩展，更没有移植性。</strong></p><p><img src="https://oss.javaguide.cn/p3-juejin/93a5e011ade4450ebfa5d82057532a49~tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p><p>至于到底要不要在项目中使用，还是要看项目实际需求，权衡好利弊即可！</p><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="#创建存储过程"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">#</a>创建存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> IF <span class="hljs-keyword">EXISTS</span> `proc_adder`;<br>DELIMITER ;;<br><span class="hljs-keyword">CREATE</span> DEFINER<span class="hljs-operator">=</span>`root`@`localhost` <span class="hljs-keyword">PROCEDURE</span> `proc_adder`(<span class="hljs-keyword">IN</span> a <span class="hljs-type">int</span>, <span class="hljs-keyword">IN</span> b <span class="hljs-type">int</span>, <span class="hljs-keyword">OUT</span> sum <span class="hljs-type">int</span>)<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> c <span class="hljs-type">int</span>;<br>    if a <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">set</span> a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span> if;<br><br>    if b <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">set</span> b <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span> if;<br><br>    <span class="hljs-keyword">set</span> sum  <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> b;<br><span class="hljs-keyword">END</span><br>;;<br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="#使用存储过程"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">#</a>使用存储过程</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">set</span> @<span class="hljs-selector-tag">b</span>=<span class="hljs-number">5</span>;<br><span class="hljs-selector-tag">call</span> <span class="hljs-selector-tag">proc_adder</span>(<span class="hljs-number">2</span>,<span class="hljs-variable">@b</span>,<span class="hljs-variable">@s</span>);<br><span class="hljs-selector-tag">select</span> @<span class="hljs-selector-tag">s</span> <span class="hljs-selector-tag">as</span> <span class="hljs-selector-tag">sum</span>;<br></code></pre></td></tr></table></figure><h2 id="游标"><a href="#游标" class="headerlink" title="#游标"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%B8%B8%E6%A0%87">#</a>游标</h2><p>游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。</p><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p><p>使用游标的几个明确步骤：</p><ul><li><p>在使用游标前，必须声明(定义)它。这个过程实际上没有检索数据， 它只是定义要使用的 <code>SELECT</code> 语句和游标选项。</p></li><li><p>一旦声明，就必须打开游标以供使用。这个过程用前面定义的 SELECT 语句把数据实际检索出来。</p></li><li><p>对于填有数据的游标，根据需要取出(检索)各行。</p></li><li><p>在结束游标使用时，必须关闭游标，可能的话，释放游标(有赖于具</p><p>体的 DBMS)。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">PROCEDURE</span> getTotal()<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> total <span class="hljs-type">INT</span>;<br>    <span class="hljs-comment">-- 创建接收游标数据的变量</span><br>    <span class="hljs-keyword">DECLARE</span> sid <span class="hljs-type">INT</span>;<br>    <span class="hljs-keyword">DECLARE</span> sname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">-- 创建总数变量</span><br>    <span class="hljs-keyword">DECLARE</span> sage <span class="hljs-type">INT</span>;<br>    <span class="hljs-comment">-- 创建结束标志变量</span><br>    <span class="hljs-keyword">DECLARE</span> done <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">-- 创建游标</span><br>    <span class="hljs-keyword">DECLARE</span> cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> id,name,age <span class="hljs-keyword">from</span> cursor_table <span class="hljs-keyword">where</span> age<span class="hljs-operator">&gt;</span><span class="hljs-number">30</span>;<br>    <span class="hljs-comment">-- 指定游标循环结束时的返回值</span><br>    <span class="hljs-keyword">DECLARE</span> CONTINUE HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">SET</span> done <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">SET</span> total <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">OPEN</span> cur;<br>    <span class="hljs-keyword">FETCH</span> cur <span class="hljs-keyword">INTO</span> sid, sname, sage;<br>    WHILE(<span class="hljs-keyword">NOT</span> done)<br>    DO<br>        <span class="hljs-keyword">SET</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">FETCH</span> cur <span class="hljs-keyword">INTO</span> sid, sname, sage;<br>    <span class="hljs-keyword">END</span> WHILE;<br><br>    <span class="hljs-keyword">CLOSE</span> cur;<br>    <span class="hljs-keyword">SELECT</span> total;<br><span class="hljs-keyword">END</span> $<br>DELIMITER ;<br><br><span class="hljs-comment">-- 调用存储过程</span><br><span class="hljs-keyword">call</span> getTotal();<br></code></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="#触发器"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E8%A7%A6%E5%8F%91%E5%99%A8">#</a>触发器</h2><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</p><p>我们可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。</p><p>使用触发器的优点：</p><ul><li>SQL 触发器提供了另一种检查数据完整性的方法。</li><li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li><li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li><li>SQL 触发器对于审计表中数据的更改非常有用。</li></ul><p>使用触发器的缺点：</p><ul><li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，ASP.NET，Perl）在服务器端验证用户的输入。</li><li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li><li>SQL 触发器可能会增加数据库服务器的开销。</li></ul><p>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。</p><blockquote><p>  注意：在 MySQL 中，分号 <code>;</code> 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p><p>  这时就会用到 <code>DELIMITER</code> 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：<code>DELIMITER new_delemiter</code>。<code>new_delemiter</code> 可以设为 1 个或多个长度的符号，默认的是分号 <code>;</code>，我们可以把它修改为其他符号，如 <code>$</code> - <code>DELIMITER $</code> 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 <code>$</code>，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p></blockquote><p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器。</p><ul><li><code>BEFORE INSERT</code> - 在将数据插入表格之前激活。</li><li><code>AFTER INSERT</code> - 将数据插入表格后激活。</li><li><code>BEFORE UPDATE</code> - 在更新表中的数据之前激活。</li><li><code>AFTER UPDATE</code> - 更新表中的数据后激活。</li><li><code>BEFORE DELETE</code> - 在从表中删除数据之前激活。</li><li><code>AFTER DELETE</code> - 从表中删除数据后激活。</li></ul><p>但是，从 MySQL 版本 5.7.2+开始，可以为同一触发事件和操作时间定义多个触发器。</p><p>**<code>NEW</code> 和 <code>OLD</code>**：</p><ul><li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li><li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要（<code>BEFORE</code>）或已经（<code>AFTER</code>）插入的新数据；</li><li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li><li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li><li>使用方法：<code>NEW.columnName</code> （columnName 为相应数据表某一列名）</li></ul><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="#创建触发器"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8">#</a>创建触发器</h3><blockquote><p>  提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p></blockquote><p><code>CREATE TRIGGER</code> 指令用于创建触发器。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name<br>trigger_time<br>trigger_event<br><span class="hljs-keyword">ON</span> table_name<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>  trigger_statements<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><code>trigger_name</code>：触发器名</li><li><code>trigger_time</code> : 触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li><li><code>trigger_event</code> : 触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li><li><code>table_name</code> : 触发器的监听目标。指定在哪张表上建立触发器。</li><li><code>FOR EACH ROW</code>: 行级监视，Mysql 固定写法，其他 DBMS 不同。</li><li><code>trigger_statements</code>: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li></ul><p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> `trigger_insert_user`<br>AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `user_history`(user_id, operate_type, operate_time)<br>    <span class="hljs-keyword">VALUES</span> (NEW.id, <span class="hljs-string">&#x27;add a user&#x27;</span>,  now());<br><span class="hljs-keyword">END</span> $<br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="#查看触发器"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9F%A5%E7%9C%8B%E8%A7%A6%E5%8F%91%E5%99%A8">#</a>查看触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TRIGGERS;<br></code></pre></td></tr></table></figure><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="#删除触发器"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8">#</a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> IF <span class="hljs-keyword">EXISTS</span> trigger_insert_user;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NoSQL基础知识.md</title>
    <link href="/2024/02/27/DB/basic_knowledge/NoSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/02/27/DB/basic_knowledge/NoSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="NoSQL-是什么？"><a href="#NoSQL-是什么？" class="headerlink" title="NoSQL 是什么？"></a>NoSQL 是什么？</h2><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p><p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/sql-nosql-tushi.png" alt="img"></p><h2 id="SQL-和-NoSQL-有什么区别？"><a href="#SQL-和-NoSQL-有什么区别？" class="headerlink" title="SQL 和 NoSQL 有什么区别？"></a>SQL 和 NoSQL 有什么区别？</h2><table><thead><tr><th align="left"></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td align="left">数据存储模型</td><td>结构化存储，具有固定行和列的表格</td><td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td align="left">发展历程</td><td>开发于 1970 年代，重点是减少数据重复</td><td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td></tr><tr><td align="left">例子</td><td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL</td><td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph</td></tr><tr><td align="left">ACID 属性</td><td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td><td>为了可扩展、高性能，通常不支持 ACID 事务，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务的支持和 MySQL 还是有所区别的。</td></tr><tr><td align="left">性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td></tr><tr><td align="left">扩展</td><td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td><td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td></tr><tr><td align="left">用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td align="left">查询语法</td><td>结构化查询语言 (SQL)</td><td>数据访问语法可能因数据库而异</td></tr></tbody></table><h2 id="NoSQL-数据库有什么优势？"><a href="#NoSQL-数据库有什么优势？" class="headerlink" title="NoSQL 数据库有什么优势？"></a>NoSQL 数据库有什么优势？</h2><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p><ul><li><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</li><li><strong>可扩展性：</strong> NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li><li><strong>高性能：</strong> NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li><li><strong>强大的功能：</strong> NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li></ul><h2 id="NoSQL-数据库有哪些类型？"><a href="#NoSQL-数据库有哪些类型？" class="headerlink" title="NoSQL 数据库有哪些类型？"></a>NoSQL 数据库有哪些类型？</h2><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li><li><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li></ul><p>下面这张图片来源于 <a href="https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/relational-vs-nosql-data">微软的官方文档 | 关系数据与 NoSQL 数据open in new window</a>。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231122153605567.png" alt="image-20231122153605567"></p>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符集.md</title>
    <link href="/2024/02/27/DB/basic_knowledge/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    <url>/2024/02/27/DB/basic_knowledge/%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  MySQL 字符编码集中有两套 UTF-8 编码实现：**<code>utf8</code>** 和 **<code>utf8mb4</code>**。</p><p>  如果使用 <strong><code>utf8</code></strong> 的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p></blockquote><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，比如说有些字符集是无法表示汉字的。</p><p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p><p>我们要将这些字符和二进制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。我们将字符对应二进制数据的过程称为”<strong>字符编码</strong>“，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p><h2 id="常见的字符集"><a href="#常见的字符集" class="headerlink" title="常见的字符集"></a>常见的字符集</h2><p>常见的字符集有 ASCII、GB2312、GBK、UTF-8……。</p><p>不同的字符集的主要区别在于：</p><ul><li>可以表示的字符范围</li><li>编码方式</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p><p><strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？</strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言。</p><p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p><p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 128（2^7）个字符。</p><p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 256（2^8）个字符。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。</p><p>对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p><p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p><h3 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h3><p>BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。</p><h3 id="Unicode-UTF-8-编码"><a href="#Unicode-UTF-8-编码" class="headerlink" title="Unicode &amp; UTF-8 编码"></a>Unicode &amp; UTF-8 编码</h3><p><strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p><p>乱码的本质：<strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p><p><img src="https://oss.javaguide.cn/javaguide/a8808cbabeea49caa3af27d314fa3c02-1.jpg" alt="img"></p><p>为了解决这个问题<strong>Unicode</strong> 诞生了。</p><p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p><p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p><p>UTF-8 使用 1 到 4 个字节为每个字符编码， UTF-16 使用 2 或 4 个字节为每个字符编码，UTF-32 固定位 4 个字节为每个字符编码。</p><p>UTF-8 可以根据不同的符号自动选择编码的长短，像英文字符只需要 1 个字节就够了，这一点 ASCII 字符集一样 。因此，对于英语字符，UTF-8 编码和 ASCII 码是相同的。</p><p>UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。</p><p><strong>UTF-8</strong> 是目前使用最广的一种字符编码。</p><p><img src="https://oss.javaguide.cn/javaguide/1280px-Utf8webgrowth.svg.png" alt="img"></p><h2 id="MySQL-字符集"><a href="#MySQL-字符集" class="headerlink" title="MySQL 字符集"></a>MySQL 字符集</h2><p>MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5。</p><h3 id="查看支持的字符集"><a href="#查看支持的字符集" class="headerlink" title="查看支持的字符集"></a>查看支持的字符集</h3><p>你可以通过 <code>SHOW CHARSET</code> 命令来查看，支持 like 和 where 子句。</p><h3 id="默认字符集"><a href="#默认字符集" class="headerlink" title="默认字符集"></a>默认字符集</h3><p>在 MySQL5.7 中，默认字符集是 <code>latin1</code> ；在 MySQL8.0 中，默认字符集是 <code>utf8mb4</code></p><h3 id="字符集的层次级别"><a href="#字符集的层次级别" class="headerlink" title="字符集的层次级别"></a>字符集的层次级别</h3><p>MySQL 中的字符集有以下的层次级别：</p><ul><li><code>server</code>（MySQL 实例级别）</li><li><code>database</code>（库级别）</li><li><code>table</code>（表级别）</li><li><code>column</code>（字段级别）</li></ul><p>它们的优先级可以简单的认为是从上往下依次增大，也即 <code>column</code> 的优先级会大于 <code>table</code> 等其余层次的。如指定 MySQL 实例级别字符集是<code>utf8mb4</code>，指定某个表字符集是<code>latin1</code>，那么这个表的所有字段如果不指定的话，编码就是<code>latin1</code>。</p><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>不同版本的 MySQL 其 <code>server</code> 级别的字符集默认值不同，在 MySQL5.7 中，其默认值是 <code>latin1</code> ；在 MySQL8.0 中，其默认值是 <code>utf8mb4</code> 。</p><p>当然也可以通过在启动 <code>mysqld</code> 时指定 <code>--character-set-server</code> 来设置 <code>server</code> 级别的字符集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqld<br>mysqld --character-set-server=utf8mb4<br>mysqld --character-set-server=utf8mb4 \<br>  --collation-server=utf8mb4_0900_ai_ci<br></code></pre></td></tr></table></figure><p>或者如果你是通过源码构建的方式启动的 MySQL，你可以在 <code>cmake</code> 命令中指定选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake . -DDEFAULT_CHARSET=latin1<br>或者<br>cmake . -DDEFAULT_CHARSET=latin1 \<br>  -DDEFAULT_COLLATION=latin1_german1_ci<br></code></pre></td></tr></table></figure><p>此外，你也可<strong>以在运行时改变 <code>character_set_server</code> 的值</strong>，从而达到修改 <code>server</code> 级别的字符集的目的。</p><p><code>server</code> 级别的字符集是 MySQL 服务器的全局设置，它不仅会作为创建或修改数据库时的默认字符集（如果没有指定其他字符集），还会影响到客户端和服务器之间的连接字符集。</p><h4 id="database"><a href="#database" class="headerlink" title="database"></a>database</h4><p><code>database</code> 级别的字符集是我们在创建数据库和修改数据库时指定的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE db_name<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> charset_name]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> collation_name]<br><br><span class="hljs-keyword">ALTER</span> DATABASE db_name<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> charset_name]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> collation_name]<br></code></pre></td></tr></table></figure><p>如前面所说，如果在执行上述语句时未指定字符集，那么 MySQL 将会使用 <code>server</code> 级别的字符集。</p><p>可以通过下面的方式查看某个数据库的字符集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE db_name;<br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@character_set_database</span>, @<span class="hljs-variable">@collation_database</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME<br><span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.SCHEMATA <span class="hljs-keyword">WHERE</span> SCHEMA_NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;db_name&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p><code>table</code> 级别的字符集是在创建表和修改表时指定的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl_name (column_list)<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> charset_name]<br>    [<span class="hljs-keyword">COLLATE</span> collation_name]]<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> charset_name]<br>    [<span class="hljs-keyword">COLLATE</span> collation_name]<br></code></pre></td></tr></table></figure><p>如果在创建表和修改表时未指定字符集，那么将会使用 <code>database</code> 级别的字符集。</p><h4 id="column"><a href="#column" class="headerlink" title="column"></a>column</h4><p><code>column</code> 级别的字符集同样是在创建表和修改表时指定的，只不过它是定义在列中。下面是个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1<br>(<br>    col1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">5</span>)<br>      <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> latin1<br>      <span class="hljs-keyword">COLLATE</span> latin1_german1_ci<br>);<br></code></pre></td></tr></table></figure><p>如果未指定列级别的字符集，那么将会使用表级别的字符集。</p><h3 id="连接字符集"><a href="#连接字符集" class="headerlink" title="连接字符集"></a>连接字符集</h3><p>前面说到了字符集的层次级别，它们是和存储相关的。而连接字符集涉及的是和 MySQL 服务器的通信。</p><p>连接字符集与下面这几个变量息息相关：</p><ul><li><code>character_set_client</code> ：描述了客户端发送给服务器的 SQL 语句使用的是什么字符集。</li><li><code>character_set_connection</code> ：描述了服务器接收到 SQL 语句时使用什么字符集进行翻译。</li><li><code>character_set_results</code> ：描述了服务器返回给客户端的结果使用的是什么字符集。</li></ul><p>它们的值可以通过下面的 SQL 语句查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> performance_schema.session_variables<br><span class="hljs-keyword">WHERE</span> VARIABLE_NAME <span class="hljs-keyword">IN</span> (<br><span class="hljs-string">&#x27;character_set_client&#x27;</span>, <span class="hljs-string">&#x27;character_set_connection&#x27;</span>,<br><span class="hljs-string">&#x27;character_set_results&#x27;</span>, <span class="hljs-string">&#x27;collation_connection&#x27;</span><br>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> VARIABLE_NAME;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> SESSION VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;character\_set\_%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>如果要想修改前面提到的几个变量的值，有以下方式：</p><p>1、修改配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">[mysql]</span><br><span class="hljs-comment"># 只针对MySQL客户端程序</span><br><span class="hljs-attr">default-character-set</span>=<span class="hljs-string">utf8mb4</span><br></code></pre></td></tr></table></figure><p>2、使用 SQL 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> names utf8mb4<br># 或者一个个进行修改<br># <span class="hljs-keyword">SET</span> character_set_client <span class="hljs-operator">=</span> utf8mb4;<br># <span class="hljs-keyword">SET</span> character_set_results <span class="hljs-operator">=</span> utf8mb4;<br># <span class="hljs-keyword">SET</span> collation_connection <span class="hljs-operator">=</span> utf8mb4;<br></code></pre></td></tr></table></figure><h3 id="JDBC-对连接字符集的影响"><a href="#JDBC-对连接字符集的影响" class="headerlink" title="JDBC 对连接字符集的影响"></a>JDBC 对连接字符集的影响</h3><p>存储 emoji 表情正常，但是使用类似 Navicat 之类的软件的进行查询的时候，发现 emoji 表情变成了问号的情况。这个问题很有可能就是 JDBC 驱动引起的。</p><p>根据前面的内容，我们知道连接字符集也是会影响我们存储的数据的，而 JDBC驱动会影响连接字符集。</p><p><code>mysql-connector-java</code> （JDBC驱动）主要通过这几个属性影响连接字符集：</p><ul><li><code>characterEncoding</code></li><li><code>characterSetResults</code></li></ul><p>以 <code>DataGrip 2023.1.2</code> 来说，在它配置数据源的高级对话框中，可以看到 <code>characterSetResults</code> 的默认值是 <code>utf8</code> ，在使用 <code>mysql-connector-java 8.0.25</code> 时，连接字符集最后会被设置成 <code>utf8mb3</code> 。那么这种情况下 emoji 表情就会被显示为问号，并且当前版本驱动还不支持把 <code>characterSetResults</code> 设置为 <code>utf8mb4</code> ，不过换成 <code>mysql-connector-java driver 8.0.29</code> 却是允许的。</p><h3 id="UTF-8-使用"><a href="#UTF-8-使用" class="headerlink" title="UTF-8 使用"></a>UTF-8 使用</h3><p>通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。</p><p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p><ul><li>**<code>utf8</code>**：<code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li><li>**<code>utf8mb4</code>**：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li></ul><p><strong>为什么有两套 UTF-8 编码实现呢？</strong> 原因如下：</p><p><img src="https://oss.javaguide.cn/javaguide/image-20211008164542347.png" alt="img"></p><p>因此，如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code> 而不是<code>utf8</code> ，要不然存储的时候就会报错了。</p>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基础知识.md</title>
    <link href="/2024/02/27/DB/basic_knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/02/27/DB/basic_knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h2><ul><li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li></ul><h2 id="什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h2><ul><li><strong>元组</strong>：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li><li><strong>码</strong>：码就是能唯一标识实体的属性，对应表中的列。</li><li><strong>候选码</strong>：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li><li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li><li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li><strong>主属性</strong>：候选码中出现过的属性称为主属性。比如关系工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li></ul><h2 id="什么是-ER-图？"><a href="#什么是-ER-图？" class="headerlink" title="什么是 ER 图？"></a>什么是 ER 图？</h2><p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。</p><p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。</p><p>ER 图由下面 3 个要素组成：</p><ul><li><strong>实体</strong>：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li><li><strong>属性</strong>：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。</li><li><strong>联系</strong>：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li></ul><p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231122134500348.png" alt="image-20231122134500348">学生与课程之间联系的E-R图</p><h2 id="数据库范式了解吗"><a href="#数据库范式了解吗" class="headerlink" title="数据库范式了解吗?"></a>数据库范式了解吗?</h2><p>数据库范式有 3 种：</p><ul><li>1NF(第一范式)：属性不可再分。</li><li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul><h3 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p><h3 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h3><p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231122134522783.png" alt="image-20231122134522783"></p><p>一些重要的概念：</p><ul><li><strong>函数依赖（functional dependency）</strong>：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li><li><strong>部分函数依赖（partial functional dependency）</strong>：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖于（学号，身份证号）；</li><li>**完全函数依赖(Full functional dependency)**：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li><li><strong>传递函数依赖</strong>：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li></ul><h3 id="3NF-第三范式"><a href="#3NF-第三范式" class="headerlink" title="3NF(第三范式)"></a>3NF(第三范式)</h3><p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p><h2 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别?"></a>主键和外键有什么区别?</h2><ul><li>**主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li>**外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h2 id="为什么不推荐使用外键与级联？"><a href="#为什么不推荐使用外键与级联？" class="headerlink" title="为什么不推荐使用外键与级联？"></a>为什么不推荐使用外键与级联？</h2><p>对于外键和级联，阿里巴巴开发手册这样说到：</p><blockquote><p>  【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p><p>  说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度</p></blockquote><p>为什么不要用外键呢？大部分人可能会这样回答：</p><ol><li><strong>增加了复杂性：</strong> a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li><li><strong>增加了额外工作</strong>：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li><li><strong>对分库分表不友好</strong>：因为分库分表下外键是无法生效的。</li><li>……</li></ol><p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p><ol><li>保证了数据库数据的一致性和完整性；</li><li>级联操作方便，减轻了程序代码量；</li><li>……</li></ol><p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p><h2 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程?"></a>什么是存储过程?</h2><p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p><p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p><p>阿里巴巴 Java 开发手册里要求<strong>禁止使用存储过程</strong>。</p><h2 id="drop、delete-与-truncate-区别？"><a href="#drop、delete-与-truncate-区别？" class="headerlink" title="drop、delete 与 truncate 区别？"></a>drop、delete 与 truncate 区别？</h2><h3 id="用法不同"><a href="#用法不同" class="headerlink" title="用法不同"></a>用法不同</h3><ul><li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li><li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li></ul><p><code>truncate</code> 和不带 <code>where</code>子句的 <code>delete</code>、以及 <code>drop</code> 都会删除表内的数据，但是 <strong><code>truncate</code> 和 <code>delete</code> 只删除数据不删除表的结构(定义)，执行 <code>drop</code> 语句，此表的结构也会删除，也就是执行<code>drop</code> 之后对应的表不复存在。</strong></p><h3 id="属于不同的数据库语言"><a href="#属于不同的数据库语言" class="headerlink" title="属于不同的数据库语言"></a>属于不同的数据库语言</h3><p><code>truncate</code> 和 <code>drop</code> 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 <code>delete</code> 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。</p><p><strong>DML 语句和 DDL 语句区别：</strong></p><ul><li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li><li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li></ul><p>另外，由于<code>select</code>不会对表进行破坏，所以有的地方也会把<code>select</code>单独区分开叫做数据库查询语言 DQL（Data Query Language）。</p><h3 id="执行速度不同"><a href="#执行速度不同" class="headerlink" title="执行速度不同"></a>执行速度不同</h3><p>一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code>（个人没有实际测试过）</p><ul><li><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li><li><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li><li><code>drop</code>命令会把表占用的空间全部释放掉。</li></ul><p>Tips：应该更多地关注在使用场景上，而不是执行效率。</p><h2 id="数据库设计通常分为哪几步"><a href="#数据库设计通常分为哪几步" class="headerlink" title="数据库设计通常分为哪几步?"></a>数据库设计通常分为哪几步?</h2><ol><li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li></ol>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遗传算法</title>
    <link href="/2023/11/23/%E7%AE%97%E6%B3%95/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    <url>/2023/11/23/%E7%AE%97%E6%B3%95/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>三个操作：</p><ul><li>选择</li><li>交叉</li><li>变异</li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231025164709391.png" alt="image-20231025164709391"></p>]]></content>
    
    
    <categories>
      
      <category>智能算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智能算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java新版本的重要语言特性（9-17）</title>
    <link href="/2023/09/21/Java/Java%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E9%87%8D%E8%A6%81%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%EF%BC%889-17%EF%BC%89/"/>
    <url>/2023/09/21/Java/Java%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E9%87%8D%E8%A6%81%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%EF%BC%889-17%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h2><h4 id="允许在接口中使用私有方法"><a href="#允许在接口中使用私有方法" class="headerlink" title="允许在接口中使用私有方法"></a>允许在接口中使用私有方法</h4><h2 id="JDK10"><a href="#JDK10" class="headerlink" title="JDK10"></a>JDK10</h2><h4 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">String</span>&gt;();<br></code></pre></td></tr></table></figure><ul><li>声明时必须初始化</li></ul><p>可以使用在：</p><ul><li>具有初始化器的局部变量</li><li>增强型 for 循环中的索引变量</li><li>传统 for 循环中声明的局部变量</li></ul><p>不能使用在：</p><ul><li>推断方法的参数类型</li><li>构造函数参数类型推断</li><li>推断方法返回类型</li><li>字段类型推断</li><li>捕获表达式（或任何其他类型的变量声明）</li></ul><p>建议：为了程序的易读性和可维护性，尽量显式定义变量类型。</p><h2 id="JDK11"><a href="#JDK11" class="headerlink" title="JDK11"></a>JDK11</h2><h4 id="用于-Lambda-参数的局部变量语法"><a href="#用于-Lambda-参数的局部变量语法" class="headerlink" title="用于 Lambda 参数的局部变量语法"></a>用于 Lambda 参数的局部变量语法</h4><p>将局部变量和 Lambda 表达式的用法进行了统一，并且可以将注释应用于局部变量和 Lambda 表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Nonnull</span> <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br><br>(@<span class="hljs-title class_">Nonnull</span> <span class="hljs-keyword">var</span> x, @<span class="hljs-title class_">Nullable</span> <span class="hljs-keyword">var</span> y) -&gt; x.<span class="hljs-title function_">process</span>(y)<br></code></pre></td></tr></table></figure><ul><li>@NonNull 注解可以标注在方法、字段、参数之上，表示对应的值不能为空；</li><li>@Nullable 注解可以标注在方法、字段、参数之上，表示对应的值可以为空；</li></ul><h2 id="JDK12"><a href="#JDK12" class="headerlink" title="JDK12"></a>JDK12</h2><h2 id="JDK13"><a href="#JDK13" class="headerlink" title="JDK13"></a>JDK13</h2><h2 id="JDK14"><a href="#JDK14" class="headerlink" title="JDK14"></a>JDK14</h2><h4 id="Switch-表达式"><a href="#Switch-表达式" class="headerlink" title="Switch 表达式"></a>Switch 表达式</h4><p>旧版：</p><ul><li>一般使用冒号 ：来作为语句分支代码的开始。</li><li>在每个分支结束之前，需要加上 break 关键字进行分支跳出，以防 switch 语句一直往后执行到整个 switch 语句结束。</li></ul><p>新版：</p><ul><li>提供了新的分支切换方式，即 -&gt; 符号右则表达式方法体。</li><li>在执行完分支方法之后，自动结束 switch 分支。</li><li>-&gt; 右则方法块中可以是表达式、代码块或者是手动抛出的异常。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//旧版：</span><br>int dayOfWeek;<br><span class="hljs-keyword">switch</span> (day) &#123;<br>    <br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">MONDAY</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">TUESDAY</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">WEDNESDAY</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">THURSDAY</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">FRIDAY</span>:<br>        dayOfWeek = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">SATURDAY</span>:<br>        dayOfWeek = <span class="hljs-number">6</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">SUNDAY</span>:<br>        dayOfWeek = <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>        dayOfWeek = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">//新版：</span><br>int dayOfWeek = <span class="hljs-keyword">switch</span> (day) &#123;<br>    <br>    <span class="hljs-keyword">case</span> <span class="hljs-variable constant_">MONDAY</span>, <span class="hljs-variable constant_">TUESDAY</span>, <span class="hljs-variable constant_">WEDNESDAY</span>, <span class="hljs-variable constant_">THURSDAY</span>, <span class="hljs-variable constant_">FRIDAY</span> -&gt; <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-variable constant_">SATURDAY</span> -&gt; <span class="hljs-number">6</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-variable constant_">SUNDAY</span> -&gt; <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>之前需要用变量来接收返回值，现在直接返回需要返回的结果。</li><li>不再需要显式地跳出当前分支，表达式执行完后会自动跳出，不会继续往后执行。</li><li>对于多个相同的 case 方法块，可以将 case 条件并列，不再通过每个 case 后面故意不加 break 关键字来使用相同方法块。</li></ul><h2 id="JDK15"><a href="#JDK15" class="headerlink" title="JDK15"></a>JDK15</h2><h4 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h4><p>文本块就是以三个引号开始，并以三个引号结束的字符串字面量。<br>文本块减少了转义，大大提高了代码可读性，尤其是代码中对SQL、HTML、JSON字符串进行拼接的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 旧版</span><br><span class="hljs-title class_">String</span> sqlTemplate = <span class="hljs-string">&quot;SELECT\n&quot;</span> +<br>        <span class="hljs-string">&quot;    name,\n&quot;</span> +<br>        <span class="hljs-string">&quot;    age,\n&quot;</span> +<br>        <span class="hljs-string">&quot;    phone,\n&quot;</span> +<br>        <span class="hljs-string">&quot;    wechat\n&quot;</span> +<br>        <span class="hljs-string">&quot;FROM\n&quot;</span> +<br>        <span class="hljs-string">&quot;    csdn_user;&quot;</span>;<br><span class="hljs-comment">// 新版</span><br><span class="hljs-title class_">String</span> sqlTemplate = <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">        SELECT</span><br><span class="hljs-string">            name,</span><br><span class="hljs-string">            age,</span><br><span class="hljs-string">            phone,</span><br><span class="hljs-string">            wechat</span><br><span class="hljs-string">        FROM</span><br><span class="hljs-string">            csdn_user;</span><br><span class="hljs-string">        &quot;</span><span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="JDK16"><a href="#JDK16" class="headerlink" title="JDK16"></a>JDK16</h2><h4 id="instanceof-模式匹配"><a href="#instanceof-模式匹配" class="headerlink" title="instanceof 模式匹配"></a>instanceof 模式匹配</h4><p>对 instanceof 的改进，主要目的是为了让创建对象更简单、简洁和高效，并且可读性更强、提高安全性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 旧版</span><br><span class="hljs-comment">// 每次在检查类型之后，都需要强制进行类型转换。</span><br><span class="hljs-comment">// 类型转换后，需要提前创建一个局部变量来接收转换后的结果，代码显得多余且繁琐。</span><br><span class="hljs-keyword">if</span> (person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Student</span>) &#123;<br>    <br>    <span class="hljs-title class_">Student</span> student = (<span class="hljs-title class_">Student</span>) person;<br>    student.<span class="hljs-title function_">say</span>();<br>   <span class="hljs-comment">// other student operations</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Teacher</span>) &#123;<br>    <br>    <span class="hljs-title class_">Teacher</span> teacher = (<span class="hljs-title class_">Teacher</span>) person;<br>    teacher.<span class="hljs-title function_">say</span>();<br>    <span class="hljs-comment">// other teacher operations</span><br>&#125;<br><br><span class="hljs-comment">// 新版</span><br><span class="hljs-comment">// 对 person 对象进行类型匹配，校验 person 对象是否为 Student 类型</span><br><span class="hljs-comment">// 如果类型匹配成功，则会转换为 Student 类型，并赋值给模式局部变量 student</span><br><span class="hljs-keyword">if</span> (person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Student</span> student) &#123;<br>    <br><span class="hljs-comment">//这里的 student 变量只能在 if 块中使用，而不能在 else if/else 中使用</span><br>    student.<span class="hljs-title function_">say</span>();<br>   <span class="hljs-comment">// other student operations</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Teacher</span> teacher) &#123;<br>    <br>    teacher.<span class="hljs-title function_">say</span>();<br>    <span class="hljs-comment">// other teacher operations</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果 if 条件中有 &amp;&amp; 运算符时，当 instanceof 类型匹配成功，模式局部变量的作用范围也可以相应延长，如下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span> s &amp;&amp; s.<span class="hljs-title function_">length</span>() &gt; <span class="hljs-number">5</span>) &#123;<br>    .. s.<span class="hljs-title function_">contains</span>(..) ..&#125;<br></code></pre></td></tr></table></figure><p>注意：这种作用范围延长，并不适用于或 || 运算符，因为即便 || 运算符左边的 instanceof 类型匹配没有成功也不会造成短路，依旧会执行到||运算符右边的表达式.但是如果左边instanceof 类型匹配没有成功，局部变量并未定义赋值，此时使用会产生问题。</p><h4 id="Records类型"><a href="#Records类型" class="headerlink" title="Records类型"></a>Records类型</h4><ul><li>Record 类型允许在代码中使用紧凑的语法形式来声明类，而这些类能够作为不可变数据类型的封装持有者。Record 这一特性主要用在特定领域的类上；</li><li>与枚举类型一样，Record 类型是一种受限形式的类型，主要用于存储、保存数据，并且没有其它额外自定义行为的场景下。</li><li>效果有些类似 Lombok 的 @Data 注解、Kotlin 中的 data class，但是又不尽完全相同，它们的共同点都是类的部分或者全部可以直接在类头中定义、描述，并且这个类只用于存储数据而已。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 示例</span><br>public record <span class="hljs-title class_">Person</span>(<span class="hljs-title class_">String</span> name, int age) &#123;<br>    <br>    public <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> address;<br><br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 编译后反编译的结果</span><br>public final <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">java.lang.Record</span> &#123;<br>    <br>    private final java.<span class="hljs-property">lang</span>.<span class="hljs-property">String</span> name;<br>    private final java.<span class="hljs-property">lang</span>.<span class="hljs-property">String</span> age;<br><br>    public <span class="hljs-title class_">Person</span>(java.<span class="hljs-property">lang</span>.<span class="hljs-property">String</span> name, java.<span class="hljs-property">lang</span>.<span class="hljs-property">String</span> age) &#123;<br>     <span class="hljs-comment">/* compiled code */</span> &#125;<br><br>    public java.<span class="hljs-property">lang</span>.<span class="hljs-property">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">/* compiled code */</span> &#125;<br><br>    public java.<span class="hljs-property">lang</span>.<span class="hljs-property">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">/* compiled code */</span> &#125;<br><br>    public final int <span class="hljs-title function_">hashCode</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">/* compiled code */</span> &#125;<br><br>    public final boolean <span class="hljs-title function_">equals</span>(<span class="hljs-params">java.lang.<span class="hljs-built_in">Object</span> o</span>) &#123;<br>     <span class="hljs-comment">/* compiled code */</span> &#125;<br><br>    public java.<span class="hljs-property">lang</span>.<span class="hljs-property">String</span> <span class="hljs-title function_">name</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">/* compiled code */</span> &#125;<br><br>    public java.<span class="hljs-property">lang</span>.<span class="hljs-property">String</span> <span class="hljs-title function_">age</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">/* compiled code */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以得出，当用 Record 来声明一个类时，该类将自动拥有下面特征：</p><ul><li>拥有一个构造方法</li><li>获取成员属性值的方法：name()、age()</li><li>hashCode() 方法和 euqals() 方法</li><li>toString() 方法类</li><li>对象被 final 关键字修饰，不能被继承；类的成员变量也都被 final 修饰，不能再被赋值使用。</li><li>可以在 Record 声明的类中定义静态属性和方法。</li><li>注意，不能在 Record 声明的类中定义成员变量，类也不能声明为抽象类等。</li></ul><h2 id="JDK17"><a href="#JDK17" class="headerlink" title="JDK17"></a>JDK17</h2><h4 id="密封的类和接口"><a href="#密封的类和接口" class="headerlink" title="密封的类和接口"></a>密封的类和接口</h4><p>用来增强 Java 编程语言，防止其他类或接口扩展或实现它们。</p><p>使用修饰符<strong>sealed</strong>，您可以将一个类声明为密封类。<br>密封的类使用关键字<strong>permits</strong>列出可以直接扩展它的类。<br>子类可以是最终的、非密封的或密封的。<br><strong>继承了密封类的子类可以使用non-sealed修饰，这样任何类都可以继承这个子类。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 旧版</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>     &#125; <span class="hljs-comment">//人</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>     &#125;<span class="hljs-comment">//教师</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>     &#125;  <span class="hljs-comment">//工人</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span>&#123;<br>     &#125; <span class="hljs-comment">//学生</span><br><br><br><span class="hljs-comment">// 新版</span><br><span class="hljs-comment">// 添加sealed修饰符，permits后面跟上只能被继承的子类名称</span><br>public sealed <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> permits <span class="hljs-title class_">Teacher</span>, <span class="hljs-title class_">Worker</span>, <span class="hljs-title class_">Student</span>&#123;<br>     &#125; <span class="hljs-comment">//人</span><br> <br><span class="hljs-comment">// 子类可以被修饰为 final</span><br>final <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>     &#125;<span class="hljs-comment">//教师</span><br> <br><span class="hljs-comment">// 子类可以被修饰为 non-sealed，此时 Worker类就成了普通类，谁都可以继承它</span><br>non-sealed <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>     &#125;  <span class="hljs-comment">//工人</span><br><span class="hljs-comment">// 任何类都可以继承Worker</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Worker</span>&#123;<br>    &#125;<br> <br><span class="hljs-comment">//子类可以被修饰为 sealed,同上</span><br>sealed <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> permits <span class="hljs-title class_">MiddleSchoolStudent</span>,<span class="hljs-title class_">GraduateStudent</span>&#123;<br>     &#125; <span class="hljs-comment">//学生</span><br><br>final <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiddleSchoolStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Student</span> &#123;<br>     &#125;  <span class="hljs-comment">//中学生</span><br><br>final <span class="hljs-keyword">class</span> <span class="hljs-title class_">GraduateStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Student</span> &#123;<br>     &#125;  <span class="hljs-comment">//研究生</span><br></code></pre></td></tr></table></figure><p>可以限制类的层次结构。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基本语法</title>
    <link href="/2023/08/28/DB/MySQL/MySQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/08/28/DB/MySQL/MySQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 别名 <span class="hljs-keyword">as</span> 可省略，但中间需要空格<br>select name <span class="hljs-keyword">as</span> 员工姓名, position <span class="hljs-keyword">as</span> 职位名称 <span class="hljs-keyword">from</span> employees;<br></code></pre></td></tr></table></figure><h4 id="常量和运算"><a href="#常量和运算" class="headerlink" title="常量和运算"></a>常量和运算</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">select <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;篮球&#x27;</span> <span class="hljs-keyword">as</span> hobby;<br>select order_id, unit_price, quantity, unit_price * quantity <span class="hljs-keyword">as</span> total_amount <span class="hljs-keyword">from</span> orders;<br></code></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">select name, age, salary <span class="hljs-keyword">from</span> employees where age between <span class="hljs-number">25</span> and <span class="hljs-number">30</span>;<br>select name, age, salary <span class="hljs-keyword">from</span> employees where salary &gt; <span class="hljs-number">5500</span>;<br>select name, age, salary <span class="hljs-keyword">from</span> employees where name != <span class="hljs-string">&#x27;小张&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">-- <span class="hljs-variable constant_">SQL</span>查询语句<br>select name, age <span class="hljs-keyword">from</span> employees where hire_date <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NULL</span>;<br><br>select name, age <span class="hljs-keyword">from</span> employees where hire_date <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>;<br></code></pre></td></tr></table></figure><h4 id="模糊查询-like-not-like"><a href="#模糊查询-like-not-like" class="headerlink" title="模糊查询 like, not like _ %"></a>模糊查询 like, not like _ %</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">select name, age, position <span class="hljs-keyword">from</span> employees where name like <span class="hljs-string">&#x27;%张%&#x27;</span>;<br>-- 只查询以 <span class="hljs-string">&quot;张&quot;</span> 开头的数据行<br>select name, age, position <span class="hljs-keyword">from</span> employees where name like <span class="hljs-string">&#x27;张%&#x27;</span>;<br><br>-- 只查询以 <span class="hljs-string">&quot;张&quot;</span> 结尾的数据行<br>select name, age, position <span class="hljs-keyword">from</span> employees where name like <span class="hljs-string">&#x27;%张&#x27;</span>;<br>-- 可以使用 not like 来查询不包含某关键字的信息。<br></code></pre></td></tr></table></figure><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>AND OR NOT</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">-- <span class="hljs-variable constant_">SQL</span>查询语句<br>select name, age, salary <span class="hljs-keyword">from</span> employees where name like <span class="hljs-string">&#x27;%李%&#x27;</span> and age &lt; <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- <span class="hljs-variable constant_">SQL</span> 查询语句 使用<span class="hljs-variable constant_">DISTINCT</span>关键字来找出不同的班级 <span class="hljs-variable constant_">ID</span><br>select distinct class_id <span class="hljs-keyword">from</span> students;<br>-- <span class="hljs-variable constant_">DISTINCT</span> 关键字还支持根据多个字段的组合来进行去重操作，确保多个字段的组合是唯一的。<br></code></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">-- <span class="hljs-variable constant_">SQL</span> 查询语句 <span class="hljs-number">1</span><br>select name, age <span class="hljs-keyword">from</span> students order by age asc;<br><br>-- <span class="hljs-variable constant_">SQL</span> 查询语句 <span class="hljs-number">2</span><br>select name, score <span class="hljs-keyword">from</span> students order by score desc;<br></code></pre></td></tr></table></figure><h4 id="截断、偏移"><a href="#截断、偏移" class="headerlink" title="截断、偏移"></a>截断、偏移</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">-- <span class="hljs-variable constant_">LIMIT</span> 后只跟一个整数，表示要截断的数据条数（一次获取几条）<br>select task_name, due_date <span class="hljs-keyword">from</span> tasks limit <span class="hljs-number">2</span>;<br><br>-- <span class="hljs-variable constant_">LIMIT</span> 后跟 <span class="hljs-number">2</span> 个整数，依次表示从第几条数据开始、一次获取几条<br>select task_name, due_date <span class="hljs-keyword">from</span> tasks limit <span class="hljs-number">2</span>, <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h4 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span><br>  name,<br>  <span class="hljs-variable constant_">CASE</span> <span class="hljs-variable constant_">WHEN</span> (name = <span class="hljs-string">&#x27;鸡哥&#x27;</span>) <span class="hljs-variable constant_">THEN</span> <span class="hljs-string">&#x27;会&#x27;</span> <span class="hljs-variable constant_">ELSE</span> <span class="hljs-string">&#x27;不会&#x27;</span> <span class="hljs-variable constant_">END</span> <span class="hljs-variable constant_">AS</span> can_rap<br><span class="hljs-variable constant_">FROM</span><br>  student;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">CASE</span> <span class="hljs-variable constant_">WHEN</span> (条件<span class="hljs-number">1</span>) <span class="hljs-variable constant_">THEN</span> 结果<span class="hljs-number">1</span><br>   <span class="hljs-variable constant_">WHEN</span> (条件<span class="hljs-number">2</span>) <span class="hljs-variable constant_">THEN</span> 结果<span class="hljs-number">2</span><br>   ...<br>   <span class="hljs-variable constant_">ELSE</span> 其他结果 <span class="hljs-variable constant_">END</span><br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 获取当前日期<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">DATE</span>() <span class="hljs-variable constant_">AS</span> current_date;<br><br>-- 获取当前日期时间<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">DATETIME</span>() <span class="hljs-variable constant_">AS</span> current_datetime;<br><br>-- 获取当前时间<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">TIME</span>() <span class="hljs-variable constant_">AS</span> current_time;<br>-- 这里的日期、日期时间和时间将根据当前的系统时间来生成，实际运行结果可能会因为当前时间而不同。<br></code></pre></td></tr></table></figure><h4 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">round</span>(<span class="hljs-title function_">AVG</span>(grade),<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 将姓名转换为大写<br><span class="hljs-variable constant_">SELECT</span> name, <span class="hljs-title function_">UPPER</span>(name) <span class="hljs-variable constant_">AS</span> upper_name<br><span class="hljs-variable constant_">FROM</span> employees;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 计算姓名长度<br><span class="hljs-variable constant_">SELECT</span> name, <span class="hljs-title function_">LENGTH</span>(name) <span class="hljs-variable constant_">AS</span> name_length<br><span class="hljs-variable constant_">FROM</span> employees;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 将姓名转换为小写并进行条件筛选<br><span class="hljs-variable constant_">SELECT</span> name, <span class="hljs-title function_">LOWER</span>(name) <span class="hljs-variable constant_">AS</span> lower_name<br><span class="hljs-variable constant_">FROM</span> employees;<br></code></pre></td></tr></table></figure><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li><p>COUNT：计算指定列的行数或非空值的数量。<br>当Mysql确认括号内的表达式值不可能为NULL时，实际上就是在统计行数。<br>所以使用条件要加一个COUNT(c.action &#x3D; ‘confirmed’ OR NULL)<br>不为confirmed时用NULL代替，NULL不会被COUNT统计</p></li><li><p>SUM：计算指定列的数值之和。</p></li><li><p>AVG：计算指定列的数值平均值。</p></li><li><p>MAX：找出指定列的最大值。</p></li><li><p>MIN：找出指定列的最小值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用聚合函数 <span class="hljs-variable constant_">COUNT</span> 计算订单表中的总订单数<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">COUNT</span>(*) <span class="hljs-variable constant_">AS</span> order_num<br><span class="hljs-variable constant_">FROM</span> orders;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用聚合函数 <span class="hljs-title function_">COUNT</span>(<span class="hljs-variable constant_">DISTINCT</span> 列名) 计算订单表中不同客户的数量<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">COUNT</span>(<span class="hljs-variable constant_">DISTINCT</span> customer_id) <span class="hljs-variable constant_">AS</span> customer_num<br><span class="hljs-variable constant_">FROM</span> orders;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用聚合函数 <span class="hljs-variable constant_">SUM</span> 计算总订单金额<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">SUM</span>(amount) <span class="hljs-variable constant_">AS</span> total_amount<br><span class="hljs-variable constant_">FROM</span> orders;<br></code></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h4 id="字段分组"><a href="#字段分组" class="headerlink" title="字段分组"></a>字段分组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用分组聚合查询中每个客户的编号<br><span class="hljs-variable constant_">SELECT</span> customer_id<br><span class="hljs-variable constant_">FROM</span> orders<br><span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> customer_id;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用分组聚合查询每个客户的下单数<br><span class="hljs-variable constant_">SELECT</span> customer_id, <span class="hljs-title function_">COUNT</span>(order_id) <span class="hljs-variable constant_">AS</span> order_num<br><span class="hljs-variable constant_">FROM</span> orders<br><span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> customer_id;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用多字段分组查询表中 每个客户 购买的 每种商品 的总金额，相当于按照客户编号和商品编号分组<br><span class="hljs-variable constant_">SELECT</span> customer_id, product_id, <span class="hljs-title function_">SUM</span>(amount) <span class="hljs-variable constant_">AS</span> total_amount<br><span class="hljs-variable constant_">FROM</span> orders<br><span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> customer_id, product_id;<br></code></pre></td></tr></table></figure><h4 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用 <span class="hljs-variable constant_">HAVING</span> 子句查询订单数超过 <span class="hljs-number">1</span> 的客户<br><br><span class="hljs-variable constant_">SELECT</span> customer_id, <span class="hljs-title function_">COUNT</span>(order_id) <span class="hljs-variable constant_">AS</span> order_num<br><span class="hljs-variable constant_">FROM</span> orders<br><span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> customer_id<br><span class="hljs-variable constant_">HAVING</span> <span class="hljs-title function_">COUNT</span>(order_id) &gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用 <span class="hljs-variable constant_">HAVING</span> 子句查询订单总金额超过 <span class="hljs-number">100</span> 的客户<br><span class="hljs-variable constant_">SELECT</span> customer_id, <span class="hljs-title function_">SUM</span>(amount) <span class="hljs-variable constant_">AS</span> total_amount<br><span class="hljs-variable constant_">FROM</span> orders<br><span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> customer_id<br><span class="hljs-variable constant_">HAVING</span> <span class="hljs-title function_">SUM</span>(amount) &gt; <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><h4 id="CROSS-JOIN"><a href="#CROSS-JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h4><p>是一种简单的关联查询，不需要任何条件来匹配行，它直接将左表的 每一行 与右表的 每一行 进行组合，返回的结果是两个表的笛卡尔积。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> e.<span class="hljs-property">emp_name</span>, e.<span class="hljs-property">salary</span>, e.<span class="hljs-property">department</span>, d.<span class="hljs-property">manager</span><br><span class="hljs-variable constant_">FROM</span> employees e<br><span class="hljs-variable constant_">CROSS</span> <span class="hljs-variable constant_">JOIN</span> departments d;<br></code></pre></td></tr></table></figure><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><p>只返回两个表中满足关联条件的交集部分，即在两个表中都存在的匹配行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> e.<span class="hljs-property">emp_name</span>, e.<span class="hljs-property">salary</span>, e.<span class="hljs-property">department</span>, d.<span class="hljs-property">manager</span><br><span class="hljs-variable constant_">FROM</span> employees e<br><span class="hljs-variable constant_">JOIN</span> departments d <span class="hljs-variable constant_">ON</span> e.<span class="hljs-property">department</span> = d.<span class="hljs-property">department</span>;<br></code></pre></td></tr></table></figure><h4 id="OUTER-JOIN"><a href="#OUTER-JOIN" class="headerlink" title="OUTER JOIN"></a>OUTER JOIN</h4><p>根据指定的关联条件，将两个表中满足条件的行组合在一起，并包含没有匹配的行 。<br>包括 LEFT OUTER JOIN 和 RIGHT OUTER JOIN 两种类型，分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分。有些数据库并不支持 RIGHT JOIN 语法，只需要把主表（from 后面的表）和关联表（LEFT JOIN 后面的表）顺序进行调换即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> e.<span class="hljs-property">emp_name</span>, e.<span class="hljs-property">salary</span>, e.<span class="hljs-property">department</span>, d.<span class="hljs-property">manager</span><br><span class="hljs-variable constant_">FROM</span> employees e<br><span class="hljs-variable constant_">LEFT</span> <span class="hljs-variable constant_">JOIN</span> departments d <span class="hljs-variable constant_">ON</span> e.<span class="hljs-property">department</span> = d.<span class="hljs-property">department</span>;<br></code></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 查询出订单总金额 &gt; <span class="hljs-number">200</span> 的客户的姓名和他们的订单总金额<br>-- 主查询<br><span class="hljs-variable constant_">SELECT</span> name, total_amount<br><span class="hljs-variable constant_">FROM</span> customers<br><span class="hljs-variable constant_">WHERE</span> customer_id <span class="hljs-variable constant_">IN</span> (<br>    -- 子查询<br>    <span class="hljs-variable constant_">SELECT</span> <span class="hljs-variable constant_">DISTINCT</span> customer_id<br>    <span class="hljs-variable constant_">FROM</span> orders<br>    <span class="hljs-variable constant_">WHERE</span> total_amount &gt; <span class="hljs-number">200</span><br>);<br></code></pre></td></tr></table></figure><p><strong>exists</strong><br>用于检查主查询的结果集是否存在满足条件的记录，它返回布尔值（True 或 False），而不返回实际的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 主查询<br><span class="hljs-variable constant_">SELECT</span> name, total_amount<br><span class="hljs-variable constant_">FROM</span> customers<br><span class="hljs-variable constant_">WHERE</span> <span class="hljs-variable constant_">EXISTS</span> (<br>    -- 子查询<br>    <span class="hljs-variable constant_">SELECT</span> <span class="hljs-number">1</span><br>    <span class="hljs-variable constant_">FROM</span> orders<br>    <span class="hljs-variable constant_">WHERE</span> orders.<span class="hljs-property">customer_id</span> = customers.<span class="hljs-property">customer_id</span><br>);<br></code></pre></td></tr></table></figure><h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><ul><li><strong>UNION</strong> 操作：将两个或多个查询的结果集合并， 并去除重复的行 。即如果两个查询的结果有相同的行，则只保留一行。</li><li><strong>UNION ALL</strong> 操作：将两个或多个查询的结果集合并， 但不去除重复的行 。即如果两个查询的结果有相同的行，则全部保留。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> name, age, department<br><span class="hljs-variable constant_">FROM</span> table1<br><span class="hljs-variable constant_">UNION</span><br><span class="hljs-variable constant_">SELECT</span> name, age, department<br><span class="hljs-variable constant_">FROM</span> table2;<br></code></pre></td></tr></table></figure></li></ul><h2 id="开窗函数"><a href="#开窗函数" class="headerlink" title="开窗函数"></a>开窗函数</h2><h4 id="sum-over"><a href="#sum-over" class="headerlink" title="sum over"></a>sum over</h4><p>SUM(计算字段名) OVER (PARTITION BY 分组字段名)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> <br>    order_id, <br>    customer_id, <br>    order_date, <br>    total_amount,<br>    <span class="hljs-title function_">SUM</span>(total_amount) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> customer_id) <span class="hljs-variable constant_">AS</span> customer_total_amount<br><span class="hljs-variable constant_">FROM</span><br>    orders;<br></code></pre></td></tr></table></figure><h4 id="sum-over-order-by"><a href="#sum-over-order-by" class="headerlink" title="sum over order by"></a>sum over order by</h4><p>SUM(计算字段名) OVER (PARTITION BY 分组字段名 ORDER BY 排序字段 排序规则)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 计算每个客户的历史订单累计金额，并显示每个订单的详细信息<br><br><span class="hljs-variable constant_">SELECT</span> <br>    order_id, <br>    customer_id, <br>    order_date, <br>    total_amount,<br>    <span class="hljs-title function_">SUM</span>(total_amount) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> customer_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> order_date <span class="hljs-variable constant_">ASC</span>) <span class="hljs-variable constant_">AS</span> cumulative_total_amount<br><span class="hljs-variable constant_">FROM</span><br>    orders;<br></code></pre></td></tr></table></figure><h4 id="rank"><a href="#rank" class="headerlink" title="rank"></a>rank</h4><p>用于对查询结果集中的行进行 排名 的开窗函数。可以根据指定的列或表达式对结果集中的行进行排序，并为每一行分配一个排名。<br>在排名过程中，相同的值将被赋予相同的排名，而不同的值将被赋予不同的排名。<br>常见用法是在查询结果中查找前几名（Top N）或排名最高的行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">RANK</span>() <span class="hljs-variable constant_">OVER</span> (<br>  <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> 列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>, ... -- 可选，用于指定分组列<br>  <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> 列名<span class="hljs-number">3</span> [<span class="hljs-variable constant_">ASC</span>|<span class="hljs-variable constant_">DESC</span>], 列名<span class="hljs-number">4</span> [<span class="hljs-variable constant_">ASC</span>|<span class="hljs-variable constant_">DESC</span>], ... -- 用于指定排序列及排序方式<br>) <span class="hljs-variable constant_">AS</span> rank_column<br><span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> 子句可选，用于指定分组列，将结果集按照指定列进行分组；<br><span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> 子句用于指定排序列及排序方式，决定了计算 <span class="hljs-title class_">Rank</span> 时的排序规则。<br><span class="hljs-variable constant_">AS</span> rank_column 用于指定生成的 <span class="hljs-title class_">Rank</span> 排名列的别名。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> <br>    order_id, <br>    customer_id, <br>    order_date, <br>    total_amount,<br>    <span class="hljs-title function_">RANK</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> customer_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> total_amount <span class="hljs-variable constant_">DESC</span>) <span class="hljs-variable constant_">AS</span> customer_rank<br><span class="hljs-variable constant_">FROM</span><br>    orders;<br></code></pre></td></tr></table></figure><h4 id="row-number"><a href="#row-number" class="headerlink" title="row_number"></a>row_number</h4><p>用于为查询结果集中的每一行分配唯一连续排名。<br>Row_Number函数为每一行都分配一个唯一的整数值，不管是否存在并列（相同排序值）的情况。<br>每一行都有一个唯一的行号，从 1 开始连续递增。</p><p>Row_Number 开窗函数的语法如下（几乎和 Rank 函数一模一样）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">ROW_NUMBER</span>() <span class="hljs-variable constant_">OVER</span> (<br>  <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column1, column2, ... -- 可选，用于指定分组列<br>  <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column3 [<span class="hljs-variable constant_">ASC</span>|<span class="hljs-variable constant_">DESC</span>], column4 [<span class="hljs-variable constant_">ASC</span>|<span class="hljs-variable constant_">DESC</span>], ... -- 用于指定排序列及排序方式<br>) <span class="hljs-variable constant_">AS</span> row_number_column<br><span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span>子句可选，用于指定分组列，将结果集按照指定列进行分组。<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> 子句用于指定排序列及排序方式，决定了计算 <span class="hljs-title class_">Row</span>_Number 时的排序规则。<span class="hljs-variable constant_">AS</span> row_number_column 用于指定生成的行号列的别名。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> <br>    order_id, <br>    customer_id, <br>    order_date, <br>    total_amount,<br>    <span class="hljs-title function_">ROW_NUMBER</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> customer_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> total_amount <span class="hljs-variable constant_">DESC</span>) <span class="hljs-variable constant_">AS</span> row_number<br><span class="hljs-variable constant_">FROM</span><br>    orders;<br></code></pre></td></tr></table></figure><h4 id="lag-lead"><a href="#lag-lead" class="headerlink" title="lag &#x2F; lead"></a>lag &#x2F; lead</h4><p>在需要比较相邻行数据或进行时间序列分析时非常有用。</p><ul><li><p>Lag 函数用于获取当前行之前的某一列的值。Lag 函数的语法如下：<br>LAG(column_name, offset, default_value) OVER (PARTITION BY partition_column ORDER BY sort_column)<br>参数解释：<br>column_name：要获取值的列名。<br>offset：表示要向上偏移的行数。例如，offset为1表示获取上一行的值，offset为2表示获取上两行的值，以此类推。<br>default_value：可选参数，用于指定当没有前一行时的默认值。<br>PARTITION BY和ORDER BY子句可选，用于分组和排序数据。</p></li><li><p>Lead 函数用于获取 当前行之后 的某一列的值。Lead 函数的语法如下：<br>LEAD(column_name, offset, default_value) OVER (PARTITION BY partition_column ORDER BY sort_column)<br>参数解释：<br>column_name：要获取值的列名。<br>offset：表示要向下偏移的行数。例如，offset为1表示获取下一行的值，offset为2表示获取下两行的值，以此类推。<br>default_value：可选参数，用于指定当没有后一行时的默认值。<br>PARTITION BY和ORDER BY子句可选，用于分组和排序数据。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> <br>    student_id,<br>    exam_date,<br>    score,<br>    <span class="hljs-title function_">LAG</span>(score, <span class="hljs-number">1</span>, <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> student_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> exam_date) <span class="hljs-variable constant_">AS</span> previous_score,<br>    <span class="hljs-title function_">LEAD</span>(score, <span class="hljs-number">1</span>, <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> student_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> exam_date) <span class="hljs-variable constant_">AS</span> next_score<br><span class="hljs-variable constant_">FROM</span><br>    scores;<br></code></pre></td></tr></table></figure><p>整理自网站SQL之母<a href="http://sqlmother.yupi.icu/#/learn%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%BF%87%EF%BC%8C%E4%BD%86%E8%AE%B0%E4%B8%8D%E4%BD%8F%EF%BC%8C%E5%8D%95%E7%8B%AC%E6%9F%A5%E7%9C%8B%E5%A4%AA%E9%BA%BB%E7%83%A6%EF%BC%8C%E6%89%80%E4%BB%A5%E6%95%B4%E7%90%86%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9C%8B%EF%BC%89">http://sqlmother.yupi.icu/#/learn（学习过，但记不住，单独查看太麻烦，所以整理给自己看）</a></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式和Stream API</title>
    <link href="/2023/08/19/Java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CStream%20API/"/>
    <url>/2023/08/19/Java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CStream%20API/</url>
    
    <content type="html"><![CDATA[<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p><strong>1. 有且仅有一个参数时，小括号可以省略（无参数时，小括号不能省略）</strong></p><p><strong>2. 语句只有一条时，可以省略大括号和return</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Runnable</span> runnable = ()-&gt; <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Hello,World!&quot;</span>);<br><br><span class="hljs-title class_">BinaryOperator</span>&lt;<span class="hljs-title class_">Long</span>&gt; bo1 = x -&gt; x+<span class="hljs-number">1</span>;<br><br><span class="hljs-title class_">BinaryOperator</span>&lt;<span class="hljs-title class_">Long</span>&gt; bo2 = (x,y) -&gt; x+y;<br><br><span class="hljs-title class_">BinaryOperator</span>&lt;<span class="hljs-title class_">Long</span>&gt; bo3 = (x,y) -&gt; &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Hello,World!&quot;</span>);<br><span class="hljs-keyword">return</span> x+y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Lambda 表达式中无需指定参数类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。</p><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p>“集合讲的是数据，流讲的是计算！”</p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>Collection创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">stream</span>() <span class="hljs-comment">//返回一个顺序流</span><br><span class="hljs-title function_">parallelStream</span>()<span class="hljs-comment">//返回一个并行流</span><br></code></pre></td></tr></table></figure><p>Array创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">stream</span>(T[] array)<span class="hljs-comment">//返回一个流</span><br></code></pre></td></tr></table></figure><p>值创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">public <span class="hljs-keyword">static</span>&lt;T&gt; <span class="hljs-title class_">Stream</span>&lt;T&gt; <span class="hljs-title function_">of</span>(T... values)<span class="hljs-comment">//返回一个流</span><br></code></pre></td></tr></table></figure><p>函数创建无限流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 迭代</span><br>public <span class="hljs-keyword">static</span>&lt;T&gt; <span class="hljs-title class_">Stream</span>&lt;T&gt; <span class="hljs-title function_">of</span>(T... values)<br><br><span class="hljs-comment">// 生成</span><br>public <span class="hljs-keyword">static</span>&lt;T&gt; <span class="hljs-title class_">Stream</span>&lt;T&gt; <span class="hljs-title function_">generate</span>(<span class="hljs-title class_">Supplier</span>&lt;T&gt; s)<br></code></pre></td></tr></table></figure><h5 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h5><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p><p>筛选与切片(filter、distinct、limit、skip)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; integerList = <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br><span class="hljs-comment">//filter(Predicate p)接收 Lambda，从流中排除某些元素。</span><br><span class="hljs-title class_">Stream</span>&lt;<span class="hljs-title class_">Integer</span>&gt; integerStream = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">filter</span>(x -&gt; x &gt; <span class="hljs-number">6</span>);<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(integerStream.<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>()));<span class="hljs-comment">//[7, 7, 7, 8, 8, 9]</span><br><br><span class="hljs-comment">//distinct()筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span><br><span class="hljs-title class_">Stream</span>&lt;<span class="hljs-title class_">Integer</span>&gt; distinctStream = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">distinct</span>();<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(distinctStream.<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>()));<span class="hljs-comment">//[4, 5, 6, 7, 8, 9]</span><br><br><span class="hljs-comment">//limit(long maxSize) 截断流，使其元素不超过给定数量。</span><br><span class="hljs-title class_">Stream</span>&lt;<span class="hljs-title class_">Integer</span>&gt; limitStream = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">limit</span>(<span class="hljs-number">5</span>);<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(limitStream.<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>()));<span class="hljs-comment">//[4, 5, 6, 7, 7]</span><br><br><span class="hljs-comment">//skip(long n)跳过元素，返回一个扔掉了前 n 个元素的流。</span><br><span class="hljs-comment">//若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span><br><span class="hljs-title class_">Stream</span>&lt;<span class="hljs-title class_">Integer</span>&gt; skipStream = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">skip</span>(<span class="hljs-number">5</span>);<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(skipStream.<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>()));<span class="hljs-comment">//[7, 8, 8, 9]</span><br></code></pre></td></tr></table></figure><p>映射（map、flatMap）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">public <span class="hljs-keyword">static</span> <span class="hljs-title class_">Stream</span>&lt;<span class="hljs-title class_">Character</span>&gt; <span class="hljs-title function_">filterCharacter</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> str</span>)&#123;<br>    <br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Character</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Character</span> ch : str.<span class="hljs-title function_">toCharArray</span>()) &#123;<br>    <br>        list.<span class="hljs-title function_">add</span>(ch);<br>    &#125;<br>    <span class="hljs-keyword">return</span> list.<span class="hljs-title function_">stream</span>();<br>&#125;<br><br>@<span class="hljs-title class_">Test</span><br>public <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params"></span>)&#123;<br>    <br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; stringsList = <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>);<br><br>    <span class="hljs-comment">//map(Function f 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span><br>    <span class="hljs-title class_">Stream</span>&lt;<span class="hljs-title class_">String</span>&gt; mapStream = stringsList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">map</span>(<span class="hljs-title class_">String</span>::toUpperCase);<br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(mapStream.<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>()));<span class="hljs-comment">//[AAA, BBB]</span><br><br><br>    <span class="hljs-comment">//flatMap(Function f)  接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</span><br>    <span class="hljs-title class_">Stream</span>&lt;<span class="hljs-title class_">Character</span>&gt; characterStream = stringsList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">flatMap</span>(<span class="hljs-title class_">StreamTest</span>::filterCharacter).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Character</span>::toUpperCase);<br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(characterStream.<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>()));<span class="hljs-comment">//[A, A, A, B, B, B]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>排序(sorted)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//sorted() 生一个新流，其中按自然顺序排序</span><br><span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; integerList = <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>);<br><span class="hljs-title class_">Stream</span>&lt;<span class="hljs-title class_">Integer</span>&gt; sorted = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">sorted</span>();<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(sorted.<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>()));<span class="hljs-comment">//[2, 4, 5, 6, 7, 9]</span><br><br><span class="hljs-comment">//sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序</span><br><span class="hljs-title class_">Stream</span>&lt;<span class="hljs-title class_">Integer</span>&gt; sorted1 = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">sorted</span>((a, b) -&gt; b - a);<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(sorted1.<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>()));<span class="hljs-comment">//[9, 7, 6, 5, 4, 2]</span><br></code></pre></td></tr></table></figure><h5 id="终止操作-allMatch、anyMatch、noneMatch、findFirst、findAny、count…"><a href="#终止操作-allMatch、anyMatch、noneMatch、findFirst、findAny、count…" class="headerlink" title="终止操作(allMatch、anyMatch、noneMatch、findFirst、findAny、count…)"></a>终止操作(allMatch、anyMatch、noneMatch、findFirst、findAny、count…)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; integerList = <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>);<br><span class="hljs-comment">//检查是否匹配所有元素</span><br>boolean b = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">allMatch</span>(s -&gt; s == <span class="hljs-number">6</span>);<br><span class="hljs-comment">//检查是否至少匹配一个元素</span><br>boolean b1 = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">anyMatch</span>(s -&gt; s == <span class="hljs-number">6</span>);<br><span class="hljs-comment">//检查是否没有匹配所有元素</span><br>boolean b2 = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">noneMatch</span>(s -&gt; s == <span class="hljs-number">6</span>);<br><span class="hljs-comment">//返回第一个元素</span><br><span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">Integer</span>&gt; first= integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">findFirst</span>();<br><span class="hljs-comment">//返回当前流中的任意元素</span><br><span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">Integer</span>&gt; any = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">findAny</span>();<br><span class="hljs-comment">//返回流中元素总数</span><br>long count = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">count</span>();<br><span class="hljs-comment">//返回流中最大值</span><br><span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">Integer</span>&gt; max = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Integer</span>::compare);<br><span class="hljs-comment">//返回流中最小值</span><br><span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">Integer</span>&gt; min = integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Integer</span>::compare);<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(b);<span class="hljs-comment">//false</span><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(b1);<span class="hljs-comment">//true</span><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(b2);<span class="hljs-comment">//false</span><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(first.<span class="hljs-title function_">get</span>());<span class="hljs-comment">//7</span><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(any.<span class="hljs-title function_">get</span>());<span class="hljs-comment">//7</span><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(count);<span class="hljs-comment">//6</span><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(max.<span class="hljs-title function_">get</span>());<span class="hljs-comment">//9</span><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(min.<span class="hljs-title function_">get</span>());<span class="hljs-comment">//2</span><br><span class="hljs-comment">//内部迭代</span><br>integerList.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>::print);<span class="hljs-comment">//745269</span><br></code></pre></td></tr></table></figure><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1578.  使绳子变成彩色的最短时间</title>
    <link href="/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201578.%20%20%E4%BD%BF%E7%BB%B3%E5%AD%90%E5%8F%98%E6%88%90%E5%BD%A9%E8%89%B2%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4/"/>
    <url>/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201578.%20%20%E4%BD%BF%E7%BB%B3%E5%AD%90%E5%8F%98%E6%88%90%E5%BD%A9%E8%89%B2%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>拆除成本 &#x3D; 全部拆除 - 最大的不拆除</li><li>在统计成本的同时，维持一个成本的最大值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">minCost</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> colors, int[] neededTime</span>) &#123;<br>    <br>        int res = <span class="hljs-number">0</span>;<br>        int i = <span class="hljs-number">0</span>;<br>        int len = colors.<span class="hljs-title function_">length</span>();<br>        <span class="hljs-keyword">while</span> (i &lt; len) &#123;<br>    <br>            int max = -<span class="hljs-number">1</span>;<br>            int sum = <span class="hljs-number">0</span>;<br>            char ch = colors.<span class="hljs-title function_">charAt</span>(i);<br>            <span class="hljs-keyword">while</span>(i &lt; len &amp;&amp; colors.<span class="hljs-title function_">charAt</span>(i) == ch) &#123;<br>    <br>                sum += neededTime[i];<br>                max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, neededTime[i]);<br>                i++;<br>            &#125;<br>            res += sum - max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器和布谷鸟过滤器</title>
    <link href="/2023/08/19/Java/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2023/08/19/Java/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>本质：<strong>一个空的2进制数组</strong>（初始全为0，只存0和1）</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>一个key，经过<strong>k个hash函数</strong>运算后，得到k个值，将2进制数组对应下标的位置置为1。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>将key同样进行k个hash，去2进制数组比对对应下标位置的值</p><ul><li>全为1则<strong>可能存在</strong>该key；</li><li>不全为1，则<strong>一定不存在</strong>该key</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>不能删</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>大集合中检查元素是否重复</li><li>Redis中防止缓存穿透</li></ul><p>缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。<br>解决办法：将数据源的key是否存在的信息存储到布隆过滤器中，如果布隆过滤器判定数据不存在，则不再请求数据源。</p><h2 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h2><p>基本的布谷鸟过滤器由两个并不独立的哈希函数构成。<br>基本单位为条目，每个条目存储一个指纹。<br>指纹指的是使用一个哈希函数生成的n位比特位，n的具体大小由所能接受的误判率来设置。一般n&#x3D;8<br>布谷鸟哈希表由一个桶数组构成，每个桶可以有多个条目，即每个桶中有多个存放指纹的位置。</p><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>先进行一次hash，得出应当插入位置和应当插入的值（指纹）。<br>如果这个桶（桶内的m个位置均被占用）插入失败，会重新计算(指纹哈希与第一个索引异或)，查看第二个桶能否插入。</p><p>若第二个桶插入失败，则会随机在两个桶中挑选一个桶，将其中的一个值标记为旧值，用新值覆盖旧值，旧值会在重复上面的步骤进行插入。</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>如果数组过小，会发生循环挤兑的情况。<br>如果超过最大挤兑次数，进行扩容，重新计算每个指纹的位置。</p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><ul><li>通过两次hash找到索引位置，如果任何桶中的指纹匹配，则从该桶中删除匹配指纹的一份副本。</li><li>如果俩数据的哈希值和指纹相同时，会出现误删除情况。</li></ul><h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><p>删除后再添加新指纹。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>支持删除</li><li>在误判率小于3%时，空间性能优于布隆过滤器</li><li>查询效率高</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>插入性能差</li><li>插入重复元素存在上限（哈希函数个数&#x2F;*桶容量）</li><li>空间大小要求是2的指数</li><li>删除有问题，存在误删的概率</li></ul><h2 id="表格一览"><a href="#表格一览" class="headerlink" title="表格一览"></a>表格一览</h2><p>布隆过滤器 布谷鸟过滤器 插入 k个hash函数 2个hash函数 删除 不能删 可以删 更新 不能更新 删除后再添加 查询 有误判率 有误判率 优点 安全、节省空间 查询效率高、支持删除、更节省空间 缺点 有误判率、无法删除 插入性能差、插入重复元素有上限、空间大小为2的指数、删除不完美</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1048. 最长字符串链</title>
    <link href="/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201048.%20%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE/"/>
    <url>/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201048.%20%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>从短到长，增加字母的话，有多个位置，并且每个位置都有26种选择，正难则反。选择从长到短，删除某个字母。</li><li>删除字母得到的新字符串可能已经计算过，所以将计算的结果都记录一下。</li><li>记忆化搜索： 先查表再计算，先存表再返回。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br><span class="hljs-comment">//记忆化</span><br>    <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Integer</span>&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    public int <span class="hljs-title function_">longestStrChain</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] words</span>) &#123;<br>    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> <span class="hljs-attr">str</span>: words) &#123;<br>    <br>            hashMap.<span class="hljs-title function_">put</span>(str, <span class="hljs-number">0</span>);<br>        &#125;<br>        int ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> str : words) &#123;<br>    <br>            ans = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(ans, <span class="hljs-title function_">dfs</span>(str));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    private int <span class="hljs-title function_">dfs</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> str</span>) &#123;<br>    <br>        int res = hashMap.<span class="hljs-title function_">get</span>(str);<br>        <span class="hljs-comment">//大于0代表曾经计算过</span><br>        <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">0</span>) &#123;<br>    <br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-title function_">length</span>(); i++) &#123;<br>    <br>            <span class="hljs-title class_">String</span> tmp = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, i) + str.<span class="hljs-title function_">substring</span>(i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (hashMap.<span class="hljs-title function_">containsKey</span>(tmp)) &#123;<br>    <br>                res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, <span class="hljs-title function_">dfs</span>(tmp));<br>            &#125;<br>        &#125;<br>        hashMap.<span class="hljs-title function_">put</span>(str, res + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1387. 将整数按权重排序</title>
    <link href="/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201387.%20%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201387.%20%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>首先是这种计算权重的方式很有可能出现重复，所以需要记忆化搜索</li><li>记忆化搜索：先查表再计算，先存表再返回。</li><li>将整数 x 和计算的权重分别存储数组的0和1的位置</li><li>重写compare将数组排序按规则排序</li><li>返回结果</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    private <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">Integer</span>, <span class="hljs-title class_">Integer</span>&gt; me = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    public int <span class="hljs-title function_">getKth</span>(<span class="hljs-params">int lo, int hi, int k</span>) &#123;<br>    <br>        int[][] arr = <span class="hljs-keyword">new</span> int[hi - lo + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (int i = lo; i &lt;= hi; i++) &#123;<br>    <br>            int tmp = <span class="hljs-title function_">dfs</span>(i);<br>            me.<span class="hljs-title function_">put</span>(i, tmp);<br>            arr[i - lo][<span class="hljs-number">0</span>] = i;<br>            arr[i - lo][<span class="hljs-number">1</span>] = tmp;<br>        &#125;<br>        <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">sort</span>(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;int[]&gt;() &#123;<br>    <br>            @<span class="hljs-title class_">Override</span><br>            public int <span class="hljs-title function_">compare</span>(<span class="hljs-params">int[] o1, int[] o2</span>) &#123;<br>    <br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] == o2[<span class="hljs-number">1</span>] ? o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>] : o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">return</span> arr[k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br><br>    int <span class="hljs-title function_">dfs</span>(<span class="hljs-params">int x</span>) &#123;<br>    <br>        int res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(me.<span class="hljs-title function_">get</span>(x) != <span class="hljs-literal">null</span>)&#123;<br>    <br>            res = me.<span class="hljs-title function_">get</span>(x);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) &#123;<br>    <br>            res = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>    <br>            res = <span class="hljs-number">1</span> + <span class="hljs-title function_">dfs</span>(x * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>    <br>            res = <span class="hljs-number">1</span> + <span class="hljs-title function_">dfs</span>(x / <span class="hljs-number">2</span>);<br>        &#125;<br>        me.<span class="hljs-title function_">put</span>(x, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1218. 最长定差子序列</title>
    <link href="/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201218.%20%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201218.%20%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>因为不能改变顺序，所以后面的元素，直接看它前面的元素就行。</li><li>长度为n的数组 &#x3D; 长度为n - 1的数组 + 第 n 个数</li><li>从前向后遍历，对于每个元素，如果能找到它的前一个元素，就在前一个元素的基础上+1，否则就录入1。</li><li>同时记录录入的数据的最大值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">longestSubsequence</span>(<span class="hljs-params">int[] arr, int difference</span>) &#123;<br>    <br>        <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">Integer</span>, <span class="hljs-title class_">Integer</span>&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        int res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <br>            int temp = hashMap.<span class="hljs-title function_">getOrDefault</span>(arr[i] - difference, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            hashMap.<span class="hljs-title function_">put</span>(arr[i], temp);<br>            res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK监控和故障处理工具总结</title>
    <link href="/2023/07/16/JVM/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    <url>/2023/07/16/JVM/JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="JDK监控和故障处理工具总结JDK-命令行工具"><a href="#JDK监控和故障处理工具总结JDK-命令行工具" class="headerlink" title="JDK监控和故障处理工具总结JDK 命令行工具"></a>JDK监控和故障处理工具总结JDK 命令行工具</h2><p>这些命令在 JDK 安装目录下的 bin 目录下：</p><ul><li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li><li>**<code>jstat</code>**（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li><li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</li><li><strong><code>jmap</code></strong> (Memory Map for Java) : 生成堆转储快照;</li><li><strong><code>jhat</code></strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP&#x2F;HTML 服务器，让用户可以在浏览器上查看分析结果;</li><li><strong><code>jstack</code></strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li></ul><h3 id="jps-查看所有-Java-进程"><a href="#jps-查看所有-Java-进程" class="headerlink" title="#jps:查看所有 Java 进程"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jps-%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89-java-%E8%BF%9B%E7%A8%8B">#</a><code>jps</code>:查看所有 Java 进程</h3><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p><p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code>：只输出进程的本地虚拟机唯一 ID。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jps<br><span class="hljs-number">7360</span> NettyClient2<br><span class="hljs-number">17396</span><br><span class="hljs-number">7972</span> Launcher<br><span class="hljs-number">16504</span> Jps<br><span class="hljs-number">17340</span> NettyServer<br></code></pre></td></tr></table></figure><p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jps <span class="hljs-literal">-l</span><br><span class="hljs-number">7360</span> firstNettyDemo.NettyClient2<br><span class="hljs-number">17396</span><br><span class="hljs-number">7972</span> org.jetbrains.jps.cmdline.Launcher<br><span class="hljs-number">16492</span> sun.tools.jps.Jps<br><span class="hljs-number">17340</span> firstNettyDemo.NettyServer<br></code></pre></td></tr></table></figure><p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p><p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p><h3 id="jstat-监视虚拟机各种运行状态信息"><a href="#jstat-监视虚拟机各种运行状态信息" class="headerlink" title="#jstat: 监视虚拟机各种运行状态信息"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jstat-%E7%9B%91%E8%A7%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%84%E7%A7%8D%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF">#</a><code>jstat</code>: 监视虚拟机各种运行状态信息</h3><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><p><strong><code>jstat</code> 命令使用格式：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">jstat -&lt;option&gt; [-<span class="hljs-type">t</span>] [-<span class="hljs-type">h</span>&lt;<span class="hljs-type">lines</span>&gt;] &lt;vmid&gt; [&lt;<span class="hljs-built_in">int</span><span class="hljs-type">erval</span>&gt; [&lt;<span class="hljs-type">count</span>&gt;]]<br></code></pre></td></tr></table></figure><p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><p><strong>常见的 option 如下：</strong></p><ul><li><code>jstat -class vmid</code>：显示 ClassLoader 的相关信息；</li><li><code>jstat -compiler vmid</code>：显示 JIT 编译的相关信息；</li><li><code>jstat -gc vmid</code>：显示与 GC 相关的堆信息；</li><li><code>jstat -gccapacity vmid</code>：显示各个代的容量及使用情况；</li><li><code>jstat -gcnew vmid</code>：显示新生代信息；</li><li><code>jstat -gcnewcapcacity vmid</code>：显示新生代大小与使用情况；</li><li><code>jstat -gcold vmid</code>：显示老年代和永久代的行为统计，从 jdk1.8 开始,该选项仅表示老年代，因为永久代被移除了；</li><li><code>jstat -gcoldcapacity vmid</code>：显示老年代的大小；</li><li><code>jstat -gcpermcapacity vmid</code>：显示永久代大小，从 jdk1.8 开始,该选项不存在了，因为永久代被移除了；</li><li><code>jstat -gcutil vmid</code>：显示垃圾收集信息；</li></ul><p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p><h3 id="jinfo-实时地查看和调整虚拟机各项参数"><a href="#jinfo-实时地查看和调整虚拟机各项参数" class="headerlink" title="#jinfo: 实时地查看和调整虚拟机各项参数"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jinfo-%E5%AE%9E%E6%97%B6%E5%9C%B0%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%B0%83%E6%95%B4%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%84%E9%A1%B9%E5%8F%82%E6%95%B0">#</a><code>jinfo</code>: 实时地查看和调整虚拟机各项参数</h3><p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p><p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jinfo  <span class="hljs-literal">-flag</span> MaxHeapSize <span class="hljs-number">17340</span><br><span class="hljs-literal">-XX</span>:MaxHeapSize=<span class="hljs-number">2124414976</span><br>C:\Users\SnailClimb&gt;jinfo  <span class="hljs-literal">-flag</span> PrintGC <span class="hljs-number">17340</span><br><span class="hljs-literal">-XX</span>:<span class="hljs-literal">-PrintGC</span><br></code></pre></td></tr></table></figure><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p><p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jinfo  <span class="hljs-literal">-flag</span>  PrintGC <span class="hljs-number">17340</span><br><span class="hljs-literal">-XX</span>:<span class="hljs-literal">-PrintGC</span><br><br>C:\Users\SnailClimb&gt;jinfo  <span class="hljs-literal">-flag</span>  +PrintGC <span class="hljs-number">17340</span><br><br>C:\Users\SnailClimb&gt;jinfo  <span class="hljs-literal">-flag</span>  PrintGC <span class="hljs-number">17340</span><br><span class="hljs-literal">-XX</span>:+PrintGC<br></code></pre></td></tr></table></figure><h3 id="jmap-生成堆转储快照"><a href="#jmap-生成堆转储快照" class="headerlink" title="#jmap:生成堆转储快照"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jmap-%E7%94%9F%E6%88%90%E5%A0%86%E8%BD%AC%E5%82%A8%E5%BF%AB%E7%85%A7">#</a><code>jmap</code>:生成堆转储快照</h3><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p><p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p><p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jmap <span class="hljs-literal">-dump</span>:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof <span class="hljs-number">17340</span><br>Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...<br>Heap dump file created<br></code></pre></td></tr></table></figure><h3 id="jhat-分析-heapdump-文件"><a href="#jhat-分析-heapdump-文件" class="headerlink" title="#jhat: 分析 heapdump 文件"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jhat-%E5%88%86%E6%9E%90-heapdump-%E6%96%87%E4%BB%B6">#</a><strong><code>jhat</code></strong>: 分析 heapdump 文件</h3><p><strong><code>jhat</code></strong> 用于分析 heapdump 文件，它会建立一个 HTTP&#x2F;HTML 服务器，让用户可以在浏览器上查看分析结果。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jhat C:\Users\SnailClimb\Desktop\heap.hprof<br>Reading from C:\Users\SnailClimb\Desktop\heap.hprof...<br>Dump file created Sat May <span class="hljs-number">04</span> <span class="hljs-number">12</span>:<span class="hljs-number">30</span>:<span class="hljs-number">31</span> CST <span class="hljs-number">2019</span><br>Snapshot read, resolving...<br>Resolving <span class="hljs-number">131419</span> objects...<br>Chasing references, expect <span class="hljs-number">26</span> dots..........................<br>Eliminating duplicate references..........................<br>Snapshot resolved.<br>Started HTTP server on port <span class="hljs-number">7000</span><br>Server is ready.<br></code></pre></td></tr></table></figure><p>访问 <a href="http://localhost:7000/">http://localhost:7000/open in new window</a></p><h3 id="jstack-生成虚拟机当前时刻的线程快照"><a href="#jstack-生成虚拟机当前时刻的线程快照" class="headerlink" title="#jstack :生成虚拟机当前时刻的线程快照"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jstack-%E7%94%9F%E6%88%90%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BD%93%E5%89%8D%E6%97%B6%E5%88%BB%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A7">#</a><strong><code>jstack</code></strong> :生成虚拟机当前时刻的线程快照</h3><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p><p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p><p><strong>下面是一个线程死锁的代码。我们下面会通过 <code>jstack</code> 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 2</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">Thread[线程 1,5,main]get resource1<br>Thread[线程 2,5,main]get resource2<br>Thread[线程 1,5,main]waiting get resource2<br>Thread[线程 2,5,main]waiting get resource1<br></code></pre></td></tr></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p><strong>通过 <code>jstack</code> 命令分析：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jps<br><span class="hljs-number">13792</span> KotlinCompileDaemon<br><span class="hljs-number">7360</span> NettyClient2<br><span class="hljs-number">17396</span><br><span class="hljs-number">7972</span> Launcher<br><span class="hljs-number">8932</span> Launcher<br><span class="hljs-number">9256</span> DeadLockDemo<br><span class="hljs-number">10764</span> Jps<br><span class="hljs-number">17340</span> NettyServer<br><br>C:\Users\SnailClimb&gt;jstack <span class="hljs-number">9256</span><br></code></pre></td></tr></table></figure><p>输出的部分内容如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Found one Java<span class="hljs-literal">-level</span> deadlock:<br>=============================<br><span class="hljs-string">&quot;线程 2&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0</span>x000000000333e668 (object <span class="hljs-number">0</span>x00000000d5efe1c0, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;线程 1&quot;</span><br><span class="hljs-string">&quot;线程 1&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0</span>x000000000333be88 (object <span class="hljs-number">0</span>x00000000d5efe1d0, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;线程 2&quot;</span><br><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;线程 2&quot;</span>:<br>        at DeadLockDemo.lambda<span class="hljs-variable">$main</span><span class="hljs-variable">$1</span>(DeadLockDemo.java:<span class="hljs-number">31</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)<br>        - locked &lt;<span class="hljs-number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)<br>        at DeadLockDemo<span class="hljs-variable">$</span><span class="hljs-variable">$Lambda</span><span class="hljs-variable">$2</span>/<span class="hljs-number">1078694789</span>.run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-string">&quot;线程 1&quot;</span>:<br>        at DeadLockDemo.lambda<span class="hljs-variable">$main</span><span class="hljs-variable">$0</span>(DeadLockDemo.java:<span class="hljs-number">16</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)<br>        - locked &lt;<span class="hljs-number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)<br>        at DeadLockDemo<span class="hljs-variable">$</span><span class="hljs-variable">$Lambda</span><span class="hljs-variable">$1</span>/<span class="hljs-number">1324119927</span>.run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure><p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p><h2 id="JDK-可视化分析工具"><a href="#JDK-可视化分析工具" class="headerlink" title="#JDK 可视化分析工具"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jdk-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7">#</a>JDK 可视化分析工具</h2><h3 id="JConsole-Java-监视与管理控制台"><a href="#JConsole-Java-监视与管理控制台" class="headerlink" title="#JConsole:Java 监视与管理控制台"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jconsole-java-%E7%9B%91%E8%A7%86%E4%B8%8E%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0">#</a>JConsole:Java 监视与管理控制台</h3><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输入<code>jconsole</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p><h4 id="连接-Jconsole"><a href="#连接-Jconsole" class="headerlink" title="#连接 Jconsole"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#%E8%BF%9E%E6%8E%A5-jconsole">#</a>连接 Jconsole</h4><p><img src="https://javaguide.cn/assets/1JConsole%E8%BF%9E%E6%8E%A5-7490f097.png" alt="连接 Jconsole">连接 Jconsole</p><p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-Djava.rmi.server.hostname</span>=<span class="hljs-string">外网访问 ip 地址</span><br><span class="hljs-attr">-Dcom.sun.management.jmxremote.port</span>=<span class="hljs-string">60001   //监控的端口号</span><br><span class="hljs-attr">-Dcom.sun.management.jmxremote.authenticate</span>=<span class="hljs-string">false   //关闭认证</span><br><span class="hljs-attr">-Dcom.sun.management.jmxremote.ssl</span>=<span class="hljs-string">false</span><br></code></pre></td></tr></table></figure><p>在使用 JConsole 连接时，远程进程地址如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">外网访问 ip 地址:60001<br></code></pre></td></tr></table></figure><h4 id="查看-Java-程序概况"><a href="#查看-Java-程序概况" class="headerlink" title="#查看 Java 程序概况"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#%E6%9F%A5%E7%9C%8B-java-%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%86%B5">#</a>查看 Java 程序概况</h4><p><img src="https://javaguide.cn/assets/2%E6%9F%A5%E7%9C%8BJava%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%86%B5-9c949b67.png" alt="查看 Java 程序概况 ">查看 Java 程序概况</p><h4 id="内存监控"><a href="#内存监控" class="headerlink" title="#内存监控"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7">#</a>内存监控</h4><p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存&#x2F;非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p><p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p><blockquote><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC&#x2F;Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul></blockquote><p><img src="https://javaguide.cn/assets/3%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7-4f4b8a7f.png" alt="内存监控 ">内存监控</p><h4 id="线程监控"><a href="#线程监控" class="headerlink" title="#线程监控"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7">#</a>线程监控</h4><p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p><p>最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p><p><img src="https://javaguide.cn/assets/4%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7-4364833a.png" alt="线程监控 ">线程监控</p><h3 id="Visual-VM-多合一故障处理工具"><a href="#Visual-VM-多合一故障处理工具" class="headerlink" title="#Visual VM:多合一故障处理工具"></a><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#visual-vm-%E5%A4%9A%E5%90%88%E4%B8%80%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7">#</a>Visual VM:多合一故障处理工具</h3><p>VisualVM 提供在 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href="https://visualvm.github.io/">https://visualvm.github.io/open in new window</a> 。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.htmlopen in new window</a>。</p><p>下面这段话摘自《深入理解 Java 虚拟机》。</p><blockquote><p>  VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p></blockquote><p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p><ul><li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li><li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li><li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li><li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li><li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li><li><strong>其他 plugins 的无限的可能性……</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>★★★JVM 垃圾回收详解</title>
    <link href="/2023/07/16/JVM/%E2%98%85%E2%98%85%E2%98%85JVM%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/07/16/JVM/%E2%98%85%E2%98%85%E2%98%85JVM%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM垃圾回收详解（重点）前言"><a href="#JVM垃圾回收详解（重点）前言" class="headerlink" title="JVM垃圾回收详解（重点）前言"></a>JVM垃圾回收详解（重点）前言</h2><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h3 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h3><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong> 。</p><h3 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h3><h4 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h4><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。下面我们来进行实际测试一下。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">byte</span>[] allocation1, allocation2;<br>allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">30900</span>*<span class="hljs-number">1024</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过以下方式运行： <img src="https://oss.javaguide.cn/github/javaguide/java/jvm/25178350.png" alt="img"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/run-with-PrintGCDetails.png" alt="img"></p><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/28954286.jpg" alt="img"></p><p>从上图我们可以看出 Eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。</p><p>假如我们再为 <code>allocation2</code> 分配内存会出现什么情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">900</span>*<span class="hljs-number">1024</span>];<br></code></pre></td></tr></table></figure><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/28128785.jpg" alt="img"></p><p>给 <code>allocation2</code> 分配内存的时候 Eden 区内存几乎已经被分配完了</p><p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 <code>allocation1</code> 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 <code>allocation1</code>，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;<br>allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">32000</span>*<span class="hljs-number">1024</span>];<br>allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>allocation5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p>大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。</p><ul><li>G1 垃圾回收器会根据<ul><li>-XX:G1HeapRegionSize参数设置的堆区域大小</li><li>-XX:G1MixedGCLiveThresholdPercent参数设置的阈值，来决定哪些对象会直接进入老年代。</li></ul></li><li>Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(-XX:ThresholdTolerance是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。</li></ul><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p><p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁、6岁等取决于GC种类），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>  “Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p>  <strong>动态年龄计算的代码如下：</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uint <span class="hljs-title">ageTable::compute_tenuring_threshold</span><span class="hljs-params">(<span class="hljs-type">size_t</span> survivor_capacity)</span> </span>&#123;<br>    <span class="hljs-comment">//survivor_capacity是survivor空间的大小</span><br>    <span class="hljs-type">size_t</span> desired_survivor_size = (<span class="hljs-type">size_t</span>)((((<span class="hljs-type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="hljs-number">100</span>);<br>    <span class="hljs-type">size_t</span> total = <span class="hljs-number">0</span>;<br>    uint age = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (age &lt; table_size) &#123;<br>            <span class="hljs-comment">//sizes数组是每个年龄段对象大小</span><br>            total += sizes[age];<br>            <span class="hljs-keyword">if</span> (total &gt; desired_survivor_size) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        age++;<br>    &#125;<br>    uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="主要进行-gc-的区域"><a href="#主要进行-gc-的区域" class="headerlink" title="主要进行 gc 的区域"></a>主要进行 gc 的区域</h3><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018160221807.png" alt="image-20231018160221807"></p><p><strong>总结：</strong></p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和<strong>部分老年代</strong>进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：</p><blockquote><p>  JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p><p>  JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC（<strong>不会考虑是否允许担保失败，即没有担保这个说法，只要你有可能成功，就Minor GC，否则FullGC</strong>）。</p></blockquote><h3 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</strong></p><center>对象之间循环引用</center><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018161206531.png" alt="image-20231018161206531"></p><p>所谓对象之间的相互引用问题，如下面代码所示：除了对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCountingGc</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br>        <span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br>        objA.instance = objB;<br>        objB.instance = objA;<br>        objA = <span class="hljs-literal">null</span>;<br>        objB = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p><center>可达性分析算法</center><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018161451452.png" alt="image-20231018161451452"></p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li><li>JNI（Java Native Interface）引用的对象</li></ul><p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><blockquote><p>  <code>finalize</code>方法用于执行清理工作，如关闭文件、释放资源等。这个方法在Java 9之后被标记为过时(deprecated)，因为它存在一些问题，如执行时机不可预测，可能会影响性能等。</p><p>  <code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p></blockquote><h3 id="引用类型总结"><a href="#引用类型总结" class="headerlink" title="引用类型总结"></a>引用类型总结</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><center>Java 引用类型总结</center><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018162454263.png" alt="image-20231018162454263"></p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title="如何判断一个常量是废弃常量？"></a>如何判断一个常量是废弃常量？</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><ul><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot 移除了永久代，用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ul><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="如何判断一个类是无用的类？"><a href="#如何判断一个类是无用的类？" class="headerlink" title="如何判断一个类是无用的类？"></a>如何判断一个类是无用的类？</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><center>标记-清除算法</center><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018164152456.png" alt="image-20231018164152456"></p><p>关于具体是标记可回收对象还是不可回收对象，众说纷纭，两种说法其实都没问题，我个人更倾向于是前者。</p><p>如果按照前者的理解，整个标记-清除过程大致是这样的：</p><ol><li>当一个对象被创建时，给一个标记位，假设为 0 (false)；</li><li>在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；</li><li>扫描阶段清除的就是标记位为 0 (false)的对象。</li></ol><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018164339237.png" alt="image-20231018164339237"></p><p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li><li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><center>标记-整理算法</center><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018165759410.png" alt="image-20231018165759410"></p><p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>需要使用分代收集算法</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>没有最好的、万能的垃圾收集器，<strong>应该根据具体应用场景选择适合的垃圾收集器</strong>。</p><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK20: G1</li></ul><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器是一个单线程收集器。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020141604067.png" alt="image-20231020141604067"></p><p>在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿）。</p><p>优点：<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><blockquote><p>  为什么此处老年代的是单线程呢？？？</p></blockquote><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020141853616.png" alt="image-20231020141853616"></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态（同一时刻）。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上（同一时间段内）。</li></ul><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+UseParallelGC<br><br>    使用 Parallel 收集器+ 老年代串行<br><br>-XX:+UseParallelOldGC<br><br>    使用 Parallel 收集器+ 老年代并行<br></code></pre></td></tr></table></figure><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020145536253.png" alt="image-20231020145536253"></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC<br>java version <span class="hljs-string">&quot;1.8.0_211&quot;</span><br>Java(TM) SE Runtime Environment (build 1.8.0_211-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)<br></code></pre></td></tr></table></figure><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能。</p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020145849102.png" alt="image-20231020145849102"></p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020145903014.png" alt="image-20231020145903014"></p><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</p></li><li><p><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p></li><li><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p></li><li><p><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</p><blockquote><p>  总结：先暂停所有，记录直接相连的对象；然后取消暂停，利用直接相连的对象将所有可达对象进行标记，然后重新标记有变动的部分，最后删除未标记的地方。</p></blockquote></li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020160151272.png" alt="image-20231020160151272"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020161753555.png" alt="image-20231020161753555"></p><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><p><strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p><h3 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><p>Java11 的时候 ，ZGC 还在试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！</p><p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ java -XX:+UseZGC className<br></code></pre></td></tr></table></figure><blockquote><p>  算法做出了哪些改进？？？</p><p>  ZGC收集器相对于G1收集器做了以下改进：</p><ol><li>并发整理：ZGC在标记整理阶段使用了读屏障技术，实现了整理阶段与应用线程并发执行，从而消除了停顿。而G1收集器在这个阶段是需要完全停顿的。</li><li>并发标记：ZGC的并发标记阶段不需要停顿，而G1收集器在这个阶段需要短暂的停顿。</li><li>分区对齐：ZGC的堆内存被划分为多个固定大小的分区，每个分区独立进行垃圾收集，这样可以减少跨分区引用的更新开销，同时也方便进行并行和并发处理。</li></ol><p>  总的来说，ZGC收集器相对于G1收集器在减少停顿时间、提高并发性能等方面做了改进，使得垃圾收集对应用线程的影响更小，提高了整体性能。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM线上问题排查和性能调优案例</title>
    <link href="/2023/07/16/JVM/JVM%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%92%8C%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/"/>
    <url>/2023/07/16/JVM/JVM%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%92%8C%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM线上问题排查和性能调优案例"><a href="#JVM线上问题排查和性能调优案例" class="headerlink" title="JVM线上问题排查和性能调优案例"></a>JVM线上问题排查和性能调优案例</h2><p><a href="https://juejin.cn/post/7205141492264976445">一次线上 OOM 问题分析 - 艾小仙 - 2023open in new window</a></p><ul><li><strong>现象</strong>：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。</li><li><strong>分析</strong>：使用 JDK 自带的<code>jvisualvm</code>分析 dump 文件(MAT 也能分析)。</li><li><strong>建议</strong>：对于 SQL 语句，如果监测到没有<code>where</code>条件的全表查询应该默认增加一个合适的<code>limit</code>作为限制，防止这种问题拖垮整个系统</li><li><strong>资料</strong>：<a href="https://heapdump.cn/article/3489050">实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022open in new window</a>。</li></ul><p><a href="https://www.cnblogs.com/mylibs/p/production-accident-0002.html">生产事故-记一次特殊的 OOM 排查 - 程语有云 - 2023open in new window</a></p><ul><li><strong>现象</strong>：网络没有问题的情况下，系统某开放接口从 2023 年 3 月 10 日 14 时许开始无法访问和使用。</li><li><strong>临时解决办法</strong>：紧急回滚至上一稳定版本。</li><li><strong>分析</strong>：使用 MAT (Memory Analyzer Tool)工具分析 dump 文件。</li><li><strong>建议</strong>：正常情况下，<code>-Xmn</code>参数（控制 Young 区的大小）总是应当小于<code>-Xmx</code>参数（控制堆内存的最大大小），否则就会触发 OOM 错误。</li><li><strong>资料</strong>：<a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html">最重要的 JVM 参数总结 - JavaGuide - 2023open in new window</a></li></ul><p><a href="https://juejin.cn/post/7078624931826794503">一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022open in new window</a></p><ul><li><strong>现象</strong>：线上项目刚启动完使用 top 命令查看 RES 占用了超过 1.5G。</li><li><strong>分析</strong>：整个分析流程用到了较多工作，可以跟着作者思路一步一步来，值得学习借鉴。</li><li><strong>建议</strong>：远离 Hibernate。</li><li><strong>资料</strong>：<a href="https://liam.page/2020/07/17/memory-stat-in-TOP/">Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）open in new window</a></li></ul><p><a href="https://www.heapdump.cn/article/1661497">YGC 问题排查，又让我涨姿势了！ - IT 人的职场进阶 - 2021open in new window</a></p><ul><li><strong>现象</strong>：广告服务在新版本上线后，收到了大量的服务超时告警。</li><li><strong>分析</strong>：使用 MAT (Memory Analyzer Tool) 工具分析 dump 文件。</li><li><strong>建议</strong>：学会 YGC（Young GC） 问题的排查思路，掌握 YGC 的相关知识点。</li></ul><p><a href="https://shuyi.tech/archives/have-a-try-in-jvm-combat">听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021open in new window</a></p><p>通过观察 GC 频率和停顿时间，来进行 JVM 内存空间调整，使其达到最合理的状态。调整过程记得小步快跑，避免内存剧烈波动影响线上服务。 这其实是最为简单的一种 JVM 性能调优方式了，可以算是粗调吧。</p><p><a href="https://mp.weixin.qq.com/s/df1uxHWUXzhErxW1sZ6OvQ">你们要的线上 GC 问题案例来啦 - 编了个程 - 2021open in new window</a></p><ul><li><strong>案例 1</strong>：使用 guava cache 的时候，没有设置最大缓存数量和弱引用，导致频繁触发 Young GC</li><li><strong>案例 2</strong>： 对于一个查询和排序分页的 SQL，同时这个 SQL 需要 join 多张表，在分库分表下，直接调用 SQL 性能很差。于是，查单表，再在内存排序分页，用了一个 List 来保存数据，而有些数据量大，造成了这个现象。</li></ul><p><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团 - 2020open in new window</a></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>★★★Java 内存区域详解</title>
    <link href="/2023/07/16/JVM/%E2%98%85%E2%98%85%E2%98%85Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/07/16/JVM/%E2%98%85%E2%98%85%E2%98%85Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Java内存区域详解（重点）"><a href="#Java内存区域详解（重点）" class="headerlink" title="Java内存区域详解（重点）"></a>Java内存区域详解（重点）</h2><blockquote><p>  如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p></blockquote><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><p>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。</p><p><strong>JDK 1.7</strong>：</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017210357314.png" alt="image-20231017210357314"></p><p><strong>JDK 1.8</strong>：</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017210416444.png" alt="image-20231017210416444"></p><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><blockquote><p>  注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></blockquote><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p><p>虚拟机栈是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过虚拟机栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。</p><p>方法调用的数据需要通过虚拟机栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>虚拟机栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018090959743.png" alt="image-20231018090959743"></p><p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、char、short、int、long、float、double、byte）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018091028846.png" alt="image-20231018091028846"></p><p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，<strong>计算过程中产生的临时变量也会放在操作数栈中</strong>。</p><p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018092017249.png" alt="image-20231018092017249"></p><p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p><p>除了 <code>StackOverFlowError</code> 错误之外，栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p><p>简单总结一下程序运行中栈可能会出现两种错误：</p><ul><li><strong><code>StackOverFlowError</code>：</strong> 当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中本地方法栈和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老年代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018154514970.png" alt="image-20231018154514970"></p><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong> </p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>  （个人理解：15岁肯定会被晋升到老年代，如果年轻的对象已经达到某个比率，那么比他们大的对象都晋升到老年代）</p></blockquote><blockquote><p>  <strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552open in new window</a>）</strong>：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p>  <strong>动态年龄计算的代码如下</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uint <span class="hljs-title">ageTable::compute_tenuring_threshold</span><span class="hljs-params">(<span class="hljs-type">size_t</span> survivor_capacity)</span> </span>&#123;<br><span class="hljs-comment">//survivor_capacity是survivor空间的大小</span><br><span class="hljs-type">size_t</span> desired_survivor_size = (<span class="hljs-type">size_t</span>)((((<span class="hljs-type">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="hljs-number">100</span>);<br><span class="hljs-type">size_t</span> total = <span class="hljs-number">0</span>;<br>uint age = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (age &lt; table_size) &#123;<br>total += sizes[age];<span class="hljs-comment">//sizes数组是每个年龄段对象大小</span><br><span class="hljs-keyword">if</span> (total &gt; desired_survivor_size) <span class="hljs-keyword">break</span>;<br>age++;<br>&#125;<br>uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ol><li>**<code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code>**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值。</li></ol><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p>HotSpot 虚拟机方法区的两种实现:</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018094558273.png" alt="image-20231018094558273"></p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231018154551474.png" alt="image-20231018154551474"></p><p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p><blockquote><p>  当元空间溢出时会得到如下错误：<code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 设置元空间的初始大小，如果未指定此标志，JVM会使用一个默认的值作为元空间的初始大小，这个默认值通常是根据JVM的版本和平台来决定的。</p><p>2、元空间里面存放的是类的元数据，加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了，因为此参数已经被<code>-XX：MaxMetaspaceSize</code>取而代之,在不指定最大元空间大小时，元空间大小由系统的实际可用空间来控制，这样能加载的类就更多了。</p><p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:PermSize=N <span class="hljs-comment">//方法区 (永久代) 初始大小</span><br>-XX:MaxPermSize=N <span class="hljs-comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span><br></code></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 中元空间使用的是本地内存。下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:MetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的初始（和最小大小）</span><br>-XX:MaxMetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的最大大小</span><br></code></pre></td></tr></table></figure><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p><p>常量池表会在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”ab“</span><br><span class="hljs-comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>System.out.println(aa==bb);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><blockquote><p>  <strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p></blockquote><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p><p>JDK1.4 中新加入的 <strong>NIO（Non-Blocking I&#x2F;O，也被称为 New I&#x2F;O）</strong>，引入了一种基于**通道（Channel）**与**缓存区（Buffer）**的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。</p><p>直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><p>类似的概念还有 <strong>堆外内存</strong> 。在一些文章中将直接内存等价于堆外内存，个人觉得不是特别准确。</p><p>堆外内存就是把内存对象分配在堆（新生代+老年代+永久代）以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p><h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。</p><h4 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1:类加载检查"></a>1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2:分配内存"></a>2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式★★★</strong> ：</p><ul><li>指针碰撞：<ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表：<ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p><p><strong>内存分配并发问题 ★★★</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="3-初始化零值"><a href="#3-初始化零值" class="headerlink" title="3:初始化零值"></a>3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="4-设置对象头"><a href="#4-设置对象头" class="headerlink" title="4:设置对象头"></a>4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="5-执行-init-方法"><a href="#5-执行-init-方法" class="headerlink" title="5:执行 init 方法"></a>5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中存储的是对象实例数据与对象类型数据各自的具体地址信息。</p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><p>HotSpot 虚拟机主要使用<strong>直接指针</strong>来进行对象访问。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最重要的JVM参数总结</title>
    <link href="/2023/07/16/JVM/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84JVM%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <url>/2023/07/16/JVM/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84JVM%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="最重要的JVM参数总结"><a href="#最重要的JVM参数总结" class="headerlink" title="最重要的JVM参数总结"></a>最重要的JVM参数总结</h2><h2 id="堆内存相关"><a href="#堆内存相关" class="headerlink" title="堆内存相关"></a>堆内存相关</h2><blockquote><p>  Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p></blockquote><p><img src="https://javaguide.cn/assets/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0-53ddeca6.png" alt="内存区域常见配置参数">内存区域常见配置参数</p><h3 id="显式指定堆内存–Xms和-Xmx"><a href="#显式指定堆内存–Xms和-Xmx" class="headerlink" title="显式指定堆内存–Xms和-Xmx"></a>显式指定堆内存<code>–Xms</code>和<code>-Xmx</code></h3><p>与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms&lt;heap size&gt;[unit]<br>-Xmx&lt;heap size&gt;[unit]<br></code></pre></td></tr></table></figure><ul><li><strong>heap size</strong> 表示要初始化内存的具体大小。</li><li><strong>unit</strong> 表示要初始化内存的单位。单位为 <em><strong>“ g”*</strong> (GB)、</em>*<em>“ m”*<strong>（MB）、</strong></em>“ k”***（KB）。</li></ul><p>举个栗子 🌰，如果我们要为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小，我们的参数应该这样来写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms2G -Xmx5G<br></code></pre></td></tr></table></figure><h3 id="显式新生代内存-Young-Generation"><a href="#显式新生代内存-Young-Generation" class="headerlink" title="显式新生代内存(Young Generation)"></a>显式新生代内存(Young Generation)</h3><p>根据<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html">Oracle 官方文档open in new window</a>，在堆总可用内存配置完成之后，第二大影响因素是为 <code>Young Generation</code> 在堆内存所占的比例。默认情况下，YG 的最小大小为 1310 <em>MB</em>，最大大小为<em>无限制</em>。</p><p>一共有两种指定 新生代内存(Young Generation)大小的方法：</p><p><strong>1.通过<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>指定</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:NewSize=&lt;young size&gt;[unit]<br>-XX:MaxNewSize=&lt;young size&gt;[unit]<br></code></pre></td></tr></table></figure><p>举个栗子 🌰，如果我们要为 新生代分配 最小 256m 的内存，最大 1024m 的内存我们的参数应该这样来写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:NewSize=256m<br>-XX:MaxNewSize=1024m<br></code></pre></td></tr></table></figure><p><strong>2.通过<code>-Xmn&lt;young size&gt;[unit]</code>指定</strong></p><p>举个栗子 🌰，如果我们要为 新生代分配 256m 的内存（NewSize 与 MaxNewSize 设为一致），我们的参数应该这样来写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xmn256m<br></code></pre></td></tr></table></figure><p>GC 调优策略中很重要的一条经验总结是这样说的：</p><blockquote><p>  将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p></blockquote><p>另外，你还可以通过 <strong><code>-XX:NewRatio=&lt;int&gt;</code></strong> 来设置老年代与新生代内存的比值。</p><p>比如下面的参数就是设置老年代与新生代内存的比值为 1。也就是说老年代和新生代所占比值为 1：1，新生代占整个堆栈的 1&#x2F;2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">-XX:NewRatio=1<br></code></pre></td></tr></table></figure><h3 id="显式指定永久代-元空间的大小"><a href="#显式指定永久代-元空间的大小" class="headerlink" title="显式指定永久代&#x2F;元空间的大小"></a>显式指定永久代&#x2F;元空间的大小</h3><p><strong>从 Java 8 开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:PermSize=N <span class="hljs-comment">#方法区 (永久代) 初始大小</span><br>-XX:MaxPermSize=N <span class="hljs-comment">#方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span><br></code></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p><strong>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。</strong></p><p>下面是一些常用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:MetaspaceSize=N <span class="hljs-comment">#设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）</span><br>-XX:MaxMetaspaceSize=N <span class="hljs-comment">#设置 Metaspace 的最大大小</span><br></code></pre></td></tr></table></figure><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/1947">issue#1947open in new window</a>）</strong>：</p><p>1、Metaspace 的初始容量并不是 <code>-XX:MetaspaceSize</code> 设置，无论 <code>-XX:MetaspaceSize</code> 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）。</p><p>可以参考 Oracle 官方文档中提到的：</p><blockquote><p>  MetaspaceSize 的默认大小取决于平台，范围从 12 MB 到大约 20 MB。</p></blockquote><p>2、Metaspace 由于使用不断扩容到<code>-XX:MetaspaceSize</code>参数指定的量，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC。</p><p>也就是说，MetaspaceSize 表示 Metaspace 使用过程中触发 Full GC 的阈值，只对触发起作用。</p><p>垃圾搜集器内部是根据变量 <code>_capacity_until_GC</code>来判断 Metaspace 区域是否达到阈值的，初始化代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MetaspaceGC::initialize</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// Set the high-water mark to MaxMetapaceSize during VM initializaton since</span><br>  <span class="hljs-comment">// we can&#x27;t do a GC during initialization.</span><br>  _capacity_until_GC = MaxMetaspaceSize;<br>&#125;<br></code></pre></td></tr></table></figure><p>相关阅读：<a href="https://github.com/Snailclimb/JavaGuide/issues/1204">issue 更正：MaxMetaspaceSize 如果不指定大小的话，不会耗尽内存 #1204open in new window</a> 。</p><h2 id="3-垃圾收集相关"><a href="#3-垃圾收集相关" class="headerlink" title="#3.垃圾收集相关"></a><a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html#_3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9B%B8%E5%85%B3">#</a>3.垃圾收集相关</h2><h3 id="3-1-垃圾回收器"><a href="#3-1-垃圾回收器" class="headerlink" title="#3.1.垃圾回收器"></a><a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html#_3-1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8">#</a>3.1.垃圾回收器</h3><p>为了提高应用程序的稳定性，选择正确的<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">垃圾收集open in new window</a>算法至关重要。</p><p>JVM 具有四种类型的 GC 实现：</p><ul><li>串行垃圾收集器</li><li>并行垃圾收集器</li><li>CMS 垃圾收集器</li><li>G1 垃圾收集器</li></ul><p>可以使用以下参数声明这些实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+UseSerialGC<br>-XX:+UseParallelGC<br>-XX:+UseParNewGC<br>-XX:+UseG1GC<br></code></pre></td></tr></table></figure><p>有关<em>垃圾回收</em>实施的更多详细信息，请参见<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md">此处open in new window</a>。</p><h3 id="3-2-GC-日志记录"><a href="#3-2-GC-日志记录" class="headerlink" title="#3.2.GC 日志记录"></a><a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html#_3-2-gc-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95">#</a>3.2.GC 日志记录</h3><p>生产环境上，或者其他要测试 GC 问题的环境上，一定会配置上打印 GC 日志的参数，便于分析 GC 相关的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 必选</span><br><span class="hljs-comment"># 打印基本 GC 信息</span><br>-XX:+PrintGCDetails<br>-XX:+PrintGCDateStamps<br><span class="hljs-comment"># 打印对象分布</span><br>-XX:+PrintTenuringDistribution<br><span class="hljs-comment"># 打印堆数据</span><br>-XX:+PrintHeapAtGC<br><span class="hljs-comment"># 打印Reference处理信息</span><br><span class="hljs-comment"># 强引用/弱引用/软引用/虚引用/finalize 相关的方法</span><br>-XX:+PrintReferenceGC<br><span class="hljs-comment"># 打印STW时间</span><br>-XX:+PrintGCApplicationStoppedTime<br><br><span class="hljs-comment"># 可选</span><br><span class="hljs-comment"># 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint</span><br>-XX:+PrintSafepointStatistics<br>-XX:PrintSafepointStatisticsCount=1<br><br><span class="hljs-comment"># GC日志输出的文件路径</span><br>-Xloggc:/path/to/gc-%t.log<br><span class="hljs-comment"># 开启日志文件分割</span><br>-XX:+UseGCLogFileRotation<br><span class="hljs-comment"># 最多分割几个文件，超过之后从头文件开始写</span><br>-XX:NumberOfGCLogFiles=14<br><span class="hljs-comment"># 每个文件上限大小，超过就触发分割</span><br>-XX:GCLogFileSize=50M<br></code></pre></td></tr></table></figure><h2 id="4-处理-OOM"><a href="#4-处理-OOM" class="headerlink" title="#4.处理 OOM"></a><a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html#_4-%E5%A4%84%E7%90%86-oom">#</a>4.处理 OOM</h2><p>对于大型应用程序来说，面对内存不足错误是非常常见的，这反过来会导致应用程序崩溃。这是一个非常关键的场景，很难通过复制来解决这个问题。</p><p>这就是为什么 JVM 提供了一些参数，这些参数将堆内存转储到一个物理文件中，以后可以用来查找泄漏:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof<br>-XX:OnOutOfMemoryError=<span class="hljs-string">&quot;&lt; cmd args &gt;;&lt; cmd args &gt;&quot;</span><br>-XX:+UseGCOverheadLimit<br></code></pre></td></tr></table></figure><p>这里有几点需要注意:</p><ul><li><strong>HeapDumpOnOutOfMemoryError</strong> 指示 JVM 在遇到 <strong>OutOfMemoryError</strong> 错误时将 heap 转储到物理文件中。</li><li><strong>HeapDumpPath</strong> 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <code>&lt;pid&gt;</code> 标记，则当前进程的进程 id 将附加到文件名中，并使用<code>.hprof</code>格式</li><li><strong>OnOutOfMemoryError</strong> 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 <code>cmd args</code> 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: <code>-XX:OnOutOfMemoryError=&quot;shutdown -r&quot;</code> 。</li><li><strong>UseGCOverheadLimit</strong> 是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例</li></ul><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="#5.其他"></a><a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html#_5-%E5%85%B6%E4%BB%96">#</a>5.其他</h2><ul><li><code>-server</code> : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM</li><li><code>-XX:+UseStringDeduplication</code> : <em>Java 8u20</em> 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 <code>char []</code> 数组来优化堆内存。</li><li><code>-XX:+UseLWPSynchronization</code>: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。</li><li><code>-XX:LargePageSizeInBytes</code>: 设置用于 Java 堆的较大页面大小; 它采用 GB&#x2F;MB&#x2F;KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。</li><li><code>-XX:MaxHeapFreeRatio</code> : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。</li><li><code>-XX:SurvivorRatio</code> : eden&#x2F;survivor 空间的比例, 例如<code>-XX:SurvivorRatio=6</code> 设置每个 survivor 和 eden 之间的比例为 1:6。</li><li><code>-XX:+UseLargePages</code> : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。</li><li><code>-XX:+UseStringCache</code> : 启用 String 池中可用的常用分配字符串的缓存。</li><li><code>-XX:+UseCompressedStrings</code> : 对 String 对象使用 <code>byte []</code> 类型，该类型可以用纯 ASCII 格式表示。</li><li><code>-XX:+OptimizeStringConcat</code> : 它尽可能优化字符串串联操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>★★★类加载器详解</title>
    <link href="/2023/07/16/JVM/%E2%98%85%E2%98%85%E2%98%85%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/07/16/JVM/%E2%98%85%E2%98%85%E2%98%85%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="类加载器详解（重点）回顾一下类加载过程"><a href="#类加载器详解（重点）回顾一下类加载过程" class="headerlink" title="类加载器详解（重点）回顾一下类加载过程"></a>类加载器详解（重点）回顾一下类加载过程</h2><p>开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。</p><ul><li>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。</li><li>连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020194414423.png" alt="image-20231020194414423">类</p><p>加载是类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h3><p>类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。</p><p>根据官方 API 文档的介绍：</p><blockquote><p>  类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。</p><p>  每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p></blockquote><p>从上面的介绍可以看出:</p><ul><li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</li><li>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</li><li>数组类不是通过 <code>ClassLoader</code> 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>&lt;T&gt; &#123;<br>  ...<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader classLoader;<br>  <span class="hljs-meta">@CallerSensitive</span><br>  <span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title function_">getClassLoader</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">//...</span><br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，<strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong> 字节码可以是 Java 源程序（<code>.java</code>文件）经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p><p>其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。本文只讨论其核心功能：加载类。</p><h3 id="类加载器加载规则"><a href="#类加载器加载规则" class="headerlink" title="类加载器加载规则"></a>类加载器加载规则</h3><p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</p><p>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>  ...<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br>  <span class="hljs-comment">// 由这个类加载器加载的类。</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>  <span class="hljs-comment">// 由VM调用，用此类加载器记录每个已加载类。</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">addClass</span><span class="hljs-params">(Class&lt;?&gt; c)</span> &#123;<br>        classes.addElement(c);<br>   &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a>类加载器总结</h3><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p><ol><li>**<code>BootstrapClassLoader</code>(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li><li>**<code>ExtensionClassLoader</code>(扩展类加载器)**：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li><li>**<code>AppClassLoader</code>(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><blockquote><p>  🌈 拓展一下：</p><ul><li>**<code>rt.jar</code>**：rt 代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li><li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</li></ul></blockquote><p>除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ <code>.class</code> 文件）进行加密，加载时再利用自定义的类加载器对其解密。</p><center>类加载器层次关系图</center><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020194502790.png" alt="image-20231020194502790"></p><p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p><p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>  ...<br>  <span class="hljs-comment">// 父加载器</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br>  <span class="hljs-meta">@CallerSensitive</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClassLoader <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">//...</span><br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么 获取到 <code>ClassLoader</code> 为<code>null</code>就是 <code>BootstrapClassLoader</code> 加载的呢？</strong> 这是因为<code>BootstrapClassLoader</code> 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。</p><p>下面我们来看一个获取 <code>ClassLoader</code> 的小案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintClassLoaderTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> PrintClassLoaderTree.class.getClassLoader();<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">split</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;|--&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needContinue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (needContinue)&#123;<br>            System.out.println(split.toString() + classLoader);<br>            <span class="hljs-keyword">if</span>(classLoader == <span class="hljs-literal">null</span>)&#123;<br>                needContinue = <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                classLoader = classLoader.getParent();<br>                split.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果(JDK 8 )：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">|--sun.misc.Launcher$AppClassLoader@18b4aac2<br>    |--sun.misc.Launcher$ExtClassLoader@53bd815b<br>        |--null<br></code></pre></td></tr></table></figure><p>从输出结果可以看出：</p><ul><li>我们编写的 Java 类 <code>PrintClassLoaderTree</code> 的 <code>ClassLoader</code> 是<code>AppClassLoader</code>；</li><li><code>AppClassLoader</code>的父 <code>ClassLoader</code> 是<code>ExtClassLoader</code>；</li><li><code>ExtClassLoader</code>的父<code>ClassLoader</code>是<code>Bootstrap ClassLoader</code>，因此输出结果为 null。</li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>我们前面也说说了，除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>抽象类。</p><p><code>ClassLoader</code> 类有两个关键的方法：</p><ul><li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li><li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li></ul><p>官方 API 文档中写到：</p><blockquote><p>  Subclasses of <code>ClassLoader</code> are encouraged to override <code>findClass(String name)</code>, rather than this method.</p><p>  建议 <code>ClassLoader</code>的子类重写 <code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code> 方法。</p></blockquote><p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p><h2 id="双亲委派模型-★★★"><a href="#双亲委派模型-★★★" class="headerlink" title="双亲委派模型 ★★★"></a>双亲委派模型 ★★★</h2><h3 id="双亲委派模型介绍"><a href="#双亲委派模型介绍" class="headerlink" title="双亲委派模型介绍"></a>双亲委派模型介绍</h3><p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。</p><p>根据官网介绍：</p><blockquote><p>  <code>ClassLoader</code> 类使用委托模型来搜索类和资源。每个 <code>ClassLoader</code> 实例都有一个相关的父类加载器。需要查找类或资源时，<code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。 虚拟机中被称为 “bootstrap class loader”的内置类加载器本身没有父类加载器，但是可以作为 <code>ClassLoader</code> 实例的父类加载器。</p></blockquote><p>从上面的介绍可以看出：</p><ul><li><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li><li><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</li></ul><p>下图展示的各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型(Parents Delegation Model)**”。</p><center>类加载器层次关系图</center><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020194613081.png" alt="image-20231020194613081"></p><p>注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的。</p><p>这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 <code>MotherClassLoader</code> 和一个<code>FatherClassLoader</code> 。</p><p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>  ...<br>  <span class="hljs-comment">// 组合</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ClassLoader</span><span class="hljs-params">(ClassLoader parent)</span> &#123;<br>       <span class="hljs-built_in">this</span>(checkCreateClassLoader(), parent);<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承。</strong></p><h3 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h3><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">//首先，检查该类是否已经加载过</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果 c 为 null，则说明该类没有被加载过</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span><br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span><br>                <span class="hljs-comment">//用户可通过覆写该方法，来自定义类加载器</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">//用于统计类加载器相关的信息</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            <span class="hljs-comment">//对类进行link操作</span><br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p><p>结合上面的源码，简单总结一下双亲委派模型的执行流程：</p><ul><li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li><li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li><li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li><li>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常。</li></ul><p>🌈 拓展一下：</p><p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p><h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p><p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p><h3 id="打破双亲委派模型方法"><a href="#打破双亲委派模型方法" class="headerlink" title="打破双亲委派模型方法"></a>打破双亲委派模型方法</h3><p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p><p>为什么是重写 <code>loadClass()</code> 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p><blockquote><p>  类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。</p></blockquote><p>重写 <code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。</p><p>我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p><p>Tomcat 的类加载器的层次结构如下：</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/tomcat-class-loader-parents-delegation-model.png" alt="Tomcat 的类加载器的层次结构">Tomcat 的类加载器的层次结构</p><p>Tomcat 这四个自定义的类加载器对应的目录如下：</p><ul><li><code>CommonClassLoader</code>对应<code>&lt;Tomcat&gt;/common/*</code></li><li><code>CatalinaClassLoader</code>对应<code>&lt;Tomcat &gt;/server/*</code></li><li><code>SharedClassLoader</code>对应 <code>&lt;Tomcat &gt;/shared/*</code></li><li><code>WebAppClassloader</code>对应 <code>&lt;Tomcat &gt;/webapps/&lt;app&gt;/WEB-INF/*</code></li></ul><p>从图中的委派关系中可以看出：</p><ul><li><code>CommonClassLoader</code>作为 <code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code> 的父加载器。<code>CommonClassLoader</code> 能加载的类都可以被 <code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code> 使用。因此，<code>CommonClassLoader</code> 是为了实现公共类库（可以被所有 Web 应用和 Tomcat 内部组件使用的类库）的共享和隔离。</li><li><code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code> 能加载的类则与对方相互隔离。<code>CatalinaClassLoader</code> 用于加载 Tomcat 自身的类，为了隔离 Tomcat 本身的类和 Web 应用的类。<code>SharedClassLoader</code> 作为 <code>WebAppClassLoader</code> 的父加载器，专门来加载 Web 应用之间共享的类比如 Spring、Mybatis。</li><li>每个 Web 应用都会创建一个单独的 <code>WebAppClassLoader</code>，并在启动 Web 应用的线程里设置线程线程上下文类加载器为 <code>WebAppClassLoader</code>。各个 <code>WebAppClassLoader</code> 实例之间相互隔离，进而实现 Web 应用之间的类隔。</li></ul><p>单纯依靠自定义类加载器没办法满足某些场景的要求，例如，有些情况下，高层的类加载器需要加载低层的加载器才能加载的类。</p><p>比如，SPI 中，SPI 的接口（如 <code>java.sql.Driver</code>）是由 Java 核心库提供的，由<code>BootstrapClassLoader</code> 加载。而 SPI 的实现（如<code>com.mysql.cj.jdbc.Driver</code>）是由第三方供应商提供的，它们是由应用程序类加载器或者自定义类加载器来加载的。默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载 SPI 的接口的类加载器（<code>BootstrapClassLoader</code>）也会用来加载 SPI 的实现。按照双亲委派模型，<code>BootstrapClassLoader</code> 是无法找到 SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。</p><p>再比如，假设我们的项目中有 Spring 的 jar 包，由于其是 Web 应用之间共享的，因此会由 <code>SharedClassLoader</code> 加载（Web 服务器是 Tomcat）。我们项目中有一些用到了 Spring 的业务类，比如实现了 Spring 提供的接口、用到了 Spring 提供的注解。所以，加载 Spring 的类加载器（也就是 <code>SharedClassLoader</code>）也会用来加载这些业务类。但是业务类在 Web 应用目录下，不在 <code>SharedClassLoader</code> 的加载路径下，所以 <code>SharedClassLoader</code> 无法找到业务类，也就无法加载它们。</p><p>如何解决这个问题呢？ 这个时候就需要用到 <strong>线程上下文类加载器（<code>ThreadContextClassLoader</code>）</strong> 了。</p><p>拿 Spring 这个例子来说，当 Spring 需要加载业务类的时候，它不是用自己的类加载器，而是用当前线程的上下文类加载器。还记得我上面说的吗？每个 Web 应用都会创建一个单独的 <code>WebAppClassLoader</code>，并在启动 Web 应用的线程里设置线程线程上下文类加载器为 <code>WebAppClassLoader</code>。这样就可以让高层的类加载器（<code>SharedClassLoader</code>）借助子类加载器（ <code>WebAppClassLoader</code>）来加载业务类，破坏了 Java 的类加载委托机制，让应用逆向使用类加载器。</p><p>线程线程上下文类加载器的原理是将一个类加载器保存在线程私有数据里，跟线程绑定，然后在需要的时候取出来使用。这个类加载器通常是由应用程序或者容器（如 Tomcat）设置的。</p><p><code>Java.lang.Thread</code> 中的<code>getContextClassLoader()</code>和 <code>setContextClassLoader(ClassLoader cl)</code>分别用来获取和设置线程的上下文类加载器。如果没有通过<code>setContextClassLoader(ClassLoader cl)</code>进行设置的话，线程将继承其父线程的上下文类加载器。</p><p>Spring 获取线程线程上下文类加载器的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cl = Thread.currentThread().getContextClassLoader();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载过程详解</title>
    <link href="/2023/07/16/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/07/16/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="类加载过程详解类的生命周期"><a href="#类加载过程详解类的生命周期" class="headerlink" title="类加载过程详解类的生命周期"></a>类加载过程详解类的生命周期</h2><p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</p><p>这 7 个阶段的顺序如下图所示：</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020192729446.png" alt="image-20231020192729446"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020192805597.png" alt="image-20231020192805597"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li></ol><p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取（ <code>ZIP</code>、 <code>JAR</code>、<code>EAR</code>、<code>WAR</code>、网络、动态代理技术运行时动态生成、其他文件生成比如 <code>JSP</code>…）、怎样获取。</p><p>加载这一步主要是通过我们后面要讲到的 <strong>类加载器</strong> 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定（不过，我们也能打破由双亲委派模型）。</p><p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。</p><p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，<strong>加载阶段尚未结束，连接阶段可能就已经开始</strong>了。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><strong>验证是连接阶段的第一步，目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</strong></p><p>验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。</p><p>不过，验证阶段也不是必须要执行的阶段。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 <code>-Xverify:none</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p>验证阶段主要由四个检验阶段组成：</p><ol><li>文件格式验证（Class 文件格式检查）</li><li>元数据验证（字节码语义检查）</li><li>字节码验证（程序语义检查）</li><li>符号引用验证（类的正确性检查）</li></ol><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020193352876.png" alt="image-20231020193352876"></p><p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p><blockquote><p>  方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p></blockquote><p>符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。</p><p>符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常，比如：</p><ul><li><code>java.lang.IllegalAccessError</code>：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li><li><code>java.lang.NoSuchFieldError</code>：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li><li><code>java.lang.NoSuchMethodError</code>：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li></ol><p><strong>基本数据类型的零值</strong>：</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020194231331.png" alt="image-20231020194231331"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><blockquote><p>  符号引用和直接引用的定义分别是什么？</p></blockquote><p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong></p><blockquote><p>  说明：<code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p></blockquote><p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有 6 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li><p>当遇到</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">getstatic</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">putstatic</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">invokestatic</span><br></code></pre></td></tr></table></figure><p>这 4 条字节码指令时，比如</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure><p>一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</p><ul><li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li><li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</p></li><li><p>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</p></li><li><p><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</p></li><li><p>当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li></ol><h2 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h2><p><strong>卸载类即该类的 Class 对象被 GC。</strong></p><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类文件结构详解</title>
    <link href="/2023/07/16/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/07/16/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="类文件结构详解回顾一下字节码"><a href="#类文件结构详解回顾一下字节码" class="headerlink" title="类文件结构详解回顾一下字节码"></a>类文件结构详解回顾一下字节码</h2><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020163524415.png" alt="image-20231020163524415"></p><p>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p><h2 id="Class-文件结构总结"><a href="#Class-文件结构总结" class="headerlink" title="Class 文件结构总结"></a>Class 文件结构总结</h2><p>根据 Java 虚拟机规范，Class 文件通过 <code>ClassFile</code> 定义，有点类似 C 语言的结构体。</p><p><code>ClassFile</code> 的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassFile &#123;<br>    u4             magic; <span class="hljs-comment">//Class 文件的标志</span><br>    u2             minor_version;<span class="hljs-comment">//Class 的小版本号</span><br>    u2             major_version;<span class="hljs-comment">//Class 的大版本号</span><br>    u2             constant_pool_count;<span class="hljs-comment">//常量池的数量</span><br>    cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];<span class="hljs-comment">//常量池</span><br>    u2             access_flags;<span class="hljs-comment">//Class 的访问标记</span><br>    u2             this_class;<span class="hljs-comment">//当前类</span><br>    u2             super_class;<span class="hljs-comment">//父类</span><br>    u2             interfaces_count;<span class="hljs-comment">//接口数量</span><br>    u2             interfaces[interfaces_count];<span class="hljs-comment">//一个类可以实现多个接口</span><br>    u2             fields_count;<span class="hljs-comment">//字段数量</span><br>    field_info     fields[fields_count];<span class="hljs-comment">//一个类可以有多个字段</span><br>    u2             methods_count;<span class="hljs-comment">//方法数量</span><br>    method_info    methods[methods_count];<span class="hljs-comment">//一个类可以有个多个方法</span><br>    u2             attributes_count;<span class="hljs-comment">//此类的属性表中的属性数</span><br>    attribute_info attributes[attributes_count];<span class="hljs-comment">//属性表集合</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过分析 <code>ClassFile</code> 的内容，我们便可以知道 class 文件的组成。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020164347439.png" alt="image-20231020164347439"></p><p>下面这张图是通过 IDEA 插件 <code>jclasslib</code> 查看的，你可以更直观看到 Class 文件结构。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020164330279.png" alt="image-20231020164330279"></p><p>使用 <code>jclasslib</code> 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。</p><p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p><h3 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u4             magic; <span class="hljs-comment">//Class 文件的标志</span><br></code></pre></td></tr></table></figure><p>每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。Java 规范规定魔数为固定值：0xCAFEBABE。如果读取的文件不是以这个魔数开头，Java 虚拟机将拒绝加载它。</p><h3 id="Class-文件版本号（Minor-Major-Version）"><a href="#Class-文件版本号（Minor-Major-Version）" class="headerlink" title="Class 文件版本号（Minor&amp;Major Version）"></a>Class 文件版本号（Minor&amp;Major Version）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             minor_version;<span class="hljs-comment">//Class 的小版本号</span><br>u2             major_version;<span class="hljs-comment">//Class 的大版本号</span><br></code></pre></td></tr></table></figure><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是<strong>次版本号</strong>，第 7 和第 8 个字节是<strong>主版本号</strong>。</p><p>每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 <code>javap -v</code> 命令来快速查看 Class 文件的版本号信息。</p><p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p><h3 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             constant_pool_count;<span class="hljs-comment">//常量池的数量</span><br>cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];<span class="hljs-comment">//常量池</span><br></code></pre></td></tr></table></figure><p>紧接着主次版本号之后的是常量池，常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p><table><thead><tr><th align="center">类型</th><th align="center">标志（tag）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CONSTANT_utf8_info</td><td align="center">1</td><td align="center">UTF-8 编码的字符串</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">3</td><td align="center">整形字面量</td></tr><tr><td align="center">CONSTANT_Float_info</td><td align="center">4</td><td align="center">浮点型字面量</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">5</td><td align="center">长整型字面量</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">6</td><td align="center">双精度浮点型字面量</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">7</td><td align="center">类或接口的符号引用</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">8</td><td align="center">字符串类型字面量</td></tr><tr><td align="center">CONSTANT_FieldRef_info</td><td align="center">9</td><td align="center">字段的符号引用</td></tr><tr><td align="center">CONSTANT_MethodRef_info</td><td align="center">10</td><td align="center">类中方法的符号引用</td></tr><tr><td align="center">CONSTANT_InterfaceMethodRef_info</td><td align="center">11</td><td align="center">接口中方法的符号引用</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">12</td><td align="center">字段或方法的符号引用</td></tr><tr><td align="center">CONSTANT_MethodType_info</td><td align="center">16</td><td align="center">标志方法类型</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">15</td><td align="center">表示方法句柄</td></tr><tr><td align="center">CONSTANT_InvokeDynamic_info</td><td align="center">18</td><td align="center">表示一个动态方法调用点</td></tr></tbody></table><p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code>：将结果输出到 temp.txt 文件)。</p><h3 id="访问标志-Access-Flags"><a href="#访问标志-Access-Flags" class="headerlink" title="访问标志(Access Flags)"></a>访问标志(Access Flags)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             access_flags;<span class="hljs-comment">//Class 的访问标记</span><br></code></pre></td></tr></table></figure><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等等。</p><p>类访问和属性修饰符:</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020180613066.png" alt="image-20231020180613066">饰符</p><p>我们定义了一个 <code>Employee</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.snailclimb.bean;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p><center>查看类的访问标志</center><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020180744731.png" alt="image-20231020180744731"></p><h3 id="当前类（This-Class）"><a href="#当前类（This-Class）" class="headerlink" title="当前类（This Class）"></a>当前类（This Class）</h3><h3 id="父类（Super-Class）"><a href="#父类（Super-Class）" class="headerlink" title="父类（Super Class）"></a>父类（Super Class）</h3><h3 id="接口（Interfaces）索引集合"><a href="#接口（Interfaces）索引集合" class="headerlink" title="接口（Interfaces）索引集合"></a>接口（Interfaces）索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             this_class;<span class="hljs-comment">//当前类</span><br>u2             super_class;<span class="hljs-comment">//父类</span><br>u2             interfaces_count;<span class="hljs-comment">//接口数量</span><br>u2             interfaces[interfaces_count];<span class="hljs-comment">//一个类可以实现多个接口</span><br></code></pre></td></tr></table></figure><p>Java 类的继承关系由类索引、父类索引和接口索引集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，</p><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，<strong>除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类</strong>，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p><p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p><h3 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             fields_count;<span class="hljs-comment">//字段数量</span><br>field_info     fields[fields_count];<span class="hljs-comment">//一个类会可以有个字段</span><br></code></pre></td></tr></table></figure><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><p><strong>field info(字段表) 的结构:</strong></p><center>字段表的结构</center><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020181145309.png" alt="image-20231020181145309"></p><ul><li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li><li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p><strong>字段的 access_flag 的取值:</strong></p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020181348721.png" alt="image-20231020181348721"></p><h3 id="方法表集合（Methods）"><a href="#方法表集合（Methods）" class="headerlink" title="方法表集合（Methods）"></a>方法表集合（Methods）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             methods_count;<span class="hljs-comment">//方法数量</span><br>method_info    methods[methods_count];<span class="hljs-comment">//一个类可以有个多个方法</span><br></code></pre></td></tr></table></figure><p>methods_count 表示方法的数量，而 method_info 表示方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><p><strong>method_info(方法表的) 结构:</strong></p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020181531506.png" alt="image-20231020181531506"></p><p><strong>方法表的 access_flag 取值：</strong></p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231020181631751.png" alt="image-20231020181631751"></p><blockquote><p>  注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p></blockquote><h3 id="属性表集合（Attributes）"><a href="#属性表集合（Attributes）" class="headerlink" title="属性表集合（Attributes）"></a>属性表集合（Attributes）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             attributes_count;<span class="hljs-comment">//此类的属性表中的属性数</span><br>attribute_info attributes[attributes_count];<span class="hljs-comment">//属性表集合</span><br></code></pre></td></tr></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，<strong>Java 虚拟机运行时会忽略掉它不认识的属性</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1700. 无法吃午餐的学生数量</title>
    <link href="/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201700.%20%E6%97%A0%E6%B3%95%E5%90%83%E5%8D%88%E9%A4%90%E7%9A%84%E5%AD%A6%E7%94%9F%E6%95%B0%E9%87%8F/"/>
    <url>/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201700.%20%E6%97%A0%E6%B3%95%E5%90%83%E5%8D%88%E9%A4%90%E7%9A%84%E5%AD%A6%E7%94%9F%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h5 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h5><p>LeetCode 1700. 无法吃午餐的学生数量<a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/</a></p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。<br>餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：</p><p>如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。<br>否则，这名学生会 放弃这个三明治 并回到队列的尾部。<br>这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p><p>给你两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i 个三明治的类型（i &#x3D; 0 是栈的顶部）， students[j] 是初始队列里第 j 名学生对三明治的喜好（j &#x3D; 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch">https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h5 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h5><ul><li>总的来说就是，食物不能乱碰（厨师洁癖），每个人，只能拿栈顶的三明治。</li><li>如果栈顶是圆形的，你就需要一个喜欢吃圆的人把三明治拿走。</li><li>如果栈顶是方形的，你就需要一个喜欢吃方的人把三明治拿走。</li><li>如果大伙没有喜欢栈顶三明治的人，不好意思，都饿着吧。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">countStudents</span>(<span class="hljs-params">int[] students, int[] sandwiches</span>) &#123;<br>    <br>       int x=<span class="hljs-number">0</span>;<br>       int y=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;students.<span class="hljs-property">length</span>; i++)&#123;<br>    <br>           <span class="hljs-keyword">if</span>(students[i] == <span class="hljs-number">0</span>)&#123;<br>    <br>               x++;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>               y++;<br>           &#125;<br>       &#125;<br><br>        <span class="hljs-keyword">for</span>(int j=<span class="hljs-number">0</span>; j&lt;sandwiches.<span class="hljs-property">length</span>; j++)&#123;<br>    <br>            <span class="hljs-keyword">if</span>(sandwiches[j] == <span class="hljs-number">0</span> &amp;&amp; x&gt;<span class="hljs-number">0</span>)&#123;<br>    <br>                x--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sandwiches[j] == <span class="hljs-number">1</span> &amp;&amp; y&gt;<span class="hljs-number">0</span>)&#123;<br>    <br>                y--;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>                <span class="hljs-keyword">return</span> x+y;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x+y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 901. 股票价格跨度</title>
    <link href="/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20901.%20%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/"/>
    <url>/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20901.%20%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h5 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h5><p>LeetCode 901. 股票价格跨度<a href="https://leetcode.cn/problems/online-stock-span/">https://leetcode.cn/problems/online-stock-span/</a></p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p><p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><p>例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/online-stock-span">https://leetcode.cn/problems/online-stock-span</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h5 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h5><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543877.png" alt="在这里插入图片描述"></p><ul><li>设A为 B之前 最近的 比B大 的元素。</li><li>即A与B之间的任一元素X满足 A&gt;X &amp;&amp; X&lt;&#x3D; B</li><li>若此时在B后添加一元素C</li><li>若C小于B则返回1</li><li>否则，C&gt;&#x3D;B，又因为A与B之间任一元素X&lt;&#x3D;B, 即X&lt;&#x3D;B&lt;&#x3D;C</li><li>所以我们获取A后一共多少个元素就行。即A与B之间的元素在添加B时就可以remove了。</li><li>为了避免没有元素充当A这种情况，在初始化list时添加一个Integer.MAX_VALUE元素。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span> &#123;<br>    <br><br>    private <span class="hljs-title class_">List</span>&lt;int[]&gt; list;<br>    private int index = -<span class="hljs-number">1</span>;<br><br>    public <span class="hljs-title class_">StockSpanner</span>() &#123;<br>    <br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;int[]&gt;();<br>        list.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> int[]&#123;<br>    index,<span class="hljs-title class_">Integer</span>.<span class="hljs-property">MAX_VALUE</span>&#125;);<br>    &#125;<br>    <br>    public int <span class="hljs-title function_">next</span>(<span class="hljs-params">int price</span>) &#123;<br>    <br>        index++;<br>        <span class="hljs-keyword">for</span>(int i=list.<span class="hljs-title function_">size</span>()-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>    <br>            <span class="hljs-keyword">if</span>(list.<span class="hljs-title function_">get</span>(i)[<span class="hljs-number">1</span>] &lt;= price)&#123;<br>    <br>                list.<span class="hljs-title function_">remove</span>(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br><br>        int res = index - list.<span class="hljs-title function_">get</span>(list.<span class="hljs-title function_">size</span>()-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br><br>        list.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> int[]&#123;<br>    index,price&#125;);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your StockSpanner object will be instantiated and called as such:</span><br><span class="hljs-comment"> * StockSpanner obj = new StockSpanner();</span><br><span class="hljs-comment"> * int param_1 = obj.next(price);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 779. 第K个语法符号</title>
    <link href="/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/Leetcode%20779.%20%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/Leetcode%20779.%20%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h5 id="题目来源：-Leetcode-779-第K个语法符号https-leetcode-cn-problems-k-th-symbol-in-grammar"><a href="#题目来源：-Leetcode-779-第K个语法符号https-leetcode-cn-problems-k-th-symbol-in-grammar" class="headerlink" title="题目来源： Leetcode 779. 第K个语法符号https://leetcode.cn/problems/k-th-symbol-in-grammar/"></a>题目来源： Leetcode 779. 第K个语法符号<a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/">https://leetcode.cn/problems/k-th-symbol-in-grammar/</a></h5><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>我们构建了一个包含 n 行( 索引从 1 开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。</p><p>例如，对于 n &#x3D; 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。<br>给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/k-th-symbol-in-grammar">https://leetcode.cn/problems/k-th-symbol-in-grammar</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h5 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h5><ul><li>每一行的前半部分正好为上一行</li><li>每一行的后半部分正好为前半部分的反转。</li><li>后半部分因为相当于上一行的反转，用1-x来达到这种目的</li></ul><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">kthGrammar</span>(<span class="hljs-params">int n, int k</span>) &#123;<br>    <br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>    <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br><span class="hljs-comment">//处于前半部分还是后半部分</span><br>        <span class="hljs-keyword">if</span>(k &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,n-<span class="hljs-number">2</span>))&#123;<br>    <br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>-<span class="hljs-title function_">kthGrammar</span>(n-<span class="hljs-number">1</span>, k-(int)<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,n-<span class="hljs-number">2</span>)));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">kthGrammar</span>(n-<span class="hljs-number">1</span>,k);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没想到这辈子还能赶上一次绿的题。</p>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>规则引擎</title>
    <link href="/2022/09/09/others/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/"/>
    <url>/2022/09/09/others/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="Drools"><a href="#Drools" class="headerlink" title="Drools"></a>Drools</h1><blockquote><p>通常规则文件的后缀为.drl</p></blockquote><h3 id="规则体语法结构"><a href="#规则体语法结构" class="headerlink" title="规则体语法结构"></a>规则体语法结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">rule <span class="hljs-string">&quot;ruleName&quot;</span><br>    attributes<br>    when<br>        LHS <br>    then<br>        RHS<br>end<br></code></pre></td></tr></table></figure><ul><li><p><strong>rule</strong>：关键字，表示规则开始，参数为规则的唯一名称。</p></li><li><p><strong>attributes</strong>：规则属性，是rule与when之间的参数，为可选项。</p></li><li><p><strong>when</strong>：关键字，后面跟规则的条件部分。</p></li><li><p><strong>LHS</strong>(Left Hand Side)：是规则的条件部分的通用名称。它由零个或多个条件元素组成。<strong>如果LHS为空，则它将被视为始终为true的条件元素</strong>。 （左手边）</p></li><li><p><strong>then</strong>：关键字，后面跟规则的结果部分。</p></li><li><p><strong>RHS</strong>(Right Hand Side)：是规则的后果或行动部分的通用名称。 （右手边）</p></li><li><p><strong>end</strong>：关键字，表示一个规则结束。</p></li></ul><blockquote><p>在drl形式的规则文件中使用注释和Java类中使用注释一致，分为单行注释和多行注释。</p></blockquote><blockquote><p>在规则体的LHS部分定义规则并进行模式匹配。LHS部分由一个或者多个条件组成，条件又称为pattern。</p></blockquote><ul><li><strong>pattern的语法结构为：绑定变量名:Object(Field约束)</strong></li></ul><p>​其中绑定变量名可以省略，通常绑定变量名的命名一般建议以$开始。</p><p>​如果定义了绑定变量名，就可以在规则体的RHS部分使用此绑定变量名来操作相应的Fact对象。</p><p>​Field约束部分是需要返回true或者false的0个或多个表达式。</p><h3 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h3><p>包括Java的  &gt;，&lt; ，&gt;&#x3D; ，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;</p><table><thead><tr><th align="center">符号</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">contains</td><td align="center">是否包含一个指定的对象值</td></tr><tr><td align="center">not  contains</td><td align="center">是否不包含一个指定的对象值</td></tr><tr><td align="center">memberOf</td><td align="center">是否在一个或多个集合中</td></tr><tr><td align="center">not memberOf</td><td align="center">是否不在一个或多个集合中</td></tr><tr><td align="center">matches</td><td align="center">是否与提供的标准的Java正则表达式进行匹配</td></tr><tr><td align="center">not matches</td><td align="center">是否不与提供的标准的Java正则表达式进行匹配</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试比较操作符contains</span><br>rule <span class="hljs-string">&quot;rule_comparison_contains&quot;</span><br>    when<br>        <span class="hljs-title function_">ComparisonEntity</span><span class="hljs-params">(names contains <span class="hljs-string">&quot;张三&quot;</span>)</span><br>        ComparisonEntity(list contains names)<br>    then<br>        System.out.println(<span class="hljs-string">&quot;规则rule_comparison_contains触发&quot;</span>);<br>end<br></code></pre></td></tr></table></figure><h3 id="规则属性-attributes"><a href="#规则属性-attributes" class="headerlink" title="规则属性 attributes"></a><strong>规则属性 attributes</strong></h3><ul><li><p><strong>enabled</strong></p><p>对应的取值为true和false，默认值为true。</p><p>用于指定当前规则是否启用，如果设置的值为false则当前规则无论是否匹配成功都不会触发</p></li><li><p><strong>dialect</strong></p><p>用于指定当前规则使用的语言类型，取值为java和mvel，默认值为java。</p></li><li><p><strong>salience</strong></p><p>用于指定规则的执行优先级，<strong>取值类型为Integer</strong>。<strong>数值越大越优先执行</strong>。每个规则都有一个默认的执行顺序，如果不设置salience属性，规则体的执行顺序为由上到下。</p></li><li><p><strong>no-loop</strong></p><p>用于防止死循环，当规则通过update之类的函数修改了Fact对象时，可能使当前规则再次被激活从而导致死循环。取值类型为Boolean，默认值为false。</p></li><li><p><strong>lock-on-active</strong></p><p>用于限制当前规则只会被执行一次，包括当前规则的重复执行不是本身触发的。取值类型为Boolean，默认值为false。</p><ul><li>no-loop的作用是限制因为modify等更新操作导致规则重复执行，但是有一个限定条件，是当前规则中进行更新导致当前规则重复执行。而不是防止其他规则更新相同的fact对象，导致当前规则更新。</li><li>lock-on-active可以看作是no-loop的加强版，不仅能限制自己的更新，还能限制别人的更新造成的死循环。</li></ul></li><li><p><strong>activation-group</strong></p><p>用于<strong>激活分组</strong>，取值为String类型。具有相同分组名称的规则只能有一个规则被触发。同一个分组中的多个规则如果都能够匹配成功，具体哪一个最终能够被触发可以通过salience属性确定。</p></li><li><p><strong>agenda-group</strong></p><p>用于<strong>议程分组</strong>，属于另一种可控的规则执行方式。用户可以通过设置agenda-group来控制规则的执行，只有获取焦点的组中的规则才会被触发。</p><p>activation-group定义的分组中只能够有一个规则可以被触发</p><p>agenda-group分组中的多个规则都可以被触发。</p></li><li><p><strong>auto-focus</strong></p><p><strong>自动获取焦点</strong>，取值类型为Boolean，默认值为false。一般结合agenda-group属性使用，当一个议程分组未获取焦点时，可以设置auto-focus属性来控制。</p></li><li><p><strong>timer</strong></p><p>timer属性可以通过定时器的方式指定规则执行的时间，使用方式有两种：</p><p><strong>方式一</strong>：timer (int: ?) &#x2F;&#x2F;timer(5s 2s)</p><p>遵循java.util.Timer对象的使用方式，第一个参数表示几秒后执行，第二个参数表示每隔几秒执行一次，第二个参数为可选。</p><p><strong>方式二</strong>：timer(cron: )&#x2F;&#x2F;timer(cron:0&#x2F;1 * * * * ?)</p><p>使用cron表达式来定义规则执行的规则。</p><blockquote><p>注意：如果规则中有用到了timer属性，匹配规则需要调用<a href="https://link.zhihu.com/?target=https://shimo.im/docs/m8AZVyE97DIz04Ab">kieSession.fireUntilHalt()</a>;这里涉及一个规则引擎的执行模式和线程问题</p></blockquote></li><li><p><strong>date-effective</strong></p><p><strong>用于指定规则的生效时间</strong>，即只有当前系统时间大于等于设置的时间或者日期规则才有可能触发。默认日期格式为：dd-MMM-yyyy。用户也可以自定义日期格式。</p><blockquote><p>注意：需要在VM参数上加上日期格式:-Ddrools.dateformat&#x3D;yyyy-MM-dd，在生产环境所在规则引擎的JVM设置中，也需要设置此参数，以保证开发和生产的一致性。</p></blockquote></li><li><p><strong>date-expires</strong></p><p>用于指定规则的<strong>失效时间</strong>，即只有当前系统时间小于设置的时间或者日期规则才有可能触发。默认日期格式为：dd-MMM-yyyy。用户也可以自定义日期格式。</p><blockquote><p>注意：需要在VM参数上加上日期格式:-Ddrools.dateformat&#x3D;yyyy-MM-dd，在生产环境所在规则引擎的JVM设置中，也需要设置此参数，以保证开发和生产的一致性。</p></blockquote></li></ul><h1 id="Jexl"><a href="#Jexl" class="headerlink" title="Jexl"></a>Jexl</h1><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-jexl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>公共方法  &#x2F;&#x2F; 例：正则表达式匹配</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">regMatch</span><span class="hljs-params">(String regEx, String str)</span> &#123;<br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regEx);<br>        <span class="hljs-keyword">return</span> pattern.matcher(str).matches();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>调用示例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">RL</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">JexlContext</span> <span class="hljs-variable">jc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapContext</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;一二三四五六七八九十&quot;</span>;<br>    jc.set(<span class="hljs-string">&quot;Util&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Util</span>());<br>    jc.set(<span class="hljs-string">&quot;str&quot;</span>, str);<br>    jc.set(<span class="hljs-string">&quot;ans&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">//可以动态编译的表达式</span><br>    <span class="hljs-comment">//表达式中出现的所有变量,都需要事先set进JexlContext中</span><br>  <span class="hljs-comment">//&quot; \u4e00”和“\u9fa5”是unicode编码，并且正好是中文编码的开始和结束的两个值，所以这个正则表达式可以用来判断字符串中是否包含中文。&#123;10, &#125; 表示重复10次或更多次</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ans = Util.regMatch(&quot;</span>[u4e00-u9fa5]&#123;<span class="hljs-number">10</span>,&#125;<span class="hljs-string">&quot;,str)&quot;</span>;<br>    <span class="hljs-type">Expression</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JexlEngine</span>().createExpression(expression);<br>    e.evaluate(jc);<br>    System.out.println(jc.get(<span class="hljs-string">&quot;ans&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>Jexl支持两种循环方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (item : list)&#123;<br>    x = x + item;<br>&#125;<br><br><br><span class="hljs-keyword">for</span> ( x lt <span class="hljs-number">10</span> )&#123;<br>    x = x + <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Jexl支持传入对象，并调用对象的<strong>get&#x2F;set</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">TmpTest</span> <span class="hljs-variable">tmpTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TmpTest</span>();<br>    tmpTest.setA(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">JexlContext</span> <span class="hljs-variable">jc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapContext</span>();<br>    jc.set(<span class="hljs-string">&quot;tmpTest&quot;</span>, tmpTest);<br>    jc.set(<span class="hljs-string">&quot;ans&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-type">Expression</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JexlEngine</span>().createExpression(<span class="hljs-string">&quot;ans = tmpTest.getA()&quot;</span>);<br>    e.evaluate(jc);<br>    System.out.println(jc.get(<span class="hljs-string">&quot;ans&quot;</span>));<br>    e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JexlEngine</span>().createExpression(<span class="hljs-string">&quot;ans = tmpTest.setA(2)&quot;</span>);<br>    e.evaluate(jc);<br>    <span class="hljs-type">TmpTest</span> <span class="hljs-variable">tmpTest1</span> <span class="hljs-operator">=</span> (TmpTest) jc.get(<span class="hljs-string">&quot;tmpTest&quot;</span>);<br>    System.out.println(tmpTest1.getA());<br>&#125;<br><span class="hljs-comment">//先输出1，再输出2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>规则引擎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>规则引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题解决方案</title>
    <link href="/2022/09/09/others/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2022/09/09/others/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h1><h2 id="centos7安装桌面环境-ping-未知的名称或服务"><a href="#centos7安装桌面环境-ping-未知的名称或服务" class="headerlink" title="centos7安装桌面环境 ping 未知的名称或服务"></a>centos7安装桌面环境 ping 未知的名称或服务</h2><p>检查&#x2F;etc&#x2F;resolv.conf文件，发现# Generated by NetworkManager </p><p>应该是在安装桌面的时候安装了gnome的网络管理造成的，由它接管了网络设置，直接修改&#x2F;etc&#x2F;resolv.conf这个文件是没用的，网络服务重启后会根据&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ethX来重载配置，如果ifcfg-ethX没有配置DNS，那么resolv.conf重置，重新变成默认或空值状态。</p><blockquote><p>解决方案：</p><p>编辑&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ethX，x可能是其他数字，但一般是ifcfg-eth0的，具体的X根据你的网卡确定，</p><p>在最下面添加：<br>DNS1&#x3D;8.8.8.8  #google dns服务器, 根据实际情况更换<br>DNS2&#x3D;8.8.4.4  #google dns服务器, 根据实际情况更换<br>保存后重启网络<br>#service network restart</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>问题解决方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 原生NIO存在的问题</title>
    <link href="/2022/09/06/Netty/1.%20%E5%8E%9F%E7%94%9FNIO%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8ENetty%E7%9A%84%E4%BC%98%E7%82%B9/1.%20%E5%8E%9F%E7%94%9FNIO%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/06/Netty/1.%20%E5%8E%9F%E7%94%9FNIO%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8ENetty%E7%9A%84%E4%BC%98%E7%82%B9/1.%20%E5%8E%9F%E7%94%9FNIO%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="原生NIO存在的问题"><a href="#原生NIO存在的问题" class="headerlink" title="原生NIO存在的问题"></a>原生NIO存在的问题</h4><ol><li><strong>NIO 的类库和 API 繁杂，使用麻烦</strong>：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。 </li><li><strong>需要具备其他的额外技能</strong>：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程 和网络编程非常熟悉，才能编写出高质量的 NIO 程序。 </li><li><strong>开发工作量和难度都非常大</strong>：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流 的处理等等。 </li><li><strong>JDK NIO 的 Bug</strong>：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决</li></ol>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. Netty的优点</title>
    <link href="/2022/09/06/Netty/1.%20%E5%8E%9F%E7%94%9FNIO%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8ENetty%E7%9A%84%E4%BC%98%E7%82%B9/2.%20Netty%E7%9A%84%E4%BC%98%E7%82%B9/"/>
    <url>/2022/09/06/Netty/1.%20%E5%8E%9F%E7%94%9FNIO%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8ENetty%E7%9A%84%E4%BC%98%E7%82%B9/2.%20Netty%E7%9A%84%E4%BC%98%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="Netty的优点"><a href="#Netty的优点" class="headerlink" title="Netty的优点"></a>Netty的优点</h4><p>Netty 对 JDK 自带的 NIO 的 API 进行了封装，解决了上述问题。</p><ol><li>设计优雅<br>- 适用于各种传输类型的统一 API 阻塞和非阻塞 Socket<br>- 基于灵活且可扩展的事件模型，可以清晰地分离关注点<br>- 高度可定制的线程模型 - 单线程，一个或多个线程池.</li><li>使用方便：<ul><li>详细记录的 Javadoc，用户指南和示例；</li><li>没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就 足够了。</li></ul></li><li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li><li>安全：完整的 SSL&#x2F;TLS 和 StartTLS 支持。 </li><li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 线程模型基本介绍</title>
    <link href="/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/1.%20%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/1.%20%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="线程模型基本介绍"><a href="#线程模型基本介绍" class="headerlink" title="线程模型基本介绍"></a>线程模型基本介绍</h3><p>目前存在的线程模型有： </p><ul><li>传统阻塞 I&#x2F;O 服务模型 </li><li>Reactor 模型</li></ul><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现 </p><ul><li>单 Reactor 单线程； </li><li>单 Reactor 多线程； </li><li>主从 Reactor 多线程</li></ul><p>Netty 线程模式(Netty主要基于主从Reactor多线程模型做了一定的改进，其中主从Reactor多线程模型有多个Reactor)</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 传统阻塞 IO 服务模型</title>
    <link href="/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/2.%20%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9E%20IO%20%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/2.%20%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9E%20IO%20%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="传统阻塞-I-O-服务模型"><a href="#传统阻塞-I-O-服务模型" class="headerlink" title="传统阻塞 I&#x2F;O 服务模型"></a>传统阻塞 I&#x2F;O 服务模型</h3><p>特点：</p><ul><li>采用阻塞I&#x2F;O模式获取输入的数据</li><li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li></ul><p>问题分析：</p><ul><li>当并发数很大时，会创建大量的线程，占用很多系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在Read操作，造成线程资源浪费</li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016203336562.png" alt="image-20231016203336562"></p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. Reactor 模式</title>
    <link href="/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/3.%20Reactor%20%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/3.%20Reactor%20%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><h3 id="传统阻塞-I-O-缺点的解决方案"><a href="#传统阻塞-I-O-缺点的解决方案" class="headerlink" title="传统阻塞 I&#x2F;O 缺点的解决方案"></a>传统阻塞 I&#x2F;O 缺点的解决方案</h3><ul><li><strong>基于 I&#x2F;O 复用模型</strong>：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。Reactor 对应的叫法: 1. 反应器模式 2. 分发者模式(Dispatcher) 3. 通知者模式(notifier)</li><li><strong>基于线程池复用线程资源</strong>：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理， 一个线程可以处理多个连接的业务。</li></ul><h3 id="Reactor-模式基本设计思想"><a href="#Reactor-模式基本设计思想" class="headerlink" title="Reactor 模式基本设计思想"></a>Reactor 模式基本设计思想</h3><p>I&#x2F;O复用 + 线程池，就是 Reactor 模式基本设计思想.</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016203953415.png" alt="image-20231016203953415"></p><ul><li>Reactor 模式，通过一个或多个输入同时传递给服务处理器的模式(基于事件驱动)</li><li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程， 因此 Reactor 模式也叫 Dispatcher 模式</li><li>Reactor 模式使用 I&#x2F;O 复用监听事件, 收到事件后，分发给某个线程(进程), 这是网络服务器高并发处理的关键.</li></ul><h3 id="Reactor-模式中-核心组成"><a href="#Reactor-模式中-核心组成" class="headerlink" title="Reactor 模式中 核心组成"></a><strong>Reactor 模式中 核心组成</strong></h3><ul><li>Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 I&#x2F;O 事件做出反应。 类比公司的电话接线员，接听来自客户的电话并将线路转移到适当的联系人； </li><li>Handlers：处理程序执行 I&#x2F;O 事件要完成的实际事件，类比客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I&#x2F;O 事件，处理程序执行非阻塞操作。</li></ul><h3 id="Reactor-模式分类"><a href="#Reactor-模式分类" class="headerlink" title="Reactor 模式分类"></a>Reactor 模式分类</h3><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现 </p><ul><li>单 Reactor 单线程 </li><li>单 Reactor 多线程 </li><li>主从 Reactor 多线程</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 单Reactor单线程</title>
    <link href="/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/4.%20%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/4.%20%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h2><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016204558239.png" alt="image-20231016204558239"></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>Select 可以实现应用程序通过一个阻塞对象监听多路连接请求（Reactor的设计思想是I&#x2F;O复用 + 线程池，Select就是I&#x2F;O复用）。</li><li>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发</li><li>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理.</li><li>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应 .</li><li>Handler 会完成 Read→业务处理→Send 的完整业务流程结合实例：服务器端用一个线程通过多路复用搞定所有的 I&#x2F;O 操作（包括连接，读、写等），编码简单，清晰明了， 但是如果客户端连接数量较多，将无法支撑，NIO 就属于这种模型。</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。</li></ul><p>缺点：</p><ul><li>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整 个进程无法处理其他连接事件，很容易导致性能瓶颈 。</li><li>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部 消息，造成节点故障。</li></ul><p>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis 在业务处理的时间复杂度 O(1)</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 单Reactor多线程</title>
    <link href="/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/5.%20%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/5.%20%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h2><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016225018895.png" alt="image-20231016225018895"></p><p>对上图的总结：</p><ul><li>Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发 </li><li>如果建立连接请求, 则 用 Acceptor 通过 accept 处理连接请求, 然后创建一个 Handler 对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由 reactor 的 dispatch 分发调用连接对应的 handler 来处理</li><li>handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的<strong>worker 线程池</strong>的某个线程处理业务</li><li>worker 线程池会分配独立线程完成真正的业务，并将结果返回给 handler</li><li>handler 收到响应后，通过 send 将结果返回给 client</li></ul><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p>优点：可以充分的利用多核 cpu 的处理能力</p><p>缺点：多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，Reactor在单线程运行， 在高并发场景容易出现性能瓶颈。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. 主从Reactor多线程</title>
    <link href="/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/6.%20%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/6.%20%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h2><h3 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h3><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016225632478.png" alt="image-20231016225632478"></p><p>总结：</p><ul><li>Reactor 主线程 MainReactor 对象通过 select 监听连接事件, 收到事件后，通过 Acceptor 处理连接事件</li><li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor</li><li>subreactor 将连接加入到连接队列进行监听,并创建 handler 进行各种事件处理</li><li>当有新事件发生时， subreactor 就会调用对应的 handler 处理</li><li>handler 通过 read 读取数据，分发给后面的 worker 线程处理</li><li>worker 线程池分配独立的 worker 线程进行业务处理，并返回结果</li><li>handler 收到响应的结果后，再通过 send 将结果返回给 client</li><li><strong>Reactor 主线程可以对应多个 Reactor 子线程, 即 MainRecator 可以关联多个 SubReactor</strong></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。 </li><li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</li></ul><p>缺点：编程复杂度较高</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. Reactor模式小结</title>
    <link href="/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/7.%20Reactor%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/7.%20Reactor%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Reactor-模式小结"><a href="#Reactor-模式小结" class="headerlink" title="Reactor 模式小结"></a>Reactor 模式小结</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul><li>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服务。</li><li>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待（handler 只负责响应事件，不做具体的业务处理，交给后面的Worker线程池处理）。</li><li>主从 Reactor 多线程，多个前台接待员，多个服务生。</li></ul><h3 id="Reactor-模式优点"><a href="#Reactor-模式优点" class="headerlink" title="Reactor 模式优点"></a>Reactor 模式优点</h3><ul><li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</li><li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</li><li>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</li><li>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. Netty模型</title>
    <link href="/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/8.%20Netty%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/8.%20Netty%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Netty-模型"><a href="#Netty-模型" class="headerlink" title="Netty 模型"></a>Netty 模型</h2><h3 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h3><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017101307824.png" alt="image-20231017101307824"></p><p>Netty 主要基于主从 Reactors 多线程模型（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor。</p><p>对图片说明：</p><ul><li>BossGroup 线程维护 Selector , 只关注 Accecpt</li><li>当接收到 Accept 事件，获取到对应的 SocketChannel, 封装成 NIOScoketChannel 并注册到 Worker 线程(事件循环), 并进行维护</li><li>当 Worker 线程监听到 selector 中通道发生自己感兴趣的事件后，就进行处理(就由 handler)， 注意 handler 已经加入到通道</li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017101556996.png" alt="image-20231017101556996"></p><p><strong>对上图的说明</strong></p><ul><li>Netty 抽象出两组线程池：<ul><li>BossGroup 专门负责接收客户端的连接。</li><li>WorkerGroup 专门负责网络的读写 。</li></ul></li><li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup。</li><li>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop。</li><li>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个NioEventLoop 都有一个 selector , 用于监听绑定在其上的 socket 的网络通讯。</li><li>NioEventLoopGroup 可以有多个线程, 即可以含有多个 NioEventLoop。 </li><li>每个 Boss 的 NioEventLoop 循环执行的步骤有 3 步：<ul><li>轮询 accept 事件</li><li>处理 accept 事件 , 与 client 建立连接 , 生成 NioScocketChannel , 并将其注册到某个 worker 的NioEventLoop 上 的 selector</li><li>处理任务队列的任务，即 runAllTasks</li></ul></li><li>每个 Worker的NioEventLoop 循环执行的步骤<ul><li>轮询 read, write 事件</li><li>处理 I&#x2F;O 事件， 即 read , write 事件，在对应 NioScocketChannel 处理</li><li>处理任务队列的任务 ， 即 runAllTasks</li></ul></li><li>每个Worker NIOEventLoop 处理业务时，会使用pipeline(管道)，pipeline 中包含了 channel , 即通过 pipeline 可以获取到对应通道, 管道中维护了很多的处理器</li></ul><blockquote><ul><li>NioEventLoop 内部采用串行化设计，从消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由 IO 线程 NioEventLoop 负责</li><li>NioEventLoopGroup 下包含多个 NioEventLoop<ul><li>每个 NioEventLoop 中包含有一个 Selector，一个 taskQueue</li><li>每个 NioEventLoop 的 Selector 上可以注册监听多个 NioChannel</li><li>每个 NioChannel 只会绑定在唯一的 NioEventLoop 上</li><li>每个 NioChannel 都绑定有一个自己的 ChannelPipeline</li></ul></li></ul><p>  Selector : NioChannel  一对多， NioChannel : ChannelPipeline 一对一 。</p></blockquote><p>任务队列（taskQueue）中的 Task 有 3 种典型使用场景</p><ul><li><p>用户程序自定义的普通任务</p></li><li><p>用户自定义定时任务 </p></li><li><p>非当前 Reactor 线程调用 Channel 的各种方法</p><p>例如在推送系统的业务线程里面，根据用户的标识，找到对应的 Channel 引用，然后调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到任务队列中后被异步消费。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. BootStrap、ServerBootStrap</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/1.%20BootStrap%E3%80%81ServerBootStrap/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/1.%20BootStrap%E3%80%81ServerBootStrap/</url>
    
    <content type="html"><![CDATA[<h2 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h2><ul><li>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联 各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类</li><li>常见的方法有 <ul><li>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)，该方法用于服务器端， 用来设置两个 EventLoop </li><li>public B group(EventLoopGroup group) ，该方法用于客户端，用来设置一个 EventLoop </li><li>public B channel(Class channelClass)，该方法用来设置一个服务器端的通道实现 </li><li>public  B option(ChannelOption option, T value)，用来给 ServerChannel 添加配置 </li><li>public  ServerBootstrap childOption(ChannelOption childOption, T value)，用来给接收到的通道添加配置 </li><li>public ServerBootstrap childHandler(ChannelHandler childHandler)，该方法用来设置业务处理类（自定义的 handler） </li><li>public ChannelFuture bind(int inetPort) ，该方法用于服务器端，用来设置占用的端口号 </li><li>public ChannelFuture connect(String inetHost, int inetPort) ，该方法用于客户端，用来连接服务器。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. 异步模型</title>
    <link href="/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/9.%20%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/09/06/Netty/2.%20Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/9.%20%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</p></li><li><p>Netty 中的 I&#x2F;O 操作是异步的，包括 Bind、Write、Connect 等操作会简单的返回一个 ChannelFuture。 </p></li><li><p>调用者并不能立刻获得结果，而是通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 I&#x2F;O 操作结果 </p></li><li><p>Netty 的异步模型是建立在 future 和 callback 的之上的。callback 就是回调。 Future的核心思想是：假设一个方法 fun，计算过程可能非常耗时，等待 fun 返回显然不合适。那么可以在调用 fun 的时候，立马返回一个 Future，后续可以通过 Future 去监控方法 fun 的处理过程(即 ： Future-Listener 机制)</p></li></ul><h3 id="Future-说明"><a href="#Future-说明" class="headerlink" title="Future 说明"></a>Future 说明</h3><ul><li>表示<strong>异步的执行结果</strong>, 可以通过它提供的方法来检测执行是否完成，比如检索计算等等. </li><li>ChannelFuture 是一个接口 ： public interface ChannelFuture extends Future<Void> 我们可以添加监听器，<strong>当监听的事件发生时，就会通知到监听器</strong>。</li></ul><h3 id="异步工作原理示意"><a href="#异步工作原理示意" class="headerlink" title="异步工作原理示意"></a>异步工作原理示意</h3><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017105819397.png" alt="image-20231017105819397"></p><blockquote><p>  解释：任务中的每一步都不立刻得到结果，而是返回Future或者其他的，然后直接执行下一步，之后再通过Future获取之前的执行结果。</p></blockquote><h3 id="Future-Listener-机制"><a href="#Future-Listener-机制" class="headerlink" title="Future-Listener 机制"></a>Future-Listener 机制</h3><ul><li>当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态， 注册监听函数来执行完成后的操作。</li><li>常见有如下操作<ul><li>通过 isDone 方法来判断当前操作是否完成；</li><li>通过 isSuccess 方法来判断已完成的当前操作是否成功；</li><li>通过 getCause 方法来获取已完成的当前操作失败的原因；</li><li>通过 isCancelled 方法来判断已完成的当前操作是否被取消；</li><li>通过 addListener 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知指定的监听器；如果 Future 对象已完成，则通知指定的监听器</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10. Unpooled类</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/10.%20Unpooled%E7%B1%BB/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/10.%20Unpooled%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>Unpooled类</p><ul><li>Netty 提供一个专门用来操作缓冲区(即 Netty 的数据容器)的工具类</li><li>常用方法如下所示</li></ul><p>​<img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017132243029.png" alt="image-20231017132243029"></p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. Netty应用实例-心跳机制</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/11.%20Netty%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/11.%20Netty%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>Netty心跳检索机制案例</p><p>实例要求: </p><ul><li>编写一个 Netty 心跳检测机制案例, 当服务器超过 3 秒没有读时，就提示读空闲</li><li>当服务器超过 5 秒没有写操作时，就提示写空闲</li><li>实现当服务器超过 7 秒没有读或者写操作时，就提示读写空闲</li><li>代码如下：TODO</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12. Netty应用实例-通过WebSocket实现长连接</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/12.%20Netty%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E9%80%9A%E8%BF%87WebSocket%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/12.%20Netty%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E9%80%9A%E8%BF%87WebSocket%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>Netty 通过 WebSocket 编程实现服务器和客户端长连接</strong></p><p>实例要求: </p><ul><li>Http 协议是无状态的, 浏览器和服务器间的请求响应一次，下一次会重新创建连接。</li><li>要求：实现基于 webSocket 的长连接的全双工的交互。</li><li>改变 Http 协议多次请求的约束，实现长连接，服务器可以发送消息给浏览器。</li><li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知。</li></ul><p>代码： TODO</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. Future、ChannelFuture</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/2.%20Future%E3%80%81ChannelFuture/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/2.%20Future%E3%80%81ChannelFuture/</url>
    
    <content type="html"><![CDATA[<h2 id="Future、ChannelFuture"><a href="#Future、ChannelFuture" class="headerlink" title="Future、ChannelFuture"></a>Future、ChannelFuture</h2><p>Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p><p>常见的方法有 </p><ul><li>Channel channel()，返回当前正在进行 IO 操作的通道 </li><li>ChannelFuture sync()，等待异步操作执行完毕</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. Channel</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/3.%20Channel/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/3.%20Channel/</url>
    
    <content type="html"><![CDATA[<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ul><li><p>Netty 网络通信的组件，能够用于执行网络 I&#x2F;O 操作。</p></li><li><p>通过 Channel 可获得当前网络连接的通道的状态。</p></li><li><p>通过 Channel 可获得网络连接的配置参数 （例如接收缓冲区大小）。</p></li><li><p>Channel 提供异步的网络 I&#x2F;O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I&#x2F;O 调用都将立即返回，并且不保证在调用结束时所请求的 I&#x2F;O 操作已完成。</p></li><li><p>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I&#x2F;O 操作成功、失败或取消时回调通知调用方 。</p></li><li><p>支持关联 I&#x2F;O 操作与对应的处理程序。</p></li><li><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型:</p></li></ul><pre><code class="hljs">-   NioSocketChannel，异步的客户端 TCP Socket 连接。 -   NioServerSocketChannel，异步的服务器端 TCP Socket 连接。 -   NioDatagramChannel，异步的 UDP 连接。 -   NioSctpChannel，异步的客户端 Sctp（流控制传输协议） 连接。 -   NioSctpServerChannel，异步的 Sctp 服务器端连接这些通道涵盖了 UDP 和 TCP、网络 IO 以及文件 IO。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. Selector</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/4.%20Selector/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/4.%20Selector/</url>
    
    <content type="html"><![CDATA[<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><ul><li>Netty 基于 Selector 对象实现 I&#x2F;O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。</li><li>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I&#x2F;O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. ChannelHandler 及其实现类</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/5.%20ChannelHandler%20%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/5.%20ChannelHandler%20%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="ChannelHandler-及其实现类"><a href="#ChannelHandler-及其实现类" class="headerlink" title="ChannelHandler 及其实现类"></a>ChannelHandler 及其实现类</h2><ul><li><p>ChannelHandler 是一个接口，处理 I&#x2F;O 事件或拦截 I&#x2F;O 操作，并将其转发到其 ChannelPipeline(业务处理链) 中的下一个处理程序。</p></li><li><p>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它 的子类</p></li><li><p>ChannelHandler 及其实现类一览图</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017113653790.png" alt="image-20231017113653790"></p></li><li><p>我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</p></li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017113704031.png" alt="image-20231017113704031"></p><blockquote><p>  文心一言：</p><p>  在 Netty 中，通过继承 <code>ChannelInboundHandlerAdapter</code> 并重写其方法，我们可以自定义处理网络事件的逻辑。一般情况下，你可能需要重写以下方法：</p><ol><li><code>channelRegistered(ChannelHandlerContext ctx)</code>: 当 Channel 已经注册到它的 EventLoop 时被调用。</li><li><code>channelUnregistered(ChannelHandlerContext ctx)</code>: 当 Channel 从它的 EventLoop 注销并且它的所有挂起的 I&#x2F;O 操作都已经被处理完时被调用。</li><li><code>channelActive(ChannelHandlerContext ctx)</code>: 当 Channel 已经连接并且就绪时被调用。常用于检测新的连接。</li><li><code>channelInactive(ChannelHandlerContext ctx)</code>: 当 Channel 断开连接时被调用。</li><li><code>channelRead(ChannelHandlerContext ctx, Object msg)</code>: 当 Channel 上有数据可读时被调用。你可以在这里处理接收到的数据。</li><li><code>exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code>: 当处理事件过程中有异常抛出时被调用。在大多数情况下，应该记录这个异常并关闭相关的 Channel。</li></ol><p>  以上是最常用的一些方法，具体需要重写哪些方法取决于你的业务需求和网络事件的处理逻辑。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. Pipeline 和 ChannelPipeline</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/6.%20Pipeline%20%E5%92%8C%20ChannelPipeline/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/6.%20Pipeline%20%E5%92%8C%20ChannelPipeline/</url>
    
    <content type="html"><![CDATA[<h2 id="Pipeline-和-ChannelPipeline"><a href="#Pipeline-和-ChannelPipeline" class="headerlink" title="Pipeline 和 ChannelPipeline"></a>Pipeline 和 ChannelPipeline</h2><p>ChannelPipeline 是一个重点：</p><ul><li><p>ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链。(也可以这样理解：ChannelPipeline 是保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作)。</p></li><li><p>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及控制Channel 中各个的 ChannelHandler 如何相互交互。</p></li><li><p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017114353740.png" alt="image-20231017114353740"></p></li><li><p>常用方法</p><ul><li>ChannelPipeline addFirst(ChannelHandler… handlers)，把一个业务处理类（handler）添加到链中的第一个位置 </li><li>ChannelPipeline addLast(ChannelHandler… handlers)，把一个业务处理类（handler）添加到链中的最后一个位置</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. ChannelHandlerContext</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/7.%20ChannelHandlerContext/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/7.%20ChannelHandlerContext/</url>
    
    <content type="html"><![CDATA[<h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><ul><li>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象</li><li>即 ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 时 ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用.</li><li>常用方法</li></ul><blockquote><p>  文心一言：</p><p>  Netty中的<code>ChannelHandlerContext</code>提供了一些常用的方法，用于操作和管理ChannelHandler的上下文。以下是一些常用的<code>ChannelHandlerContext</code>方法：</p><ol><li><code>bind(SocketAddress localAddress, ChannelPromise promise)</code>: 绑定本地地址。</li><li><code>connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</code>: 连接到远程节点。</li><li><code>write(Object msg, ChannelPromise promise)</code>: 写数据到Channel。</li><li><code>flush()</code>: 刷新出站缓冲区。</li><li><code>read()</code>: 读取数据。</li><li><code>close(ChannelPromise promise)</code>: 关闭Channel。</li><li><code>isRemoved()</code>: 返回是否被移除。</li><li><code>executor()</code>: 返回绑定到ChannelHandler的EventExecutor。</li><li><code>channel()</code>: 返回当前Channel。</li><li><strong>writeAndFlush</strong> 将数据写到 ChannelPipeline 中当前ChannelHandler的下一个ChannelHandler开始处理（出站）</li></ol><p>  以上方法可以帮助你管理和操作ChannelHandler的上下文，具体使用哪些方法取决于你的业务需求和网络事件的处理逻辑。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. ChannelOption</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/8.%20ChannelOption/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/8.%20ChannelOption/</url>
    
    <content type="html"><![CDATA[<h2 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h2><ul><li><p>Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数。</p></li><li><p>ChannelOption 参数如下</p></li></ul><p>ChannelOption 参数包括但不限于以下几种：</p><ol><li>ChannelOption.SO_BACKLOG：用于构造服务端套接字 ServerSocket 对象，标识当服务器请求处理线程全满时，用于临时存放已完成三次握手的请求的队列的最大长度。</li><li>ChannelOption.SO_KEEPALIVE：该参数用于设置 TCP 连接，当设置该选项以后，连接会测试链接的状态。</li><li>ChannelOption.SO_REUSEADDR：允许程序重复使用本地地址和端口，即使该端口已经被占用或之前的服务进程已经结束。当一个服务器进程占用了某个端口（例如，TCP 的 80 端口）进行监听时，如果再次监听同一个端口，通常会因为端口已经被占用而返回错误。然而，如果设置了 SO_REUSEADDR 参数，即使该端口被占用，其他服务也可以共用这个端口，从而解决了这个问题。这在服务器程序中是非常有用的。例如，当一个进程非正常退出时，它占用的端口可能不会立即释放，如果不设置 SO_REUSEADDR 参数，其他进程就不能立即使用这个端口。因此，SO_REUSEADDR 参数可以避免因端口占用而造成的服务中断。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. EventLoopGroup、NioEventLoopGroup</title>
    <link href="/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/9.%20EventLoopGroup%E3%80%81NioEventLoopGroup/"/>
    <url>/2022/09/06/Netty/3.%20Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/9.%20EventLoopGroup%E3%80%81NioEventLoopGroup/</url>
    
    <content type="html"><![CDATA[<h2 id="EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="EventLoopGroup 和其实现类 NioEventLoopGroup"></a>EventLoopGroup 和其实现类 NioEventLoopGroup</h2><ul><li><p>EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源，一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个 Selector 实例。</p></li><li><p>EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop 来处理任务。在 Netty 服 务 器 端 编 程 中 ， 我 们 一 般 都 需 要 提 供 两 个 EventLoopGroup ， 例 如 ： BossEventLoopGroup 和 WorkerEventLoopGroup。</p></li><li><p>通常一个服务端口即一个 ServerSocketChannel 对应一个 Selector 和一个 EventLoop 线程。BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017131711917.png" alt="image-20231017131711917"></p></li><li><p>常用方法 </p><ul><li>public NioEventLoopGroup()，构造方法 </li><li>public Future shutdownGracefully()，断开连接，关闭线程</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 编码和解码的基本介绍</title>
    <link href="/2022/09/06/Netty/4.%20Google%20Protobuf/1.%20%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/09/06/Netty/4.%20Google%20Protobuf/1.%20%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="编码和解码的基本介绍"><a href="#编码和解码的基本介绍" class="headerlink" title="编码和解码的基本介绍"></a>编码和解码的基本介绍</h2><ul><li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据 时就需要解码</li><li>codec(编解码器) 的组成部分有两个：decoder(解码器)和 encoder(编码器)。encoder 负责把业务数据转换成字节码数据，decoder 负责把字节码数据转换成业务数据</li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017140110975.png" alt="image-20231017140110975"></p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. Netty本身的编码解码的机制和问题分析</title>
    <link href="/2022/09/06/Netty/4.%20Google%20Protobuf/2.%20Netty%E6%9C%AC%E8%BA%AB%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E7%9A%84%E6%9C%BA%E5%88%B6%E5%92%8C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <url>/2022/09/06/Netty/4.%20Google%20Protobuf/2.%20Netty%E6%9C%AC%E8%BA%AB%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E7%9A%84%E6%9C%BA%E5%88%B6%E5%92%8C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Netty-本身的编码解码的机制和问题分析"><a href="#Netty-本身的编码解码的机制和问题分析" class="headerlink" title="Netty 本身的编码解码的机制和问题分析"></a>Netty 本身的编码解码的机制和问题分析</h2><ul><li>Netty 提供的编码器 <ul><li>StringEncoder，对字符串数据进行编码 </li><li>ObjectEncoder，对 Java 对象进行编</li></ul></li><li>Netty 提供的解码器 <ul><li>StringDecoder, 对字符串数据进行解码 </li><li>ObjectDecoder，对 Java 对象进行解码</li></ul></li></ul><p>Netty 本身自带的 ObjectDecoder 和 ObjectEncoder 可以用来实现 POJO 对象或各种业务对象的编码和解码，底层使用的仍是 Java 序列化技术 , 而 Java 序列化技术本身效率就不高，存在如下问题：</p><ul><li>无法跨语言</li><li>序列化后的体积太大，是二进制编码的 5 倍多。 </li><li>序列化性能太低</li></ul><p>引出 新的解决方案 Google 的 Protobuf。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. Protobuf</title>
    <link href="/2022/09/06/Netty/4.%20Google%20Protobuf/3.%20Protobuf/"/>
    <url>/2022/09/06/Netty/4.%20Google%20Protobuf/3.%20Protobuf/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. Protobuf 快速入门实例</title>
    <link href="/2022/09/06/Netty/4.%20Google%20Protobuf/4.%20Protobuf%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B/"/>
    <url>/2022/09/06/Netty/4.%20Google%20Protobuf/4.%20Protobuf%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 基本说明</title>
    <link href="/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/1.%20%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E/"/>
    <url>/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/1.%20%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><ul><li>netty 的组件设计：Netty 的主要组件有 Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe 等</li><li>ChannelHandler 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 ChannelInboundHandler 接口（或 ChannelInboundHandlerAdapter），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时， 也可以从 ChannelInboundHandler 冲刷数据 。 业务逻辑通常写在一个或者多个ChannelInboundHandler 中。ChannelOutboundHandler 原理一样，只不过它是用来处理出站数据的。</li><li>ChannelPipeline 提供了 ChannelHandler 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 pipeline 中的一系列 ChannelOutboundHandler，并被这些 Handler 处理，反之则称为入站。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 解码器-ByteToMessageDecoder</title>
    <link href="/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/3.%20%E8%A7%A3%E7%A0%81%E5%99%A8-ByteToMessageDecoder/"/>
    <url>/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/3.%20%E8%A7%A3%E7%A0%81%E5%99%A8-ByteToMessageDecoder/</url>
    
    <content type="html"><![CDATA[<h2 id="解码器-ByteToMessageDecoder"><a href="#解码器-ByteToMessageDecoder" class="headerlink" title="解码器-ByteToMessageDecoder"></a>解码器-ByteToMessageDecoder</h2><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017141108161.png" alt="image-20231017141108161"></p><p>由于不可能知道远程节点是否会一次性发送一个完整的信息，tcp 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017141824536.png" alt="image-20231017141824536"></p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 编码解码器</title>
    <link href="/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/2.%20%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
    <url>/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/2.%20%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="编码解码器"><a href="#编码解码器" class="headerlink" title="编码解码器"></a>编码解码器</h2><ul><li>当 Netty 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 java 对象）；如果是出站消息，它会被编码成字节。</li><li>Netty 提供一系列实用的编解码器，他们都实现了 ChannelInboundHandler 或者 ChannelOutboundHandler 接口。 在这些类中，channelRead 方法已经被重写了。以入站为例，对于每个从入站 Channel 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 decode()方法进行解码，并将解码后的字节转发给 ChannelPipeline 中的下一个 ChannelInboundHandler。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 解码器-ReplayingDecoder</title>
    <link href="/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/5.%20%E8%A7%A3%E7%A0%81%E5%99%A8-ReplayingDecoder/"/>
    <url>/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/5.%20%E8%A7%A3%E7%A0%81%E5%99%A8-ReplayingDecoder/</url>
    
    <content type="html"><![CDATA[<h2 id="解码器-ReplayingDecoder"><a href="#解码器-ReplayingDecoder" class="headerlink" title="解码器-ReplayingDecoder"></a>解码器-ReplayingDecoder</h2><ul><li><p>public abstract class ReplayingDecoder extends ByteToMessageDecoder</p></li><li><p>ReplayingDecoder 扩展了 ByteToMessageDecoder 类，使用这个类，我们<strong>不必调用 readableBytes()方法</strong>。参数 S 指定了用户状态管理的类型，其中 Void代表不需要状态管理。</p></li><li><p>应用实例：使用 ReplayingDecoder 编写解码器，对前面的案例进行简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyByteToLongDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReplayingDecoder</span>&lt;Void&gt; &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;MyByteToLongDecoder2 被调用&quot;</span>);<br>                <span class="hljs-comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span><br>out.add(in.readLong());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>ReplayingDecoder 使用方便，但它也有一些局限性： </p><ul><li>并不是所有的 ByteBuf 操作都被支持 ， 如果调用了一个不被支持的方法 ， 将会抛出一个 UnsupportedOperationException。</li><li>ReplayingDecoder 在某些情况下可能稍慢于 ByteToMessageDecoder，例如网络缓慢并且消息格式复杂时， 消息会被拆成了多个碎片，速度变慢。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. Netty 的 handler 链的调用机制</title>
    <link href="/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/4.%20Netty%20%E7%9A%84%20handler%20%E9%93%BE%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/4.%20Netty%20%E7%9A%84%20handler%20%E9%93%BE%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Netty-的-handler-链的调用机制"><a href="#Netty-的-handler-链的调用机制" class="headerlink" title="Netty 的 handler 链的调用机制"></a>Netty 的 handler 链的调用机制</h2><p>实例要求: </p><pre><code class="hljs">1) 使用自定义的编码器和解码器来说明 Netty 的 handler 调用机制     1) 客户端发送 long -&gt; 服务器    2) 服务端发送 long -&gt; 客户端2) 案例演示</code></pre><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017142003112.png" alt="image-20231017142003112"></p><ol start="3"><li><p>结论</p><ol><li><p>不论解码器 handler 还是编码器 handler ，接收的消息类型必须与待处理的消息类型一致，否则该 handler 不会被执行。</p><blockquote><p>  在Netty中，当一个handler接收到一个消息时，这个消息的类型必须与该handler能够处理的消息类型相匹配。</p><p>  在Netty中，每个handler通常只负责处理特定类型的消息。例如，可能有一个handler专门用于处理HTTP请求，而另一个handler用于处理自定义协议的消息。当一个消息到达时，Netty会根据消息的类型选择相应的handler进行处理。</p><p>  因此，如果一个handler接收到了一个它无法处理的消息类型，那么它应该将这个消息传递给下一个handler，或者抛出一个异常表示无法处理该消息。</p></blockquote></li><li><p>在解码器进行数据解码时，需要判断缓存区(ByteBuf)的数据是否足够 ，否则接收到的结果会期望结果可能不一致。</p></li></ol></li></ol><blockquote><p>  文心一言：</p><p>  Netty 的 handler 链的调用机制是什么样子的？</p><p>  Netty的handler链的调用机制主要依赖于事件驱动和异步处理的机制。</p><p>  当一个网络事件发生时，Netty会根据事件类型（例如，有数据读入或数据写出）选择相应的事件处理器进行处理。这些事件处理器通常被称为“handler”。</p><p>  在Netty中，可以设置多个handler，形成一个handler链。当一个网络事件发生时，Netty会按照这个handler链的顺序依次调用每个handler进行处理。</p><p>  对于入站数据（从网络通道读入的数据），Netty会依次调用每个入站handler（ChannelInboundHandler）进行处理。每个handler可以处理入站数据，进行必要的解码、反序列化、消息分发等操作，然后将处理结果传递给下一个handler。最终的处理结果会传递给应用程序的的业务逻辑进行处理。</p><p>  对于出站数据（需要发送到网络通道的数据），Netty会依次调用每个出站handler（ChannelOutBoundHandler）进行处理。每个handler可以处理出站数据，进行必要的编码、加密、发送等操作，然后将处理结果传递给下一个handler。最终的处理结果会通过网络通道发送出去。</p><p>  需要注意的是，对于解码器handler和编码器handler，接收的消息类型必须与待处理的消息类型一致，否则该handler不会被执行。在解码器进行数据解码时，需要判断缓存区(ByteBuf)的数据是否足够，否则接收到的结果和期望结果可能不一致。</p><p>  总的来说，Netty的handler链的调用机制是一种事件驱动和异步处理的机制，通过多个handler的协同工作，可以实现复杂的网络应用。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. 其它编解码器</title>
    <link href="/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/6.%20%E5%85%B6%E5%AE%83%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
    <url>/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/6.%20%E5%85%B6%E5%AE%83%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>其它编解码器 </p><ul><li>其它解码器<ul><li>LineBasedFrameDecoder：这个类在 Netty 内部也有使用，它使用行尾控制字符（\n 或者\r\n）作为分隔符来解析数据。</li><li>DelimiterBasedFrameDecoder：使用自定义的特殊字符作为消息的分隔符。</li><li>HttpObjectDecoder：一个 HTTP 数据的解码器</li><li>LengthFieldBasedFrameDecoder：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li></ul></li><li>其它编码器</li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017143421983.png" alt="image-20231017143421983"></p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. Log4j 整合到 Netty</title>
    <link href="/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/7.%20Log4j%20%E6%95%B4%E5%90%88%E5%88%B0%20Netty/"/>
    <url>/2022/09/06/Netty/5.%20Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%B8%8EHandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/7.%20Log4j%20%E6%95%B4%E5%90%88%E5%88%B0%20Netty/</url>
    
    <content type="html"><![CDATA[<h2 id="Log4j-整合到-Netty"><a href="#Log4j-整合到-Netty" class="headerlink" title="Log4j 整合到 Netty"></a>Log4j 整合到 Netty</h2><ol><li><p>在 Maven 中添加对 Log4j 的依赖 在 pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置 Log4j 在 resources&#x2F;log4j.properties</p><ul><li><p>log4j.rootLogger&#x3D;DEBUG, stdout</p></li><li><p>log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</p></li><li><p>log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</p></li><li><p>log4j.appender.stdout.layout.ConversionPattern&#x3D;%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n</p><blockquote><p>  Log4j的配置文件中，每项配置的作用如下：</p><ol><li>log4j.rootLogger：定义了日志的最低级别，以及输出日志的appender。在这个例子中，级别为DEBUG，appender为stdout，意味着所有级别为DEBUG及以上的日志都会输出到stdout这个appender。</li><li>log4j.appender.stdout：定义了一个名为stdout的appender，它的类型是org.apache.log4j.ConsoleAppender，意味着日志会输出到控制台。</li><li>log4j.appender.stdout.layout：指定了使用 <code>PatternLayout</code> 类作为日志输出的布局方式，即使用自定义的模式来格式化日志输出。</li><li>log4j.appender.stdout.layout.ConversionPattern 定义了stdout appender的日志格式。<ol><li><code>%d&#123;yyyy-MM-dd HH:mm:ss&#125;</code>：表示日期时间的格式，按照指定的模式进行输出。</li><li><code>%-5p</code>：表示日志级别，并且最小宽度为5个字符，如果日志级别的名称长度不足5个字符，则使用空格进行填充。</li><li><code>%c&#123;1&#125;</code>：表示类名，这里 <code>&#123;1&#125;</code> 表示只输出类名的最后一部分（即不包含包名的类名）。</li><li><code>:%L</code>：表示行号，即在代码中的行数。</li><li><code>- %m%n</code>：表示日志消息和换行符。</li></ol></li></ol></blockquote></li></ul></li><li><p>在Netty中使用Log4j：在Netty的代码中，使用Log4j来记录日志。可以通过创建一个<code>Logger</code>对象，并使用其打印日志的方法来实现。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. TCP 粘包和拆包现象实例</title>
    <link href="/2022/09/06/Netty/6.%20TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2.%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E7%8E%B0%E8%B1%A1%E5%AE%9E%E4%BE%8B/"/>
    <url>/2022/09/06/Netty/6.%20TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2.%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E7%8E%B0%E8%B1%A1%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP-粘包和拆包现象实例"><a href="#TCP-粘包和拆包现象实例" class="headerlink" title="TCP 粘包和拆包现象实例"></a>TCP 粘包和拆包现象实例</h2><p>在编写 Netty 程序时，如果没有做处理，就会发生粘包和拆包的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. TCP 粘包和拆包基本介绍</title>
    <link href="/2022/09/06/Netty/6.%20TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1.%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/09/06/Netty/6.%20TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1.%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>TCP 粘包和拆包基本介绍</p><ul><li><p>TCP 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 socket， 因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（Nagle 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的。</p></li><li><p>由于 TCP 无消息保护边界, 需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题, 看一张图</p></li><li><p>示意图 TCP 粘包、拆包图解</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017153738513.png" alt="image-20231017153738513"></p></li></ul><p>对图的说明: </p><p>假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以 下四种情况：</p><ul><li>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，没有粘包和拆包。</li><li>服务端一次接受到了两个数据包，D1 和 D2 粘合在一起，称之为 TCP 粘包。</li><li>服务端分两次读取到了数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容，这称之为 TCP 拆包。</li><li>服务端分两次读取到了数据包，第一次读取到了 D1 包的部分内容 D1_1，第二次读取到了 D1 包的剩余部分内容 D1_2 和完整的 D2 包，这也是TCP拆包。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. Netty启动过程源码剖析</title>
    <link href="/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/2.%20Netty%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/2.%20Netty%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Netty-启动过程源码剖析"><a href="#Netty-启动过程源码剖析" class="headerlink" title="Netty 启动过程源码剖析"></a>Netty 启动过程源码剖析</h2><p><strong>源码剖析目的</strong></p><p>用源码分析的方式走一下 Netty （服务器）的启动过程，更好的理解 Netty 的整体 设计和运行机制。 </p><p><strong>源码剖析</strong> </p><p>说明： </p><ul><li>源码需要剖析到 Netty 调用 doBind 方法， 追踪到 NioServerSocketChannel 的 doBind</li><li>并且要 Debug 程序到 NioEventLoop 类的run代码，无限循环，在服务器端运行。</li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231017161946576.png" alt="image-20231017161946576"></p><h3 id="源码剖析过程"><a href="#源码剖析过程" class="headerlink" title="源码剖析过程"></a>源码剖析过程</h3>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. TCP 粘包和拆包解决方案</title>
    <link href="/2022/09/06/Netty/6.%20TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/3.%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2022/09/06/Netty/6.%20TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/3.%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP-粘包和拆包解决方案"><a href="#TCP-粘包和拆包解决方案" class="headerlink" title="TCP 粘包和拆包解决方案"></a>TCP 粘包和拆包解决方案</h2><ul><li><p>使用自定义协议 + 编解码器 来解决</p></li><li><p>关键就是要解决服务器端每次读取数据长度的问题, 这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 TCP 粘包、拆包 。</p></li></ul><p>编解码器是为了传输。</p><blockquote><p>  文心一言：</p><p>  自定义协议可以通过以下方式解决粘包拆包问题：</p><ol><li>消息长度固定：在自定义协议中，可以约定每个消息的长度是固定的。接收方在接收到消息后，根据约定的长度进行解析，即可避免粘包和拆包问题。</li><li>消息头部包含长度信息：在自定义协议中，可以在每个消息的头部添加一个长度字段，表示该消息的长度。接收方在接收到消息后，先读取头部中的长度信息，再根据长度解析消息，即可避免粘包和拆包问题。</li><li>使用分隔符：在自定义协议中，可以约定一个特殊的分隔符，用于区分不同的消息。接收方在接收到消息后，根据分隔符进行解析，即可将不同的消息分离开来。</li></ol><p>  需要注意的是，以上方法仅适用于基于字节流的通信方式，如TCP&#x2F;IP通信。对于基于数据报的通信方式，如UDP通信，由于数据报本身就是独立的消息单元，因此不需要进行粘包和拆包处理。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 基本说明</title>
    <link href="/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/1.%20%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E/"/>
    <url>/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/1.%20%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><p>在 io.netty.example 包下，有很多 Netty 源码案例，可以用来分析。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. ChannelPipeline 调度 handler 的源码剖析</title>
    <link href="/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/5.%20ChannelPipeline%20%E8%B0%83%E5%BA%A6%20handler%20%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/5.%20ChannelPipeline%20%E8%B0%83%E5%BA%A6%20handler%20%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. Netty 接受请求过程源码剖析</title>
    <link href="/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/3.%20Netty%20%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/3.%20Netty%20%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. Pipeline Handler HandlerContext 创建源码剖析</title>
    <link href="/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/4.%20Pipeline%20Handler%20HandlerContext%20%E5%88%9B%E5%BB%BA%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/4.%20Pipeline%20Handler%20HandlerContext%20%E5%88%9B%E5%BB%BA%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.  Netty 心跳(heartbeat)服务源码剖析</title>
    <link href="/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/6.%20%20Netty%20%E5%BF%83%E8%B7%B3(heartbeat)%E6%9C%8D%E5%8A%A1%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/6.%20%20Netty%20%E5%BF%83%E8%B7%B3(heartbeat)%E6%9C%8D%E5%8A%A1%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. Netty 核心组件 EventLoop 源码剖析</title>
    <link href="/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/7.%20Netty%20%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%20EventLoop%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/7.%20Netty%20%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%20EventLoop%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. handler 中加入线程池和 Context 中添加线程池的源码剖析</title>
    <link href="/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/8.%20handler%20%E4%B8%AD%E5%8A%A0%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%20Context%20%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2022/09/06/Netty/7.%20Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/8.%20handler%20%E4%B8%AD%E5%8A%A0%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%20Context%20%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 6. Z字变换</title>
    <link href="/2022/03/28/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%206.%20Z%E5%AD%97%E5%8F%98%E6%8D%A2/"/>
    <url>/2022/03/28/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%206.%20Z%E5%AD%97%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><p>L C I R<br>E T O E S I I G<br>E D H N</p><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zigzag-conversionhttps://leetcode-cn.com/problems/zigzag-conversion">https://leetcode-cn.com/problems/zigzag-conversionhttps://leetcode-cn.com/problems/zigzag-conversion</a></p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入: s &#x3D; “LEETCODEISHIRING”, numRows &#x3D; 3<br>输出: “LCIRETOESIIGEDHN”</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入: s &#x3D; “LEETCODEISHIRING”, numRows &#x3D; 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:<br>L D R<br>E O E I I<br>E C I H N<br>T S G</p><h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><ol><li>一行或两行可以直接返回</li><li>其余情况先从上往下填满，然后向右上方向填满，重复此步骤</li><li>加起来，toString()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s, int numRows</span>) &#123;<br>        <span class="hljs-keyword">if</span>(numRows &lt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>    &#125;<br>        char[][] chs = <span class="hljs-keyword">new</span> char[numRows][s.<span class="hljs-title function_">length</span>()];<br>        int row = <span class="hljs-number">0</span>,col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-title function_">length</span>();)&#123;<br>            <span class="hljs-keyword">while</span>(row &lt; numRows &amp;&amp; i&lt;s.<span class="hljs-title function_">length</span>())<br>            &#123;<br>                chs[row][col] = s.<span class="hljs-title function_">charAt</span>(i++);<br>                row++;<br>            &#125;<br>            row--;<br>            <span class="hljs-keyword">while</span>(row &gt;= <span class="hljs-number">1</span> &amp;&amp; i&lt;s.<span class="hljs-title function_">length</span>()) &#123;<br>                chs[--row][++col] = s.<span class="hljs-title function_">charAt</span>(i++);<br>            &#125;<br>            row++;<br>        &#125;<br>        <span class="hljs-title class_">StringBuilder</span> stringBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;numRows; i++)&#123;<br>            <span class="hljs-keyword">for</span>(int j=<span class="hljs-number">0</span>; j&lt; chs[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(chs[i][j] != <span class="hljs-number">0</span>) &#123;<br>                    stringBuilder.<span class="hljs-title function_">append</span>(chs[i][j]);<br>            &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stringBuilder.<span class="hljs-title function_">toString</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK新特性</title>
    <link href="/2022/03/06/JavaSE/JDK%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/03/06/JavaSE/JDK%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2022/03/06/JavaSE/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/06/JavaSE/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Java 学习</p><p>Java8新特性</p><p>哈希表默认大小：16</p><p>hash碰撞：生成链表，后来的作为链表头，之前的后移。</p><p>HashMap提供加载因子：默认0.75-&gt;当元素到达现有hash表的75%时进行扩容。扩容后链表中的每个元素重新进行哈希运算，置入新地址中。</p><p>变红黑树：某一个碰撞个数大于8，与此同时，总容量大于64，会将链表转换为红黑树</p><p>好处：除了添加以外的操作效率都比链表高。扩容以后重排序不需要哈希算法就可以重新运算出新的位置：原来哈希表的总长度+当前所在的位置</p><p>ConcurrentHashMap：</p><p>7并发级别（ConcurrentLevel）默认：16</p><p>8 CAS（无锁）算法 ： 链表+红黑树，效率提高了</p><p>方法区属于堆中永久区（PremGen）的一部分</p><p>永久区几乎不会垃圾回收机制回收（回收条件比较苛刻）</p><h3 id="Date-2021-11-30"><a href="#Date-2021-11-30" class="headerlink" title="Date 2021.11.30"></a>Date 2021.11.30</h3><ol><li>可变参数类型：参数写为：类型…参数名  例： String…strs</li><li>getClass()  得到 class[ I  ,[ 表示数组，I表示int类型</li><li>使用可变参数列表，不依赖自动包装机制，而是使用基本类型，应尽量避免使用可变参数列表。</li><li>初始化在Java中有至关重要的地位。</li><li>一个编译单元，即.java文件，只能有一个public类，那么包之外是看不见.java文件中的其他类的。</li><li>Java包的命名规则全部使用小写字母。</li><li>package和import是将单一的全局命名空间分隔开，使得无论多少人使用和编写类，都不会出现命名冲突。</li></ol><h3 id="Date-2021-12-01"><a href="#Date-2021-12-01" class="headerlink" title="Date 2021.12.01"></a>Date 2021.12.01</h3><ol><li><p>classpath可以包含多个可供选择的查询路径，通过分号隔开。在使用jar文件时，必须在类路径中把jar文件实际名称写清楚。</p></li><li><p>如果导入的类库有重复部分，只要不写这些重复的就没问题。</p></li><li><p>可以不import，直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.<span class="hljs-type">Vector</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Vector();<br></code></pre></td></tr></table></figure></li><li><p>定制工具库： classpath设置搜索路径（将工具库的路径放进去），其他类使用工具库时，导入工具库所在的包。</p></li><li><p>无权限修饰符  &#x3D;&#x3D; 包访问权限</p></li><li><p>继承而来的类可以访问public、protected 。 （extends：继承）</p></li><li><p>类不可以设置为private、protected。(内部类除外)</p></li></ol><h3 id="Date-2021-12-02"><a href="#Date-2021-12-02" class="headerlink" title="Date 2021.12.02"></a>Date 2021.12.02</h3><ol><li>Java会自动在导出类的构造器中插入对基类的构造器。（且在导出构造器的最前面）（super：超类）</li><li>编译器强制初始化基类，但不监督将成员对象初始化。</li><li>确保正确清理：finally 。以防异常出现。</li><li>清理动作同生成顺序相反，通常这就要求基类元素仍然存在。</li><li>垃圾回收器可能永远也不会被调用，且就算被调用，顺序也不一定。</li><li>@override 的存在可以防止程序员意外重载。</li><li>is a 继承；has a 组合。</li><li>finally修饰对象，使引用指向不变，即不能重新指向其他对象，但对象自身可以修改。</li><li>Java不提供使任何对象恒定不变的途径（但是可以自己编写实现）。数组也是对象。</li><li>带有恒定初始值的final static基本类型全用大写字母命名。</li><li>static的属性在装载时被初始化，不是每次创建新对象都初始化。</li><li>Java允许生成“空白final”。（指声明为final，但是又没有给定初值的域）必须在域的定义处或者每个构造器中用表达式对final进行赋值，这就是final域在使用前总是被初始化的原因所在。</li><li>final参数：可以将参数声明为final，无法在方法内部更改参数引用所指向的对象。主要用来向匿名内部类传递数据。</li><li>final方法。使用final方法的两个原因<ol><li>把方法锁定，以防止任何继承类修改它的含义。</li><li>效率。转为内嵌调用。方法调用机制：将参数压入栈，跳至方法代码外并执行，然后跳回并清理栈中的参数，处理返回值。如果一个方法很大，那么可能看不到内嵌带来的任何性能提高（程序代码膨胀），甚至效率可能反而降低。在最近的版本中效率问题交给编译器和JVM去处理，只有在想要明确禁止覆盖时，才会将方法设置为final的。</li></ol></li><li>一般来说，类的代码在初次使用时才加载。这里指的是加载发生于创建类的第一个对象时，但是当访问static域或static方法时，也会发生加载。</li><li>所有的static对象和static代码段都会在加载时依程序中的顺序（定义类时的书写顺序）而依次初始化。</li><li>对象被创建时，所有的基本类型都会被设置成默认值，对象引用被设为null，这是通过将对象内存设为二进制零值而一举生成的，然后再调用构造器将成员初始化。</li></ol><ul><li><strong>parseInt(String s):</strong> 返回用十进制参数表示的整数值。</li><li><strong>parseInt(int i):</strong> 使用指定基数的字符串参数表示的整数 (基数可以是 10, 2, 8, 或 16 等进制数) 。</li></ul><h3 id="Date-2022-10-10"><a href="#Date-2022-10-10" class="headerlink" title="Date 2022.10.10"></a>Date 2022.10.10</h3><p><code>trim()</code> 方法用于删除字符串的头尾空白符。</p><p>1、<code>int indexOf(String str)</code> ：返回第一次出现的指定子字符串在此字符串中的索引。<br>2、<code>int indexOf(String str, int startIndex)</code>：从指定的索引处开始，返回第一次出现的指定子字符串在此字符串中的索引。<br>3、<code>int lastIndexOf(String str)</code> ：返回在此字符串中最右边出现的指定子字符串的索引。<br>4、<code>int lastIndexOf(String str, int startIndex)</code> ：从指定的索引处开始向后搜索，返回在此字符串中最后一次出现的指定子字符串的索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collectors.toMap(Info::getName, Info::getContent, (a, b) -&gt; b)<br></code></pre></td></tr></table></figure><p>第三个参数用在key值冲突的情况下：如果新元素产生的key在Map中已经出现过了，第三个参数就会定义解决的办法。</p><h3 id="Date-2022-10-30"><a href="#Date-2022-10-30" class="headerlink" title="Date 2022.10.30"></a>Date 2022.10.30</h3><p>@Schedule<br>cron表达式语法</p><p>[秒] [分] [小时] [日] [月] [周] [年]</p><p>特殊符号：</p><blockquote><p>‘*’：任意值，可以解为‘每’   每天&#x2F;每月</p><p>‘&#x2F;‘ ：增量     例如 0&#x2F;1 表示从第0分钟开始，每隔1分钟</p><p>‘L’  :   表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发</p></blockquote><p>设置定时任务为每天凌晨2点执行和每小时执行一次<br>每天凌晨2点 0 0 2 * * ?和每天隔一小时 0 * *&#x2F;1 * * ?</p><p>例1：每隔5秒执行一次：*&#x2F;5 * * * * ?</p><p>例2：每隔5分执行一次：0 *&#x2F;5 * * * ?</p><p>在26分、29分、33分执行一次：0 26,29,33 * * * ?</p><p>例3：每天半夜12点30分执行一次：0 30 0 * * ? （注意日期域为0不是24）</p><p>每天凌晨1点执行一次：0 0 1 * * ?</p><p>每天上午10：15执行一次： 0 15 10 ? * * 或 0 15 10 * * ? 或 0 15 10 * * ? *</p><p>每天中午十二点执行一次：0 0 12 * * ?</p><p>每天14点到14：59分，每1分钟执行一次：0 * 14 * * ?</p><p>每天14点到14：05分，每1分钟执行一次：0 0-5 14 * * ?</p><p>每天14点到14：55分，每5分钟执行一次：0 0&#x2F;5 14 * * ?</p><p>每天14点到14：55分，和18点到18点55分，每5分钟执行一次：0 0&#x2F;5 14,18 * * ?</p><p>每天18点执行一次：0 0 <strong>18</strong> * * ?</p><p>每天18点、22点执行一次：0 0 <strong>18,22</strong> * * ?</p><p>每天7点到23点，每整点执行一次：0 0 <strong>7-23</strong> * * ?</p><p>每个整点执行一次：0 0 <strong>0&#x2F;1</strong> * * ?</p><h3 id="Date-2022-10-31"><a href="#Date-2022-10-31" class="headerlink" title="Date 2022.10.31"></a>Date 2022.10.31</h3><ol><li><p>父pom和子pom关系（继承）</p><ol><li><p>如果父pom中是<code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>时，那么子pom会自动继承父pom依赖，不需要子pom去导入</p></li><li><p>如果父pom中是</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>....<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>则子pom不会自动继承父pom的依赖，除非子pom中声明。声明需要groupId和artifactId，无需给到version。一句话总结：第二种方法是用来约束子pom，若要使用，需声明。</p></li></ol></li><li><p>自定义配置怎么出现提示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注解执行器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Java中Date类的toInstant()方法用于将Date对象转换为Instant对象。在转换过程中会创建一个Instant，用于表示时间轴上与此日期相同的点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Original Date: Fri Jul <span class="hljs-number">12</span> <span class="hljs-number">06</span>:<span class="hljs-number">01</span>:<span class="hljs-number">49</span> UTC <span class="hljs-number">1996</span><br>Instant: <span class="hljs-number">1996</span>-<span class="hljs-number">07</span>-12T06:<span class="hljs-number">01</span>:<span class="hljs-number">49.</span>766Z<br></code></pre></td></tr></table></figure></li></ol><h3 id="Date-2022-11-15"><a href="#Date-2022-11-15" class="headerlink" title="Date 2022.11.15"></a>Date 2022.11.15</h3><p><strong>布隆过滤器</strong>：</p><p>本质：一个空的2进制数组（数据全为0、1，初始全0）</p><ul><li><p>插入：一个key，经过k个hash函数运算后，得到k个值，将2进制数组对应下标的位置置为1。</p></li><li><p>查询：将key同样进行k个hash，去2进制数组比对对应下标位置的值，全为1则可能存在该key，不全为1，则一定不存在该key</p></li><li><p>删除：不能删</p></li><li><p>误判率：误以为存在的概率</p></li></ul><p>优点：</p><ul><li>不需要存储元素本身，节省空间的同时保证了数据安全。</li><li>查询速度很快。理解为O(k), k为哈希函数的个数。</li></ul><p>缺点：</p><ul><li>有一定的误判率，不适合对误判率要求较高的场景</li><li>无法删除数据</li></ul><p>应用：</p><ul><li><p>大集合中检查元素是否重复</p></li><li><p>Redis中防止缓存穿透</p><blockquote><p>缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。</p><p>解决办法：将数据源的key是否存在的信息存储到布隆过滤器中，如果布隆过滤器判定数据不存在，则不再请求数据源。</p></blockquote></li></ul><p><strong>布隆计数过滤器</strong>：待学</p><p><strong>布谷鸟过滤器</strong>：</p><p>​      初始化一个给定容量的过滤器Filter，这个容量数为2的n次方，如果不为2的n次方，内部会通将其转化为2的n次方。</p><ul><li><p>插入：</p><p>先进行一次hash，得出应当插入位置和应当插入的值。</p><p>如果这个这个位置（bucket内的4个位置均被占用）插入失败，会进行第二次hash(或者利用指纹和第一个hash位置异或？前提是确保指纹hash(fp)!&#x3D;0)，查看第二个位置能否插入。</p><p>若第二个位置插入失败，则会随机在两个位置挑选一个将其中的一个值标记为旧值，用新值覆盖旧值，旧值会在重复上面的步骤进行插入。</p><p>会对插入的值进行校验，只有当未插入过该值时才会插入成功，若过滤器中已经存在该值，会插入失败返回false。</p></li><li><p>扩容：  如果数组过小，会发生循环挤兑的情况，如果超过最大挤兑次数，进行扩容，重新计算每个指纹的位置。</p></li><li><p>查找：用两个hash函数计算，将计算结果与两个元素中的8个位置的指纹进行对比，如果对比成功则表示数据存在。先进行一次hash查询数据，若没有该值会进行第二次hash进行查询，若还是没有会返回false。</p></li><li><p>删除</p><ul><li><p>通过两次hash找到索引位置，若有该数据，将该位置数据删除。因为每个对象的指纹会存储到一个位置中，所以可以通过删除这个指纹来删除数据。</p></li><li><p>删除功能无法使用的情况：如果相同对象存储超过8个，就无法使用删除功能 <code>？？(TODO) 为什么？？</code>；如果俩数据的哈希值和指纹相同时，会出现误删除情况。</p></li></ul></li><li><p>删除全部：布谷鸟过滤器可以删除全部元素（重置数组为0）。</p></li><li><p>更新：删除后再添加新指纹。</p></li></ul><p>优点：</p><ul><li>支持删除</li><li>更节省空间（比布隆过滤器节省约40%），在错误率小于3%时，空间性能优于布隆过滤器</li><li>查询效率高（最低只需一次哈希，第二个位置可以根据第一个位置和指纹异或求得？<code>? ?</code>）</li></ul><p>缺点： </p><ul><li>插入性能差<ul><li>布谷鸟过滤器在计算哈希后可能当前位置上已经存储了指纹，这时就要将已存储的项踢到候选桶，随着桶越来越满，产生冲突的可能性越来越大，插入耗时越来越高。</li><li>布隆过滤器插入时计算好哈希直接写入位即可</li></ul></li><li>插入重复元素存在上限<ul><li>布谷鸟过滤器对已存在的值会做踢出操作，因此重复元素的插入存在上限。</li><li>布隆过滤器在插入重复元素时并没有影响，只是对已存在的位再置一遍。</li></ul></li><li>空间大小必须是2的指数（布隆过滤器不需要2的指数）</li><li>删除有问题：<ul><li>删除仅在相同哈希值被插入一次时是完美的</li><li>如果元素没有插入便进行删除，可能会出现误删除，这和假阳性率的原因相同</li><li>如果元素插入了多次，那么每次删除仅会删除一个值，你需要知道元素插入了多少次才能删除干净，或者循环运行删除直到删除失败为止</li></ul></li></ul><p>Arrays.sort(nums, (a, b) -&gt; b[1] - a[1]);    返回值大于0</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><blockquote><p>所有需要网络传输的对象，都需要实现序列化接口，通常所有的JavaBean都实现Serializable接口。</p></blockquote><blockquote><p>对象的类名、实例变量（包括基本类型、数组、对其他对象的引用）都会被序列化；方法、静态变量（又称类变量）、transient修饰的变量都不会被实例化</p><p>&#x2F;&#x2F; 对象的类型需要被序列化的原因是反序列化时需要对象的class文件?</p><p>transient 修饰 不想被序列化的属性</p></blockquote><blockquote><p>序列化对象的引用类型成员变量必须是可序列化的。</p><p>在通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。</p><p>&#x2F;&#x2F; 是否有某种读取方式是可以不按照实际写入的顺序读取？</p></blockquote><blockquote><p>单例类序列化时需要重写readResolve()方法，否则会破坏单例原则</p><p>同一对象序列化多次，只有第一次序列化为二进制流，以后都只会保存序列化编号，不会重复序列化。</p><p>建议所有可序列化的类加上serialVersionUID版本号，方便后期项目升级。</p><p>&#x2F;&#x2F; 如果单体应用是否需要版本号？</p><p>&#x2F;&#x2F; 如果非单体应用未添加版本号，重启应用是否可以解决问题</p></blockquote><blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/03/06/JavaSE/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/06/JavaSE/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谷粒商城学习笔记</title>
    <link href="/2022/01/26/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/26/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="谷粒商城学习笔记"><a href="#谷粒商城学习笔记" class="headerlink" title="谷粒商城学习笔记"></a>谷粒商城学习笔记</h1><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>初始化线程的四种方式</p><ul><li>继承Thread</li><li>实现Runnable接口</li><li>实现Callable接口 + FutureTask （可以拿到返回结果，可以处理异常）</li><li>线程池<ul><li><code>Executors.newFixedThreadPool(10);</code></li><li><code>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</code></li><li>好处：<ul><li>降低资源的消耗：重复利用已经创建好的线程，降低线程的创建和销毁带来的损耗。</li><li>提高响应速度：在有核心线程或者空闲线程未超时时，任务来时可以直接执行，无需创建新的线程。包括CPU不停的在线程中来进行切换，如果线程数较少，那么响应速度就会变快。（比如200线程，很快会被轮到）</li><li>提高线程的可管理性：1、系统资源紧张时，可以直接把非核心任务池优化掉。2、解决了无限创建线程降低系统稳定性的问题</li></ul></li></ul></li></ul><blockquote><p>继承Thread和实现Runnable：无法获取线程的运行结果</p><p>实现Callable接口 + FutureTask：可以获取线程的运算结果，但不利于控制服务器中的线程资源。可能导致服务器资源耗尽。</p><p>线程池：可以控制资源，系统的性能稳定。</p></blockquote><blockquote><p>使用线程池而不是Thread、Runnable、Callable，为了避免系统资源耗尽。</p><p><code>将所有的多线程异步任务都交给线程池</code>，让线程池执行。</p><p>当前系统中的池一般为少数个，比如两个：核心任务池和非核心任务池。(系统资源紧张时，可以直接把非核心任务池优化掉)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize, <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)<br><span class="hljs-comment">//corePoolSize: 核心线程数。[一直存在，除非设置(allowCoreThreadTimeOut)]，创建好以后就准备的线程数量，就等待来接受异步任务去执行</span><br><span class="hljs-comment">//maximumPoolSize: 最大线程数量，控制资源。</span><br><span class="hljs-comment">//keepAliveTime: 存活时间，如果当前线程数量大于核心线程数，只要线程空闲大于指定的时间(keepAliveTime)，就会释放空闲的核心线程外的线程(maximumPoolSize - corePoolSize)。</span><br><span class="hljs-comment">//unit： 时间单位</span><br><span class="hljs-comment">//BlockingQueue workQueue：阻塞队列，如果任务很多，线程都在工作，将目前多的任务放在队列里面。只要有线程空闲，就会去队列里面取出新的任务继续执行。</span><br><span class="hljs-comment">//ThreadFactory： 线程创建的工厂</span><br><span class="hljs-comment">//RejectedExecutionHandler：拒绝策略。如果队列满了，按照我们指定的拒绝策略，拒绝执行任务。</span><br><span class="hljs-comment">//AbortPolicy ：抛出运行时异常RejectedExecutionException。这种策略丢弃任务，并抛出异常。（jdk默认策略）</span><br><span class="hljs-comment">//CallerRunsPolicy : 线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</span><br><span class="hljs-comment">//DiscardOldestPolicy（弃老策略）jdk：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序。</span><br><span class="hljs-comment">//DiscardPolicy ：发生拒绝策略时，不触发任何动作</span><br></code></pre></td></tr></table></figure><h3 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h3><ol><li><p>线程池创建，准备好数量为corePoolSize的核心线程，准备接受任务。</p></li><li><p>新的任务进来，用准备好的核心线程执行</p><ol><li>核心线程满了，进来的任务放入阻塞队列中。空闲下来的核心线程会自己到阻塞队列获取任务执行。</li><li>阻塞队列满了，开新线程执行，最大开启线程的数量为maximumPoolSize<ol><li>new LinkedBlockingDeque&lt;&gt;()：默认是Integer的最大值，可能会导致内存不够</li></ol></li><li>线程数量已满，使用RejectedExecutionHandler拒绝任务。</li></ol></li><li><p>任务都执行完，有很多空闲，在到达keepAliveTime后，释放空闲的线程，但不会释放核心线程。</p><blockquote><p>面试题：一个线程池 core 7, max 20, queue 50, 100并发进来怎么分配的</p><ul><li>7个会立即执行</li><li>50个进入阻塞队列</li><li>再开13个线程进行执行</li><li>剩下的30个就使用拒绝策略</li></ul></blockquote></li></ol><h4 id="常见的四种线程池"><a href="#常见的四种线程池" class="headerlink" title="常见的四种线程池"></a>常见的四种线程池</h4><ul><li>newCachedThreadPool<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。core是0，所有的都可以回收。</li><li>newFixedThreadPool<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在对队列中等待。固定大小，core&#x3D;max。都不可回收。</li><li>newScheduledThreadPool<br>创建一个定长线程池。支持定时及周期性去执行。定时任务的线程池。</li><li>newSingleThreadExecutor<br>创建一个单线程化的线程池，他只会用唯一的工作线程来执行任务，保证所有任务。后台从队列里面获取任务，挨个执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1716. 计算力扣银行的钱</title>
    <link href="/2022/01/15/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201716.%20%E8%AE%A1%E7%AE%97%E5%8A%9B%E6%89%A3%E9%93%B6%E8%A1%8C%E7%9A%84%E9%92%B1/"/>
    <url>/2022/01/15/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201716.%20%E8%AE%A1%E7%AE%97%E5%8A%9B%E6%89%A3%E9%93%B6%E8%A1%8C%E7%9A%84%E9%92%B1/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>easy题我重拳出击！</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。</p><p>最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。在接下来每一个周一，他都会比 前一个周一 多存入 1 块钱。</p><p>给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank">https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>点击跳转题目<a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/">https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>简单的等差数列公式。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>else语句中<br>第一部分为所有完整周的原始形态的值，<br>第二部分为所有完整周的增加部分的值，<br>第三部分为剩余天数的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">totalMoney</span>(<span class="hljs-params">int n</span>) &#123;<br>    <br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">7</span>)&#123;<br>    <br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>    <br>            <span class="hljs-keyword">return</span> (n/<span class="hljs-number">7</span>*<span class="hljs-number">28</span> + <span class="hljs-number">7</span>*(n/<span class="hljs-number">7</span>-<span class="hljs-number">1</span>)*(n/<span class="hljs-number">7</span>)/<span class="hljs-number">2</span> + (<span class="hljs-number">1</span>+n-n/<span class="hljs-number">7</span>*<span class="hljs-number">7</span> + <span class="hljs-number">2</span>*(n/<span class="hljs-number">7</span>))*(n-n/<span class="hljs-number">7</span>*<span class="hljs-number">7</span>)/<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 169. 多数元素</title>
    <link href="/2022/01/13/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <url>/2022/01/13/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="多数元素leetcode169"><a href="#多数元素leetcode169" class="headerlink" title="多数元素leetcode169"></a>多数元素leetcode169</h3><h5 id="1、题目"><a href="#1、题目" class="headerlink" title="1、题目"></a>1、题目</h5><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/majority-element">https://leetcode-cn.com/problems/majority-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>点击跳转力扣169多数元素<a href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p><h5 id="2、思路"><a href="#2、思路" class="headerlink" title="2、思路"></a>2、思路</h5><p>摩尔投票算法。</p><p>个人理解：</p><p>记录第一个数为flag，初始化count为1，从第二个数开始遍历，当前元素与flag相等时，count++；<br>当前元素与flag不相等时，count–，当count为0时，记录下一个元素为flag，遍历到末尾则flag为最终结果。</p><p>原理</p><p>两两抵消，flag元素和非flag元素。当flag元素全部抵消（count&#x3D;&#x3D;0）时，下一个元素为新的flag。最终剩下的即为多数元素。</p><h5 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">vector&lt;int&gt;&amp; nums</span>) &#123;<br>    <br>        int flag = *nums.<span class="hljs-title function_">begin</span>();<br>        int count=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(auto i=nums.<span class="hljs-title function_">begin</span>()+<span class="hljs-number">1</span>; i&lt;nums.<span class="hljs-title function_">end</span>(); i++)&#123;<br>    <br>            <span class="hljs-keyword">if</span>(flag == *i)&#123;<br>    <br>                count++;<br>                <span class="hljs-keyword">if</span>(count &gt; nums.<span class="hljs-title function_">size</span>()/<span class="hljs-number">2</span>)&#123;<br>    <br>                    <span class="hljs-keyword">return</span> flag;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>                count--;<br>                <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br>    <br>                    flag = *(++i);<br>                    count = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验三、数据挖掘之决策树</title>
    <link href="/2021/04/13/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E5%AE%9E%E9%AA%8C%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2021/04/13/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E5%AE%9E%E9%AA%8C%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="实验三、数据挖掘之决策树"><a href="#实验三、数据挖掘之决策树" class="headerlink" title="实验三、数据挖掘之决策树"></a>实验三、数据挖掘之决策树</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><h4 id="1-熟悉掌握决策树的原理，"><a href="#1-熟悉掌握决策树的原理，" class="headerlink" title="1. 熟悉掌握决策树的原理，"></a>1. 熟悉掌握决策树的原理，</h4><h4 id="2-熟练掌握决策树的生成方法与过程"><a href="#2-熟练掌握决策树的生成方法与过程" class="headerlink" title="2. 熟练掌握决策树的生成方法与过程"></a>2. 熟练掌握决策树的生成方法与过程</h4><h3 id="二、实验工具"><a href="#二、实验工具" class="headerlink" title="二、实验工具"></a>二、实验工具</h3><h4 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h4><h4 id="2-sklearn"><a href="#2-sklearn" class="headerlink" title="2. sklearn"></a>2. sklearn</h4><h4 id="3-pydotplus"><a href="#3-pydotplus" class="headerlink" title="3. pydotplus"></a>3. pydotplus</h4><h3 id="三、实验简介"><a href="#三、实验简介" class="headerlink" title="三、实验简介"></a>三、实验简介</h3><p>决策树是一个非参数的监督式学习方法，主要用于分类和回归。算法的目标是通过推断数据特征，学习决策规则从而创建一个预测目标变量的模型。</p><h3 id="四、实验内容"><a href="#四、实验内容" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-自己创建至少2个向量，每个向量至少1个属性和1个类标号，根据向量生成决策树，并利用该决策树进行预测。如："><a href="#1-自己创建至少2个向量，每个向量至少1个属性和1个类标号，根据向量生成决策树，并利用该决策树进行预测。如：" class="headerlink" title="1. 自己创建至少2个向量，每个向量至少1个属性和1个类标号，根据向量生成决策树，并利用该决策树进行预测。如："></a>1. 自己创建至少2个向量，每个向量至少1个属性和1个类标号，根据向量生成决策树，并利用该决策树进行预测。如：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> tree<br>X = [[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>], [<span class="hljs-number">15</span>, <span class="hljs-number">17</span>],[<span class="hljs-number">23</span>,<span class="hljs-number">21</span>],[<span class="hljs-number">50</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">34</span>]]<br>Y = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>clf = tree.<span class="hljs-title class_">DecisionTreeClassifier</span>()<br>clf = clf.<span class="hljs-title function_">fit</span>(X, Y)<br><br>clf.<span class="hljs-title function_">predict</span>([[<span class="hljs-number">22.</span>, <span class="hljs-number">22.</span>]])<br>clf.<span class="hljs-title function_">predict_proba</span>([[<span class="hljs-number">22.</span>, <span class="hljs-number">22.</span>]])       #计算属于每个类的概率<br></code></pre></td></tr></table></figure><p>要求根据要求随机生成数据，并构建决策树，并举例预测。</p><h4 id="2-对鸢尾花数据构建决策树，"><a href="#2-对鸢尾花数据构建决策树，" class="headerlink" title="2. 对鸢尾花数据构建决策树，"></a>2. 对鸢尾花数据构建决策树，</h4><p>(1) 调用数据的方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">datasets</span> <span class="hljs-keyword">import</span> load_iris<br>iris = <span class="hljs-title function_">load_iris</span>()# 从sklearn 数据集中获取鸢尾花数据。<br></code></pre></td></tr></table></figure><p>(2) 利用sklearn中的决策树方法对鸢尾花数据建立决策树<br>(3) 为了能够直观看到建好的决策树，安装 pydotplus, 方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">pip install pydotplus<br></code></pre></td></tr></table></figure><p>pydotplus使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> pydotplus #引入pydotplus<br>dot_data = tree.<span class="hljs-title function_">export_graphviz</span>(clf, out_file=<span class="hljs-title class_">None</span>) <br>graph = pydotplus.<span class="hljs-title function_">graph_from_dot_data</span>(dot_data) <br>graph.<span class="hljs-title function_">write_pdf</span>(<span class="hljs-string">&quot;iris.pdf&quot;</span>)#将图写成pdf文件<br></code></pre></td></tr></table></figure><h3 id="五、实验总结（写出本次实验的收获，遇到的问题等）"><a href="#五、实验总结（写出本次实验的收获，遇到的问题等）" class="headerlink" title="五、实验总结（写出本次实验的收获，遇到的问题等）"></a>五、实验总结（写出本次实验的收获，遇到的问题等）</h3><h4 id="1、自己创建两个变量，建立决策树，并进行预测"><a href="#1、自己创建两个变量，建立决策树，并进行预测" class="headerlink" title="1、自己创建两个变量，建立决策树，并进行预测"></a>1、自己创建两个变量，建立决策树，并进行预测</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> tree<br>X = [[<span class="hljs-number">20</span>, <span class="hljs-number">21</span>], [<span class="hljs-number">22</span>, <span class="hljs-number">23</span>]]<br>Y = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>clf = tree.<span class="hljs-title class_">DecisionTreeClassifier</span>()<br>clf = clf.<span class="hljs-title function_">fit</span>(X, Y)<br><br><span class="hljs-title function_">print</span>(clf.<span class="hljs-title function_">predict</span>([[<span class="hljs-number">22.</span>, <span class="hljs-number">22.</span>]]))<br><span class="hljs-title function_">print</span>(clf.<span class="hljs-title function_">predict_proba</span>([[<span class="hljs-number">22.</span>, <span class="hljs-number">22.</span>]]))     #计算属于每个类的概率<br></code></pre></td></tr></table></figure><p><img src="/../images/e15c7344-c604-4531-bd24-ab95429982c7.png" alt="image.png"></p><h4 id="2、对鸢尾花数据构建决策树，并通过pydotplus，将决策树生成为pdf文件。"><a href="#2、对鸢尾花数据构建决策树，并通过pydotplus，将决策树生成为pdf文件。" class="headerlink" title="2、对鸢尾花数据构建决策树，并通过pydotplus，将决策树生成为pdf文件。"></a>2、对鸢尾花数据构建决策树，并通过pydotplus，将决策树生成为pdf文件。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">datasets</span> <span class="hljs-keyword">import</span> load_iris<br><span class="hljs-keyword">import</span> pydotplus #引入pydotplus<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> tree<br><br>iris = <span class="hljs-title function_">load_iris</span>()# 获取鸢尾花数据。<br><br>mode = tree.<span class="hljs-title class_">DecisionTreeClassifier</span>()<br><br>clf = mode.<span class="hljs-title function_">fit</span>(iris.<span class="hljs-property">data</span>, iris.<span class="hljs-property">target</span>)<br><br>dot_data = tree.<span class="hljs-title function_">export_graphviz</span>(clf, out_file=<span class="hljs-title class_">None</span>)<br>graph = pydotplus.<span class="hljs-title function_">graph_from_dot_data</span>(dot_data)<br>graph.<span class="hljs-title function_">write_pdf</span>(<span class="hljs-string">&quot;iris.pdf&quot;</span>)#将图写成pdf文件<br></code></pre></td></tr></table></figure><p><img src="/../images/95514db3-7533-4fa8-9391-e5a61761f576.png" alt="image.png"></p><h4 id="3、根据给的数据集自己编写决策树构建程序"><a href="#3、根据给的数据集自己编写决策树构建程序" class="headerlink" title="3、根据给的数据集自己编写决策树构建程序"></a>3、根据给的数据集自己编写决策树构建程序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">#  X 每个数组包括 <br>#<span class="hljs-title class_">Refund</span>yes = <span class="hljs-number">1</span>       no=<span class="hljs-number">0</span>,<br>#<span class="hljs-title class_">Marital</span> <span class="hljs-title class_">Status</span>single = <span class="hljs-number">0</span>    married = <span class="hljs-number">1</span>    divorce = <span class="hljs-number">2</span>，<br>#<span class="hljs-title class_">Taxable</span> <span class="hljs-title class_">Income</span>&lt;80k = <span class="hljs-number">0</span>      &gt;=<span class="hljs-number">80</span> = <span class="hljs-number">1</span>、<br>#<span class="hljs-title class_">Cheat</span>yes = <span class="hljs-number">1</span>       no = <span class="hljs-number">0</span><br><br>X = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>]<br><br>Y = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br><br>mode = tree.<span class="hljs-title class_">DecisionTreeClassifier</span>()<br><br>clf = mode.<span class="hljs-title function_">fit</span>(X, Y)<br><br>dot_data = tree.<span class="hljs-title function_">export_graphviz</span>(clf, out_file=<span class="hljs-title class_">None</span>)<br>graph = pydotplus.<span class="hljs-title function_">graph_from_dot_data</span>(dot_data)<br>graph.<span class="hljs-title function_">write_pdf</span>(<span class="hljs-string">&quot;fyy.pdf&quot;</span>)#将图写成pdf文件<br></code></pre></td></tr></table></figure><p><img src="/../images/0379c3ce-7c81-4fd0-878a-6c4b3686c8eb.png" alt="image.png"></p><h3 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h3><ul><li>学会了使用<br>tree.DecisionTreeClassifier()方法<br>tree.DecisionTreeClassifier().fit（）方法<br>tree.export_graphviz()方法，<br>pydotplus.graph_from_dot_data()方法等等。</li><li>成功使用鸢尾花数据生成决策树。</li><li>成功利用pydotplus生成pdf文件。</li><li>自己写构建决策树的算法还有一点问题，主要是逻辑比较复杂，有点弄不明白。</li><li>对决策树的算法有了更深的了解。</li></ul>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其它</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win10在VMware中安装Ubuntu18.04.5</title>
    <link href="/2021/04/09/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/Win10%E5%9C%A8VMware%E4%B8%AD%E5%AE%89%E8%A3%85Ubuntu18.04.5/"/>
    <url>/2021/04/09/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/Win10%E5%9C%A8VMware%E4%B8%AD%E5%AE%89%E8%A3%85Ubuntu18.04.5/</url>
    
    <content type="html"><![CDATA[<h5 id="首先安装VMware"><a href="#首先安装VMware" class="headerlink" title="首先安装VMware"></a>首先安装VMware</h5><h5 id="其次下载Ubuntu18-04-5的iso磁盘。"><a href="#其次下载Ubuntu18-04-5的iso磁盘。" class="headerlink" title="其次下载Ubuntu18.04.5的iso磁盘。"></a>其次下载Ubuntu18.04.5的iso磁盘。</h5><p><strong>没有图片的步骤都选择默认的：</strong><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543082.png" alt="在这里插入图片描述"></p><p>安装完虚拟机之后，编辑虚拟机设置。选择硬件的CD&#x2F;DVD<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543083.png" alt="在这里插入图片描述"></p><h5 id="开启虚拟机"><a href="#开启虚拟机" class="headerlink" title="开启虚拟机"></a>开启虚拟机</h5><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543084.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543085.png" alt="在这里插入图片描述"><br>「正常安装」将安装所有应用程序，包括网络浏览器、办公套件、游戏和媒体播放器。 如果您想要设置完整的桌面，请选择「正常安装」。 如果您只想要最小化的系统，有 Web 浏览器和基本实用程序，请选择「最小安装」。<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543086.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543087.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543088.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543089.png" alt="在这里插入图片描述"><br>选择自己的时区<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543090.png" alt="在这里插入图片描述"><br>输入自己的信息后，选择继续<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543091.png" alt="在这里插入图片描述"><br>此时需要等待系统安装一段时间。<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543092.png" alt="在这里插入图片描述"></p><p>安装完，就可以使用Ubuntu系统啦。</p><p>如果有帮助到你，非常荣幸。</p><p>如果大家有心情的话，鼓励一下我也可以的（我是穷逼大学生）。😁<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543093.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543094.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其它</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL命令</title>
    <link href="/2021/04/06/DB/SQL%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/06/DB/SQL%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>限制结果数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">.limit(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>根据条件排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">.sort(&#123;send_date: <span class="hljs-number">-1</span>&#125;)<br></code></pre></td></tr></table></figure><p>执行详情</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">.explain(<span class="hljs-string">&#x27;executionStats&#x27;</span>)<br></code></pre></td></tr></table></figure><p>多条件取交集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;$<span class="hljs-keyword">and</span>:[&#123;&#125;,&#123;&#125;]&#125;<br></code></pre></td></tr></table></figure><p>存在某属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;GPSX0:&#123;$<span class="hljs-keyword">exists</span>:<span class="hljs-literal">true</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>指定字段是否显示(默认0，_id默认为1)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find(<br>    &#123;&#125;,<br>    &#123; user_id: <span class="hljs-number">1</span>, status: <span class="hljs-number">1</span> &#125;<br>) <br></code></pre></td></tr></table></figure><p>曾用命令记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.result_msgv1.find(&#123;GLIDERID_IRID:<span class="hljs-number">162</span>&#125;).sort(&#123;send_date: <span class="hljs-number">-1</span>&#125;).limit(<span class="hljs-number">1</span>).explain(<span class="hljs-string">&#x27;executionStats&#x27;</span>);<br><br>db.result_msgv1.find(&#123;$<span class="hljs-keyword">and</span>:[&#123;GLIDERID_IRID:<span class="hljs-number">162</span>&#125;,&#123;GPSX0:&#123;$<span class="hljs-keyword">exists</span>:<span class="hljs-literal">true</span>&#125;&#125;,&#123;GPSY0:&#123;$<span class="hljs-keyword">exists</span>:<span class="hljs-literal">true</span>&#125;&#125;]&#125;).sort(&#123;send_date: <span class="hljs-number">-1</span>&#125;).limit(<span class="hljs-number">1</span>).explain(<span class="hljs-string">&#x27;executionStats&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO基础知识</title>
    <link href="/2021/04/06/IO/Java%20IO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/06/IO/Java%20IO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="IO-流简介"><a href="#IO-流简介" class="headerlink" title="IO 流简介"></a>IO 流简介</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h3><p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p><p><code>InputStream</code> 常用方法：</p><ul><li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li><li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li><li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li><li><code>available()</code>：返回输入流中可以读取的字节数。</li><li><code>close()</code>：关闭输入流释放相关的系统资源。</li></ul><p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p><ul><li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li><li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li><li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li></ul><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><p><code>FileInputStream</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Number of remaining bytes:&quot;</span><br>            + fis.available());<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> fis.skip(<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;The actual number of bytes skipped:&quot;</span> + skip);<br>    System.out.print(<span class="hljs-string">&quot;The content read from file:&quot;</span>);<br>    <span class="hljs-keyword">while</span> ((content = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，一般我们是不会直接单独使用 <code>FileInputStream</code> ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流）来使用。</p><p>像下面这段代码在我们的项目中就比较常见，我们通过 <code>readAllBytes()</code> 读取输入流所有字节并将其直接赋值给一个 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br><span class="hljs-comment">// 读取文件的内容并复制到 String 对象中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufferedInputStream.readAllBytes());<br>System.out.println(result);<br></code></pre></td></tr></table></figure><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br><span class="hljs-comment">//必须将fileInputStream作为构造参数才能使用</span><br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dataInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(fileInputStream);<br><span class="hljs-comment">//可以读取任意具体的类型数据</span><br>dataInputStream.readBoolean();<br>dataInputStream.readInt();<br>dataInputStream.readUTF();<br></code></pre></td></tr></table></figure><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;object.data&quot;</span>));<br><span class="hljs-type">MyClass</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> (MyClass) input.readObject();<br>input.close();<br></code></pre></td></tr></table></figure><p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p><h3 id="OutputStream（字节输出流）"><a href="#OutputStream（字节输出流）" class="headerlink" title="OutputStream（字节输出流）"></a>OutputStream（字节输出流）</h3><p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p><p><code>OutputStream</code> 常用方法：</p><ul><li><code>write(int b)</code>：将特定字节写入输出流。</li><li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li><li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li><li><code>close()</code>：关闭输出流释放相关的系统资源。</li></ul><p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p><p><code>FileOutputStream</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-string">&quot;test&quot;</span>.getBytes();<br>    output.write(array);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace(<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code>（字节缓冲输出流，后文会讲到）来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fileOutputStream)<br></code></pre></td></tr></table></figure><p><strong><code>DataOutputStream</code></strong> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileOutputStream</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输出流</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;out.txt&quot;</span>);<br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dataOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(fileOutputStream);<br><span class="hljs-comment">// 输出任意数据类型</span><br>dataOutputStream.writeBoolean(<span class="hljs-literal">true</span>);<br>dataOutputStream.writeByte(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（<code>ObjectInputStream</code>,反序列化），<code>ObjectOutputStream</code>将对象写入到输出流(<code>ObjectOutputStream</code>，序列化)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;file.txt&quot;</span>)<br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Guide哥&quot;</span>, <span class="hljs-string">&quot;JavaGuide作者&quot;</span>);<br>output.writeObject(person);<br></code></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>个人认为主要有两点原因：</p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li><li>如果我们不知道编码类型就很容易出现乱码问题。</li></ul><p>乱码问题这个很容易就可以复现，我们只需要将上面提到的 <code>FileInputStream</code> 代码示例中的 <code>input.txt</code> 文件内容改为中文即可，原代码不需要改动。可以很明显地看到读取出来的内容已经变成了乱码。</p><p>因此，I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。</p><p>常用字符编码所占字节数？</p><ul><li><code>utf8</code> :英文占 1 字节，中文占 3 字节</li><li><code>unicode</code>：任何字符都占 2 个字节</li><li><code>gbk</code>：英文占 1 字节，中文占 2 字节</li></ul><h3 id="Reader（字符输入流）"><a href="#Reader（字符输入流）" class="headerlink" title="Reader（字符输入流）"></a>Reader（字符输入流）</h3><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p><p><code>Reader</code> 常用方法：</p><ul><li><code>read()</code> : 从输入流读取一个字符。</li><li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li><li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li><li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li></ul><p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字节流转换为字符流的桥梁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader</span> &#123;<br>&#125;<br><span class="hljs-comment">// 用于读取字符文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStreamReader</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FileReader</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);) &#123;<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> fileReader.skip(<span class="hljs-number">3</span>);<br>    System.out.println(<span class="hljs-string">&quot;The actual number of bytes skipped:&quot;</span> + skip);<br>    System.out.print(<span class="hljs-string">&quot;The content read from file:&quot;</span>);<br>    <span class="hljs-keyword">while</span> ((content = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Writer（字符输出流）"><a href="#Writer（字符输出流）" class="headerlink" title="Writer（字符输出流）"></a>Writer（字符输出流）</h3><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p><p><code>Writer</code> 常用方法：</p><ul><li><code>write(int c)</code> : 写入单个字符。</li><li><code>write(char[] cbuf)</code>：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li><li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>write(String str)</code>：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li><li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li><li><code>append(char c)</code>：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li><li><code>close()</code>:关闭输出流释放相关的系统资源。</li></ul><p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符流转换为字节流的桥梁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Writer</span> &#123;<br>&#125;<br><span class="hljs-comment">// 用于写入字符到文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OutputStreamWriter</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FileWriter</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Writer</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>    output.write(<span class="hljs-string">&quot;你好，我是Guide。&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p><p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br></code></pre></td></tr></table></figure><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p><p>我使用 <code>write(int b)</code> 和 <code>read()</code> 方法，分别通过字节流和字节缓冲流复制一个 <code>524.9 mb</code> 的 PDF 文件耗时对比如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">使用缓冲流复制PDF文件总耗时:15428 毫秒<br>使用普通字节流复制PDF文件总耗时:2555062 毫秒<br></code></pre></td></tr></table></figure><p>两者耗时差别非常大，缓冲流耗费的时间是字节流的 1&#x2F;165。</p><p>测试代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy_pdf_to_another_pdf_buffer_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 记录开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统.pdf&quot;</span>));<br>         <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;<br>        <span class="hljs-type">int</span> content;<br>        <span class="hljs-keyword">while</span> ((content = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(content);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 记录结束时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy_pdf_to_another_pdf_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 记录开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统.pdf&quot;</span>);<br>         <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;<br>        <span class="hljs-type">int</span> content;<br>        <span class="hljs-keyword">while</span> ((content = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            fos.write(content);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 记录结束时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是调用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。</p><p>这次我们使用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 方法，分别通过字节流和字节缓冲流复制一个 524.9 mb 的 PDF 文件耗时对比如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">使用缓冲流复制PDF文件总耗时:695 毫秒<br>使用普通字节流复制PDF文件总耗时:989 毫秒<br></code></pre></td></tr></table></figure><p>两者耗时差别不是很大，缓冲流的性能要略微好一点点。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy_pdf_to_another_pdf_with_byte_array_buffer_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 记录开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统.pdf&quot;</span>));<br>         <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> ((len = bis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(bytes, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 记录结束时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy_pdf_to_another_pdf_with_byte_array_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 记录开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统.pdf&quot;</span>);<br>         <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> ((len = fis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>            fos.write(bytes, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 记录结束时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BufferedInputStream（字节缓冲输入流）"><a href="#BufferedInputStream（字节缓冲输入流）" class="headerlink" title="BufferedInputStream（字节缓冲输入流）"></a>BufferedInputStream（字节缓冲输入流）</h3><p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p><p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 <code>BufferedInputStream</code> 源码即可得到这个结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br>    <span class="hljs-comment">// 内部缓冲区数组</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">byte</span> buf[];<br>    <span class="hljs-comment">// 缓冲区的默认大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8192</span>;<br>    <span class="hljs-comment">// 使用默认的缓冲区大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>(in, DEFAULT_BUFFER_SIZE);<br>    &#125;<br>    <span class="hljs-comment">// 自定义缓冲区大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">super</span>(in);<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>        &#125;<br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缓冲区的大小默认为 <strong>8192</strong> 字节，可以通过 <code>BufferedInputStream(InputStream in, int size)</code> 这个构造方法来指定缓冲区的大小。</p><h3 id="BufferedOutputStream（字节缓冲输出流）"><a href="#BufferedOutputStream（字节缓冲输出流）" class="headerlink" title="BufferedOutputStream（字节缓冲输出流）"></a>BufferedOutputStream（字节缓冲输出流）</h3><p><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>))) &#123;<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-string">&quot;JavaGuide&quot;</span>.getBytes();<br>    bos.write(array);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BufferedOutputStream</code> 内部也维护了一个缓冲区，大小也是 <strong>8192</strong> 字节。</p><h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(<span class="hljs-string">&quot;Hello！&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Hello！&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>System.out</code> 实际是用于获取一个 <code>PrintStream</code> 对象，<code>print</code>方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。</p><p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterOutputStream</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Appendable</span>, Closeable &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Writer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h2><p>这里要介绍的随机访问流指的是支持随意跳转到文件的任意位置进行读写的 <code>RandomAccessFile</code> 。</p><p><code>RandomAccessFile</code> 的构造方法如下，我们可以指定 <code>mode</code>（读写模式）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomAccessFile</span><span class="hljs-params">(File file, String mode)</span><br>    <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <span class="hljs-built_in">this</span>(file, mode, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">// 私有方法</span><br><span class="hljs-comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">RandomAccessFile</span><span class="hljs-params">(File file, String mode, <span class="hljs-type">boolean</span> openAndDelete)</span>  <span class="hljs-keyword">throws</span> FileNotFoundException&#123;<br>  <span class="hljs-comment">// 省略大部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读写模式主要有下面四种：</p><ul><li><code>r</code> : 只读模式。</li><li><code>rw</code>: 读写模式</li><li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code> 同步更新对“文件的内容”的修改到外部存储设备。</li><li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code> 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li></ul><p>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p><p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p><p><code>RandomAccessFile</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;input.txt&quot;</span>), <span class="hljs-string">&quot;rw&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="hljs-string">&quot;,当前读取到的字符&quot;</span> + (<span class="hljs-type">char</span>) randomAccessFile.read() + <span class="hljs-string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());<br><span class="hljs-comment">// 指针当前偏移量为 6</span><br>randomAccessFile.seek(<span class="hljs-number">6</span>);<br>System.out.println(<span class="hljs-string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="hljs-string">&quot;,当前读取到的字符&quot;</span> + (<span class="hljs-type">char</span>) randomAccessFile.read() + <span class="hljs-string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());<br><span class="hljs-comment">// 从偏移量 7 的位置开始往后写入字节数据</span><br>randomAccessFile.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>&#125;);<br><span class="hljs-comment">// 指针当前偏移量为 0，回到起始位置</span><br>randomAccessFile.seek(<span class="hljs-number">0</span>);<br>System.out.println(<span class="hljs-string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="hljs-string">&quot;,当前读取到的字符&quot;</span> + (<span class="hljs-type">char</span>) randomAccessFile.read() + <span class="hljs-string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());<br></code></pre></td></tr></table></figure><p><code>input.txt</code> 文件内容：</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016123203978.png" alt="image-20231016123203978"></p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1<br>读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7<br>读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1<br></code></pre></td></tr></table></figure><p><code>input.txt</code> 文件内容变为 <code>ABCDEFGHIJK</code> 。</p><p><code>RandomAccessFile</code> 的 <code>write</code> 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;input.txt&quot;</span>), <span class="hljs-string">&quot;rw&quot;</span>);<br>randomAccessFile.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure><p>假设运行上面这段程序之前 <code>input.txt</code> 文件内容变为 <code>ABCD</code> ，运行之后则变为 <code>HIJK</code> 。</p><p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。断点续传就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p><p><code>RandomAccessFile</code> 可以帮助我们合并文件分片，示例代码如下：</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/io/20210609164749122.png" alt="img"></p><p><code>RandomAccessFile</code> 的实现依赖于 <code>FileDescriptor</code> (文件描述符) 和 <code>FileChannel</code> （内存映射文件）。</p>]]></content>
    
    
    <categories>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO模型</title>
    <link href="/2021/04/06/IO/Java%20IO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/04/06/IO/Java%20IO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="什么是-I-O"><a href="#什么是-I-O" class="headerlink" title="什么是 I&#x2F;O?"></a>什么是 I&#x2F;O?</h3><h4 id="计算机结构的角度解读I-O"><a href="#计算机结构的角度解读I-O" class="headerlink" title="计算机结构的角度解读I&#x2F;O"></a><strong>计算机结构的角度解读I&#x2F;O</strong></h4><p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p><p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p><p><strong>从计算机结构的视角来看的话， I&#x2F;O 描述了计算机系统与外部设备之间通信的过程。</strong></p><h4 id="应用程序的角度解读-I-O。"><a href="#应用程序的角度解读-I-O。" class="headerlink" title="应用程序的角度解读 I&#x2F;O。"></a><strong>应用程序的角度解读 I&#x2F;O。</strong></h4><p>为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p><p>平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。想要进行 IO 操作，一定是要依赖内核空间的能力。</p><p>并且，用户空间的程序不能直接访问内核空间。</p><p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p><p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p><p>常见IO有：<strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p><p><strong>从应用程序的视角来看的话，应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I&#x2F;O 调用后，会经历两个步骤：</p><ol><li>内核等待 I&#x2F;O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol><h3 id="有哪些常见的-IO-模型"><a href="#有哪些常见的-IO-模型" class="headerlink" title="有哪些常见的 IO 模型?"></a>有哪些常见的 IO 模型?</h3><p>UNIX 系统下， IO 模型一共有 5 种：<strong>同步阻塞 I&#x2F;O</strong>、<strong>同步非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。</p><h2 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I&#x2F;O)"></a>BIO (Blocking I&#x2F;O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><p>在客户端连接数量不高的情况下，是没问题的。但是，高并发情况下传统的 BIO 模型是无能为力的。所以需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p><h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking&#x2F;New I&#x2F;O)"></a>NIO (Non-blocking&#x2F;New I&#x2F;O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I&#x2F;O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><blockquote><p>  目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><strong>select 调用</strong>：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong>：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016161243160.png" alt="image-20231016161243160"><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016161256469.png" alt="image-20231016161256469"></p><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和<code>回调机制</code>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>BIO、NIO 和 AIO 对比</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016160928352.png" alt="image-20231016160928352"></p>]]></content>
    
    
    <categories>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO设计模式</title>
    <link href="/2021/04/06/IO/Java%20IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/04/06/IO/Java%20IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p><strong>装饰器（Decorator）模式</strong> 可以在不改变原有对象的情况下拓展其功能。</p><p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p><p>对于字节流来说， <code>FilterInputStream</code> （对应输入流）和<code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心，分别用于增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>我们常见的<code>BufferedInputStream</code>(字节缓冲输入流)、<code>DataInputStream</code> 等等都是<code>FilterInputStream</code> 的子类，<code>BufferedOutputStream</code>（字节缓冲输出流）、<code>DataOutputStream</code>等等都是<code>FilterOutputStream</code>的子类。</p><p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p><p><code>BufferedInputStream</code> 构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>    <span class="hljs-built_in">this</span>(in, DEFAULT_BUFFER_SIZE);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-built_in">super</span>(in);<br>    <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>    &#125;<br>    buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，<code>BufferedInputStream</code> 的构造函数其中的一个参数就是 <code>InputStream</code> 。</p><p><code>BufferedInputStream</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>))) &#123;<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> bis.skip(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span> ((content = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，你可以会想了：<strong>为啥我们直接不弄一个<code>BufferedFileInputStream</code>（字符缓冲文件输入流）呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedFileInputStream</span> <span class="hljs-variable">bfis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedFileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果 <code>InputStream</code>的子类比较少的话，这样做是没问题的。不过， <code>InputStream</code>的子类实在太多，继承关系也太复杂了。如果我们为每一个子类都定制一个对应的缓冲输入流，那岂不是太麻烦了。</p><p>如果你对 IO 流比较熟悉的话，你会发现<code>ZipInputStream</code> 和<code>ZipOutputStream</code> 还可以分别增强 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName));<br><span class="hljs-type">ZipInputStream</span> <span class="hljs-variable">zis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipInputStream</span>(bis);<br><br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(fileName));<br><span class="hljs-type">ZipOutputStream</span> <span class="hljs-variable">zipOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipOutputStream</span>(bos);<br></code></pre></td></tr></table></figure><p><code>ZipInputStream</code> 和<code>ZipOutputStream</code> 分别继承自<code>InflaterInputStream</code> 和<code>DeflaterOutputStream</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InflaterInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeflaterOutputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterOutputStream</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这也是装饰器模式很重要的一个特征，那就是可以对原始类嵌套使用多个装饰器。</p><p>为了实现这一效果，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。上面介绍到的这些 IO 相关的装饰类和原始类共同的父类是 <code>InputStream</code> 和<code>OutputStream</code>。</p><p>对于字符流来说，<code>BufferedReader</code> 可以用来增加 <code>Reader</code> （字符输入流）子类的功能，<code>BufferedWriter</code> 可以用来增加 <code>Writer</code> （字符输出流）子类的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(fileName), <span class="hljs-string">&quot;UTF-8&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><strong>适配器（Adapter Pattern）模式</strong> 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。</p><p>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong> 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。</p><p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。<code>InputStreamReader</code> 使用 <code>StreamDecoder</code> （流解码器）对字节进行解码，<strong>实现字节流到字符流的转换，</strong> <code>OutputStreamWriter</code> 使用<code>StreamEncoder</code>（流编码器）对字符进行编码，实现字符流到字节流的转换。</p><p><code>InputStream</code> 和 <code>OutputStream</code> 的子类是被适配者， <code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>是适配器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span><br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br></code></pre></td></tr></table></figure><p><code>java.io.InputStreamReader</code> 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader</span> &#123;<br><span class="hljs-comment">//用于解码的对象</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StreamDecoder sd;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">InputStreamReader</span><span class="hljs-params">(InputStream in)</span> &#123;<br>            <span class="hljs-built_in">super</span>(in);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 获取 StreamDecoder 对象</span><br>                sd = StreamDecoder.forInputStreamReader(in, <span class="hljs-built_in">this</span>, (String)<span class="hljs-literal">null</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 使用 StreamDecoder 对象做具体的读取工作</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">return</span> sd.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>java.io.OutputStreamWriter</code> 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Writer</span> &#123;<br>    <span class="hljs-comment">// 用于编码的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StreamEncoder se;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OutputStreamWriter</span><span class="hljs-params">(OutputStream out)</span> &#123;<br>        <span class="hljs-built_in">super</span>(out);<br>        <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 获取 StreamEncoder 对象</span><br>            se = StreamEncoder.forOutputStreamWriter(out, <span class="hljs-built_in">this</span>, (String)<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 使用 StreamEncoder 对象做具体的写入工作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        se.write(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="适配器模式和装饰器模式有什么区别呢？"><a href="#适配器模式和装饰器模式有什么区别呢？" class="headerlink" title="适配器模式和装饰器模式有什么区别呢？"></a><strong>适配器模式和装饰器模式有什么区别呢？</strong></h4><p><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</p><p><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 <code>StreamDecoder</code> （流解码器）和<code>StreamEncoder</code>（流编码器）就是分别基于 <code>InputStream</code> 和 <code>OutputStream</code> 来获取 <code>FileChannel</code>对象并调用对应的 <code>read</code> 方法和 <code>write</code> 方法进行字节数据的读取和写入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">StreamDecoder(InputStream in, Object lock, CharsetDecoder dec) &#123;<br>    <span class="hljs-comment">// 省略大部分代码</span><br>    <span class="hljs-comment">// 根据 InputStream 对象获取 FileChannel 对象</span><br>    ch = getChannel((FileInputStream)in);<br>&#125;<br></code></pre></td></tr></table></figure><p>适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</p><p>另外，<code>FutureTask</code> 类使用了适配器模式，<code>Executors</code> 的内部类 <code>RunnableAdapter</code> 实现属于适配器，用于将 <code>Runnable</code> 适配成 <code>Callable</code>。</p><p><code>FutureTask</code>参数包含 <code>Runnable</code> 的一个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-comment">// 调用 Executors 类的 callable 方法</span><br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>    <span class="hljs-built_in">this</span>.state = NEW;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Executors</code>中对应的方法和适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实际调用的是 Executors 的内部类 RunnableAdapter 的构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);<br>&#125;<br><span class="hljs-comment">// 适配器</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">final</span> Runnable task;<br>    <span class="hljs-keyword">final</span> T result;<br>    RunnableAdapter(Runnable task, T result) &#123;<br>        <span class="hljs-built_in">this</span>.task = task;<br>        <span class="hljs-built_in">this</span>.result = result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        task.run();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如</p><ul><li><code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（静态工厂）</li><li><code>Paths</code> 类的 <code>get</code> 方法创建 <code>Path</code> 对象（静态工厂）</li><li><code>ZipFileSystem</code> 类（<code>sun.nio</code>包下的类，属于 <code>java.nio</code> 相关的一些内部实现）的 <code>getPath</code> 的方法创建 <code>Path</code> 对象（简单工厂）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Files.newInputStream(Paths.get(generatorLogoPath))<br></code></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>NIO 中的文件目录监听服务使用到了观察者模式。</p><p>NIO 中的文件目录监听服务基于 <code>WatchService</code> 接口和 <code>Watchable</code> 接口。<code>WatchService</code> 属于观察者，<code>Watchable</code> 属于被观察者。</p><p><code>Watchable</code> 接口定义了一个用于将对象注册到 <code>WatchService</code>（监控服务） 并绑定监听事件的方法 <code>register</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Path</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Path&gt;, Iterable&lt;Path&gt;, Watchable&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Watchable</span> &#123;<br>        WatchKey <span class="hljs-title function_">register</span><span class="hljs-params">(WatchService watcher,</span><br><span class="hljs-params">                      WatchEvent.Kind&lt;?&gt;[] events,</span><br><span class="hljs-params">                      WatchEvent.Modifier... modifiers)</span><br>        <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>WatchService</code> 用于监听文件目录的变化，同一个 <code>WatchService</code> 对象能够监听多个文件目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 WatchService 对象</span><br><span class="hljs-type">WatchService</span> <span class="hljs-variable">watchService</span> <span class="hljs-operator">=</span> FileSystems.getDefault().newWatchService();<br><br><span class="hljs-comment">// 初始化一个被监控文件夹的 Path 类:</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;workingDirectory&quot;</span>);<br><span class="hljs-comment">// 将这个 path 对象注册到 WatchService（监控服务） 中去</span><br><span class="hljs-type">WatchKey</span> <span class="hljs-variable">watchKey</span> <span class="hljs-operator">=</span> path.register(<br>watchService, StandardWatchEventKinds...);<br></code></pre></td></tr></table></figure><p><code>Path</code> 类 <code>register</code> 方法的第二个参数 <code>events</code> （需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">WatchKey <span class="hljs-title function_">register</span><span class="hljs-params">(WatchService watcher,</span><br><span class="hljs-params">                  WatchEvent.Kind&lt;?&gt;... events)</span><br>    <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><p>常用的监听事件有 3 种：</p><ul><li>StandardWatchEventKinds.ENTRY_CREATE：文件创建。</li><li>StandardWatchEventKinds.ENTRY_DELETE : 文件删除。</li><li>StandardWatchEventKinds.ENTRY_MODIFY : 文件修改。</li></ul><p><code>register</code> 方法返回 <code>WatchKey</code> 对象，通过<code>WatchKey</code> 对象可以获取事件的具体信息比如文件目录下是创建、删除还是修改了文件、创建、删除或者修改的文件的具体名称是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">WatchKey key;<br><span class="hljs-keyword">while</span> ((key = watchService.take()) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;<br><span class="hljs-comment">// 可以调用 WatchEvent 对象的方法做一些事情比如输出事件的具体上下文信息</span><br>        &#125;<br>key.reset();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>WatchService</code> 内部是通过一个 daemon thread（守护线程）采用定期轮询的方式来检测文件的变化，简化后的源码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PollingWatchService</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractWatchService</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个 daemon thread（守护线程）轮询检测文件变化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService scheduledExecutor;<br><br>    PollingWatchService() &#123;<br>        scheduledExecutor = Executors.newSingleThreadScheduledExecutor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>                 <span class="hljs-meta">@Override</span><br>                 <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>                     <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>                     t.setDaemon(<span class="hljs-literal">true</span>);<br>                     <span class="hljs-keyword">return</span> t;<br>                 &#125;&#125;);<br>    &#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">enable</span><span class="hljs-params">(Set&lt;? extends WatchEvent.Kind&lt;?&gt;&gt; events, <span class="hljs-type">long</span> period)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>      <span class="hljs-comment">// 更新监听事件</span><br>      <span class="hljs-built_in">this</span>.events = events;<br>       <br>      <span class="hljs-comment">// 开启定期轮询</span><br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">thunk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; poll(); &#125;&#125;;<br>      <span class="hljs-built_in">this</span>.poller = scheduledExecutor.scheduleAtFixedRate(thunk, period, period, TimeUnit.SECONDS);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO核心知识</title>
    <link href="/2021/04/06/IO/Java%20NIO%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/06/IO/Java%20NIO%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="NIO-简介"><a href="#NIO-简介" class="headerlink" title="NIO 简介"></a>NIO 简介</h2><p>在传统的 Java I&#x2F;O 模型（BIO）中，I&#x2F;O 操作是以阻塞的方式进行的，这种阻塞模型在处理多个并发连接时可能会导致性能瓶颈。</p><p>Java1.4 版本引入了 <strong>NIO</strong> 。NIO 弥补了同步阻塞 I&#x2F;O 的不足，它在标准 Java 代码中提供了非阻塞、面向缓冲、基于通道的 I&#x2F;O，可以使用少量的线程来处理多个连接，大大提高了 I&#x2F;O 效率和并发。</p><p>⚠️需要注意：使用 NIO 并不一定意味着高性能，它的性能优势主要体现在高并发和高延迟的网络环境下。当连接数较少、并发程度较低或者网络传输速度较快时，NIO 的性能并不一定优于传统的 BIO 。</p><h2 id="NIO-核心组件"><a href="#NIO-核心组件" class="headerlink" title="NIO 核心组件"></a>NIO 核心组件</h2><p>NIO 主要包括以下三个核心组件：</p><ul><li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li><li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li><li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I&#x2F;O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li></ul><p>三者的关系</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016175543156.png" alt="image-20231016175543156"></p><h3 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h3><p>在传统的 BIO 中，数据的读写是面向流的， 分为字节流和字符流。</p><p>在 Java 1.4 的 NIO 库中，所有数据都是用缓冲区处理的，这是新库和之前的 BIO 的一个重要区别，有点类似于 BIO 中的缓冲流。NIO 在读取数据时，它是直接读到缓冲区中的。在写入数据时，写入到缓冲区中。 使用 NIO 在读写数据时，都是通过缓冲区进行操作。</p><p><code>Buffer</code> 的子类如下图所示。其中，最常用的是 <code>ByteBuffer</code>，它可以用来存储和操作字节数据。</p><p>Buffer 的子类</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016162106420.png" alt="image-20231016162106420"></p><p>可以将 Buffer 理解为一个数组，<code>IntBuffer</code>、<code>FloatBuffer</code>、<code>CharBuffer</code> 等分别对应 <code>int[]</code>、<code>float[]</code>、<code>char[]</code> 等。</p><p>为了更清晰地认识缓冲区，我们来简单看看<code>Buffer</code> 类中定义的四个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123;<br>    <span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>&#125;<br></code></pre></td></tr></table></figure><p>这四个成员变量的具体含义如下：</p><ol><li>容量（<code>capacity</code>）：<code>Buffer</code>可以存储的最大数据量，<code>Buffer</code>创建时设置且不可改变；</li><li>界限（<code>limit</code>）：<code>Buffer</code> 中可以读&#x2F;写数据的边界。写模式下，<code>limit</code> 代表最多能写入的数据，一般等于 <code>capacity</code>（可以通过<code>limit(int newLimit)</code>方法设置）；读模式下，<code>limit</code> 等于 Buffer 中实际写入的数据大小（所有位置都可以写，只有写的位置才可以读）。</li><li>位置（<code>position</code>）：索引。从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零。</li><li>标记（<code>mark</code>）：<code>Buffer</code>允许将位置直接定位到该标记处，这是一个可选属性；</li></ol><p>并且，上述变量满足如下的关系：<strong>0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong> 。</p><p>另外，Buffer 有读模式和写模式这两种模式，分别用于从 Buffer 中读取数据或者向 Buffer 中写入数据。Buffer 被创建之后默认是写模式，调用 <code>flip()</code> 可以切换到读模式。如果要再次切换回写模式，可以调用 <code>clear()</code> 或者 <code>compact()</code> 方法。</p><p>position 、limit 和 capacity 之前的关系</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016162411413.png" alt="image-20231016162411413"></p><p><code>Buffer</code> 对象不能通过 <code>new</code> 调用构造方法创建对象 ，只能通过静态方法实例化 <code>Buffer</code>。</p><p>以 <code>ByteBuffer</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 分配堆内存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>; <br><span class="hljs-comment">// 分配直接内存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocateDirect</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>; <br></code></pre></td></tr></table></figure><p>Buffer 最核心的两个方法：</p><ol><li><code>get</code> : 读取缓冲区的数据</li><li><code>put</code> ：向缓冲区写入数据</li></ol><p>其他的重要方法：</p><ul><li><code>flip</code> ：将缓冲区从写模式切换到读模式，它会将 <code>limit</code> 的值设置为当前 <code>position</code> 的值，将 <code>position</code> 的值设置为 0。</li><li><code>clear</code>:  清空缓冲区，将缓冲区从读模式切换到写模式，并将 <code>position</code> 的值设置为 0，将 <code>limit</code> 的值设置为 <code>capacity</code> 的值。</li></ul><p>Buffer 中数据变化的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.nio.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharBufferDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 分配一个容量为8的CharBuffer</span><br>        <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> CharBuffer.allocate(<span class="hljs-number">8</span>);<br>        System.out.println(<span class="hljs-string">&quot;初始状态：&quot;</span>); <br>        printState(buffer); <br><br>        <span class="hljs-comment">// 向buffer写入3个字符</span><br>        buffer.put(<span class="hljs-string">&#x27;a&#x27;</span>).put(<span class="hljs-string">&#x27;b&#x27;</span>).put(<span class="hljs-string">&#x27;c&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&quot;写入3个字符后的状态：&quot;</span>);<br>        printState(buffer);<br><br>        <span class="hljs-comment">// 调用flip()方法，准备读取buffer中的数据，将 position 置 0,limit 的置 3</span><br>        buffer.flip();<br>        System.out.println(<span class="hljs-string">&quot;调用flip()方法后的状态：&quot;</span>);<br>        printState(buffer);<br><br>        <span class="hljs-comment">// 读取字符</span><br>        <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123; <br>            System.out.print(buffer.get());<br>        &#125;<br><br>        <span class="hljs-comment">// 调用clear()方法，清空缓冲区，将 position 的值置为 0，将 limit 的值置为 capacity 的值</span><br>        buffer.clear();<br>        System.out.println(<span class="hljs-string">&quot;调用clear()方法后的状态：&quot;</span>);<br>        printState(buffer);<br>        <br>    &#125;<br><br>    <span class="hljs-comment">// 打印buffer的capacity、limit、position、mark的位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printState</span><span class="hljs-params">(CharBuffer buffer)</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;capacity: &quot;</span> + buffer.capacity());<br>        System.out.print(<span class="hljs-string">&quot;, limit: &quot;</span> + buffer.limit());<br>        System.out.print(<span class="hljs-string">&quot;, position: &quot;</span> + buffer.position());<br>        System.out.print(<span class="hljs-string">&quot;, mark 开始读取的字符: &quot;</span> + buffer.mark());<br>        System.out.println(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">初始状态：<br>capacity: 8, <span class="hljs-built_in">limit</span>: 8, position: 0<br><br>写入3个字符后的状态：<br>capacity: 8, <span class="hljs-built_in">limit</span>: 8, position: 3<br><br>准备读取buffer中的数据！<br><br>调用flip()方法后的状态：<br>capacity: 8, <span class="hljs-built_in">limit</span>: 3, position: 0<br><br>读取到的数据：abc<br><br>调用clear()方法后的状态：<br>capacity: 8, <span class="hljs-built_in">limit</span>: 8, position: 0   <br></code></pre></td></tr></table></figure><h3 id="Channel（通道）"><a href="#Channel（通道）" class="headerlink" title="Channel（通道）"></a>Channel（通道）</h3><p>Channel 是一个通道，它建立了与数据源（如文件、网络套接字等）之间的连接。我们可以利用它来读取和写入数据，就像打开了一条自来水管，让数据在 Channel 中自由流动。</p><p>BIO 中的流是单向的，分为各种 <code>InputStream</code>（输入流）和 <code>OutputStream</code>（输出流），数据只是在一个方向上传输。通道与流的不同之处在于通道是双向的，它可以用于读、写或者同时用于读写。</p><p>Channel 与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016190019985.png" alt="image-20231016190019985">Channel 和 Buffer之间的关系</p><p>另外，Channel 是全双工的，它可以比流更好地映射底层操作系统的 API。特别是在 UNIX 网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。</p><p>Channel子类中最常用的几种类型的通道：</p><ul><li><p><code>FileChannel</code>：文件访问通道；</p></li><li><p><code>SocketChannel</code>、<code>ServerSocketChannel</code>：TCP 通信通道；</p></li><li><p><code>DatagramChannel</code>：UDP 通信通道；</p></li></ul><p>Channel 最核心的两个方法：</p><ol><li><p><code>read</code> ：读取数据并写入到 Buffer 中。</p></li><li><p><code>write</code> ：将 Buffer 中的数据写入到 Channel 中。</p></li></ol><p> <code>FileChannel</code> 读取文件数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;/Users/guide/Documents/test_read.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)) <br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> reader.getChannel();<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>channel.read(buffer);<br></code></pre></td></tr></table></figure><h3 id="Selector（选择器）"><a href="#Selector（选择器）" class="headerlink" title="Selector（选择器）"></a>Selector（选择器）</h3><p>Selector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I&#x2F;O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行响应的 I&#x2F;O 操作。</p><p>Selector 选择器工作示意图</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016190605292.png" alt="image-20231016190605292"></p><p>一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了 <code>epoll()</code> 代替传统的 <code>select</code> 实现，所以它并没有最大连接句柄 <code>1024/2048</code> 的限制。这也就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p><p>Selector 可以监听以下四种事件类型：</p><ol><li><code>SelectionKey.OP_ACCEPT</code>：表示通道接受连接的事件，这通常用于 <code>ServerSocketChannel</code>。</li><li><code>SelectionKey.OP_CONNECT</code>：表示通道完成连接的事件，这通常用于 <code>SocketChannel</code>。</li><li><code>SelectionKey.OP_READ</code>：表示通道准备好进行读取的事件，即有数据可读。</li><li><code>SelectionKey.OP_WRITE</code>：表示通道准备好进行写入的事件，即可以写入数据。</li></ol><p><code>Selector</code>是抽象类，可以通过调用此类的 <code>open()</code> 静态方法来创建 Selector 实例。Selector 可以同时监控多个 <code>SelectableChannel</code> 的 <code>IO</code> 状况，是非阻塞 <code>IO</code> 的核心。</p><p>一个 Selector 实例有三个 <code>SelectionKey</code> 集合：</p><ol><li>所有的 <code>SelectionKey</code> 集合：代表了注册在该 Selector 上的 <code>Channel</code>，这个集合可以通过 <code>keys()</code> 方法返回。</li><li>被选择的 <code>SelectionKey</code> 集合：代表了所有可通过 <code>select()</code> 方法获取的、需要进行 <code>IO</code> 处理的 Channel，这个集合可以通过 <code>selectedKeys()</code> 返回。</li><li>被取消的 <code>SelectionKey</code> 集合：代表了所有被取消注册关系的 <code>Channel</code>，在下一次执行 <code>select()</code> 方法时，这些 <code>Channel</code> 对应的 <code>SelectionKey</code> 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。</li></ol><p>如何遍历被选择的 <code>SelectionKey</code> 集合并进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();<br><span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>    <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>            <span class="hljs-comment">// ServerSocketChannel 接收了一个新连接</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>            <span class="hljs-comment">// 表示一个新连接建立</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            <span class="hljs-comment">// Channel 有准备好的数据，可以读取</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>            <span class="hljs-comment">// Channel 有空闲的 Buffer，可以写入数据</span><br>        &#125;<br>    &#125;<br>    keyIterator.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p>Selector 还提供了一系列和 <code>select()</code> 相关的方法：</p><ul><li><p><code>int select()</code>：监控所有注册的 <code>Channel</code>，当它们中间有需要处理的 <code>IO</code> 操作时，将对应的 <code>SelectionKey</code> 加入被选择的 <code>SelectionKey</code> 集合中，该方法返回这些 <code>Channel</code> 的数量。</p></li><li><p><code>int select(long timeout)</code>：可以设置超时时长的 <code>select()</code> 操作。</p></li><li><p><code>int selectNow()</code>：执行一个立即返回的 <code>select()</code> 操作，相对于无参数的 <code>select()</code> 方法而言，<strong>该方法不会阻塞线程</strong>。</p></li><li><p><code>Selector wakeup()</code>：使一个还未返回的 <code>select()</code> 方法立刻返回。</p></li></ul><p>使用 Selector 实现网络读写的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioSelectorExample</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>      serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>      serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br>      <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>      <span class="hljs-comment">// 将 ServerSocketChannel 注册到 Selector 并监听 OP_ACCEPT 事件</span><br>      serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readyChannels</span> <span class="hljs-operator">=</span> selector.select();<br><br>        <span class="hljs-keyword">if</span> (readyChannels == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>        Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();<br><br>        <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>          <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br><br>          <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>            <span class="hljs-comment">// 处理连接事件</span><br>            <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> server.accept();<br>            client.configureBlocking(<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-comment">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span><br>            client.register(selector, SelectionKey.OP_READ);<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            <span class="hljs-comment">// 处理读事件</span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> client.read(buffer);<br><br>            <span class="hljs-keyword">if</span> (bytesRead &gt; <span class="hljs-number">0</span>) &#123;<br>              buffer.flip();<br>              System.out.println(<span class="hljs-string">&quot;收到数据：&quot;</span> +<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, bytesRead));<br>              <span class="hljs-comment">// 将客户端通道注册到 Selector 并监听 OP_WRITE 事件</span><br>              client.register(selector, SelectionKey.OP_WRITE);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytesRead &lt; <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-comment">// 客户端断开连接</span><br>              client.close();<br>            &#125;<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>            <span class="hljs-comment">// 处理写事件</span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-string">&quot;Hello, Client!&quot;</span>.getBytes());<br>            client.write(buffer);<br><br>            <span class="hljs-comment">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span><br>            client.register(selector, SelectionKey.OP_READ);<br>          &#125;<br><br>          keyIterator.remove();<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在示例中，我们创建了一个简单的服务器，监听 8080 端口，使用 Selector 处理连接、读取和写入事件。当接收到客户端的数据时，服务器将读取数据并将其打印到控制台，然后向客户端回复 “Hello, Client!”。</p><h2 id="NIO-零拷贝"><a href="#NIO-零拷贝" class="headerlink" title="NIO 零拷贝"></a>NIO 零拷贝</h2><p>零拷贝是提升 IO 操作性能的一个常用手段，像 ActiveMQ、Kafka 、RocketMQ、QMQ、Netty 等顶级开源项目都用到了零拷贝。</p><p>零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以<strong>减少上下文切换以及 CPU 的拷贝时间</strong>。也就是说，零拷贝主要解决操作系统在处理 I&#x2F;O 操作时频繁复制数据的问题。零拷贝的常见实现技术有： <code>mmap+write</code>、<code>sendfile</code>和 <code>sendfile + DMA gather copy</code> 。</p><p>下图展示了各种零拷贝技术的对比图：</p><table><thead><tr><th></th><th>CPU 拷贝</th><th>DMA 拷贝</th><th>系统调用</th><th>上下文切换</th></tr></thead><tbody><tr><td>传统方法</td><td>2</td><td>2</td><td>read+write</td><td>4</td></tr><tr><td>mmap+write</td><td>1</td><td>2</td><td>mmap+write</td><td>4</td></tr><tr><td>sendfile</td><td>1</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>sendfile + DMA gather copy</td><td>0</td><td>2</td><td>sendfile</td><td>2</td></tr></tbody></table><p>可以看出，无论是传统的 I&#x2F;O 方式，还是引入了零拷贝之后，2 次 DMA(Direct Memory Access) 拷贝是都少不了的。因为两次 DMA 都是依赖硬件完成的。零拷贝主要是减少了 CPU 拷贝及上下文的切换。</p><p>Java 对零拷贝的支持：</p><ul><li><code>MappedByteBuffer</code> 是 NIO 基于内存映射（<code>mmap</code>）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 <code>mmap</code> 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。</li><li><code>FileChannel</code> 的<code>transferTo()/transferFrom()</code>是 NIO 基于发送文件（<code>sendfile</code>）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 <code>sendfile</code>系统调用。它可以直接将文件数据从磁盘发送到网络，而不需要经过用户空间的缓冲区。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFileIntoMemory</span><span class="hljs-params">(File xmlFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(xmlFile);<br>  <span class="hljs-comment">// 创建 FileChannel 对象</span><br>  <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> fis.getChannel();<br>  <span class="hljs-comment">// FileChannle.map() 将文件映射到直接内存并返回 MappedByteBuffer 对象</span><br>  <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">mmb</span> <span class="hljs-operator">=</span> fc.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, fc.size());<br>  xmlFileBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)fc.size()];<br>  mmb.get(xmlFileBuffer);<br>  fis.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>NIO 的核心知识点，包括 NIO 的核心组件和零拷贝。</p><p>如果我们需要使用 NIO 构建网络程序的话，不建议直接使用原生 NIO，编程复杂且功能性太弱，推荐使用一些成熟的基于 NIO 的网络编程框架比如 Netty。Netty 在 NIO 的基础上进行了一些优化和扩展比如支持多种协议、支持 SSL&#x2F;TLS 等等。</p>]]></content>
    
    
    <categories>
      
      <category>NIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS</title>
    <link href="/2021/04/06/JUC/AQS/"/>
    <url>/2021/04/06/JUC/AQS/</url>
    
    <content type="html"><![CDATA[<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="AQS-是什么？"><a href="#AQS-是什么？" class="headerlink" title="AQS 是什么？"></a>AQS 是什么？</h4><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。AQS 就是一个抽象类，主要用来构建锁和同步器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p><h4 id="AQS-的原理是什么？"><a href="#AQS-的原理是什么？" class="headerlink" title="AQS 的原理是什么？"></a>AQS 的原理是什么？</h4><p>AQS 核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 在AQS中 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p><p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>线程等待队列</strong> 来完成获取资源线程的排队工作。</p><p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 共享变量，使用volatile修饰保证线程可见性</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure><p>另外，状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回同步状态的当前值</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> state;<br>&#125;<br> <span class="hljs-comment">// 设置同步状态的值</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br>     state = newState;<br>&#125;<br><span class="hljs-comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>      <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><p>以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p><p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，<code>state</code> 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code>countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后续动作。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atomic 原子类</title>
    <link href="/2021/04/06/JUC/Atomic%20%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
    <url>/2021/04/06/JUC/Atomic%20%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Atomic-原子类介绍"><a href="#Atomic-原子类介绍" class="headerlink" title="Atomic 原子类介绍"></a>Atomic 原子类介绍</h2><p>Atomic 翻译成中文是原子的意思，指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>原子类就是具有原子&#x2F;原子操作特征的类。</p><p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p><p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p><ul><li><strong>基本类型</strong> （更新基本类型）</li><li><strong>数组类型</strong> （更新数组中的某个元素）</li><li><strong>引用类型</strong></li><li><strong>对象的属性修改类型</strong></li></ul><h2 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h2><p>使用原子的方式更新基本类型</p><ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code>：布尔型原子类</li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicInteger</code> 为例子来介绍。</p><p><strong>AtomicInteger 类常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//获取当前的值，并设置新的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span><span class="hljs-comment">//获取当前的值，并自增</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndDecrement</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前的值，并自减</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span> <span class="hljs-comment">//获取当前的值，并加上预期的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> <span class="hljs-comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySet</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></code></pre></td></tr></table></figure><p><strong><code>AtomicInteger</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temvalue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>        temvalue = i.getAndSet(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i); <span class="hljs-comment">//temvalue:0;  i:3</span><br>        temvalue = i.getAndIncrement();<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i); <span class="hljs-comment">//temvalue:3;  i:4</span><br>        temvalue = i.getAndAdd(<span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i); <span class="hljs-comment">//temvalue:4;  i:9</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本数据类型原子类的优势"><a href="#基本数据类型原子类的优势" class="headerlink" title="基本数据类型原子类的优势"></a>基本数据类型原子类的优势</h3><p><strong>1、多线程环境使用原子类保证线程安全（基本数据类型）不需要加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//若要线程安全执行执行count++，需要加锁</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>                  count++;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>                  <span class="hljs-keyword">return</span> count;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>                  count.incrementAndGet();<br>        &#125;<br>       <span class="hljs-comment">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> count.get();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AtomicInteger-线程安全原理简单分析"><a href="#AtomicInteger-线程安全原理简单分析" class="headerlink" title="AtomicInteger 线程安全原理简单分析"></a>AtomicInteger 线程安全原理简单分析</h3><p><code>AtomicInteger</code> 类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br></code></pre></td></tr></table></figure><p><code>AtomicInteger</code> 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h2 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h2><p>使用原子的方式更新数组里的某个元素</p><ul><li><code>AtomicIntegerArray</code>：整型数组原子类</li><li><code>AtomicLongArray</code>：长整型数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul><p><strong><code>AtomicIntegerArray</code> 类常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//获取 index=i 位置元素的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndDecrement</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> delta)</span> <span class="hljs-comment">//获取 index=i 位置元素的值，并加上预期的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> <span class="hljs-comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></code></pre></td></tr></table></figure><p><strong><code>AtomicIntegerArray</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerArrayTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temvalue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] nums = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br>        <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            System.out.println(i.get(j));<br>        &#125;<br>        temvalue = i.getAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i);<br>        temvalue = i.getAndIncrement(<span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i);<br>        temvalue = i.getAndAdd(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h2><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</li></ul><p><strong><code>AtomicReference</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        AtomicReference &lt; Person &gt; ar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;Person&gt; ();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;SnailClimb&quot;</span>, <span class="hljs-number">22</span>);<br>        ar.set(person);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">updatePerson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Daisy&quot;</span>, <span class="hljs-number">20</span>);<br>        ar.compareAndSet(person, updatePerson);<br><br>        System.out.println(ar.get().getName());<br>        System.out.println(ar.get().getAge());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码首先创建了一个 <code>Person</code> 对象，然后把 <code>Person</code> 对象set进 <code>AtomicReference</code> 对象中，然后调用 <code>compareAndSet</code> 方法，该方法就是通过 CAS 操作设置 ar。实现原理与 <code>AtomicInteger</code> 类中的 <code>compareAndSet</code> 方法相同。运行上面的代码后的输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Daisy<br>20<br></code></pre></td></tr></table></figure><p><strong><code>AtomicStampedReference</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicStampedReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 实例化、取当前值和 stamp 值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">initialRef</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, initialStamp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">final</span> AtomicStampedReference&lt;Integer&gt; asr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(initialRef, initialStamp);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + asr.getStamp());<br><br>        <span class="hljs-comment">// compare and set</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">newReference</span> <span class="hljs-operator">=</span> <span class="hljs-number">666</span>, newStamp = <span class="hljs-number">999</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">casResult</span> <span class="hljs-operator">=</span> asr.compareAndSet(initialRef, newReference, initialStamp, newStamp);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + asr.getReference()<br>                + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + asr.getStamp()<br>                + <span class="hljs-string">&quot;, casResult=&quot;</span> + casResult);<br><br>        <span class="hljs-comment">// 获取当前的值和当前的 stamp 值</span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">currentValue</span> <span class="hljs-operator">=</span> asr.get(arr);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentStamp</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + currentValue + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + currentStamp);<br><br>        <span class="hljs-comment">// 单独设置 stamp 值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">attemptStampResult</span> <span class="hljs-operator">=</span> asr.attemptStamp(newReference, <span class="hljs-number">88</span>);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + asr.getReference()<br>                + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + asr.getStamp()<br>                + <span class="hljs-string">&quot;, attemptStampResult=&quot;</span> + attemptStampResult);<br><br>        <span class="hljs-comment">// 重新设置当前值和 stamp 值</span><br>        asr.set(initialRef, initialStamp);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + asr.getStamp());<br><br>        <span class="hljs-comment">// 不推荐使用  weakCompareAndSet</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">wCasResult</span> <span class="hljs-operator">=</span> asr.weakCompareAndSet(initialRef, newReference, initialStamp, newStamp);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + asr.getReference()<br>                + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + asr.getStamp()<br>                + <span class="hljs-string">&quot;, wCasResult=&quot;</span> + wCasResult);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">currentValue=0, currentStamp=0<br>currentValue=666, currentStamp=999, casResult=true<br>currentValue=666, currentStamp=999<br>currentValue=666, currentStamp=88, attemptStampResult=true<br>currentValue=0, currentStamp=0<br>currentValue=666, currentStamp=999, wCasResult=true<br></code></pre></td></tr></table></figure><p><strong><code>AtomicMarkableReference</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicMarkableReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 实例化、取当前值和 mark 值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">initialRef</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, initialMark = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> AtomicMarkableReference&lt;Boolean&gt; amr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(initialRef, initialMark);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="hljs-string">&quot;, currentMark=&quot;</span> + amr.isMarked());<br><br>        <span class="hljs-comment">// compare and set</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">newReference1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>, newMark1 = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">casResult</span> <span class="hljs-operator">=</span> amr.compareAndSet(initialRef, newReference1, initialMark, newMark1);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + amr.getReference()<br>                + <span class="hljs-string">&quot;, currentMark=&quot;</span> + amr.isMarked()<br>                + <span class="hljs-string">&quot;, casResult=&quot;</span> + casResult);<br><br>        <span class="hljs-comment">// 获取当前的值和当前的 mark 值</span><br>        <span class="hljs-type">boolean</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">currentValue</span> <span class="hljs-operator">=</span> amr.get(arr);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">currentMark</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + currentValue + <span class="hljs-string">&quot;, currentMark=&quot;</span> + currentMark);<br><br>        <span class="hljs-comment">// 单独设置 mark 值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">attemptMarkResult</span> <span class="hljs-operator">=</span> amr.attemptMark(newReference1, <span class="hljs-literal">false</span>);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + amr.getReference()<br>                + <span class="hljs-string">&quot;, currentMark=&quot;</span> + amr.isMarked()<br>                + <span class="hljs-string">&quot;, attemptMarkResult=&quot;</span> + attemptMarkResult);<br><br>        <span class="hljs-comment">// 重新设置当前值和 mark 值</span><br>        amr.set(initialRef, initialMark);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="hljs-string">&quot;, currentMark=&quot;</span> + amr.isMarked());<br><br>        <span class="hljs-comment">// 不推荐使用 weakCompareAndSet</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">wCasResult</span> <span class="hljs-operator">=</span> amr.weakCompareAndSet(initialRef, newReference1, initialMark, newMark1);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + amr.getReference()<br>                + <span class="hljs-string">&quot;, currentMark=&quot;</span> + amr.isMarked()<br>                + <span class="hljs-string">&quot;, wCasResult=&quot;</span> + wCasResult);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">currentValue=null, currentMark=false<br>currentValue=true, currentMark=true, casResult=true<br>currentValue=true, currentMark=true<br>currentValue=true, currentMark=false, attemptMarkResult=true<br>currentValue=null, currentMark=false<br>currentValue=true, currentMark=true, wCasResult=true<br></code></pre></td></tr></table></figure><h2 id="对象的属性修改类型原子类"><a href="#对象的属性修改类型原子类" class="headerlink" title="对象的属性修改类型原子类"></a>对象的属性修改类型原子类</h2><p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p><ul><li><code>AtomicIntegerFieldUpdater</code>:原子更新整型字段的更新器</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段的更新器</li></ul><p>要想原子地更新对象的属性需要两步。</p><ul><li>第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</li><li>第二步，更新的对象属性必须使用 public volatile 修饰符。</li></ul><p><strong><code>AtomicIntegerFieldUpdater</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="hljs-string">&quot;age&quot;</span>);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-number">22</span>);<br>System.out.println(a.getAndIncrement(user));<span class="hljs-comment">// 22</span><br>System.out.println(a.get(user));<span class="hljs-comment">// 23</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> age;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">22<br>23<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS算法</title>
    <link href="/2021/04/06/JUC/CAS%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/06/JUC/CAS%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="CAS-算法"><a href="#CAS-算法" class="headerlink" title="CAS 算法"></a>CAS 算法</h4><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p><blockquote><p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p></blockquote><p>CAS 涉及到三个操作数：</p><ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)</li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p><p><strong>举一个简单的例子</strong>：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。</p><ol><li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li><li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li></ol><p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture</title>
    <link href="/2021/04/06/JUC/CompletableFuture/"/>
    <url>/2021/04/06/JUC/CompletableFuture/</url>
    
    <content type="html"><![CDATA[<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><h4 id="Future-类有什么用？"><a href="#Future-类有什么用？" class="headerlink" title="Future 类有什么用？"></a>Future 类有什么用？</h4><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// V 代表了Future执行的任务返回值的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">// 取消任务执行</span><br>    <span class="hljs-comment">// 成功取消返回 true，否则返回 false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br>    <span class="hljs-comment">// 判断任务是否被取消</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 判断任务是否已经执行完成</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取任务执行结果</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    <span class="hljs-comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException<br>&#125;<br></code></pre></td></tr></table></figure><p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</p><p>Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><p>下面我们来简单看看 <code>CompletableFuture</code> 类的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompletableFuture</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。</p><p><code>CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p><p><code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程的能力。</p><p><code>Future</code> 接口有 5 个方法：</p><ul><li><code>boolean cancel(boolean mayInterruptIfRunning)</code>：尝试取消执行任务。</li><li><code>boolean isCancelled()</code>：判断任务是否被取消。</li><li><code>boolean isDone()</code>：判断任务是否已经被执行完成。</li><li><code>get()</code>：等待任务执行完成并获取运算结果。</li><li><code>get(long timeout, TimeUnit unit)</code>：多了一个超时时间。</li></ul><p><code>CompletionStage</code> 接口中的方法比较多，<code>CompletableFuture</code> 的函数式能力就是这个接口赋予的。其大量使用了 Java8 引入的函数式编程。</p><h2 id="CompletableFuture-常见操作"><a href="#CompletableFuture-常见操作" class="headerlink" title="CompletableFuture 常见操作"></a>CompletableFuture 常见操作</h2><h3 id="创建-CompletableFuture"><a href="#创建-CompletableFuture" class="headerlink" title="创建 CompletableFuture"></a>创建 CompletableFuture</h3><p>常见的创建 <code>CompletableFuture</code> 对象的方法如下：</p><ol><li>通过 new 关键字。</li><li>基于 <code>CompletableFuture</code> 自带的静态工厂方法：<code>runAsync()</code>、<code>supplyAsync()</code> 。</li></ol><h4 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h4><p>通过 new 关键字创建 <code>CompletableFuture</code> 对象这种使用方式可以看作是将 <code>CompletableFuture</code> 当做 <code>Future</code> 来使用。</p><p>下面咱们来看一个简单的案例。</p><p>我们通过创建了一个结果值类型为 <code>RpcResponse&lt;Object&gt;</code> 的 <code>CompletableFuture</code>，你可以把 <code>resultFuture</code> 看作是异步运算结果的载体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>你可以通过 <code>isDone()</code> 方法来检查是否已经完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> result != <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取异步计算的结果也非常简单，直接调用 <code>get()</code> 方法即可。调用 <code>get()</code> 方法的线程会阻塞直到 <code>CompletableFuture</code> 完成运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">rpcResponse = completableFuture.get();<br></code></pre></td></tr></table></figure><p>假设在未来的某个时刻，我们得到了最终的结果。这时，我们可以调用 <code>complete()</code> 方法为其传入结果，这表示 <code>resultFuture</code> 已经被完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// complete() 方法只能调用一次，后续调用将被忽略。</span><br>resultFuture.complete(rpcResponse);<br></code></pre></td></tr></table></figure><p>如果你已经知道计算的结果的话，可以使用静态方法 <code>completedFuture()</code> 来创建 <code>CompletableFuture</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="hljs-string">&quot;hello!&quot;</span>);<br>assertEquals(<span class="hljs-string">&quot;hello!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p><code>completedFuture()</code> 方法底层调用的是带参数的 new 方法，只不过，这个方法不对外暴露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">completedFuture</span><span class="hljs-params">(U value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;U&gt;((value == <span class="hljs-literal">null</span>) ? NIL : value);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h4><p>这两个方法可以帮助我们封装计算逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span>;<br><span class="hljs-comment">// 使用自定义线程池(推荐)</span><br><span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;<br><span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable)</span>;<br><span class="hljs-comment">// 使用自定义线程池(推荐)</span><br><span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable, Executor executor)</span>;<br></code></pre></td></tr></table></figure><p><code>runAsync()</code> 方法接受的参数是 <code>Runnable</code> ，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用 <code>runAsync()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>supplyAsync()</code> 方法接受的参数是 <code>Supplier&lt;T&gt;</code> ，这也是一个函数式接口，<code>T</code> 是返回结果值的类型。当你需要异步操作且关心返回结果的时候,可以使用 <code>supplyAsync()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets a result.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a result</span><br><span class="hljs-comment">     */</span><br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>));<br>future.get();<span class="hljs-comment">// 输出 &quot;hello!&quot;</span><br>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;hello!&quot;</span>);<br>assertEquals(<span class="hljs-string">&quot;hello!&quot;</span>, future2.get());<br></code></pre></td></tr></table></figure><h3 id="处理异步结算的结果"><a href="#处理异步结算的结果" class="headerlink" title="处理异步结算的结果"></a>处理异步结算的结果</h3><p>当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：</p><ul><li><code>thenApply()</code></li><li><code>thenAccept()</code></li><li><code>thenRun()</code></li><li><code>whenComplete()</code></li></ul><p><code>thenApply()</code> 方法接受一个 <code>Function</code> 实例，用它来处理结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 沿用上一个任务的线程池</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApply</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br><br><span class="hljs-comment">//使用默认的 ForkJoinPool 线程池（不推荐）</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApplyAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(defaultExecutor(), fn);<br>&#125;<br><span class="hljs-comment">// 使用自定义线程池(推荐)</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApplyAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>thenApply()</code> 方法使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenApply(s -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>);<br>assertEquals(<span class="hljs-string">&quot;hello!world!&quot;</span>, future.get());<br><span class="hljs-comment">// 这次调用将被忽略。（为啥呢？）</span><br>future.thenApply(s -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>);<br>assertEquals(<span class="hljs-string">&quot;hello!world!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p>你还可以进行 <strong>流式调用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenApply(s -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>);<br>assertEquals(<span class="hljs-string">&quot;hello!world!nice!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p><strong>如果你不需要从回调函数中获取返回结果，可以使用 <code>thenAccept()</code> 或者 <code>thenRun()</code>。这两个方法的区别在于 <code>thenRun()</code> 不能访问异步计算的结果。</strong></p><p><code>thenAccept()</code> 方法的参数是 <code>Consumer&lt;? super T&gt;</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAccept</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(<span class="hljs-literal">null</span>, action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(defaultExecutor(), action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p>顾名思义，<code>Consumer</code> 属于消费型接口，它可以接收 1 个输入对象然后进行“消费”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;<br><br>    <span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>thenRun()</code> 的方法的参数是 <code>Runnable</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRun</span><span class="hljs-params">(Runnable action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniRunStage(<span class="hljs-literal">null</span>, action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRunAsync</span><span class="hljs-params">(Runnable action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniRunStage(defaultExecutor(), action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRunAsync</span><span class="hljs-params">(Runnable action, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniRunStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>thenAccept()</code> 和 <code>thenRun()</code> 使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture.completedFuture(<span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenApply(s -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>).thenAccept(System.out::println);<span class="hljs-comment">//hello!world!nice!</span><br><br>CompletableFuture.completedFuture(<span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenApply(s -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>).thenRun(() -&gt; System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>));<span class="hljs-comment">//hello!</span><br></code></pre></td></tr></table></figure><p><code>whenComplete()</code> 的方法的参数是 <code>BiConsumer&lt;? super T, ? super Throwable&gt;</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">whenComplete</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniWhenCompleteStage(<span class="hljs-literal">null</span>, action);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniWhenCompleteStage(defaultExecutor(), action);<br>&#125;<br><span class="hljs-comment">// 使用自定义线程池(推荐)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p>相对于 <code>Consumer</code> ， <code>BiConsumer</code> 可以接收 2 个输入对象然后进行“消费”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BiConsumer</span>&lt;T, U&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t, U u)</span>;<br><br>    <span class="hljs-keyword">default</span> BiConsumer&lt;T, U&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br><br>        <span class="hljs-keyword">return</span> (l, r) -&gt; &#123;<br>            accept(l, r);<br>            after.accept(l, r);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>whenComplete()</code> 使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;hello!&quot;</span>)<br>        .whenComplete((res, ex) -&gt; &#123;<br>            <span class="hljs-comment">// res 代表返回的结果</span><br>            <span class="hljs-comment">// ex 的类型为 Throwable ，代表抛出的异常</span><br>            System.out.println(res);<br>            <span class="hljs-comment">// 这里没有抛出异常所以为 null</span><br>            assertNull(ex);<br>        &#125;);<br>assertEquals(<span class="hljs-string">&quot;hello!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>你可以通过 <code>handle()</code> 方法来处理任务执行过程中可能出现的抛出异常的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniHandleStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handleAsync</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniHandleStage(defaultExecutor(), fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handleAsync</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniHandleStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Computation error!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello!&quot;</span>;<br>&#125;).handle((res, ex) -&gt; &#123;<br>    <span class="hljs-comment">// res 代表返回的结果</span><br>    <span class="hljs-comment">// ex 的类型为 Throwable ，代表抛出的异常</span><br>    <span class="hljs-keyword">return</span> res != <span class="hljs-literal">null</span> ? res : <span class="hljs-string">&quot;world!&quot;</span>;<br>&#125;);<br>assertEquals(<span class="hljs-string">&quot;world!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p>你还可以通过 <code>exceptionally()</code> 方法来处理异常情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future<br>        = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Computation error!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello!&quot;</span>;<br>&#125;).exceptionally(ex -&gt; &#123;<br>    System.out.println(ex.toString());<span class="hljs-comment">// CompletionException</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;world!&quot;</span>;<br>&#125;);<br>assertEquals(<span class="hljs-string">&quot;world!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p>如果你想让 <code>CompletableFuture</code> 的结果就是异常的话，可以使用 <code>completeExceptionally()</code> 方法为其赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; completableFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br><span class="hljs-comment">// ...</span><br>completableFuture.completeExceptionally(<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Calculation failed!&quot;</span>));<br><span class="hljs-comment">// ...</span><br>completableFuture.get(); <span class="hljs-comment">// ExecutionException</span><br></code></pre></td></tr></table></figure><h3 id="组合-CompletableFuture"><a href="#组合-CompletableFuture" class="headerlink" title="组合 CompletableFuture"></a>组合 CompletableFuture</h3><p>你可以使用 <code>thenCompose()</code> 按顺序链接两个 <code>CompletableFuture</code> 对象，实现异步的任务链。它的作用是将前一个任务的返回结果作为下一个任务的输入参数，从而形成一个依赖关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenCompose</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniComposeStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenComposeAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniComposeStage(defaultExecutor(), fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenComposeAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,</span><br><span class="hljs-params">    Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniComposeStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>thenCompose()</code> 方法会使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future<br>        = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>));<br>assertEquals(<span class="hljs-string">&quot;hello!world!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p>在实际开发中，这个方法还是非常有用的。比如说，task1 和 task2 都是异步执行的，但 task1 必须执行完成后才能开始执行 task2（task2 依赖 task1 的执行结果）。</p><p>和 <code>thenCompose()</code> 方法类似的还有 <code>thenCombine()</code> 方法， 它同样可以组合两个 <code>CompletableFuture</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; completableFuture<br>        = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenCombine(CompletableFuture.supplyAsync(<br>                () -&gt; <span class="hljs-string">&quot;world!&quot;</span>), (s1, s2) -&gt; s1 + s2)<br>        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>));<br>assertEquals(<span class="hljs-string">&quot;hello!world!nice!&quot;</span>, completableFuture.get());<br></code></pre></td></tr></table></figure><p><strong>那 <code>thenCompose()</code> 和 <code>thenCombine()</code> 有什么区别呢？</strong></p><ul><li><code>thenCompose()</code> 可以链接两个 <code>CompletableFuture</code> 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</li><li><code>thenCombine()</code> 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</li></ul><p>除了 <code>thenCompose()</code> 和 <code>thenCombine()</code> 之外， 还有一些其他的组合 <code>CompletableFuture</code> 的方法用于实现不同的效果，满足不同的业务需求。</p><p>例如，如果我们想要实现 task1 和 task2 中的任意一个任务执行完后就执行 task3 的话，可以使用 <code>acceptEither()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">acceptEither</span><span class="hljs-params">(</span><br><span class="hljs-params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> orAcceptStage(<span class="hljs-literal">null</span>, other, action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">acceptEitherAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> orAcceptStage(asyncPool, other, action);<br>&#125;<br></code></pre></td></tr></table></figure><p>简单举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务1开始执行，当前时间：&quot;</span> + System.currentTimeMillis());<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;任务1执行完毕，当前时间：&quot;</span> + System.currentTimeMillis());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;task1&quot;</span>;<br>&#125;);<br><br>CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务2开始执行，当前时间：&quot;</span> + System.currentTimeMillis());<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;任务2执行完毕，当前时间：&quot;</span> + System.currentTimeMillis());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;task2&quot;</span>;<br>&#125;);<br><br>task.acceptEitherAsync(task2, (res) -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务3开始执行，当前时间：&quot;</span> + System.currentTimeMillis());<br>    System.out.println(<span class="hljs-string">&quot;上一个任务的结果为：&quot;</span> + res);<br>&#125;);<br><br><span class="hljs-comment">// 增加一些延迟时间，确保异步任务有足够的时间完成</span><br><span class="hljs-keyword">try</span> &#123;<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">任务1开始执行，当前时间：1695088058520<br>任务2开始执行，当前时间：1695088058521<br>任务1执行完毕，当前时间：1695088059023<br>任务3开始执行，当前时间：1695088059023<br>上一个任务的结果为：task1<br>任务2执行完毕，当前时间：1695088059523<br></code></pre></td></tr></table></figure><p>任务组合操作<code>acceptEitherAsync()</code>会在异步任务 1 和异步任务 2 中的任意一个完成时触发执行任务 3，但是需要注意，这个触发时机是不确定的。如果任务 1 和任务 2 都还未完成，那么任务 3 就不能被执行。</p><h3 id="并行运行多个-CompletableFuture"><a href="#并行运行多个-CompletableFuture" class="headerlink" title="并行运行多个 CompletableFuture"></a>并行运行多个 CompletableFuture</h3><p>你可以通过 <code>CompletableFuture</code> 的 <code>allOf()</code>这个静态方法来并行运行多个 <code>CompletableFuture</code> 。</p><p>实际项目中，我们经常需要并行运行多个互不相关的任务，这些任务之间没有依赖关系，可以互相独立地运行。</p><p>比说我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。像这种情况我们就可以使用并行运行多个 <code>CompletableFuture</code> 来处理。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Void&gt; task1 =<br>  CompletableFuture.supplyAsync(()-&gt;&#123;<br>    <span class="hljs-comment">//自定义业务操作</span><br>  &#125;);<br>......<br>CompletableFuture&lt;Void&gt; task6 =<br>  CompletableFuture.supplyAsync(()-&gt;&#123;<br>    <span class="hljs-comment">//自定义业务操作</span><br>  &#125;);<br>......<br> CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    headerFuture.join();<br>  &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    ......<br>  &#125;<br>System.out.println(<span class="hljs-string">&quot;all done. &quot;</span>);<br></code></pre></td></tr></table></figure><p>经常和 <code>allOf()</code> 方法拿来对比的是 <code>anyOf()</code> 方法。</p><p><strong><code>allOf()</code> 方法会等到所有的 <code>CompletableFuture</code> 都运行完成之后再返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span> + rand.nextInt(<span class="hljs-number">1000</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;future1 done...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;);<br>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span> + rand.nextInt(<span class="hljs-number">1000</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;future2 done...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;efg&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>调用 <code>join()</code> 可以让程序等<code>future1</code> 和 <code>future2</code> 都运行完了之后再继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.allOf(future1, future2);<br>completableFuture.join();<br>assertTrue(completableFuture.isDone());<br>System.out.println(<span class="hljs-string">&quot;all futures done...&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">future1 done...<br>future2 done...<br>all futures done...<br></code></pre></td></tr></table></figure><p><strong><code>anyOf()</code> 方法不会等待所有的 <code>CompletableFuture</code> 都运行完成之后再返回，只要有一个执行完成即可！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(future1, future2);<br>System.out.println(f.get());<br></code></pre></td></tr></table></figure><p>输出结果可能是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">future2 done...<br>efg<br></code></pre></td></tr></table></figure><p>也可能是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">future1 done...<br>abc<br></code></pre></td></tr></table></figure><h2 id="CompletableFuture-使用建议"><a href="#CompletableFuture-使用建议" class="headerlink" title="CompletableFuture 使用建议"></a>CompletableFuture 使用建议</h2><h3 id="使用自定义线程池"><a href="#使用自定义线程池" class="headerlink" title="使用自定义线程池"></a>使用自定义线程池</h3><p><code>CompletableFuture</code> 默认使用<code>ForkJoinPool.commonPool()</code> 作为执行器，这个线程池是全局共享的，可能会被其他任务占用，导致性能下降或者饥饿。因此，建议使用自定义的线程池来执行 <code>CompletableFuture</code> 的异步任务，可以提高并发度和灵活性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>,<br>        <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br><br>CompletableFuture.runAsync(() -&gt; &#123;<br> <span class="hljs-comment">//...</span><br>&#125;, executor);<br></code></pre></td></tr></table></figure><h3 id="尽量避免使用-get"><a href="#尽量避免使用-get" class="headerlink" title="尽量避免使用 get()"></a>尽量避免使用 get()</h3><p><code>CompletableFuture</code>的<code>get()</code>方法是阻塞的，尽量避免使用。如果必须要使用的话，需要添加超时时间，否则可能会导致主线程一直等待，无法执行其他任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10_000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-comment">// 获取异步任务的返回值，设置超时时间为 5 秒</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        System.out.println(result);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>        <span class="hljs-comment">// 处理异常</span><br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码在调用 <code>get()</code> 时抛出了 <code>TimeoutException</code> 异常。这样我们就可以在异常处理中进行相应的操作，比如取消任务、重试任务、记录日志等。</p><h3 id="正确进行异常处理"><a href="#正确进行异常处理" class="headerlink" title="正确进行异常处理"></a>正确进行异常处理</h3><ul><li>使用 <code>whenComplete</code> 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。</li><li>使用 <code>exceptionally</code> 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。</li><li>使用 <code>handle</code> 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。</li><li>使用 <code>CompletableFuture.allOf</code> 方法可以组合多个 <code>CompletableFuture</code>，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复。</li></ul><h3 id="合理组合多个异步任务"><a href="#合理组合多个异步任务" class="headerlink" title="合理组合多个异步任务"></a>合理组合多个异步任务</h3><p>正确使用 <code>thenCompose()</code> 、 <code>thenCombine()</code> 、<code>acceptEither()</code>、<code>allOf()</code>、<code>anyOf() </code>等方法来组合多个异步任务，以满足实际业务的需求，提高程序执行效率。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231015211855815.png" alt="image-20231015211855815"></p><h4 id="Callable-和-Future-有什么关系？"><a href="#Callable-和-Future-有什么关系？" class="headerlink" title="Callable 和 Future 有什么关系？"></a>Callable 和 Future 有什么关系？</h4><p>我们可以通过 <code>FutureTask</code> 来理解 <code>Callable</code> 和 <code>Future</code> 之间的关系。</p><p><code>FutureTask</code> 提供了 <code>Future</code> 接口的基本实现，常用来封装 <code>Callable</code> 和 <code>Runnable</code>，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;T&gt;</span> Future<span class="hljs-attribute">&lt;T&gt;</span> submit(Callable<span class="hljs-attribute">&lt;T&gt;</span> task);<br>Future<span class="hljs-attribute">&lt;?&gt;</span> submit(Runnable task);<br></code></pre></td></tr></table></figure><p><code>FutureTask</code> 不光实现了 <code>Future</code>接口，还实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p><p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为<code>Callable</code> 对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> FutureTask(Callable&lt;V&gt; callable) &#123;<br>        <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">throw</span> new NullPointerException();<br>        <span class="hljs-keyword">this</span>.callable = callable;<br>        <span class="hljs-keyword">this</span>.state = NEW;<br>&#125;<br><span class="hljs-keyword">public</span> FutureTask(Runnable runnable, V result) &#123;<br>        <span class="hljs-comment">// 通过适配器RunnableAdapter来将Runnable对象runnable转换成Callable对象</span><br>        <span class="hljs-keyword">this</span>.callable = Executors.callable(runnable, result);<br>        <span class="hljs-keyword">this</span>.state = NEW;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FutureTask</code>相当于对<code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantReadWriteLock</title>
    <link href="/2021/04/06/JUC/ReentrantReadWriteLock/"/>
    <url>/2021/04/06/JUC/ReentrantReadWriteLock/</url>
    
    <content type="html"><![CDATA[<h3 id="ReentrantReadWriteLock-是什么？"><a href="#ReentrantReadWriteLock-是什么？" class="headerlink" title="ReentrantReadWriteLock 是什么？"></a>ReentrantReadWriteLock 是什么？</h3><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantReadWriteLock</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReadWriteLock</span>, java.io.Serializable&#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br>    Lock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>;<br>    Lock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</li><li>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</li></ul><p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p><p>和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。</p><p><code>ReentrantReadWriteLock</code> 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>    readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);<br>    writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReentrantReadWriteLock-适合什么场景？"><a href="#ReentrantReadWriteLock-适合什么场景？" class="headerlink" title="ReentrantReadWriteLock 适合什么场景？"></a>ReentrantReadWriteLock 适合什么场景？</h3><p>由于 <code>ReentrantReadWriteLock</code> 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能。</p><h3 id="线程持有读锁还能获取写锁吗？"><a href="#线程持有读锁还能获取写锁吗？" class="headerlink" title="线程持有读锁还能获取写锁吗？"></a>线程持有读锁还能获取写锁吗？</h3><ul><li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li><li>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</li></ul><h3 id="读锁为什么不能升级为写锁？"><a href="#读锁为什么不能升级为写锁？" class="headerlink" title="读锁为什么不能升级为写锁？"></a>读锁为什么不能升级为写锁？</h3><p>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</p><p>另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>StampedLock(了解)</title>
    <link href="/2021/04/06/JUC/StampedLock(%E4%BA%86%E8%A7%A3)/"/>
    <url>/2021/04/06/JUC/StampedLock(%E4%BA%86%E8%A7%A3)/</url>
    
    <content type="html"><![CDATA[<h4 id="StampedLock-是什么？"><a href="#StampedLock-是什么？" class="headerlink" title="StampedLock 是什么？"></a>StampedLock 是什么？</h4><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 <code>Conditon</code>。</p><p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StampedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>StampedLock</code> 提供了三种模式的读写控制模式：读锁、写锁和乐观读。</p><ul><li><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是不可重入的。</li><li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</li><li><strong>乐观读</strong>：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</li></ul><p>另外，<code>StampedLock</code> 还支持这三种锁在一定条件下进行相互转换 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToWriteLock</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToReadLock</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToOptimisticRead</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p><code>StampedLock</code> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是<code>StampedLock</code>不可重入的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> s, next;  <span class="hljs-comment">// bypass acquireWrite in fully unlocked case only</span><br>    <span class="hljs-keyword">return</span> ((((s = state) &amp; ABITS) == <span class="hljs-number">0L</span> &amp;&amp;<br>             U.compareAndSwapLong(<span class="hljs-built_in">this</span>, STATE, s, next = s + WBIT)) ?<br>            next : acquireWrite(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>));<br>&#125;<br><span class="hljs-comment">// 读锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state, next;  <span class="hljs-comment">// bypass acquireRead on common uncontended case</span><br>    <span class="hljs-keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;<br>             U.compareAndSwapLong(<span class="hljs-built_in">this</span>, STATE, s, next = s + RUNIT)) ?<br>            next : acquireRead(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>));<br>&#125;<br><span class="hljs-comment">// 乐观读</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">tryOptimisticRead</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> s;<br>    <span class="hljs-keyword">return</span> (((s = state) &amp; WBIT) == <span class="hljs-number">0L</span>) ? (s &amp; SBITS) : <span class="hljs-number">0L</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="StampedLock-的性能为什么更好？"><a href="#StampedLock-的性能为什么更好？" class="headerlink" title="StampedLock 的性能为什么更好？"></a>StampedLock 的性能为什么更好？</h4><p>相比于传统读写锁多出来的乐观读是<code>StampedLock</code>比 <code>ReadWriteLock</code> 性能更好的关键原因。<code>StampedLock</code> 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。</p><h4 id="StampedLock-适合什么场景？"><a href="#StampedLock-适合什么场景？" class="headerlink" title="StampedLock 适合什么场景？"></a>StampedLock 适合什么场景？</h4><p>和 <code>ReentrantReadWriteLock</code> 一样，<code>StampedLock</code> 同样适合读多写少的业务场景，可以作为 <code>ReentrantReadWriteLock</code>的替代品，性能更好。</p><p>不过，需要注意的是<code>StampedLock</code>不可重入，不支持条件变量 <code>Conditon</code>，对中断操作支持也不友好（使用不当容易导致 CPU 飙升）。如果你需要用到 <code>ReentrantLock</code> 的一些高级性能，就不太建议使用 <code>StampedLock</code> 了。</p><p>另外，<code>StampedLock</code> 性能虽好，但使用起来相对比较麻烦，一旦使用不当，就会出现生产问题。强烈建议你在使用<code>StampedLock</code> 之前，看看 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html">StampedLock 官方文档中的案例open in new window</a>。</p><h4 id="StampedLock-的底层原理了解吗？"><a href="#StampedLock-的底层原理了解吗？" class="headerlink" title="StampedLock 的底层原理了解吗？"></a>StampedLock 的底层原理了解吗？</h4><p><code>StampedLock</code> 不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。<code>StampedLock</code> 通过 CLH 队列进行线程的管理，通过同步状态值 <code>state</code> 来表示锁的状态和类型。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2021/04/06/JUC/ThreadLocal/"/>
    <url>/2021/04/06/JUC/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="ThreadLocal-有什么用？"><a href="#ThreadLocal-有什么用？" class="headerlink" title="ThreadLocal 有什么用？"></a>ThreadLocal 有什么用？</h4><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。</p><p><strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p><p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> SimpleDateFormat <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyyMMdd HHmm&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="ThreadLocal-原理了解吗？"><a href="#ThreadLocal-原理了解吗？" class="headerlink" title="ThreadLocal 原理了解吗？"></a>ThreadLocal 原理了解吗？</h4><p>从 <code>Thread</code>类源代码入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">//......</span><br>    <span class="hljs-comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p><p><code>ThreadLocal</code>类的<code>set()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//获取当前请求的线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 将需要存储的值放入到这个哈希表中</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p><p><code>ThreadLocal</code> 数据结构如下图所示：</p><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p><h4 id="ThreadLocal-内存泄露问题是怎么导致的？"><a href="#ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的？"></a>ThreadLocal 内存泄露问题是怎么导致的？</h4><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p><p><strong>弱引用介绍：</strong></p><blockquote><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2021/04/06/JUC/synchronized/"/>
    <url>/2021/04/06/JUC/synchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><blockquote><p>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</p></blockquote><blockquote><p>synchronized是非公平锁</p></blockquote><blockquote><p>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</p></blockquote><blockquote><p>锁对象不能为空，因为锁的信息都保存在对象头里</p></blockquote><h4 id="1-对象锁"><a href="#1-对象锁" class="headerlink" title="1. 对象锁"></a>1. 对象锁</h4><p>包括方法锁（默认锁对象为this，当前实例对象）和同步代码块锁（自己指定锁对象）</p><p><strong>代码块形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法锁形式</strong>：synchronized修饰普通方法，锁对象默认为this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-类锁"><a href="#2-类锁" class="headerlink" title="2. 类锁"></a>2. 类锁</h4><p>指的是修饰<strong>静态方法</strong>或指定锁对象为<strong>Class对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 所有线程需要的锁都是同一把</span><br>    <span class="hljs-keyword">synchronized</span>(类名.class)&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="synchronized加锁与释放锁的原理"><a href="#synchronized加锁与释放锁的原理" class="headerlink" title="synchronized加锁与释放锁的原理"></a>synchronized加锁与释放锁的原理</h3><p>每个对象拥有一个monitor计数器，使用指令控制锁计数器加1或者减1，每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候有三种情况：</p><ul><li><p>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</p></li><li><p>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加（退出时， 当计数器为0时，锁才会被释放）</p></li><li><p>这把锁已经被别的线程获取了，等待锁释放</p></li></ul><h3 id="synchronized缺陷"><a href="#synchronized缺陷" class="headerlink" title="synchronized缺陷"></a>synchronized缺陷</h3><ul><li><p>效率低： 锁的释放情况较少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设置超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时。</p></li><li><p>不够灵活：加锁和释放锁的时机单一，每个锁仅有一个单一的条件，相对而言，读写锁更加灵活</p></li><li><p>无法知道是否成功获得锁：Lock可以拿到状态</p></li></ul><p>Lock解决相应问题：</p><ul><li><code>lock()</code>: 加锁</li><li><code>unlock()</code>: 解锁</li><li><code>tryLock()</code>: 尝试获取锁，返回一个boolean值</li><li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li></ul><p>Synchronized加锁只与一个条件(是否获取锁)相关联，不灵活，后来<code>Condition与Lock的结合</code>解决了这个问题。</p><p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。</p><blockquote><p><code>ReentrantLock</code>为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。详细分析请看: <a href="">JUC锁: ReentrantLock详解</a></p></blockquote><p>synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛的使用。</p><ul><li><strong>使用Synchronized有哪些要注意的？</strong><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li></ul></li><li><strong>synchronized是公平锁吗？</strong></li></ul><p>synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="/2021/04/06/JUC/volatile/"/>
    <url>/2021/04/06/JUC/volatile/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-关键字volatile"><a href="#title-关键字volatile" class="headerlink" title="title: 关键字volatile"></a>title: 关键字volatile</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>多线程的环境下，操作系统对指令的重排序可能会导致将一个未初始化的对象引用暴露出来，为了防止实例化过程中的重排序，可以将这个对象设置为volatile类型的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数私有，禁止外部实例化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h3><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。</p><p>引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。</p><p>volatile关键字能有效的解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestVolatile</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// Thread-A</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;Thread A&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (!stop) &#123;<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; stopped&quot;</span>);<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-comment">// Thread-main</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; after 1 seconds&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        stop = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread[main,<span class="hljs-number">5</span>,main] after <span class="hljs-number">1</span> seconds<br><span class="hljs-comment">// Thread A一直在loop, 因为Thread A 由于可见性原因看不到Thread Main 已经修改stop的值</span><br></code></pre></td></tr></table></figure><p>可以看到 Thread-main 休眠1秒之后，设置 stop &#x3D; ture，但是Thread A根本没停下来，这就是可见性问题。</p><p>如果通过在stop变量前面加上volatile关键字则会真正stop。</p><p>volatile不能保证完全的原子性，只能保证单次的读&#x2F;写操作具有原子性。（本质上i++是读、写两次操作，通过AtomicInteger或者Synchronized来保证+1操作的原子性）</p><h4 id="共享的long和double变量的为什么要用volatile"><a href="#共享的long和double变量的为什么要用volatile" class="headerlink" title="共享的long和double变量的为什么要用volatile?"></a>共享的long和double变量的为什么要用volatile?</h4><p>因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读&#x2F;写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读&#x2F;写操作都具有原子性。</p><blockquote><p>目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。</p></blockquote><h3 id="volatile-的实现原理"><a href="#volatile-的实现原理" class="headerlink" title="volatile 的实现原理"></a>volatile 的实现原理</h3><h4 id="volatile-可见性实现"><a href="#volatile-可见性实现" class="headerlink" title="volatile 可见性实现"></a>volatile 可见性实现</h4><p>volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现：</p><ul><li><p>内存屏障，又称内存栅栏，是一个 CPU 指令。</p></li><li><p>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止将特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</p></li></ul><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。</p><p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，就会从内存中重读该变量数据到处理器缓存里。</p><p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p><p>总结：如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li><li>多核处理器发现本地缓存失效后，就会从内存中重读该变量数据到处理器缓存里。</li></ul><h5 id="缓存一致性之嗅探-snooping-”-协议："><a href="#缓存一致性之嗅探-snooping-”-协议：" class="headerlink" title="缓存一致性之嗅探(snooping)” 协议："></a>缓存一致性之嗅探(snooping)” 协议：</h5><p>所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是<strong>不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步</strong>。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效</p><h4 id="volatile-有序性实现"><a href="#volatile-有序性实现" class="headerlink" title="volatile 有序性实现"></a>volatile 有序性实现</h4><h5 id="volatile-的-happens-before-关系"><a href="#volatile-的-happens-before-关系" class="headerlink" title="volatile 的 happens-before 关系"></a>volatile 的 happens-before 关系</h5><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//假设线程A执行writer方法，线程B执行reader方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileExample</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        a = <span class="hljs-number">1</span>;              <span class="hljs-comment">// 1 线程A修改共享变量</span><br>        flag = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 2 线程A写volatile变量</span><br>    &#125; <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;         <span class="hljs-comment">// 3 线程B读同一个volatile变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a;          <span class="hljs-comment">// 4 线程B读共享变量</span><br>        ……<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p><ul><li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li><li>根据 volatile 规则：2 happens-before 3。</li><li>根据 happens-before 的传递性规则：1 happens-before 4。</li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20230922144410214.png" alt="image-20230922144410214"></p><p>因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。</p><h4 id="volatile-禁止重排序"><a href="#volatile-禁止重排序" class="headerlink" title="volatile 禁止重排序"></a>volatile 禁止重排序</h4><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读&#x2F;写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20230922151956654.png" alt="image-20230922151956654"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>使用 volatile 必须具备的条件</p><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>悲观锁与乐观锁</title>
    <link href="/2021/04/06/JUC/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <url>/2021/04/06/JUC/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h3><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些。</p><h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子</strong>：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code>&#x3D;1 ），连同帐户扣除后余额（ <code>balance</code>&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号（ <code>version</code>&#x3D;1 ）试图向数据库提交数据（ <code>balance</code>&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol><p>这样就避免了操作员 B 用基于 <code>version</code>&#x3D;1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p><h3 id="乐观锁存在哪些问题？"><a href="#乐观锁存在哪些问题？" class="headerlink" title="乐观锁存在哪些问题？"></a>乐观锁存在哪些问题？</h3><p><strong>ABA 问题</strong></p><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以<strong>原子方式</strong>将该引用和该标志的值设置为给定的更新值。</p><p><strong>循环时间长开销大</strong></p><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p><ol><li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li><li>可以避免在退出循环的时候因内存顺序冲突而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li></ol><p><strong>只能保证一个共享变量的原子操作</strong></p><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死锁</title>
    <link href="/2021/04/06/JUC/%E6%AD%BB%E9%94%81/"/>
    <url>/2021/04/06/JUC/%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>产生死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁?"></a>如何预防和避免线程死锁?</h3><h4 id="如何预防死锁？"><a href="#如何预防死锁？" class="headerlink" title="如何预防死锁？"></a><strong>如何预防死锁？</strong></h4><p> 破坏死锁的产生的必要条件即可：</p><ol><li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><h4 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a><strong>如何避免死锁？</strong></h4><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><blockquote><p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2021/04/06/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2021/04/06/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池?"></a>什么是线程池?</h4><p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><p>线程池、数据库连接池、Http 连接池等等都是对池化思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p><strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h4><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为60秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li><li>**<code>ScheduledThreadPool</code>**：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h4 id="为什么不推荐使用内置线程池？"><a href="#为什么不推荐使用内置线程池？" class="headerlink" title="为什么不推荐使用内置线程池？"></a>为什么不推荐使用内置线程池？</h4><p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><p><strong>为什么呢？</strong></p><blockquote><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></blockquote><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式。</p><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li><p>**<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>**：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</p></li><li><p>**<code>CachedThreadPool</code>**：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</p></li><li><p><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</p></li></ul><h4 id="线程池常见参数有哪些？如何解释？"><a href="#线程池常见参数有哪些？如何解释？" class="headerlink" title="线程池常见参数有哪些？如何解释？"></a>线程池常见参数有哪些？如何解释？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行的任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理（队列放不下）时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池<strong>回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code></strong> ，回收过程才会停止。</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :创建新线程的时候会用到的线程工厂。</li><li><strong><code>handler</code></strong> :拒绝策略。关于拒绝策略下面单独介绍一下。</li></ul><h4 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h4><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子：Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 拒绝策略来配置线程池的时候，默认使用的是 <code>AbortPolicy</code>。在这种拒绝策略下，如果队列满了，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 异常来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。如果不想丢弃任务的话，可以使用<code>CallerRunsPolicy</code>。<code>CallerRunsPolicy</code> 和其他的几个策略不同，它既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>                <span class="hljs-comment">// 直接主线程执行，而不是线程池中的线程执行</span><br>                r.run();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="线程池常用的阻塞队列有哪些？"><a href="#线程池常用的阻塞队列有哪些？" class="headerlink" title="线程池常用的阻塞队列有哪些？"></a>线程池常用的阻塞队列有哪些？</h4><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li><li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li><li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><h4 id="线程池处理任务的流程了解吗？"><a href="#线程池处理任务的流程了解吗？" class="headerlink" title="线程池处理任务的流程了解吗？"></a>线程池处理任务的流程了解吗？</h4><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><h4 id="如何给线程池命名？"><a href="#如何给线程池命名？" class="headerlink" title="如何给线程池命名？"></a>如何给线程池命名？</h4><p>初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。</p><p>默认情况下创建的线程名字类似 <code>pool-1-thread-n</code> 这样的，没有业务含义，不利于我们定位问题。</p><p>给线程池里的线程命名通常有下面两种方式：</p><p><strong>1、利用 guava 的 <code>ThreadFactoryBuilder</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>                        .setNameFormat(threadNamePrefix + <span class="hljs-string">&quot;-%d&quot;</span>)<br>                        .setDaemon(<span class="hljs-literal">true</span>).build();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);<br></code></pre></td></tr></table></figure><p><strong>2、自己实现 <code>ThreadFactory</code>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory delegate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个带名字的线程池生产工厂</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NamingThreadFactory</span><span class="hljs-params">(ThreadFactory delegate, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.delegate = delegate;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// TODO consider uniquifying this</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> delegate.newThread(r);<br>        t.setName(name + <span class="hljs-string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="如何设定线程池的大小？"><a href="#如何设定线程池的大小？" class="headerlink" title="如何设定线程池的大小？"></a>如何设定线程池的大小？</h4><blockquote><p>上下文切换：</p><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p><ul><li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</li><li>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li></ul><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><blockquote><p>线程数更严谨的计算的方法应该是：<code>最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间））</code>，其中 <code>WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）</code>。</p><p>线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。</p><p>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）&#x3D; N，和我们上面说的 N（CPU 核心数）+1 差不多。</p><p>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT&#x2F;ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</p></blockquote><h4 id="如何动态修改线程池的参数？"><a href="#如何动态修改线程池的参数？" class="headerlink" title="如何动态修改线程池的参数？"></a>如何动态修改线程池的参数？</h4><p>美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><strong>为什么是这三个参数？</strong></p><p>这三个参数是 <code>ThreadPoolExecutor</code> 最重要的参数，它们基本决定了线程池对于任务的处理策略。</p><p><strong>如何支持参数动态配置？</strong> 且看 <code>ThreadPoolExecutor</code> 提供的方法。</p><p>格外需要注意的是<code>corePoolSize</code>， 程序运行期间的时候，我们调用 <code>setCorePoolSize（）</code>这个方法的话，线程池会首先判断当前工作线程数是否大于<code>corePoolSize</code>，如果大于的话就会回收工作线程。</p><p>另外，其中并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 <code>ResizableCapacityLinkedBlockIngQueue</code> 的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p><p>如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：</p><ul><li>**<a href="https://github.com/opengoofy/hippo4j">Hippo4jopen in new window</a>**：异步线程池框架，支持线程池动态变更&amp;监控&amp;报警，无需修改代码轻松引入。支持多种使用模式，轻松引入，致力于提高系统运行保障能力。</li><li>**<a href="https://github.com/dromara/dynamic-tp">Dynamic TPopen in new window</a>**：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持 Nacos、Apollo，Zookeeper、Consul、Etcd，可通过 SPI 自定义实现）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程线程协程</title>
    <link href="/2021/04/06/JUC/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/"/>
    <url>/2021/04/06/JUC/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁的优化</title>
    <link href="/2021/04/06/JUC/%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <url>/2021/04/06/JUC/%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p><code>锁粗化</code>：就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</p><p><code>锁消除</code>：JVM会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</p><p><code>轻量级锁</code>：这种锁实现的背后基于这样一种假设，即：在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒 （执行CAS指令成功的线程执行完后，释放锁 唤醒被阻塞的线程）。</p><p><code>偏向锁</code>：是为了在无锁竞争的情况下，避免在重复的获取锁和释放锁过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在一定程度上的本地延迟。</p><p>​偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p><p><code>适应性自旋</code>：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入重量级锁前，会进入忙等待然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用互斥锁进入到阻塞状态。</p><blockquote><p>总结：</p><ul><li>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。</li><li>轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</li><li>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</li></ul></blockquote><h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><table><thead><tr><th>锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td align="center">加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td align="center">适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td align="center">竞争的线程不会阻塞，提高了响应速度</td><td align="center">始终得不到锁的线程，使用自旋会消耗CPU性能</td><td align="center">追求响应时间，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td align="center">线程竞争不适用自旋，不会消耗CPU</td><td align="center">线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td align="center">追求吞吐量，同步块执行时间较长</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁的定义</title>
    <link href="/2021/04/06/JUC/%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    <url>/2021/04/06/JUC/%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><ul><li>乐观锁、悲观锁</li><li>自旋锁、适应性自旋锁</li><li>无锁、偏向锁、轻量级锁、重量级锁</li><li>公平锁、非公平锁</li><li>可重入锁、非可重入锁</li><li>独享锁（排他锁）、共享锁</li></ul><blockquote><p>synchronized关键字和Lock的实现类都是悲观锁</p></blockquote><p><strong>悲观锁</strong>： 认为在使用数据的时候，一定会有别的线程来修改数据，因此在获取数据的时候先加锁，确保数据不会被其他的线程修改。<code>适合写操作多的场景</code>，先加锁可以保证写操作时的数据正确。</p><p><strong>乐观锁</strong>：认为不会有其他的线程修改数据，不会添加锁。但会在更新数据的时候去判断有没有别的线程更新了数据（具体方法可以使用版本号机制或 CAS 算法）。<code> 适合读操作多的场景</code>，不加锁可以使读的操作性能大幅提升。</p><p><strong>自旋锁</strong>： 挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。自旋可以使线程不必阻塞直接获取同步资源，避免切换线程的开销。</p><ul><li>应用场景：同步资源的锁定时间很短，为了一点时间去切换线程、线程挂起和恢复现场的花费可能会让系统得不偿失，所以在物理机器有多个处理器的时候，可以选择使得线程不放弃CPU，看持有锁的线程是否很快就会释放锁。</li><li>缺点：虽然避免了线程切换的开销，但要占用处理器的时间。<strong>如果锁被占用的时间很短，那么自旋锁的效果会非常好。但如果锁被占用的时间很长，那么自旋的线程会白白浪费处理器的资源。</strong>所以自旋等待的时间会有一定的限度。如果自旋超过限定次数（<strong>默认十次</strong>）还没有成功获得锁，线程就应该被挂起。</li></ul><p><strong>自适应自旋锁</strong>： 自旋的时间不再固定，由上一次在同一个锁上的自旋时间和锁的拥有者的状态来决定。如果某个锁对象自旋等待成功获取过锁，并且持有锁的线程正在运行，那么JVM会认为该锁自旋获取到锁的可能性更大，会自动增加等待时间（自旋次数）。如果某个线程自旋很少获得锁，那么以后可能就会直接挂起，省略掉自旋的过程，避免浪费处理器资源。自适应自旋会使JVM对程序的锁的状态预测越来越准确。</p><p><strong>公平锁</strong>：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，只有队列中的第一个线程才能获得锁。</p><ul><li>优点：等待锁的线程不会饿死。</li><li>缺点：整体的吞吐效率相对于非公平锁要低，等待队列中除了第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的总开销比非公平锁大。</li></ul><p><strong>非公平锁</strong>： 线程直接尝试获得锁，获取不到后才进入等待队列的队尾等待。（即如果此时锁刚好可用，那么这个线程就可以无需阻塞的直接获取到锁）会出现后申请锁的线程先获取锁的场景。</p><ul><li><p>优点：减少唤起线程的开销，整体的吞吐效率高。（因为线程有概率直接获得锁，所以CPU不需要每次都唤醒线程）</p></li><li><p>缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p></li></ul><p><strong>可重入锁</strong>：在同一个线程在外层方法已经获得锁的时候，再进入该线程的内部方法会<strong>自动获取锁</strong>，前提是锁对象是同一个对象或class，不会因为之前获取过锁但还没释放而阻塞。ReentrantLock和synchronized都是可重入锁。</p><ul><li>优点：一定程度上避免死锁</li></ul><p><strong>非可重入锁</strong>： 不允许同一个线程多次获取同一个锁</p><p><strong>独享锁（排他锁）</strong>：该锁一次只能被一个线程所持有。如果某线程对数据加上排他锁后，其它线程不能再对数据加任何类型的锁。<code>获得排他锁的线程既能读数据又能修改数据</code>。synchronize和Lock的实现类就是独享锁。</p><p><strong>共享锁</strong>：该锁可被多个线程所持有。如果某线程对数据加上共享锁之后，那么其它线程只能再对其加共享锁，不能加排他锁。<code>获得共享锁的线程只能读数据，不能修改数据</code>。（读完了才可以加排他锁去写）</p><blockquote><p>在ReentrantReadWriteLock里面，读锁和写锁的加锁的方式不一样，读锁是共享锁，写锁是独享锁。因为读写锁分离，所以ReentrantReadWriteLock的并发性相比一般的互斥锁有很大的提升。</p></blockquote><p><strong>偏向锁</strong>：是为了在无锁竞争的情况下，避免在重复的获取锁和释放锁过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在一定程度的本地延迟。</p><p>​偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题目</title>
    <link href="/2021/04/06/JUC/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <url>/2021/04/06/JUC/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器、虚拟机栈</strong>和<strong>本地方法栈</strong>。</p><p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p><h3 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h3><blockquote><p>程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p></blockquote><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><h3 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h3><blockquote><p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong></p></blockquote><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>堆和方法区是所有线程共享的资源</p><ul><li>堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)</li><li>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ul><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h3><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程?"></a>为什么要使用多线程?</h3><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li><li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）。</li></ul><h3 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h3><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p><h3 id="如何理解线程安全和不安全？"><a href="#如何理解线程安全和不安全？" class="headerlink" title="如何理解线程安全和不安全？"></a>如何理解线程安全和不安全？</h3><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。</p><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><h3 id="单核-CPU-上运行多个线程效率一定会高吗？"><a href="#单核-CPU-上运行多个线程效率一定会高吗？" class="headerlink" title="单核 CPU 上运行多个线程效率一定会高吗？"></a>单核 CPU 上运行多个线程效率一定会高吗？</h3><p>单核CPU同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。一般来说，有两种类型的线程：CPU密集型和IO密集型。CPU密集型的线程主要进行计算和逻辑处理，需要占用大量的CPU资源。IO密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待IO设备的响应，而不占用太多的CPU资源。</p><p>在单核CPU上，同一时刻只能有一个线程在运行，其他线程需要等待CPU的时间片分配。如果线程是CPU密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。如果线程是IO密集型的，那么多个线程同时运行可以利用CPU在等待IO时的空闲时间，提高了效率。</p><p>因此，对于单核CPU来说，如果任务是CPU密集型的，那么开很多线程会影响效率；如果任务是IO密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。</p><h3 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态?"></a>说说线程的生命周期和状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJavaopen in new window</a>：<a href="https://howtodoinjava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread Statesopen in new window</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p><p><strong>为什么 JVM 没有区分这两种状态呢？</strong> （摘自：<a href="https://www.zhihu.com/question/56494969/answer/154053599">Java 线程运行怎么有第六种状态？ - Dawell 的回答open in new window</a> ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p></blockquote><ul><li>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li><li><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li><li>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</li><li>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</li></ul><h3 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换?"></a>什么是线程上下文切换?</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h3 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h3><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>：</p><ul><li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？下一个问题就会聊到。</li></ul><h3 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a>为什么 wait() 方法不定义在 Thread 中？</h3><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p><p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p><p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p><h3 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a>可以直接调用 Thread 类的 run 方法吗？</h3><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h3 id="如何保证变量的可见性？"><a href="#如何保证变量的可见性？" class="headerlink" title="如何保证变量的可见性？"></a>如何保证变量的可见性？</h3><p>将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证.</p><h3 id="如何禁止指令重排序？"><a href="#如何禁止指令重排序？" class="headerlink" title="如何禁止指令重排序？"></a>如何禁止指令重排序？</h3><p><strong><code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><p><strong>双重校验锁实现对象单例（线程安全）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>uniqueInstance &#x3D; new Singleton(); </p><p>这段代码其实是分为三步执行：</p><ul><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ul><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p></blockquote><h3 id="构造方法可以用-synchronized-修饰么？"><a href="#构造方法可以用-synchronized-修饰么？" class="headerlink" title="构造方法可以用 synchronized 修饰么？"></a>构造方法可以用 synchronized 修饰么？</h3><p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><h3 id="synchronized-底层原理了解吗"><a href="#synchronized-底层原理了解吗" class="headerlink" title="synchronized 底层原理了解吗"></a>synchronized 底层原理了解吗</h3><p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p><p>字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p><blockquote><p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitoropen in new window</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p><p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p></blockquote><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><p><strong>总结</strong></p><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>两者的本质都是对对象监视器 monitor 的获取</strong>。</p><h3 id="JDK1-6-之后的-synchronized-底层做了哪些优化？"><a href="#JDK1-6-之后的-synchronized-底层做了哪些优化？" class="headerlink" title="JDK1.6 之后的 synchronized 底层做了哪些优化？"></a>JDK1.6 之后的 synchronized 底层做了哪些优化？</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h3 id="synchronized-和-volatile-有什么区别？"><a href="#synchronized-和-volatile-有什么区别？" class="headerlink" title="synchronized 和 volatile 有什么区别？"></a>synchronized 和 volatile 有什么区别？</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><p><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</p></li><li><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p></li><li><p><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习</title>
    <link href="/2021/04/06/Linux/Linux%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/06/Linux/Linux%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h3 id="安装gcc相关"><a href="#安装gcc相关" class="headerlink" title="安装gcc相关"></a>安装gcc相关</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum -y install gcc<br>yum -y install gcc-c++<br></code></pre></td></tr></table></figure><h3 id="安装yum相关"><a href="#安装yum相关" class="headerlink" title="安装yum相关"></a>安装yum相关</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install -y yum-utils<br>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum makecache fast//更新yum软件包索引<br></code></pre></td></tr></table></figure><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum -y install docker-ce docker-ce-cli containerd.io<br>systemctl start docker//启动docker<br>ps -ef|grep docker//查看状态<br>docker run hello-world//helloworld<br>docker version//查看版本<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架</title>
    <link href="/2021/04/06/SpringBoot/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/04/06/SpringBoot/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Collection相关"><a href="#Collection相关" class="headerlink" title="Collection相关"></a>Collection相关</h1><p>如何选用集合：</p><p>需要根据键值获取到元素值时，选用 <code>Map</code> 接口下的集合</p><ul><li>需要排序时选择 <code>TreeMap</code></li><li>不需要排序时就选择 <code>HashMap</code></li><li>需要保证线程安全就选用 <code>ConcurrentHashMap</code></li></ul><p>只需要存放元素值时，选择实现<code>Collection</code> 接口的集合：</p><ul><li>需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet(有序，唯一)</code> 或 <code>HashSet(无序，唯一)</code></li><li>不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList-（线程不安全）"><a href="#ArrayList-（线程不安全）" class="headerlink" title="ArrayList （线程不安全）"></a>ArrayList （线程不安全）</h3><blockquote><p>可以存储任何类型的对象，包括 <code>null</code> 值。不过，不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Arrays.asList(<span class="hljs-string">&quot;element1&quot;</span>, <span class="hljs-string">&quot;element2&quot;</span>).toArray().getClass() == Object[].class);<br><span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>当我们调用 List的 toArray() 时，我们实际上调用的是其具体实现类中重写的 String[] toArray() 方法。因此，返回数组并不是 Object[] 而是 String[]，而向下转型是不安全的，因此会抛出异常。</p><p>通过分析这个官方bug，我们就记住了：</p><ol><li>抽象类(接口)其具体类型，取决于实例化时所采用的导出类的类型。</li><li>子类实现和父类同名的方法，仅仅返回值不一致时，默认调用的是子类的那个实现方法。如String[] toArray()</li></ol><blockquote><p>有了垃圾收集器并不意味着一定不会有内存泄露。 对象能否被GC的依据是 是否还有引用指向它，remove后，如果不手动赋值为null，除非对应位置被其它元素覆盖，否则原来的对象就一直不会回收。</p></blockquote><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</p><p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。<code>ArrayList</code> 底层是数组，所以实现了 <code>RandomAccess</code> 接口，表明了他具有快速随机访问功能。 </p><blockquote><p><code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p><p>在 Collections的<code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RandomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法。</p><p>在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好。</p></blockquote><h3 id="Vector-和-Stack-的区别"><a href="#Vector-和-Stack-的区别" class="headerlink" title="Vector 和 Stack 的区别"></a>Vector 和 Stack 的区别</h3><ul><li><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</li><li><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</li></ul><p>已经被淘汰，推荐使用并发集合类（ <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>）</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><blockquote><p>底层通过循环数组实现。</p><p>是非线程安全的</p><p>不允许放入null元素；</p><p>&#x2F;&#x2F; 由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">(tail + <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)<br><span class="hljs-comment">//由于elements.length一定为2的指数，所以elements.length - 1的二进制低位全为1，相与后起到了取模的作用；</span><br><span class="hljs-comment">//如果前者为-1，那就相当于</span><br></code></pre></td></tr></table></figure><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a><em>PriorityQueue</em></h3><blockquote><p>不允许放入null元素，是通过完全二叉树实现的<code>小根堆</code>，即可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p>移除队首元素时，除非队列已经为空，否则都需要对小根堆进行维护，维护后，方能取出剩余的元素。</p></blockquote><blockquote><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素(如果有多个相等，只删除一个)</p><p>分为2种情况: </p><ul><li><ol><li>删除的是最后一个元素。直接删除即可，不需要调整。</li><li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。</li></ol></li></ul></blockquote><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>Comparable是被排序的类内部的方法，需要修改源码，而Comparator是另外实现一个比较器， 不需要修改源代码。</p><h3 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p>相同点：都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p><p>不同点：</p><p>底层数据结构不同：</p><ul><li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。</li><li><code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li><li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li></ul><p>应用场景不同： </p><ul><li><code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景</li><li><code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景</li><li><code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h2 id="Map相关"><a href="#Map相关" class="headerlink" title="Map相关"></a>Map相关</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote><p>允许放入key为null的元素，也允许插入value为null的元素</p></blockquote><blockquote><p>未实现同步</p></blockquote><blockquote><p>不保证元素顺序</p></blockquote><blockquote><p>JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p></blockquote><blockquote><p>对于<code>迭代比较频繁</code>的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p></blockquote><blockquote><p>有两个参数可以影响<em>HashMap</em>的性能 :</p><ul><li>初始容量(inital capacity)： 指定初始table的大小</li><li>负载系数(load factor)： 指定自动扩容的临界值。</li></ul><p>当entry的数量超过<code>capacity * load_factor</code>时，容器将自动扩容并重新哈希。</p><p>对于<code>插入元素较多</code>的场景，将初始容量设大可以减少重新哈希的次数。</p></blockquote><blockquote><p><em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。</p></blockquote><blockquote><p><code>resize()</code>时，如果原有的大小oldCap已经&gt;&#x3D; 1&lt;&lt;30 , 不能盲目的在此基础上将大小翻倍，因为会越界，所以设置大小为Integer.MAX_VALUE;</p></blockquote><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a><em>LinkedHashMap</em></h3><blockquote><p>实现了<em>Map</em>接口，底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。</p><p>允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。</p></blockquote><blockquote><p>在HashMap的基础上，增加了一条双向链表，将所有entry连接起来是为了保证元素的迭代顺序和插入顺序相同（双向链表的迭代顺序就是entry的插入顺序）</p><p>&#x2F;&#x2F; 迭代时只需要直接遍历双向链表，即LinkedHashMap的迭代时间只与entry的个数有关，和table的大小无关</p></blockquote><blockquote><p>性能受初始容量和负载系数影响，当entry数量超过初始容量*负载系数时，容器会自动扩容并重新哈希。所以对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p></blockquote><blockquote><p>非同步的，多线程环境使用时需要手动同步，或者将其包装成为同步的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Collections.synchronizedMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>(...));<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>  插入新元素时：</p><ol><li>从<code>table</code>的角度看，新的<code>entry</code>需要插入到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li><li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li></ol></blockquote><blockquote><p>删除元素时：</p><p>从<code>table</code>的角度看，需要将该<code>entry</code>从对应的<code>bucket</code>里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</p><p>从<code>header</code>的角度来看，需要将该<code>entry</code>从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</p></blockquote><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><blockquote><p>实现了SortedMap接口，会按照key的大小对元素进行排序</p></blockquote><blockquote><p>底层使用红黑树实现，即containsKey()、get()、put()、remove()时间复杂度都为log(n)</p></blockquote><blockquote><p><code> 非同步的</code>,需要多线程环境下使用时，手动同步或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SortedMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Collections.synchronizedSortedMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>(...));<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><code>红黑树</code>即满足如下条件的二叉查找树:</p><ul><li>每个节点的颜色非红即黑</li><li>根节点为黑色</li><li>红色节点不能连续（指父亲和孩子不能同时是红色）</li><li>每个节点向下到叶子节点的任何路径，所含有的黑色节点个数相同</li></ul></blockquote><blockquote><p><code>后继节点</code>（树中大于指定节点的所有节点中最小的那个），寻找方式：</p><ul><li>指定节点的右子树不为空，则后继为右子树总最小的那个元素</li><li>指定节点的右子树为空，则后继为其第一个向左走的祖先</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//(TODO) 红黑树的结构和颜色调节</span><br></code></pre></td></tr></table></figure><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><blockquote><p>适用于需要缓存的场景:</p><p>对象缓存命中可以提高系统效率，缓存MISS也不会造成错误，因为可以通过计算重新得到</p></blockquote><blockquote><p>垃圾回收时不考虑弱引用（垃圾回收时，判断某个对象是否可以被回收的依据是：是否存在有效的引用指向该对象，而有效引用并不包含弱引用，即仅有弱引用指向的对象仍然会被GC回收）</p></blockquote><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><blockquote><p>数组 + 链表组成，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习</title>
    <link href="/2021/04/06/Web/Vue%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/06/Web/Vue%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 初识Vue</span><br><br><span class="hljs-bullet">1.</span> 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象。<br><span class="hljs-bullet">2.</span> root容器里的代码依然符合html规范，但混入一些特殊的Vue语法<br><span class="hljs-bullet">3.</span> root容器里的代码被称为Vue模板<br><span class="hljs-bullet">4.</span> Vue实例和容器是一一对应的<br><span class="hljs-bullet">5.</span> 真实开发只有一个Vue实例，并且会配合组件一起使用。<br><span class="hljs-bullet">6.</span> &#123;&#123;xxxx&#125;&#125; 中的xxx要写js表达式， 且xxx可以自动读取到data里的所有属性<br><span class="hljs-bullet">7.</span> 一旦data里的数据发生改变，页面中用到该数据的地方会自动更新<br><span class="hljs-bullet">8.</span> js表达式和js代码（语句）的区分<br><span class="hljs-bullet">    1.</span> 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方<br><span class="hljs-bullet">        1.</span> a<br><span class="hljs-bullet">        2.</span> a+b<br><span class="hljs-bullet">        3.</span> demo(1)<br><span class="hljs-bullet">        4.</span> x === y ？ &#x27;a&#x27; : &#x27;b&#x27;<br><span class="hljs-bullet">    2.</span> js代码（语句）<br><span class="hljs-bullet">        1.</span> if()&#123;&#125;<br><span class="hljs-bullet">        2.</span> for()&#123;&#125;<br><br><span class="hljs-section">### 模板语法</span><br><br><span class="hljs-bullet">1.</span> 插值语法：<br><span class="hljs-bullet">    -</span> 功能：用于解析标签体内容<br><span class="hljs-bullet">    -</span> 写法：&#123;&#123;xxx&#125;&#125;，xxx是js表达式，且可以直接读取到data中的所有区域<br><span class="hljs-bullet">2.</span> 指令语法：<br><span class="hljs-bullet">    -</span> 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）<br><span class="hljs-bullet">    -</span> 举例：<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span></span>或简写为<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span></span>，xxx同样要写js表达式，且可以直接读取到data中的所有属性<br><br><span class="hljs-section">### 数据绑定</span><br><br><span class="hljs-bullet">1.</span> 单向绑定（v-bind）：数据只能从data流向页面<br><br><span class="hljs-bullet">2.</span> 双向绑定（v-model）：数据不仅能从data流向页面，还可以从页面流向data<br><br><span class="hljs-code">    &gt; 双向绑定一般都应用在表单类元素（可以输入的元素）上（如：&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;等）</span><br><span class="hljs-code">    &gt; v-model:value可以简写为v-model，因为v-model默认收集的就是value值</span><br><span class="hljs-code"></span><br><span class="hljs-section">### el与data的两种写法</span><br><br><span class="hljs-bullet">1.</span> el<br><br><span class="hljs-code">    ```Vue</span><br><span class="hljs-code">    const vm = new Vue(&#123;</span><br><span class="hljs-code">    el:&#x27;#root&#x27;, //第一种写法</span><br><span class="hljs-code">    data:&#123;</span><br><span class="hljs-code">    name:&#x27;JOJO&#x27;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    &#125;)</span><br><span class="hljs-code">    vm.$mount(&#x27;#root&#x27;)//第二种写法</span><br><span class="hljs-code">    ```</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">2.</span> data<br><br><span class="hljs-code">    ```vue</span><br><span class="hljs-code">    data:&#123;</span><br><span class="hljs-code">    name:&#x27;JOJO&#x27;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    ```</span><br><span class="hljs-code"></span><br><span class="hljs-code">    ```vue</span><br><span class="hljs-code">    data()&#123;</span><br><span class="hljs-code">    return&#123;</span><br><span class="hljs-code">    name:&#x27;JOJO&#x27;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    ```</span><br><span class="hljs-code"></span><br><span class="hljs-code">    </span><br><span class="hljs-code"></span><br><span class="hljs-section">### 数据代理</span><br><br>![<span class="hljs-string">image-20220925215057541</span>](<span class="hljs-link">C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20220925215057541.png</span>)<br><br><span class="hljs-bullet">1.</span> 通过vm对象来代理data对象中属性的操作（读/写）<br><span class="hljs-bullet">2.</span> 代理的好处是更加方便的操作data中的数据<br><span class="hljs-bullet">3.</span> 原理：通过Object.defineProperty()把data对象中的所有属性添加到vm上，为每一个添加到vm上的属性都指定一个getter/setter，在getter/setter的内部去操作读写data中对应的属性。<br><br><br><br><span class="hljs-section">### 事件处理</span><br><br><span class="hljs-bullet">1.</span> 使用v-on:xxx或@xxx绑定事件，其中xxx是事件名<br><span class="hljs-bullet">2.</span> 事件的回调需要配置在methods对象中，最终会在vm上<br><span class="hljs-bullet">3.</span> methods中配置的函数，==不要用箭头函数！==否则this就不是vm了<br><span class="hljs-bullet">4.</span> methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象<br><span class="hljs-bullet">5.</span> @click=&quot;demo和@click=&quot;demo($event)&quot;效果一致，但后者可以传参<br><br><span class="hljs-section">### 事件修饰符</span><br><br><span class="hljs-bullet">1.</span> prevent：阻止默认事件（常用）<br><br><span class="hljs-bullet">2.</span> stop：阻止事件冒泡（常用）<br><br><span class="hljs-bullet">3.</span> once：事件只触发一次（常用）<br><br><span class="hljs-bullet">4.</span> capture：使用事件的捕获模式<br><br><span class="hljs-bullet">5.</span> self：只有event.target是当前操作的元素时才触发事件<br><br><span class="hljs-bullet">6.</span> passive：事件的默认行为立即执行，无需等待事件回调执行完毕<br><br><span class="hljs-code">    &gt; 修饰符可以连续写，比如可以这么用：@click.prevent.stop=&quot;showInfo&quot;</span><br><span class="hljs-code"></span><br><span class="hljs-section">### 常用的按键别名</span><br><br><span class="hljs-bullet">1.</span> 回车：enter<br><span class="hljs-bullet">2.</span> 删除：delete (捕获“删除”和“退格”键)<br><span class="hljs-bullet">3.</span> 退出：esc<br><span class="hljs-bullet">4.</span> 空格：space<br><span class="hljs-bullet">5.</span> 换行：tab (特殊，必须配合keydown去使用)<br><span class="hljs-bullet">6.</span> 上：up<br><span class="hljs-bullet">7.</span> 下：down<br><span class="hljs-bullet">8.</span> 左：left<br><span class="hljs-bullet">9.</span> 右：right<br><br><span class="hljs-quote">&gt; 注意：</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; - 系统修饰键（用法特殊）：ctrl、alt、shift、meta</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; - 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发</span><br><span class="hljs-quote">&gt;     配合keydown使用：正常触发事件</span><br><span class="hljs-quote">&gt;     可以使用keyCode去指定具体的按键，比如：@keydown.13=&quot;showInfo&quot;，但不推荐这样使用</span><br><span class="hljs-quote">&gt; - Vue.config.keyCodes.自定义键名 = 键码，可以自定义按键别名</span><br><br><br><br><br><br><span class="hljs-section">### 计算属性</span><br><br>定义：要用的属性不存在，需要通过已有属性计算得来。<br><br>原理：底层借助了Objcet.defineproperty()方法提供的getter和setter。<br><br>get函数什么时候执行？ <br><br><span class="hljs-bullet">-</span> 初次读取时会执行一次<br><span class="hljs-bullet">-</span> 当依赖的数据发生改变时会被再次调用<br><br>优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便<br><br><span class="hljs-quote">&gt; 备注：</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; 计算属性最终会出现在vm上，直接读取使用即可</span><br><span class="hljs-quote">&gt; 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变</span><br><span class="hljs-quote">&gt; 如果计算属性确定不考虑修改，可以使用计算属性的简写形式</span><br><br><br><br><span class="hljs-section">### 监视属性watch</span><br><br><span class="hljs-bullet">1.</span> 当被监视的属性变化时，回调函数自动调用，进行相关操作<br><span class="hljs-bullet">2.</span> 监视的属性必须存在，才能进行监视<br><span class="hljs-bullet">3.</span> 监视有两种写法：<br><span class="hljs-bullet">    1.</span> 创建Vue时传入watch配置<br><span class="hljs-bullet">    2.</span> 通过<span class="hljs-code">`vm.$watch`</span>监视<br><br><br><br><span class="hljs-section">### 深度监视</span><br><br><span class="hljs-bullet">1.</span> Vue中的watch默认不监测对象内部值的改变（一层）<br><span class="hljs-bullet">2.</span> 在watch中配置deep:true可以监测对象内部值的改变（多层）<br><br><span class="hljs-quote">&gt; 备注：</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以</span><br><span class="hljs-quote">&gt; 使用watch时根据监视数据的具体结构，决定是否采用深度监视</span><br><br><br><br><span class="hljs-section">### 监视属性简写</span><br><br>如果监视属性除了handler没有其他配置项的话，可以进行简写。<br><br><br><br><span class="hljs-section">#### computed和watch之间的区别</span><br><br><span class="hljs-bullet">1.</span> computed能完成的功能，watch都可以完成<br><span class="hljs-bullet">2.</span> watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作<br><br><span class="hljs-quote">&gt; 两个重要的小原则：</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; - 所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象</span><br><span class="hljs-quote">&gt; - 所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</span><br><br><br><br><span class="hljs-section">### 绑定样式</span><br><br>class样式：<br><br>写法：class=&quot;xxx&quot;，xxx可以是字符串、对象、数组<br><br>字符串写法适用于：类名不确定，要动态获取<br><br>对象写法适用于：要绑定多个样式，个数不确定，名字也不确定<br><br>数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用<br><br>style样式：<br><br><span class="hljs-code">```vue</span><br><span class="hljs-code">:style=&quot;&#123;fontSize: xxx&#125;&quot;  #其中xxx是动态值</span><br><span class="hljs-code">:style=&quot;[a,b]&quot; #其中a、b是样式对</span><br><span class="hljs-code">```</span><br><br><span class="hljs-section">### 条件渲染</span><br><br><span class="hljs-bullet">1.</span> v-if：<br><br><span class="hljs-bullet">    -</span> 写法：<br><br><span class="hljs-bullet">    -</span> v-if=&quot;表达式&quot;<br><span class="hljs-code">        v-else-if=&quot;表达式&quot;</span><br><span class="hljs-code">        v-else</span><br><span class="hljs-code">        适用于：切换频率较低的场景</span><br><span class="hljs-code">    - 特点：不展示的DOM元素直接被移除</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">    -</span> 注意：v-if可以和v-else-if、v-else一起使用，但要求结构不能被打断<br><br><span class="hljs-bullet">2.</span> v-show：<br><br><span class="hljs-bullet">    -</span> 写法：v-show=&quot;表达式&quot;<br><span class="hljs-bullet">    -</span> 适用于：切换频率较高的场景<br><span class="hljs-bullet">    -</span> 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉<br><span class="hljs-code">        使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到</span><br><span class="hljs-code"></span><br><span class="hljs-section">### 列表渲染</span><br><br><span class="hljs-section">#### 基本列表</span><br><br><span class="hljs-code">`v-for`</span>指令：<br><br><span class="hljs-bullet">1.</span> 用于展示列表数据<br><span class="hljs-bullet">2.</span> 语法：<span class="hljs-code">`&lt;li v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;&gt;`</span>，其中key可以是index，也可以是遍历对象的唯一标识<br><span class="hljs-bullet">3.</span> 可遍历：数组、对象、字符串（用的少）、指定次数（用的少）<br><br><span class="hljs-section">#### key的作用与原理</span><br><br>面试题：react、vue中的key有什么作用？（key的内部原理）<br><br>虚拟DOM中key的作用：key是虚拟DOM中对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：<br><br>对比规则：<br><br>旧虚拟DOM中找到了与新虚拟DOM相同的key：<br><br>若虚拟DOM中内容没变, 直接使用之前的真实DOM<br>若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM<br>旧虚拟DOM中未找到与新虚拟DOM相同的key：创建新的真实DOM，随后渲染到到页面<br><br>用index作为key可能会引发的问题：<br><br>若对数据进行逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低<br>若结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题<br>开发中如何选择key?<br><br>最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值<br>如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用index作为key是没有问题的<br><br><br><br><span class="hljs-section">#### 列表过滤</span><br><br><span class="hljs-section">#### 列表排序</span><br><br><span class="hljs-section">#### 数据监视</span><br><br><span class="hljs-bullet">1.</span> Vue监视数据的原理：<br><br><span class="hljs-code">    ​vue会监视data中所有层次的数据</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">2.</span> 如何监测对象中的数据？、<br><br><span class="hljs-code">    ​通过setter实现监视，且要在new Vue时就传入要监测的数据</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">    1.</span> 对象中后追加的属性，Vue默认不做响应式处理<br><br><span class="hljs-bullet">    2.</span> 如需给后添加的属性做响应式，请使用如下API：<br><br><span class="hljs-bullet">        -</span> Vue.set(target,propertyName/index,value)<br><br><span class="hljs-bullet">        -</span> vm.$set(target,propertyName/index,value)<br><br><span class="hljs-bullet">3.</span> 如何监测数组中的数据？<br><br><span class="hljs-bullet">4.</span> 通过包裹数组更新元素的方法实现，本质就是做了两件事：<br><br><span class="hljs-bullet">    1.</span> 调用原生对应的方法对数组进行更新<br><span class="hljs-bullet">    2.</span> 重新解析模板，进而更新页面<br><br><span class="hljs-bullet">5.</span> 在Vue修改数组中的某个元素一定要用如下方法：<br><br><span class="hljs-bullet">    1.</span> 使用这些API：push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br><br><span class="hljs-bullet">    2.</span> Vue.set() 或 vm.$set()<br><br><span class="hljs-code">        &gt; 特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象（data等） 添加属性</span><br><span class="hljs-code"></span><br><br><br><span class="hljs-section">### 收集表单数据</span><br><br>收集表单数据：<br><br><span class="hljs-bullet">-</span> 若：<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>/&gt;</span></span>，则v-model收集的是value值，用户输入的内容就是value值<br><span class="hljs-bullet">-</span> 若：<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>/&gt;</span></span>，则v-model收集的是value值，且要给标签配置value属性<br><span class="hljs-bullet">-</span> 若：<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>/&gt;</span></span><br><span class="hljs-bullet">    -</span> 没有配置value属性，那么收集的是checked属性（勾选 or 未勾选，是布尔值）<br><span class="hljs-bullet">    -</span> 配置了value属性：<br><span class="hljs-bullet">        -</span> v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br><span class="hljs-bullet">        -</span> v-model的初始值是数组，那么收集的就是value组成的数组<br><br>v-model的三个修饰符(v-model.xxx)：<br><br><span class="hljs-bullet">1.</span> lazy：失去焦点后再收集数据<br><span class="hljs-bullet">2.</span> number：输入字符串转为有效的数字<br><span class="hljs-bullet">3.</span> trim：输入首尾空格过滤<br><br><span class="hljs-section">#### 过滤器：</span><br><br><span class="hljs-bullet">-</span> 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。<br><br><span class="hljs-bullet">-</span> 语法：<br><br><span class="hljs-bullet">    1.</span> 注册过滤器：Vue.filter(name,callback) 或 new Vue&#123;filters:&#123;&#125;&#125;<br><br><span class="hljs-bullet">    2.</span> 使用过滤器：&#123;&#123; xxx | 过滤器名&#125;&#125; 或 v-bind:属性 = &quot;xxx | 过滤器名&quot;<br><br><br><span class="hljs-quote">&gt; 备注：</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; 过滤器可以接收额外参数，多个过滤器也可以串联</span><br><span class="hljs-quote">&gt; 并没有改变原本的数据，而是产生新的对应的数据</span><br><br><span class="hljs-section">### 内置指令</span><br><br><span class="hljs-section">#### v-text指令</span><br><br><span class="hljs-bullet">-</span> 之前学过的指令：<br><br><span class="hljs-bullet">    -</span> v-bind：单向绑定解析表达式，可简写为:<br><br><span class="hljs-bullet">    -</span> v-model：双向数据绑定<br><br><span class="hljs-bullet">    -</span> v-for：遍历数组 / 对象 / 字符串<br><br><span class="hljs-bullet">    -</span> v-on：绑定事件监听，可简写为@<br><br><span class="hljs-bullet">    -</span> v-if：条件渲染（动态控制节点是否存存在）<br><br><span class="hljs-bullet">    -</span> v-else：条件渲染（动态控制节点是否存存在）<br><br><span class="hljs-bullet">    -</span> v-show：条件渲染 (动态控制节点是否展示)<br><br><span class="hljs-bullet">-</span> v-text指令：<br><br><span class="hljs-bullet">    -</span> 作用：向其所在的节点中渲染文本内容<br><br><span class="hljs-bullet">    -</span> 与插值语法的区别：v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。<br><br><br><br><span class="hljs-section">#### v-html指令</span><br><br><span class="hljs-bullet">1.</span> 作用：向指定节点中渲染包含html结构的内容<br><span class="hljs-bullet">2.</span> 与插值语法的区别：<br><span class="hljs-bullet">    -</span> v-html会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125;则不会<br><span class="hljs-bullet">    -</span> v-html可以识别html结构<br><span class="hljs-bullet">3.</span> 严重注意：<br><span class="hljs-bullet">    -</span> v-html有安全性问题！！！<br><span class="hljs-bullet">    -</span> 在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击<br><span class="hljs-bullet">    -</span> 一定要在可信的内容上使用v-html，永远不要用在用户提交的内容上！！！<br><br><br><br><span class="hljs-section">#### v-cloak指令</span><br><br><span class="hljs-code">`v-cloak`</span>指令（没有值）：<br><br><span class="hljs-bullet">1.</span> 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉<span class="hljs-code">`v-cloak`</span>属性<br><span class="hljs-bullet">2.</span> 使用css配合<span class="hljs-code">`v-cloak`</span>可以解决网速慢时页面展示出<span class="hljs-code">`&#123;&#123;xxx&#125;&#125;`</span>的问题<br><br><span class="hljs-section">#### v-once指令</span><br><br><span class="hljs-code">`v-once`</span>指令：<br><br><span class="hljs-bullet">1.</span> <span class="hljs-code">`v-once`</span>所在节点在初次动态渲染后，就视为静态内容了<br><span class="hljs-bullet">2.</span> 以后数据的改变不会引起<span class="hljs-code">`v-once`</span>所在结构的更新，可以用于优化性能<br><br><span class="hljs-section">#### v-pre指令</span><br><br><span class="hljs-code">`v-pre`</span>指令：<br><br><span class="hljs-bullet">1.</span> 跳过其所在节点的编译过程。<br><span class="hljs-bullet">2.</span> 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译<br><br><span class="hljs-section">#### 自定义指令</span><br><br>总结：<br><br>自定义指令定义语法：<br><br>局部指令：<br><br><span class="hljs-code">```Vue</span><br><span class="hljs-code">new Vue(&#123;</span><br><span class="hljs-code">directives:&#123;指令名:配置对象&#125;   </span><br><span class="hljs-code">&#125;) </span><br><span class="hljs-code">new Vue(&#123;</span><br><span class="hljs-code">directives:&#123;指令名:回调函数&#125;   </span><br><span class="hljs-code">&#125;)</span><br><span class="hljs-code">```</span><br><br><br>全局指令：<br><br><span class="hljs-code">```Vue</span><br><span class="hljs-code">Vue.directive(指令名,配置对象)</span><br><span class="hljs-code">Vue.directive(指令名,回调函数)</span><br><span class="hljs-code">```</span><br><br>配置对象中常用的3个回调函数：<br><br>bind(element,binding) ：指令与元素成功绑定时调用<br>inserted(element,binding)：指令所在元素被插入页面时调用<br>update(element,binding)：指令所在模板结构被重新解析时调用<br>备注：<br><br>指令定义时不加“v-”，但使用时要加“v-”<br><br>指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名<br><br><span class="hljs-section">### Vue生命周期</span><br><br><span class="hljs-bullet">1.</span> 生命周期：<br><span class="hljs-bullet">    1.</span> 又名：生命周期回调函数、生命周期函数、生命周期钩子<br><span class="hljs-bullet">    2.</span> 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数<br><span class="hljs-bullet">    3.</span> 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的<br><span class="hljs-bullet">    4.</span> 生命周期函数中的this指向是vm 或 组件实例对象<br><span class="hljs-bullet">2.</span> 常用的生命周期钩子：<br><span class="hljs-bullet">    1.</span> mounted：发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作（如页面标签挂载后，启动定时器）<br><span class="hljs-bullet">    2.</span> beforeDestroy：清除定时器、解绑自定义事件、取消订阅消息等收尾工作<br><span class="hljs-bullet">3.</span> 销毁Vue实例：<br><span class="hljs-bullet">    1.</span> 销毁后借助Vue开发者工具看不到任何信息<br><span class="hljs-bullet">    2.</span> 销毁后自定义事件会失效，但原生DOM事件依然有效<br><span class="hljs-bullet">    3.</span> 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了<br><br><br><br><br><br><span class="hljs-section"># Vue组件化编程</span><br><br><span class="hljs-section">### 模块与组件、模块化与组件化</span><br><br><span class="hljs-bullet">-</span> 模块<br><br><span class="hljs-bullet">    -</span> 理解：向外提供特定功能的 js 程序，一般就是一个 js 文件<br><span class="hljs-bullet">    -</span> 为什么：js 文件很多很复杂<br><span class="hljs-bullet">    -</span> 作用：复用 js，简化 js 的编写，提高 js 运行效率<br><span class="hljs-bullet">-</span> 组件<br><span class="hljs-bullet">    -</span> 定义：用来实现局部功能的代码和资源的集合（html/css/js/image…）<br><span class="hljs-bullet">    -</span> 为什么：一个界面的功能很复杂<br><span class="hljs-bullet">    -</span> 作用：复用编码，简化项目编码，提高运行效率<br><span class="hljs-bullet">-</span> 模块化<br><span class="hljs-bullet">    -</span> 当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用<br><br><span class="hljs-bullet">-</span> 组件化<br><span class="hljs-bullet">    -</span> 当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用<br><br><br><br><span class="hljs-section">### Vue中使用组件的三大步骤</span><br><br><span class="hljs-bullet">1.</span> 定义组件(创建组件)<br><br><span class="hljs-bullet">2.</span> 注册组件<br><span class="hljs-bullet">3.</span> 使用组件(写组件标签)<br><br><span class="hljs-bullet">-</span> 如何定义一个组件？<br><span class="hljs-bullet">    -</span> 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的options几乎一样，但也有点区别：<br><br><span class="hljs-bullet">-</span> el不要写，为什么？<br><br><span class="hljs-bullet">    -</span> 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器<br><br><span class="hljs-bullet">-</span> data必须写成函数，为什么？<br><br><span class="hljs-bullet">    -</span> 避免组件被复用时，数据存在引用关系<br><br><span class="hljs-bullet">-</span> 如何注册组件？<br><br><span class="hljs-bullet">    -</span> 局部注册：new Vue的时候传入components选项<br><span class="hljs-bullet">    -</span> 全局注册：Vue.component(&#x27;组件名&#x27;,组件)<br><span class="hljs-bullet">-</span> 编写组件标签：<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span></span><br><br><br><br><span class="hljs-section">### 关于组件名</span><br><br><span class="hljs-strong">**一个单词组成**</span><br><br>第一种写法（首字母小写）：school<br><br>第二种写法（首字母大写）：School<br><br><span class="hljs-strong">**多个单词组成**</span><br><br>第一种写法（kebab-case命名）：my-school<br>第二种写法（CamelCase命名）：MySchool （需要Vue脚手架支持）<br><br><span class="hljs-quote">&gt; 备注：组件名尽可能回避HTML中已有的元素名称，</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; 例如：h2、H2都不行</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; options中可以使用name配置项指定组件在开发者工具中呈现的名字</span><br><br><span class="hljs-section">### 关于组件标签</span><br><br>第一种写法：<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span></span><br>第二种写法：<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>/&gt;</span></span><br><br><span class="hljs-quote">&gt; 备注：不使用脚手架时，<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>/&gt;</span></span>会导致后续组件不能渲染</span><br><span class="hljs-quote">&gt; 一个简写方式：const school = Vue.extend(options)可简写为：const school = options</span><br><br><br><br><br><br><span class="hljs-section">### 关于VueComponent</span><br><br>school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的<br><br>我们只需要写<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>/&gt;</span></span>或<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span></span>，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)<br><br>特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！<br><br><span class="hljs-strong">**关于this指向**</span><br><br><span class="hljs-bullet">-</span> 组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是VueComponent实例对象new<br><span class="hljs-bullet">-</span> Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是Vue实例对象<br><br>Vue的实例对象，以后简称vm。<br><br><span class="hljs-quote">&gt; VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; 只有在本笔记中VueComponent的实例对象才简称为vc</span><br><br><br><br><span class="hljs-section">### 一个重要的内置关系</span><br><br><span class="hljs-bullet">1.</span> 一个重要的内置关系：<span class="hljs-code">`VueComponent.prototype.__proto__ === Vue.prototype`</span><br><br><span class="hljs-code">    &gt; VueComponent（构造函数）的prototype（即VueComponent的原型对象）的_ _proto _ _(即Vue的原型对象) === Vue（构造函数）的 prototype（Vue的原型对象）</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">2.</span> 为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue 原型上的属性、方法<br><br><span class="hljs-code">    &gt; 访问实例对象vc的数据时，找不到会到vc的_ _proto _ _里面找，即找到Vue</span><br><span class="hljs-code"></span><br><span class="hljs-section"># Vue CLI</span><br><br><span class="hljs-bullet">1.</span> Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）<br><br><span class="hljs-bullet">2.</span> 步骤<br><br><span class="hljs-bullet">    -</span> 如果下载缓慢请配置 npm 淘宝镜像：npm config set registry http://registry.npm.taobao.org<br><br><span class="hljs-bullet">    -</span> 全局安装@vue/cli：npm install -g @vue/cli<br><br><span class="hljs-bullet">    -</span> 切换到你要创建项目的目录，然后使用命令创建项目：vue create xxxx<br><span class="hljs-bullet">    -</span> 选择使用vue的版本<br><br><span class="hljs-bullet">    -</span> 启动项目：npm run serve<br><br><span class="hljs-bullet">    -</span> 暂停项目：Ctrl+C<br><br><span class="hljs-code">    &gt; Vue 脚手架隐藏了所有 webpack 相关的配置，若想查看具体的 webpakc 配置，请执行：</span><br><span class="hljs-code">    &gt;</span><br><span class="hljs-code">    &gt; ```</span><br><span class="hljs-code">    &gt; vue inspect &gt; output.js</span><br><span class="hljs-code">    &gt; ```</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">3.</span> 脚手架文件结构<br><br><span class="hljs-code">    ```txt</span><br><span class="hljs-code">    .文件目录</span><br><span class="hljs-code">    ├── node_modules </span><br><span class="hljs-code">    ├── public</span><br><span class="hljs-code">    │   ├── favicon.ico: 页签图标</span><br><span class="hljs-code">    │   └── index.html: 主页面</span><br><span class="hljs-code">    ├── src</span><br><span class="hljs-code">    │   ├── assets: 存放静态资源</span><br><span class="hljs-code">    │   │   └── logo.png</span><br><span class="hljs-code">    │   │── component: 存放组件</span><br><span class="hljs-code">    │   │   └── HelloWorld.vue</span><br><span class="hljs-code">    │   │── App.vue: 汇总所有组件</span><br><span class="hljs-code">    │   └── main.js: 入口文件</span><br><span class="hljs-code">    ├── .gitignore: git版本管制忽略的配置</span><br><span class="hljs-code">    ├── babel.config.js: babel的配置文件</span><br><span class="hljs-code">    ├── package.json: 应用包配置文件 </span><br><span class="hljs-code">    ├── README.md: 应用描述文件</span><br><span class="hljs-code">    └── package-lock.json: 包版本控制文件</span><br><span class="hljs-code">    ```</span><br><span class="hljs-code"></span><br><span class="hljs-code">    </span><br><span class="hljs-code"></span><br><span class="hljs-section">### Vue的不同版本js</span><br><br><span class="hljs-strong">**vue.js 与 vue.runtime.xxx.js的区别**</span><br><br><span class="hljs-bullet">-</span> vue.js 是完整版的 Vue，包含：核心功能+模板解析器<br><br><span class="hljs-bullet">-</span> vue.runtime.xxx.js 是运行版的 Vue，只包含核心功能，没有模板解析器。<br><br><span class="hljs-code">    &gt; 因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 配置项，</span><br><span class="hljs-code">    &gt;</span><br><span class="hljs-code">    &gt; 需要使用 render函数接收到的createElement 函数去指定具体内容</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantLock</title>
    <link href="/2021/04/06/JUC/ReentrantLock/"/>
    <url>/2021/04/06/JUC/ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h3 id="ReentrantLock-是什么？"><a href="#ReentrantLock-是什么？" class="headerlink" title="ReentrantLock 是什么？"></a>ReentrantLock 是什么？</h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p><h3 id="公平锁和非公平锁有什么区别？"><a href="#公平锁和非公平锁有什么区别？" class="headerlink" title="公平锁和非公平锁有什么区别？"></a>公平锁和非公平锁有什么区别？</h3><ul><li><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h3 id="synchronized-和-ReentrantLock-有什么区别？"><a href="#synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="synchronized 和 ReentrantLock 有什么区别？"></a>synchronized 和 ReentrantLock 有什么区别？</h3><h4 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h4><p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p><p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p><p>在下面的代码中，<code>method1()</code> 和 <code>method2()</code>都被 <code>synchronized</code> 关键字修饰，<code>method1()</code>调用了<code>method2()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法1&quot;</span>);<br>        method2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>synchronized</code>锁是可重入的，同一个线程在调用<code>method1()</code> 时可以直接获得当前对象的锁，执行 <code>method2()</code> 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如<code>synchronized</code>是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 <code>method2()</code>时获取锁失败，会出现死锁问题。</p><h4 id="synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h4><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p><p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><h4 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h4><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><p>如果你想使用上述功能，那么选择 <code>ReentrantLock</code> 是一个不错的选择。</p><p>关于 <code>Condition</code>接口的补充：</p><blockquote><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p></blockquote><h3 id="可中断锁和不可中断锁有什么区别？"><a href="#可中断锁和不可中断锁有什么区别？" class="headerlink" title="可中断锁和不可中断锁有什么区别？"></a>可中断锁和不可中断锁有什么区别？</h3><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB的include方法踩坑</title>
    <link href="/2021/04/06/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/mongo%E7%9A%84include%E6%96%B9%E6%B3%95%E8%B8%A9%E5%9D%91/"/>
    <url>/2021/04/06/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/mongo%E7%9A%84include%E6%96%B9%E6%B3%95%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>又是不认识自己代码的一天</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Query</span> query = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Query</span>();<br><span class="hljs-keyword">if</span>(<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isNotNull</span>(reqVO.<span class="hljs-title function_">getFieldLimitList</span>()) &amp;&amp; reqVO.<span class="hljs-title function_">getFieldLimitList</span>().<span class="hljs-title function_">size</span>() &gt; <span class="hljs-number">0</span>)&#123;<br>    <br><span class="hljs-keyword">for</span>(<span class="hljs-title class_">String</span> filedName : reqVO.<span class="hljs-title function_">getFieldLimitList</span>())&#123;<br>    <br>query.<span class="hljs-title function_">fields</span>().<span class="hljs-title function_">include</span>(filedName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到 <strong>query.fields().include(filedName);</strong> 这行代码，</p><p><strong>以为效果是</strong>： 如果数据没有这个字段就把这条数据筛掉，加上自己当时写的注释有歧义，所以误解了。</p><p><strong>实际效果是</strong>： include只是对返回的结果集进行了处理，使得只返回结果集的某些字段，并不会减少结果。</p><p>如果需要查询时，不返回某字段为空的数据，正确做法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Query</span> query = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Query</span>();<br><span class="hljs-keyword">if</span>(<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isNotNull</span>(reqVO.<span class="hljs-title function_">getFieldLimitList</span>()) &amp;&amp; reqVO.<span class="hljs-title function_">getFieldLimitList</span>().<span class="hljs-title function_">size</span>() &gt; <span class="hljs-number">0</span>)&#123;<br>    <br>query.<span class="hljs-title function_">addCriteria</span>(<span class="hljs-title class_">Criteria</span>.<span class="hljs-title function_">where</span>(<span class="hljs-title class_">MongoConsts</span>.<span class="hljs-property">fieldName</span>).<span class="hljs-title function_">exists</span>(<span class="hljs-literal">true</span>));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2021/04/06/DB/MySQL/1.%20MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/06/DB/MySQL/1.%20MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h2><h3 id="什么是关系型数据库？"><a href="#什么是关系型数据库？" class="headerlink" title="什么是关系型数据库？"></a>什么是关系型数据库？</h3><p>关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><p><img src="https://oss.javaguide.cn/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="关系型数据库表关系"></p><center>关系型数据库表关系</center><p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</p><p><strong>有哪些常见的关系型数据库呢？</strong></p><p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ……。</p><h3 id="什么是-SQL？"><a href="#什么是-SQL？" class="headerlink" title="什么是 SQL？"></a>什么是 SQL？</h3><p>SQL 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。</p><p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，<strong>一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</strong></p><p>SQL 可以帮助我们：</p><ul><li>新建数据库、数据表、字段；</li><li>在数据库中增加，删除，修改，查询数据；</li><li>新建视图、函数、存储过程；</li><li>对数据库中的数据进行简单的数据分析；</li><li>搭配 Hive，Spark SQL 做大数据；</li><li>搭配 SQLFlow 做机器学习；</li><li>……</li></ul><h3 id="什么是-MySQL？"><a href="#什么是-MySQL？" class="headerlink" title="什么是 MySQL？"></a>什么是 MySQL？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/csdn/20210327143351823.png" alt="img"></p><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储数据。</strong></p><p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。MySQL 的默认端口号是<strong>3306</strong>。</p><h3 id="MySQL-有什么优点？MySQL-如此流行的原因"><a href="#MySQL-有什么优点？MySQL-如此流行的原因" class="headerlink" title="MySQL 有什么优点？MySQL 如此流行的原因"></a>MySQL 有什么优点？MySQL 如此流行的原因</h3><p>MySQL 主要具有下面这些优点：</p><ol><li>成熟稳定，功能完善。</li><li>开源免费。</li><li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li>开箱即用，操作简单，维护成本低。</li><li>兼容性好，支持常见的操作系统，支持多种开发语言。</li><li>社区活跃，生态完善。</li><li>事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li>支持分库分表、读写分离、高可用。</li></ol><h2 id="MySQL-字段类型"><a href="#MySQL-字段类型" class="headerlink" title="MySQL 字段类型"></a>MySQL 字段类型</h2><p>MySQL 字段类型可以简单分为三大类：</p><ul><li><strong>数值类型</strong>：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）</li><li><strong>字符串类型</strong>：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。</li><li><strong>日期时间类型</strong>：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。</li></ul><p>下面这张图不是我画的，忘记是从哪里保存下来的了，总结的还蛮不错的。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/image-20240228194855612.png" alt="image-20240228194855612"></p><center>MySQL 常见字段类型总结</center><h3 id="整数类型的-UNSIGNED-属性有什么用？"><a href="#整数类型的-UNSIGNED-属性有什么用？" class="headerlink" title="整数类型的 UNSIGNED 属性有什么用？"></a>整数类型的 UNSIGNED 属性有什么用？</h3><p>MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来表示不允许负值的无符号整数。使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p><p>例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 2,147,483,648 ~ 2,147,483,647。</p><p>对于从 0 开始递增的 ID 列，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p><h3 id="CHAR-和-VARCHAR-的区别是什么？"><a href="#CHAR-和-VARCHAR-的区别是什么？" class="headerlink" title="#CHAR 和 VARCHAR 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>CHAR 和 VARCHAR 的区别是什么？</h3><p>CHAR 和 VARCHAR 是最常用到的字符串类型，两者的主要区别在于：<strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p><p>CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</p><p>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</p><p>CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</p><h3 id="VARCHAR-100-和-VARCHAR-10-的区别是什么？"><a href="#VARCHAR-100-和-VARCHAR-10-的区别是什么？" class="headerlink" title="#VARCHAR(100)和 VARCHAR(10)的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#varchar-100-%E5%92%8C-varchar-10-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>VARCHAR(100)和 VARCHAR(10)的区别是什么？</h3><p>VARCHAR(100)和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，VARCHAR (100) 可以满足更大范围的字符存储需求，有更好的业务拓展性。而 VARCHAR(10)存储超过 10 个字符时，就需要修改表结构才可以。</p><p>虽说 VARCHAR(100)和 VARCHAR(10)能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p><p>不过，VARCHAR(100) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR(100)是按照 100 这个长度来进行的，也就会消耗更多内存。</p><h3 id="DECIMAL-和-FLOAT-DOUBLE-的区别是什么？"><a href="#DECIMAL-和-FLOAT-DOUBLE-的区别是什么？" class="headerlink" title="#DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#decimal-%E5%92%8C-float-double-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</h3><p>DECIMAL 和 FLOAT 的区别是：<strong>DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT&#x2F;DOUBLE 只能存储近似的小数值。</strong></p><p>DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。</p><p>在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类 <code>java.math.BigDecimal</code>。</p><h3 id="为什么不推荐使用-TEXT-和-BLOB？"><a href="#为什么不推荐使用-TEXT-和-BLOB？" class="headerlink" title="#为什么不推荐使用 TEXT 和 BLOB？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-text-%E5%92%8C-blob">#</a>为什么不推荐使用 TEXT 和 BLOB？</h3><p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据，例如博客内容。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>0-255 字节</td><td>一般文本字符串</td></tr><tr><td>TEXT</td><td>0-65,535 字节</td><td>长文本字符串</td></tr><tr><td>MEDIUMTEXT</td><td>0-16,772,150 字节</td><td>较大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4,294,967,295 字节</td><td>极大文本数据</td></tr></tbody></table><p>BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>0-255 字节</td><td>短文本二进制字符串</td></tr><tr><td>BLOB</td><td>0-65KB</td><td>二进制字符串</td></tr><tr><td>MEDIUMBLOB</td><td>0-16MB</td><td>二进制形式的长文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4GB</td><td>二进制形式的极大文本数据</td></tr></tbody></table><p>在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT。</p><p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p><ul><li>不能有默认值。</li><li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。</li><li>检索效率较低。</li><li>不能直接创建索引，需要指定前缀长度。</li><li>可能会消耗大量的网络和 IO 带宽。</li><li>可能导致表上的 DML 操作变慢。</li><li>……</li></ul><h3 id="DATETIME-和-TIMESTAMP-的区别是什么？"><a href="#DATETIME-和-TIMESTAMP-的区别是什么？" class="headerlink" title="#DATETIME 和 TIMESTAMP 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#datetime-%E5%92%8C-timestamp-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>DATETIME 和 TIMESTAMP 的区别是什么？</h3><p>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。</p><p>TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p><ul><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><p>关于两者的详细对比，请参考我写的<a href="https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html">MySQL 时间类型数据存储建议</a>。</p><h3 id="NULL-和-‘’-的区别是什么？"><a href="#NULL-和-‘’-的区别是什么？" class="headerlink" title="#NULL 和 ‘’ 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#null-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>NULL 和 ‘’ 的区别是什么？</h3><p><code>NULL</code> 跟 <code>&#39;&#39;</code>(空字符串)是两个完全不一样的值，区别如下：</p><ul><li><code>NULL</code> 代表一个不确定的值,就算是两个 <code>NULL</code>,它俩也不一定相等。例如，<code>SELECT NULL=NULL</code>的结果为 false，但是在我们使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时,<code>NULL</code>又被认为是相等的。</li><li><code>&#39;&#39;</code>的长度是 0，是不占用空间的，而<code>NULL</code> 是需要占用空间的。</li><li><code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li><li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li></ul><p>看了上面的介绍之后，相信你对另外一个高频面试题：“为什么 MySQL 不建议使用 <code>NULL</code> 作为列默认值？”也有了答案。</p><h3 id="Boolean-类型如何表示？"><a href="#Boolean-类型如何表示？" class="headerlink" title="#Boolean 类型如何表示？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#boolean-%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA">#</a>Boolean 类型如何表示？</h3><p>MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。</p><h2 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="#MySQL 基础架构"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84">#</a>MySQL 基础架构</h2><blockquote><p>  建议配合 <a href="https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。另外，“一个 SQL 语句在 MySQL 中的执行流程”也是面试中比较常问的一个问题。</p></blockquote><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p><p><img src="https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png" alt="img"></p><p>从上图可以看出， MySQL 主要由下面几部分构成：</p><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="#MySQL 存储引擎"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">#</a>MySQL 存储引擎</h2><p>MySQL 核心在于存储引擎，想要深入学习 MySQL，必定要深入研究 MySQL 存储引擎。</p><h3 id="MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="#MySQL 支持哪些存储引擎？默认使用哪个？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA">#</a>MySQL 支持哪些存储引擎？默认使用哪个？</h3><p>MySQL 支持多种存储引擎，你可以通过 <code>SHOW ENGINES</code> 命令来查看 MySQL 支持的所有存储引擎。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510105408703.png" alt="查看 MySQL 提供的所有存储引擎">查看 MySQL 提供的所有存储引擎</p><p>从上图我们可以查看出， MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p><p>我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。</p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>你可以通过 <code>SELECT VERSION()</code> 命令查看你的 MySQL 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; SELECT VERSION();<br>+-----------+<br>| VERSION() |<br>+-----------+<br>| 8.0.27    |<br>+-----------+<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><p>你也可以通过 <code>SHOW VARIABLES LIKE &#39;%storage_engine%&#39;</code> 命令直接查看 MySQL 当前默认的存储引擎。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; SHOW VARIABLES  LIKE <span class="hljs-string">&#x27;%storage_engine%&#x27;</span>;<br>+---------------------------------+-----------+<br>| Variable_name                   | Value     |<br>+---------------------------------+-----------+<br>| default_storage_engine          | InnoDB    |<br>| default_tmp_storage_engine      | InnoDB    |<br>| disabled_storage_engines        |           |<br>| internal_tmp_mem_storage_engine | TempTable |<br>+---------------------------------+-----------+<br>4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><p>如果你想要深入了解每个存储引擎以及它们之间的区别，推荐你去阅读以下 MySQL 官方文档对应的介绍(面试不会问这么细，了解即可)：</p><ul><li>InnoDB 存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.htmlopen in new window</a> 。</li><li>其他存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">https://dev.mysql.com/doc/refman/8.0/en/storage-engines.htmlopen in new window</a> 。</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510155143458.png" alt="img"></p><h3 id="MySQL-存储引擎架构了解吗？"><a href="#MySQL-存储引擎架构了解吗？" class="headerlink" title="#MySQL 存储引擎架构了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97">#</a>MySQL 存储引擎架构了解吗？</h3><p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><p>并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。</p><p>MySQL 官方文档也有介绍到如何编写一个自定义存储引擎，地址：<a href="https://dev.mysql.com/doc/internals/en/custom-engine.html">https://dev.mysql.com/doc/internals/en/custom-engine.htmlopen in new window</a> 。</p><h3 id="MyISAM-和-InnoDB-有什么区别？"><a href="#MyISAM-和-InnoDB-有什么区别？" class="headerlink" title="#MyISAM 和 InnoDB 有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#myisam-%E5%92%8C-innodb-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>MyISAM 和 InnoDB 有什么区别？</h3><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p><p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>言归正传！咱们下面还是来简单对比一下两者：</p><p><strong>1.是否支持行级锁</strong></p><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p><p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解</a>。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510090309427.png" alt="img"></p><p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p><p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p><p><strong>6.索引实现不一样。</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><p>详细区别，推荐你看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解</a>。</p><p><strong>7.性能有差别。</strong></p><p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/innodb-myisam-performance-comparison.png" alt="InnoDB 和 MyISAM 性能对比">InnoDB 和 MyISAM 性能对比</p><p><strong>总结</strong>：</p><ul><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大。</li></ul><p>最后，再分享一张图片给你，这张图片详细对比了常见的几种 MySQL 存储引擎。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/comparison-of-common-mysql-storage-engines.png" alt="常见的几种 MySQL 存储引擎对比">常见的几种 MySQL 存储引擎对比</p><h3 id="MyISAM-和-InnoDB-如何选择？"><a href="#MyISAM-和-InnoDB-如何选择？" class="headerlink" title="#MyISAM 和 InnoDB 如何选择？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#myisam-%E5%92%8C-innodb-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">#</a>MyISAM 和 InnoDB 如何选择？</h3><p>大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。</p><p>《MySQL 高性能》上面有一句话这样写到:</p><blockquote><p>  不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p></blockquote><p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p><p>因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。</p><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="#MySQL 索引"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%B4%A2%E5%BC%95">#</a>MySQL 索引</h2><p>MySQL 索引相关的问题比较多，对于面试和工作都比较重要，于是，我单独抽了一篇文章专门来总结 MySQL 索引相关的知识点和问题：<a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解</a> 。</p><h2 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="#MySQL 查询缓存"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98">#</a>MySQL 查询缓存</h2><p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p><p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">query_cache_type</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">query_cache_size</span>=<span class="hljs-string">600000</span><br></code></pre></td></tr></table></figure><p>MySQL 执行以下命令也可以开启查询缓存</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">set</span> <span class="hljs-string">global  query_cache_type=1;</span><br><span class="hljs-attr">set</span> <span class="hljs-string">global  query_cache_size=600000;</span><br></code></pre></td></tr></table></figure><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p><p><strong>查询缓存不命中的情况：</strong></p><ol><li>任何两个查询在任何字符上的不同都会导致缓存不命中。</li><li>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li><li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li></ol><p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 <code>sql_cache</code> 和 <code>sql_no_cache</code> 来控制某个查询语句是否需要缓存：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sql_no_cache <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> usr;<br></code></pre></td></tr></table></figure><h2 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="#MySQL 日志"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%97%A5%E5%BF%97">#</a>MySQL 日志</h2><p>MySQL 日志常见的面试题有：</p><ul><li>MySQL 中常见的日志有哪些？</li><li>慢查询日志有什么用？</li><li>binlog 主要记录了什么？</li><li>redo log 如何保证事务的持久性？</li><li>页修改之后为什么不直接刷盘呢？</li><li>binlog 和 redolog 有什么区别？</li><li>undo log 如何保证事务的原子性？</li><li>……</li></ul><p>上诉问题的答案可以在<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》(付费)</a> 的 <strong>「技术面试题篇」</strong> 中找到。</p><p><img src="https://oss.javaguide.cn/javamianshizhibei/technical-interview-questions.png" alt="《Java 面试指北》技术面试题篇">《Java 面试指北》技术面试题篇</p><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="#MySQL 事务"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E4%BA%8B%E5%8A%A1">#</a>MySQL 事务</h2><h3 id="何谓事务？"><a href="#何谓事务？" class="headerlink" title="#何谓事务？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%BD%95%E8%B0%93%E4%BA%8B%E5%8A%A1">#</a>何谓事务？</h3><p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p><ul><li>数据库中途突然因为某些原因挂掉了。</li><li>客户端突然因为网络原因连接不上数据库了。</li><li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li><li>……</li></ul><p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p><ol><li>将小明的余额减少 1000 元</li><li>将小红的余额增加 1000 元。</li></ol><p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="事务示意图">事务示意图</p><h3 id="何谓数据库事务？"><a href="#何谓数据库事务？" class="headerlink" title="#何谓数据库事务？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%BD%95%E8%B0%93%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1">#</a>何谓数据库事务？</h3><p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p><p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p><p><strong>那数据库事务有什么作用呢？</strong></p><p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 开启一个事务<br><span class="hljs-keyword">START</span> TRANSACTION;<br># 多条 <span class="hljs-keyword">SQL</span> 语句<br>SQL1,SQL2...<br>## 提交事务<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="数据库事务示意图">数据库事务示意图</p><p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/ACID.png" alt="ACID">ACID</p><ol><li><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong> 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课<a href="https://time.geekbang.org/opencourse/intro/100064201">《周志明的软件架构课》open in new window</a>才搞清楚的（多看好书！！！）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/AID-%3EC.png" alt="AID-&gt;C">AID-&gt;C</p><p>另外，DDIA 也就是 <a href="https://book.douban.com/subject/30329536/">《Designing Data-Intensive Application（数据密集型应用系统设计）》open in new window</a> 的作者在他的这本书中如是说：</p><blockquote><p>  Atomicity, isolation, and durability are properties of the database, whereas consis‐ tency (in the ACID sense) is a property of the application. The application may rely on the database’s atomicity and isolation properties in order to achieve consistency, but it’s not up to the database alone.</p><p>  翻译过来的意思是：原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。</p></blockquote><p>《Designing Data-Intensive Application（数据密集型应用系统设计）》这本书强推一波，值得读很多遍！豆瓣有接近 90% 的人看了这本书之后给了五星好评。另外，中文翻译版本已经在 GitHub 开源，地址：<a href="https://github.com/Vonng/ddia">https://github.com/Vonng/ddiaopen in new window</a> 。</p><p><img src="https://oss.javaguide.cn/github/javaguide/books/ddia.png" alt="img"></p><h3 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="#并发事务带来了哪些问题?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">#</a>并发事务带来了哪些问题?</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><h4 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="#脏读（Dirty read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%84%8F%E8%AF%BB-dirty-read">#</a>脏读（Dirty read）</h4><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 读取到 A &#x3D; 19,事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading-ee15b0b9.png" alt="脏读">脏读</p><h4 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="#丢失修改（Lost to modify）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9-lost-to-modify">#</a>丢失修改（Lost to modify）</h4><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 先修改 A&#x3D;A-1，事务 2 后来也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-missing-modifications-5b2e2bd8.png" alt="丢失修改">丢失修改</p><h4 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="#不可重复读（Unrepeatable read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-unrepeatable-read">#</a>不可重复读（Unrepeatable read）</h4><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 再次读取 A &#x3D;19，此时读取的结果和第一次读取的结果不同。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-unrepeatable-read-ff9186e1.png" alt="不可重复读">不可重复读</p><h4 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="#幻读（Phantom read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%BB%E8%AF%BB-phantom-read">#</a>幻读（Phantom read）</h4><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-phantom-read-7cba7a85.png" alt="幻读">幻读</p><h3 id="不可重复读和幻读有什么区别？"><a href="#不可重复读和幻读有什么区别？" class="headerlink" title="#不可重复读和幻读有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>不可重复读和幻读有什么区别？</h3><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h3 id="并发事务的控制方式有哪些？"><a href="#并发事务的控制方式有哪些？" class="headerlink" title="#并发事务的控制方式有哪些？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>并发事务的控制方式有哪些？</h3><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p><p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p><p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul><p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html">InnoDB 存储引擎对 MVCC 的实现</a> 。</p><h3 id="SQL-标准定义了哪些事务隔离级别"><a href="#SQL-标准定义了哪些事务隔离级别" class="headerlink" title="#SQL 标准定义了哪些事务隔离级别?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#sql-%E6%A0%87%E5%87%86%E5%AE%9A%E4%B9%89%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">#</a>SQL 标准定义了哪些事务隔离级别?</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h3 id="MySQL-的隔离级别是基于锁实现的吗？"><a href="#MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="#MySQL 的隔离级别是基于锁实现的吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97">#</a>MySQL 的隔离级别是基于锁实现的吗？</h3><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h3 id="MySQL-的默认隔离级别是什么"><a href="#MySQL-的默认隔离级别是什么" class="headerlink" title="#MySQL 的默认隔离级别是什么?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>MySQL 的默认隔离级别是什么?</h3><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@tx_isolation</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@tx_isolation</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br></code></pre></td></tr></table></figure><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解</a>。</p><h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="#MySQL 锁"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E9%94%81">#</a>MySQL 锁</h2><p>锁是一种常见的并发事务的控制方式。</p><h3 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="#表级锁和行级锁了解吗？有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>表级锁和行级锁了解吗？有什么区别？</h3><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p><p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p><p><strong>表级锁和行级锁对比</strong>：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li></ul><h3 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="#行级锁的使用有什么注意事项？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">#</a>行级锁的使用有什么注意事项？</h3><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p><p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p><h3 id="InnoDB-有哪几类行锁？"><a href="#InnoDB-有哪几类行锁？" class="headerlink" title="#InnoDB 有哪几类行锁？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#innodb-%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BB%E8%A1%8C%E9%94%81">#</a>InnoDB 有哪几类行锁？</h3><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p><p>一些大厂面试中可能会问到 Next-Key Lock 的加锁范围，这里推荐一篇文章：<a href="https://segmentfault.com/a/1190000040129107">MySQL next-key lock 加锁范围是什么？ - 程序员小航 - 2021open in new window</a> 。</p><h3 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="#共享锁和排他锁呢？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81%E5%91%A2">#</a>共享锁和排他锁呢？</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th align="left"></th><th align="left">S 锁</th><th align="left">X 锁</th></tr></thead><tbody><tr><td align="left">S 锁</td><td align="left">不冲突</td><td align="left">冲突</td></tr><tr><td align="left">X 锁</td><td align="left">冲突</td><td align="left">冲突</td></tr></tbody></table><p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 共享锁 可以在 MySQL <span class="hljs-number">5.7</span> 和 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 共享锁 可以在 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> SHARE;<br># 排他锁<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><h3 id="意向锁有什么作用？"><a href="#意向锁有什么作用？" class="headerlink" title="#意向锁有什么作用？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E6%84%8F%E5%90%91%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">#</a>意向锁有什么作用？</h3><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p><p>意向锁是表级锁，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><p>《MySQL 技术内幕 InnoDB 存储引擎》这本书对应的描述应该是笔误了。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220511171419081.png" alt="img"></p><h3 id="当前读和快照读有什么区别？"><a href="#当前读和快照读有什么区别？" class="headerlink" title="#当前读和快照读有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>当前读和快照读有什么区别？</h3><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span><br># 共享锁 可以在 MySQL <span class="hljs-number">5.7</span> 和 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 共享锁 可以在 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> SHARE;<br></code></pre></td></tr></table></figure><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p><p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p><p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><p>当前读的一些常见 SQL 语句类型如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 对读的记录加一个X锁<br>SELECT...FOR <span class="hljs-keyword">UPDATE</span><br># 对读的记录加一个S锁<br>SELECT...LOCK <span class="hljs-keyword">IN</span> SHARE MODE<br># 对读的记录加一个S锁<br>SELECT...FOR SHARE<br># 对修改的记录加一个X锁<br>INSERT...<br>UPDATE...<br>DELETE...<br></code></pre></td></tr></table></figure><h3 id="自增锁有了解吗？"><a href="#自增锁有了解吗？" class="headerlink" title="#自增锁有了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%87%AA%E5%A2%9E%E9%94%81%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97">#</a>自增锁有了解吗？</h3><blockquote><p>  不太重要的一个知识点，简单了解即可。</p></blockquote><p>关系型数据库设计表的时候，通常会有一列作为自增主键。InnoDB 中的自增主键会涉及一种比较特殊的表级锁— <strong>自增锁（AUTO-INC Locks）</strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `sequence_id` (<br>  `id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `stub` <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `stub` (`stub`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br></code></pre></td></tr></table></figure><p>更准确点来说，不仅仅是自增主键，<code>AUTO_INCREMENT</code>的列都会涉及到自增锁，毕竟非主键也可以设置自增长。</p><p>如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住。这里的阻塞行为只是自增锁行为的其中一种，可以理解为自增锁就是一个接口，其具体的实现有多种。具体的配置项为 <code>innodb_autoinc_lock_mode</code> （MySQL 5.1.22 引入），可以选择的值如下：</p><table><thead><tr><th align="left">innodb_autoinc_lock_mode</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">传统模式</td></tr><tr><td align="left">1</td><td align="left">连续模式（MySQL 8.0 之前默认）</td></tr><tr><td align="left">2</td><td align="left">交错模式(MySQL 8.0 之后默认)</td></tr></tbody></table><p>交错模式下，所有的“INSERT-LIKE”语句（所有的插入语句，包括：<code>INSERT</code>、<code>REPLACE</code>、<code>INSERT…SELECT</code>、<code>REPLACE…SELECT</code>、<code>LOAD DATA</code>等）都不使用表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行，速度更快，扩展性也更好。</p><p>不过，如果你的 MySQL 数据库有主从同步需求并且 Binlog 存储格式为 Statement 的话，不要将 InnoDB 自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序就无法得到保障。</p><blockquote><p>  如果 MySQL 采用的格式为 Statement ，那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。</p></blockquote><p>最后，再推荐一篇文章：<a href="https://draveness.me/whys-the-design-mysql-auto-increment/">为什么 MySQL 的自增主键不单调也不连续open in new window</a> 。</p><h2 id="MySQL-性能优化"><a href="#MySQL-性能优化" class="headerlink" title="#MySQL 性能优化"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">#</a>MySQL 性能优化</h2><p>关于 MySQL 性能优化的建议总结，请看这篇文章：<a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html">MySQL 高性能优化规范建议总结</a> 。</p><h3 id="能用-MySQL-直接存储文件（比如图片）吗？"><a href="#能用-MySQL-直接存储文件（比如图片）吗？" class="headerlink" title="#能用 MySQL 直接存储文件（比如图片）吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%83%BD%E7%94%A8-mysql-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6-%E6%AF%94%E5%A6%82%E5%9B%BE%E7%89%87-%E5%90%97">#</a>能用 MySQL 直接存储文件（比如图片）吗？</h3><p>可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。</p><p>可以选择使用云服务厂商提供的开箱即用的文件存储服务，成熟稳定，价格也比较低。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/oss-search.png" alt="img"></p><p>也可以选择自建文件存储服务，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。</p><p><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p><p>相关阅读：<a href="https://www.51cto.com/article/716978.html">Spring Boot 整合 MinIO 实现分布式文件服务open in new window</a> 。</p><h3 id="MySQL-如何存储-IP-地址？"><a href="#MySQL-如何存储-IP-地址？" class="headerlink" title="#MySQL 如何存储 IP 地址？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8-ip-%E5%9C%B0%E5%9D%80">#</a>MySQL 如何存储 IP 地址？</h3><p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li><li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><h3 id="有哪些常见的-SQL-优化手段？"><a href="#有哪些常见的-SQL-优化手段？" class="headerlink" title="#有哪些常见的 SQL 优化手段？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84-sql-%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5">#</a>有哪些常见的 SQL 优化手段？</h3><p><a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》(付费)</a> 的 <strong>「技术面试题篇」</strong> 有一篇文章详细介绍了常见的 SQL 优化手段，非常全面，清晰易懂！</p><p><img src="https://oss.javaguide.cn/javamianshizhibei/javamianshizhibei-sql-optimization.png" alt="常见的 SQL 优化手段">常见的 SQL 优化手段</p><h3 id="如何分析-SQL-的性能？"><a href="#如何分析-SQL-的性能？" class="headerlink" title="#如何分析 SQL 的性能？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-sql-%E7%9A%84%E6%80%A7%E8%83%BD">#</a>如何分析 SQL 的性能？</h3><p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 适用于 <code>SELECT</code>, <code>DELETE</code>, <code>INSERT</code>, <code>REPLACE</code>, 和 <code>UPDATE</code>语句，我们一般分析 <code>SELECT</code> 查询较多。</p><p>我们这里简单来演示一下 <code>EXPLAIN</code> 的使用。</p><p><code>EXPLAIN</code> 的输出格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> `score`,`name` <span class="hljs-keyword">FROM</span> `cus_order` <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `score` <span class="hljs-keyword">DESC</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>     <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>   <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> cus_order <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">997572</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> filesort <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>各个字段的含义如下：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的序列标识符</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询类型</td></tr><tr><td>table</td><td>用到的表名</td></tr><tr><td>partitions</td><td>匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td>type</td><td>表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际用到的索引</td></tr><tr><td>key_len</td><td>所选索引的长度</td></tr><tr><td>ref</td><td>当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><p>篇幅问题，我这里只是简单介绍了一下 MySQL 执行计划，详细介绍请看：<a href="https://javaguide.cn/database/mysql/mysql-query-execution-plan.html">SQL 的执行计划</a>这篇文章。</p><h3 id="读写分离和分库分表了解吗？"><a href="#读写分离和分库分表了解吗？" class="headerlink" title="#读写分离和分库分表了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%92%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BA%86%E8%A7%A3%E5%90%97">#</a>读写分离和分库分表了解吗？</h3><p>读写分离和分库分表相关的问题比较多，于是，我单独写了一篇文章来介绍：<a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html">读写分离和分库分表详解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2021/04/06/DB/MySQL/10.%20MYSQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2021/04/06/DB/MySQL/10.%20MYSQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-性能优化"><a href="#MySQL-性能优化" class="headerlink" title="MySQL 性能优化"></a>MySQL 性能优化</h2>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL高性能优化规范建议总结</title>
    <link href="/2021/04/06/DB/MySQL/11.%20MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/06/DB/MySQL/11.%20MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h2><ul><li>所有数据库对象名称必须使用小写字母并用下划线分割</li><li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li><li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li><li>临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀，备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀</li><li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li></ul><h2 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="#数据库基本设计规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">#</a>数据库基本设计规范</h2><h3 id="所有表必须使用-InnoDB-存储引擎"><a href="#所有表必须使用-InnoDB-存储引擎" class="headerlink" title="#所有表必须使用 InnoDB 存储引擎"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%89%80%E6%9C%89%E8%A1%A8%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">#</a>所有表必须使用 InnoDB 存储引擎</h3><p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。</p><p>InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p><h3 id="数据库和表的字符集统一使用-UTF8"><a href="#数据库和表的字符集统一使用-UTF8" class="headerlink" title="#数据库和表的字符集统一使用 UTF8"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8-utf8">#</a>数据库和表的字符集统一使用 UTF8</h3><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p><p>推荐阅读一下我写的这篇文章：<a href="https://javaguide.cn/database/character-set.html">MySQL 字符集详解</a> 。</p><h3 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="#所有表和字段都需要添加注释"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%89%80%E6%9C%89%E8%A1%A8%E5%92%8C%E5%AD%97%E6%AE%B5%E9%83%BD%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A">#</a>所有表和字段都需要添加注释</h3><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p><h3 id="尽量控制单表数据量的大小，建议控制在-500-万以内"><a href="#尽量控制单表数据量的大小，建议控制在-500-万以内" class="headerlink" title="#尽量控制单表数据量的大小，建议控制在 500 万以内"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%B0%BD%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E8%A1%A8%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%A4%A7%E5%B0%8F-%E5%BB%BA%E8%AE%AE%E6%8E%A7%E5%88%B6%E5%9C%A8-500-%E4%B8%87%E4%BB%A5%E5%86%85">#</a>尽量控制单表数据量的大小，建议控制在 500 万以内</h3><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p><h3 id="谨慎使用-MySQL-分区表"><a href="#谨慎使用-MySQL-分区表" class="headerlink" title="#谨慎使用 MySQL 分区表"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8-mysql-%E5%88%86%E5%8C%BA%E8%A1%A8">#</a>谨慎使用 MySQL 分区表</h3><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p><p>谨慎选择分区键，跨分区查询效率可能更低；</p><p>建议采用物理分表的方式管理大数据。</p><h3 id="经常一起使用的列放到一个表中"><a href="#经常一起使用的列放到一个表中" class="headerlink" title="#经常一起使用的列放到一个表中"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%BB%8F%E5%B8%B8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%97%E6%94%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%A1%A8%E4%B8%AD">#</a>经常一起使用的列放到一个表中</h3><p>避免更多的关联操作。</p><h3 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="#禁止在表中建立预留字段"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E5%9C%A8%E8%A1%A8%E4%B8%AD%E5%BB%BA%E7%AB%8B%E9%A2%84%E7%95%99%E5%AD%97%E6%AE%B5">#</a>禁止在表中建立预留字段</h3><ul><li>预留字段的命名很难做到见名识义。</li><li>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</li><li>对预留字段类型的修改，会对表进行锁定。</li></ul><h3 id="禁止在数据库中存储文件（比如图片）这类大的二进制数据"><a href="#禁止在数据库中存储文件（比如图片）这类大的二进制数据" class="headerlink" title="#禁止在数据库中存储文件（比如图片）这类大的二进制数据"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6-%E6%AF%94%E5%A6%82%E5%9B%BE%E7%89%87-%E8%BF%99%E7%B1%BB%E5%A4%A7%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE">#</a>禁止在数据库中存储文件（比如图片）这类大的二进制数据</h3><p>在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。</p><p>文件（比如图片）这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息。</p><h3 id="不要被数据库范式所束缚"><a href="#不要被数据库范式所束缚" class="headerlink" title="#不要被数据库范式所束缚"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E4%B8%8D%E8%A6%81%E8%A2%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E6%89%80%E6%9D%9F%E7%BC%9A">#</a>不要被数据库范式所束缚</h3><p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p><h3 id="禁止在线上做数据库压力测试"><a href="#禁止在线上做数据库压力测试" class="headerlink" title="#禁止在线上做数据库压力测试"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E5%9C%A8%E7%BA%BF%E4%B8%8A%E5%81%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95">#</a>禁止在线上做数据库压力测试</h3><h3 id="禁止从开发环境-测试环境直接连接生产环境数据库"><a href="#禁止从开发环境-测试环境直接连接生产环境数据库" class="headerlink" title="#禁止从开发环境,测试环境直接连接生产环境数据库"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%BB%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9B%B4%E6%8E%A5%E8%BF%9E%E6%8E%A5%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE%E5%BA%93">#</a>禁止从开发环境,测试环境直接连接生产环境数据库</h3><p>安全隐患极大，要对生产环境抱有敬畏之心！</p><h2 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="#数据库字段设计规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">#</a>数据库字段设计规范</h2><h3 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="#优先选择符合存储需要的最小的数据类型"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9%E7%AC%A6%E5%90%88%E5%AD%98%E5%82%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">#</a>优先选择符合存储需要的最小的数据类型</h3><p>存储字节越小，占用也就空间越小，性能也越好。</p><p><strong>a.某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据。</strong></p><p>数字是连续的，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li><li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。</strong></p><p>无符号相对于有符号可以多出一倍的存储空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">SIGNED <span class="hljs-type">INT</span> <span class="hljs-number">-2147483648</span><span class="hljs-operator">~</span><span class="hljs-number">2147483647</span><br>UNSIGNED <span class="hljs-type">INT</span> <span class="hljs-number">0</span><span class="hljs-operator">~</span><span class="hljs-number">4294967295</span><br></code></pre></td></tr></table></figure><p><strong>c.小数值类型（比如年龄、状态表示如 0&#x2F;1）优先使用 TINYINT 类型。</strong></p><h3 id="避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据"><a href="#避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据" class="headerlink" title="#避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-text-blob-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84-text-%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8-64k-%E7%9A%84%E6%95%B0%E6%8D%AE">#</a>避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h3><p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p><p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 <code>select *</code>而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p><p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p><p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p><h3 id="避免使用-ENUM-类型"><a href="#避免使用-ENUM-类型" class="headerlink" title="#避免使用 ENUM 类型"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-enum-%E7%B1%BB%E5%9E%8B">#</a>避免使用 ENUM 类型</h3><ul><li>修改 ENUM 值需要使用 ALTER 语句；</li><li>ENUM 类型的 ORDER BY 操作效率低，需要额外操作；</li><li>ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。</li></ul><p>相关阅读：<a href="https://www.zhihu.com/question/404422255/answer/1661698499">是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎open in new window</a> 。</p><h3 id="尽可能把所有列定义为-NOT-NULL"><a href="#尽可能把所有列定义为-NOT-NULL" class="headerlink" title="#尽可能把所有列定义为 NOT NULL"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%B0%BD%E5%8F%AF%E8%83%BD%E6%8A%8A%E6%89%80%E6%9C%89%E5%88%97%E5%AE%9A%E4%B9%89%E4%B8%BA-not-null">#</a>尽可能把所有列定义为 NOT NULL</h3><p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p><ul><li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li><li>进行比较和计算时要对 NULL 值做特别的处理。</li></ul><p>相关阅读：<a href="https://opensource.actionsky.com/20190710-mysql/">技术分享 | MySQL 默认值选型（是空，还是 NULL）open in new window</a> 。</p><h3 id="一定不要用字符串存储日期"><a href="#一定不要用字符串存储日期" class="headerlink" title="#一定不要用字符串存储日期"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E4%B8%80%E5%AE%9A%E4%B8%8D%E8%A6%81%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8%E6%97%A5%E6%9C%9F">#</a>一定不要用字符串存储日期</h3><p>对于日期类型来说， 一定不要用字符串存储日期。可以考虑 DATETIME、TIMESTAMP 和 数值型时间戳。</p><p>这三种种方式都有各自的优势，根据实际场景选择最合适的才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p><table><thead><tr><th>类型</th><th>存储空间</th><th>日期格式</th><th>日期范围</th><th>是否带时区信息</th></tr></thead><tbody><tr><td>DATETIME</td><td>5~8 字节</td><td>YYYY-MM-DD hh:mm:ss[.fraction]</td><td>1000-01-01 00:00:00[.000000] ～ 9999-12-31 23:59:59[.999999]</td><td>否</td></tr><tr><td>TIMESTAMP</td><td>4~7 字节</td><td>YYYY-MM-DD hh:mm:ss[.fraction]</td><td>1970-01-01 00:00:01[.000000] ～ 2038-01-19 03:14:07[.999999]</td><td>是</td></tr><tr><td>数值型时间戳</td><td>4 字节</td><td>全数字如 1578707612</td><td>1970-01-01 00:00:01 之后的时间</td><td>否</td></tr></tbody></table><p>MySQL 时间类型选择的详细介绍请看这篇：<a href="https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html">MySQL 时间类型数据存储建议open in new window</a>。</p><h3 id="同财务相关的金额类数据必须使用-decimal-类型"><a href="#同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="#同财务相关的金额类数据必须使用 decimal 类型"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%90%8C%E8%B4%A2%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E9%87%91%E9%A2%9D%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-decimal-%E7%B1%BB%E5%9E%8B">#</a>同财务相关的金额类数据必须使用 decimal 类型</h3><ul><li><strong>非精准浮点</strong>：float,double</li><li><strong>精准浮点</strong>：decimal</li></ul><p>decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据</p><p>不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p><h3 id="单表不要包含过多字段"><a href="#单表不要包含过多字段" class="headerlink" title="#单表不要包含过多字段"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%8D%95%E8%A1%A8%E4%B8%8D%E8%A6%81%E5%8C%85%E5%90%AB%E8%BF%87%E5%A4%9A%E5%AD%97%E6%AE%B5">#</a>单表不要包含过多字段</h3><p>如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。</p><h2 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="#索引设计规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">#</a>索引设计规范</h2><h3 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="#限制每张表上的索引数量,建议单张表索引不超过 5 个"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%99%90%E5%88%B6%E6%AF%8F%E5%BC%A0%E8%A1%A8%E4%B8%8A%E7%9A%84%E7%B4%A2%E5%BC%95%E6%95%B0%E9%87%8F-%E5%BB%BA%E8%AE%AE%E5%8D%95%E5%BC%A0%E8%A1%A8%E7%B4%A2%E5%BC%95%E4%B8%8D%E8%B6%85%E8%BF%87-5-%E4%B8%AA">#</a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h3><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h3 id="禁止使用全文索引"><a href="#禁止使用全文索引" class="headerlink" title="#禁止使用全文索引"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95">#</a>禁止使用全文索引</h3><p>全文索引不适用于 OLTP 场景。</p><h3 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="#禁止给表中的每一列都建立单独的索引"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E7%BB%99%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%88%97%E9%83%BD%E5%BB%BA%E7%AB%8B%E5%8D%95%E7%8B%AC%E7%9A%84%E7%B4%A2%E5%BC%95">#</a>禁止给表中的每一列都建立单独的索引</h3><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h3 id="每个-InnoDB-表必须有个主键"><a href="#每个-InnoDB-表必须有个主键" class="headerlink" title="#每个 InnoDB 表必须有个主键"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%AF%8F%E4%B8%AA-innodb-%E8%A1%A8%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%AA%E4%B8%BB%E9%94%AE">#</a>每个 InnoDB 表必须有个主键</h3><p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>InnoDB 是按照主键索引的顺序来组织表的</p><ul><li>不要使用更新频繁的列作为主键，不使用多列主键（相当于联合索引）</li><li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li><li>主键建议使用自增 ID 值</li></ul><h3 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="#常见索引列建议"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%88%97%E5%BB%BA%E8%AE%AE">#</a>常见索引列建议</h3><ul><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>多表 join 的关联列</li></ul><h3 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="#如何选择索引列的顺序"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F">#</a>如何选择索引列的顺序</h3><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li>区分度最高的放在联合索引的最左侧（区分度&#x3D;列中不同值的数量&#x2F;列的总行数）</li><li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li><li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><h3 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E5%BB%BA%E7%AB%8B%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95%E5%92%8C%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95-%E5%A2%9E%E5%8A%A0%E4%BA%86%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E6%97%B6%E9%97%B4">#</a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h3><ul><li>重复索引示例：primary key(id)、index(id)、unique index(id)</li><li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li></ul><h3 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="#对于频繁的查询优先考虑使用覆盖索引"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%AF%B9%E4%BA%8E%E9%A2%91%E7%B9%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">#</a>对于频繁的查询优先考虑使用覆盖索引</h3><blockquote><p>  覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p></blockquote><p><strong>覆盖索引的好处：</strong></p><ul><li><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li><li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><hr><h3 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="#索引 SET 规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%B4%A2%E5%BC%95-set-%E8%A7%84%E8%8C%83">#</a>索引 SET 规范</h3><p><strong>尽量避免使用外键约束</strong></p><ul><li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li><li>外键可用于保证数据的参照完整性，但建议在业务端实现</li><li>外键会影响父表和子表的写操作从而降低性能</li></ul><h2 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="#数据库 SQL 开发规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%95%B0%E6%8D%AE%E5%BA%93-sql-%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83">#</a>数据库 SQL 开发规范</h2><h3 id="尽量不在数据库做运算，复杂运算需移到业务应用里完成"><a href="#尽量不在数据库做运算，复杂运算需移到业务应用里完成" class="headerlink" title="#尽量不在数据库做运算，复杂运算需移到业务应用里完成"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%B0%BD%E9%87%8F%E4%B8%8D%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%81%9A%E8%BF%90%E7%AE%97-%E5%A4%8D%E6%9D%82%E8%BF%90%E7%AE%97%E9%9C%80%E7%A7%BB%E5%88%B0%E4%B8%9A%E5%8A%A1%E5%BA%94%E7%94%A8%E9%87%8C%E5%AE%8C%E6%88%90">#</a>尽量不在数据库做运算，复杂运算需移到业务应用里完成</h3><p>尽量不在数据库做运算，复杂运算需移到业务应用里完成。这样可以避免数据库的负担过重，影响数据库的性能和稳定性。数据库的主要作用是存储和管理数据，而不是处理数据。</p><h3 id="优化对性能影响较大的-SQL-语句"><a href="#优化对性能影响较大的-SQL-语句" class="headerlink" title="#优化对性能影响较大的 SQL 语句"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E4%BC%98%E5%8C%96%E5%AF%B9%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E8%BE%83%E5%A4%A7%E7%9A%84-sql-%E8%AF%AD%E5%8F%A5">#</a>优化对性能影响较大的 SQL 语句</h3><p>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句。</p><h3 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="#充分利用表上已经存在的索引"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E8%A1%A8%E4%B8%8A%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E7%B4%A2%E5%BC%95">#</a>充分利用表上已经存在的索引</h3><p>避免使用双%号的查询条件。如：<code>a like &#39;%123%&#39;</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p><p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p><p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p><h3 id="禁止使用-SELECT-必须使用-SELECT-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-查询" class="headerlink" title="#禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8-select-%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-select-%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8-%E6%9F%A5%E8%AF%A2">#</a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h3><ul><li><code>SELECT *</code> 会消耗更多的 CPU。</li><li><code>SELECT *</code> 无用字段增加网络带宽资源消耗，增加数据传输时间，尤其是大字段（如 varchar、blob、text）。</li><li><code>SELECT *</code> 无法使用 MySQL 优化器覆盖索引的优化（基于 MySQL 优化器的“覆盖索引”策略又是速度极快，效率极高，业界极为推荐的查询优化方式）</li><li><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响、</li></ul><h3 id="禁止使用不含字段列表的-INSERT-语句"><a href="#禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="#禁止使用不含字段列表的 INSERT 语句"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%AB%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8%E7%9A%84-insert-%E8%AF%AD%E5%8F%A5">#</a>禁止使用不含字段列表的 INSERT 语句</h3><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure><p>应使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t(c1,c2,c3) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="#建议使用预编译语句进行数据库操作"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C">#</a>建议使用预编译语句进行数据库操作</h3><ul><li>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li><li>只传参数，比传递 SQL 语句更高效。</li><li>相同语句可以一次解析，多次使用，提高处理效率。</li></ul><h3 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="#避免数据类型的隐式转换"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2">#</a>避免数据类型的隐式转换</h3><p>隐式转换会导致索引失效如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name,phone <span class="hljs-keyword">from</span> customer <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;111&#x27;</span>;<br></code></pre></td></tr></table></figure><p>详细解读可以看：<a href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html">MySQL 中的隐式转换造成的索引失效</a> 这篇文章。</p><h3 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="#避免使用子查询，可以把子查询优化为 join 操作"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2-%E5%8F%AF%E4%BB%A5%E6%8A%8A%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%BA-join-%E6%93%8D%E4%BD%9C">#</a>避免使用子查询，可以把子查询优化为 join 操作</h3><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p><strong>子查询性能差的原因：</strong> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><h3 id="避免使用-JOIN-关联太多的表"><a href="#避免使用-JOIN-关联太多的表" class="headerlink" title="#避免使用 JOIN 关联太多的表"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-join-%E5%85%B3%E8%81%94%E5%A4%AA%E5%A4%9A%E7%9A%84%E8%A1%A8">#</a>避免使用 JOIN 关联太多的表</h3><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p><p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p><p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p><p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p><h3 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="#减少同数据库的交互次数"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%87%8F%E5%B0%91%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0">#</a>减少同数据库的交互次数</h3><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p><h3 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="#对应同一列进行 or 判断时，使用 in 代替 or"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%AF%B9%E5%BA%94%E5%90%8C%E4%B8%80%E5%88%97%E8%BF%9B%E8%A1%8C-or-%E5%88%A4%E6%96%AD%E6%97%B6-%E4%BD%BF%E7%94%A8-in-%E4%BB%A3%E6%9B%BF-or">#</a>对应同一列进行 or 判断时，使用 in 代替 or</h3><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p><h3 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="#禁止使用 order by rand() 进行随机排序"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8-order-by-rand-%E8%BF%9B%E8%A1%8C%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F">#</a>禁止使用 order by rand() 进行随机排序</h3><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p><p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h3 id="WHERE-从句中禁止对列进行函数转换和计算"><a href="#WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="#WHERE 从句中禁止对列进行函数转换和计算"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#where-%E4%BB%8E%E5%8F%A5%E4%B8%AD%E7%A6%81%E6%AD%A2%E5%AF%B9%E5%88%97%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%AE%A1%E7%AE%97">#</a>WHERE 从句中禁止对列进行函数转换和计算</h3><p>对列进行函数转换或计算时会导致无法使用索引</p><p><strong>不推荐：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> <span class="hljs-type">date</span>(create_time)<span class="hljs-operator">=</span><span class="hljs-string">&#x27;20190101&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>推荐：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> create_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;20190101&#x27;</span> <span class="hljs-keyword">and</span> create_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;20190102&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="#在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%9C%A8%E6%98%8E%E6%98%BE%E4%B8%8D%E4%BC%9A%E6%9C%89%E9%87%8D%E5%A4%8D%E5%80%BC%E6%97%B6%E4%BD%BF%E7%94%A8-union-all-%E8%80%8C%E4%B8%8D%E6%98%AF-union">#</a>在明显不会有重复值时使用 UNION ALL 而不是 UNION</h3><ul><li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>UNION ALL 不会再对结果集进行去重操作</li></ul><h3 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="#拆分复杂的大 SQL 为多个小 SQL"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%8B%86%E5%88%86%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A4%A7-sql-%E4%B8%BA%E5%A4%9A%E4%B8%AA%E5%B0%8F-sql">#</a>拆分复杂的大 SQL 为多个小 SQL</h3><ul><li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li><li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li><li>SQL 拆分后可以通过并行执行来提高处理效率</li></ul><h3 id="程序连接不同的数据库使用不同的账号，禁止跨库查询"><a href="#程序连接不同的数据库使用不同的账号，禁止跨库查询" class="headerlink" title="#程序连接不同的数据库使用不同的账号，禁止跨库查询"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B4%A6%E5%8F%B7-%E7%A6%81%E6%AD%A2%E8%B7%A8%E5%BA%93%E6%9F%A5%E8%AF%A2">#</a>程序连接不同的数据库使用不同的账号，禁止跨库查询</h3><ul><li>为数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免权限过大而产生的安全风险</li></ul><h2 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="#数据库操作行为规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E8%A1%8C%E4%B8%BA%E8%A7%84%E8%8C%83">#</a>数据库操作行为规范</h2><h3 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="#超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E8%B6%85-100-%E4%B8%87%E8%A1%8C%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99-update-delete-insert-%E6%93%8D%E4%BD%9C-%E8%A6%81%E5%88%86%E6%89%B9%E5%A4%9A%E6%AC%A1%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">#</a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h3><p><strong>大批量操作可能会造成严重的主从延迟</strong></p><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p><p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p><p><strong>避免产生大事务操作</strong></p><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p><h3 id="对于大表使用-pt-online-schema-change-修改表结构"><a href="#对于大表使用-pt-online-schema-change-修改表结构" class="headerlink" title="#对于大表使用 pt-online-schema-change 修改表结构"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%AF%B9%E4%BA%8E%E5%A4%A7%E8%A1%A8%E4%BD%BF%E7%94%A8-pt-online-schema-change-%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84">#</a>对于大表使用 pt-online-schema-change 修改表结构</h3><ul><li>避免大表修改产生的主从延迟</li><li>避免在对表字段进行修改时进行锁表</li></ul><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p><p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p><h3 id="禁止为程序使用的账号赋予-super-权限"><a href="#禁止为程序使用的账号赋予-super-权限" class="headerlink" title="#禁止为程序使用的账号赋予 super 权限"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%B8%BA%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B4%A6%E5%8F%B7%E8%B5%8B%E4%BA%88-super-%E6%9D%83%E9%99%90">#</a>禁止为程序使用的账号赋予 super 权限</h3><ul><li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li><li>super 权限只能留给 DBA 处理问题的账号使用</li></ul><h3 id="对于程序连接数据库账号-遵循权限最小原则"><a href="#对于程序连接数据库账号-遵循权限最小原则" class="headerlink" title="#对于程序连接数据库账号,遵循权限最小原则"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%AF%B9%E4%BA%8E%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B4%A6%E5%8F%B7-%E9%81%B5%E5%BE%AA%E6%9D%83%E9%99%90%E6%9C%80%E5%B0%8F%E5%8E%9F%E5%88%99">#</a>对于程序连接数据库账号,遵循权限最小原则</h3><ul><li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li><li>程序使用的账号原则上不准有 drop 权限</li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="#推荐阅读"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">#</a>推荐阅读</h2>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL字段类型</title>
    <link href="/2021/04/06/DB/MySQL/2.%20MySQL%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/06/DB/MySQL/2.%20MySQL%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-字段类型"><a href="#MySQL-字段类型" class="headerlink" title="MySQL 字段类型"></a>MySQL 字段类型</h2>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL存储引擎</title>
    <link href="/2021/04/06/DB/MySQL/4.%20MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2021/04/06/DB/MySQL/4.%20MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础架构</title>
    <link href="/2021/04/06/DB/MySQL/3.%20MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    <url>/2021/04/06/DB/MySQL/3.%20MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2021/04/06/DB/MySQL/5.%20MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/04/06/DB/MySQL/5.%20MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL查询缓存</title>
    <link href="/2021/04/06/DB/MySQL/6.%20MySQL%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/"/>
    <url>/2021/04/06/DB/MySQL/6.%20MySQL%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL事务</title>
    <link href="/2021/04/06/DB/MySQL/8.%20MYSQL%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/04/06/DB/MySQL/8.%20MYSQL%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL日志</title>
    <link href="/2021/04/06/DB/MySQL/7.%20MYSQL%E6%97%A5%E5%BF%97/"/>
    <url>/2021/04/06/DB/MySQL/7.%20MYSQL%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL锁</title>
    <link href="/2021/04/06/DB/MySQL/9.%20MYSQL%E9%94%81/"/>
    <url>/2021/04/06/DB/MySQL/9.%20MYSQL%E9%94%81/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2021/04/06/DB/MySQL/MySQL%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/06/DB/MySQL/MySQL%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h2><h3 id="什么是关系型数据库？"><a href="#什么是关系型数据库？" class="headerlink" title="什么是关系型数据库？"></a>什么是关系型数据库？</h3><p>关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><p><img src="https://oss.javaguide.cn/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="关系型数据库表关系"></p><center>关系型数据库表关系</center><p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</p><p><strong>有哪些常见的关系型数据库呢？</strong></p><p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ……。</p><h3 id="什么是-SQL？"><a href="#什么是-SQL？" class="headerlink" title="#什么是 SQL？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF-sql">#</a>什么是 SQL？</h3><p>SQL 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。</p><p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p><p>SQL 可以帮助我们：</p><ul><li>新建数据库、数据表、字段；</li><li>在数据库中增加，删除，修改，查询数据；</li><li>新建视图、函数、存储过程；</li><li>对数据库中的数据进行简单的数据分析；</li><li>搭配 Hive，Spark SQL 做大数据；</li><li>搭配 SQLFlow 做机器学习；</li><li>……</li></ul><h3 id="什么是-MySQL？"><a href="#什么是-MySQL？" class="headerlink" title="什么是 MySQL？"></a>什么是 MySQL？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/csdn/20210327143351823.png" alt="img"></p><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p><p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong>3306</strong>。</p><h3 id="MySQL-有什么优点？"><a href="#MySQL-有什么优点？" class="headerlink" title="#MySQL 有什么优点？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9">#</a>MySQL 有什么优点？</h3><p>这个问题本质上是在问 MySQL 如此流行的原因。</p><p>MySQL 主要具有下面这些优点：</p><ol><li>成熟稳定，功能完善。</li><li>开源免费。</li><li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li>开箱即用，操作简单，维护成本低。</li><li>兼容性好，支持常见的操作系统，支持多种开发语言。</li><li>社区活跃，生态完善。</li><li>事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li>支持分库分表、读写分离、高可用。</li></ol><h2 id="MySQL-字段类型"><a href="#MySQL-字段类型" class="headerlink" title="#MySQL 字段类型"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B">#</a>MySQL 字段类型</h2><p>MySQL 字段类型可以简单分为三大类：</p><ul><li><strong>数值类型</strong>：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）</li><li><strong>字符串类型</strong>：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。</li><li><strong>日期时间类型</strong>：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。</li></ul><p>下面这张图不是我画的，忘记是从哪里保存下来的了，总结的还蛮不错的。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/summary-of-mysql-field-types.png" alt="MySQL 常见字段类型总结">MySQL 常见字段类型总结</p><p>MySQL 字段类型比较多，我这里会挑选一些日常开发使用很频繁且面试常问的字段类型，以面试问题的形式来详细介绍。如无特殊说明，针对的都是 InnoDB 存储引擎。</p><p>另外，推荐阅读一下《高性能 MySQL(第三版)》的第四章，有详细介绍 MySQL 字段类型优化。</p><h3 id="整数类型的-UNSIGNED-属性有什么用？"><a href="#整数类型的-UNSIGNED-属性有什么用？" class="headerlink" title="#整数类型的 UNSIGNED 属性有什么用？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84-unsigned-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">#</a>整数类型的 UNSIGNED 属性有什么用？</h3><p>MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来表示不允许负值的无符号整数。使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p><p>例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 2,147,483,648 ~ 2,147,483,647。</p><p>对于从 0 开始递增的 ID 列，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p><h3 id="CHAR-和-VARCHAR-的区别是什么？"><a href="#CHAR-和-VARCHAR-的区别是什么？" class="headerlink" title="#CHAR 和 VARCHAR 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>CHAR 和 VARCHAR 的区别是什么？</h3><p>CHAR 和 VARCHAR 是最常用到的字符串类型，两者的主要区别在于：<strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p><p>CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</p><p>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</p><p>CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</p><h3 id="VARCHAR-100-和-VARCHAR-10-的区别是什么？"><a href="#VARCHAR-100-和-VARCHAR-10-的区别是什么？" class="headerlink" title="#VARCHAR(100)和 VARCHAR(10)的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#varchar-100-%E5%92%8C-varchar-10-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>VARCHAR(100)和 VARCHAR(10)的区别是什么？</h3><p>VARCHAR(100)和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，VARCHAR (100) 可以满足更大范围的字符存储需求，有更好的业务拓展性。而 VARCHAR(10)存储超过 10 个字符时，就需要修改表结构才可以。</p><p>虽说 VARCHAR(100)和 VARCHAR(10)能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p><p>不过，VARCHAR(100) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR(100)是按照 100 这个长度来进行的，也就会消耗更多内存。</p><h3 id="DECIMAL-和-FLOAT-DOUBLE-的区别是什么？"><a href="#DECIMAL-和-FLOAT-DOUBLE-的区别是什么？" class="headerlink" title="#DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#decimal-%E5%92%8C-float-double-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</h3><p>DECIMAL 和 FLOAT 的区别是：<strong>DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT&#x2F;DOUBLE 只能存储近似的小数值。</strong></p><p>DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。</p><p>在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类 <code>java.math.BigDecimal</code>。</p><h3 id="为什么不推荐使用-TEXT-和-BLOB？"><a href="#为什么不推荐使用-TEXT-和-BLOB？" class="headerlink" title="#为什么不推荐使用 TEXT 和 BLOB？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-text-%E5%92%8C-blob">#</a>为什么不推荐使用 TEXT 和 BLOB？</h3><p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据，例如博客内容。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>0-255 字节</td><td>一般文本字符串</td></tr><tr><td>TEXT</td><td>0-65,535 字节</td><td>长文本字符串</td></tr><tr><td>MEDIUMTEXT</td><td>0-16,772,150 字节</td><td>较大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4,294,967,295 字节</td><td>极大文本数据</td></tr></tbody></table><p>BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>0-255 字节</td><td>短文本二进制字符串</td></tr><tr><td>BLOB</td><td>0-65KB</td><td>二进制字符串</td></tr><tr><td>MEDIUMBLOB</td><td>0-16MB</td><td>二进制形式的长文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4GB</td><td>二进制形式的极大文本数据</td></tr></tbody></table><p>在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT。</p><p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p><ul><li>不能有默认值。</li><li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。</li><li>检索效率较低。</li><li>不能直接创建索引，需要指定前缀长度。</li><li>可能会消耗大量的网络和 IO 带宽。</li><li>可能导致表上的 DML 操作变慢。</li><li>……</li></ul><h3 id="DATETIME-和-TIMESTAMP-的区别是什么？"><a href="#DATETIME-和-TIMESTAMP-的区别是什么？" class="headerlink" title="#DATETIME 和 TIMESTAMP 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#datetime-%E5%92%8C-timestamp-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>DATETIME 和 TIMESTAMP 的区别是什么？</h3><p>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。</p><p>TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p><ul><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><p>关于两者的详细对比，请参考我写的<a href="https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html">MySQL 时间类型数据存储建议</a>。</p><h3 id="NULL-和-‘’-的区别是什么？"><a href="#NULL-和-‘’-的区别是什么？" class="headerlink" title="#NULL 和 ‘’ 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#null-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>NULL 和 ‘’ 的区别是什么？</h3><p><code>NULL</code> 跟 <code>&#39;&#39;</code>(空字符串)是两个完全不一样的值，区别如下：</p><ul><li><code>NULL</code> 代表一个不确定的值,就算是两个 <code>NULL</code>,它俩也不一定相等。例如，<code>SELECT NULL=NULL</code>的结果为 false，但是在我们使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时,<code>NULL</code>又被认为是相等的。</li><li><code>&#39;&#39;</code>的长度是 0，是不占用空间的，而<code>NULL</code> 是需要占用空间的。</li><li><code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li><li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li></ul><p>看了上面的介绍之后，相信你对另外一个高频面试题：“为什么 MySQL 不建议使用 <code>NULL</code> 作为列默认值？”也有了答案。</p><h3 id="Boolean-类型如何表示？"><a href="#Boolean-类型如何表示？" class="headerlink" title="#Boolean 类型如何表示？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#boolean-%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA">#</a>Boolean 类型如何表示？</h3><p>MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。</p><h2 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="#MySQL 基础架构"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84">#</a>MySQL 基础架构</h2><blockquote><p>  建议配合 <a href="https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。另外，“一个 SQL 语句在 MySQL 中的执行流程”也是面试中比较常问的一个问题。</p></blockquote><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p><p><img src="https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png" alt="img"></p><p>从上图可以看出， MySQL 主要由下面几部分构成：</p><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="#MySQL 存储引擎"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">#</a>MySQL 存储引擎</h2><p>MySQL 核心在于存储引擎，想要深入学习 MySQL，必定要深入研究 MySQL 存储引擎。</p><h3 id="MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="#MySQL 支持哪些存储引擎？默认使用哪个？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA">#</a>MySQL 支持哪些存储引擎？默认使用哪个？</h3><p>MySQL 支持多种存储引擎，你可以通过 <code>SHOW ENGINES</code> 命令来查看 MySQL 支持的所有存储引擎。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510105408703.png" alt="查看 MySQL 提供的所有存储引擎">查看 MySQL 提供的所有存储引擎</p><p>从上图我们可以查看出， MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p><p>我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。</p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>你可以通过 <code>SELECT VERSION()</code> 命令查看你的 MySQL 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; SELECT VERSION();<br>+-----------+<br>| VERSION() |<br>+-----------+<br>| 8.0.27    |<br>+-----------+<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><p>你也可以通过 <code>SHOW VARIABLES LIKE &#39;%storage_engine%&#39;</code> 命令直接查看 MySQL 当前默认的存储引擎。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; SHOW VARIABLES  LIKE <span class="hljs-string">&#x27;%storage_engine%&#x27;</span>;<br>+---------------------------------+-----------+<br>| Variable_name                   | Value     |<br>+---------------------------------+-----------+<br>| default_storage_engine          | InnoDB    |<br>| default_tmp_storage_engine      | InnoDB    |<br>| disabled_storage_engines        |           |<br>| internal_tmp_mem_storage_engine | TempTable |<br>+---------------------------------+-----------+<br>4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><p>如果你想要深入了解每个存储引擎以及它们之间的区别，推荐你去阅读以下 MySQL 官方文档对应的介绍(面试不会问这么细，了解即可)：</p><ul><li>InnoDB 存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.htmlopen in new window</a> 。</li><li>其他存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">https://dev.mysql.com/doc/refman/8.0/en/storage-engines.htmlopen in new window</a> 。</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510155143458.png" alt="img"></p><h3 id="MySQL-存储引擎架构了解吗？"><a href="#MySQL-存储引擎架构了解吗？" class="headerlink" title="#MySQL 存储引擎架构了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97">#</a>MySQL 存储引擎架构了解吗？</h3><p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><p>并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。</p><p>MySQL 官方文档也有介绍到如何编写一个自定义存储引擎，地址：<a href="https://dev.mysql.com/doc/internals/en/custom-engine.html">https://dev.mysql.com/doc/internals/en/custom-engine.htmlopen in new window</a> 。</p><h3 id="MyISAM-和-InnoDB-有什么区别？"><a href="#MyISAM-和-InnoDB-有什么区别？" class="headerlink" title="#MyISAM 和 InnoDB 有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#myisam-%E5%92%8C-innodb-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>MyISAM 和 InnoDB 有什么区别？</h3><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p><p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>言归正传！咱们下面还是来简单对比一下两者：</p><p><strong>1.是否支持行级锁</strong></p><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p><p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解</a>。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510090309427.png" alt="img"></p><p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p><p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p><p><strong>6.索引实现不一样。</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><p>详细区别，推荐你看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解</a>。</p><p><strong>7.性能有差别。</strong></p><p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/innodb-myisam-performance-comparison.png" alt="InnoDB 和 MyISAM 性能对比">InnoDB 和 MyISAM 性能对比</p><p><strong>总结</strong>：</p><ul><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大。</li></ul><p>最后，再分享一张图片给你，这张图片详细对比了常见的几种 MySQL 存储引擎。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/comparison-of-common-mysql-storage-engines.png" alt="常见的几种 MySQL 存储引擎对比">常见的几种 MySQL 存储引擎对比</p><h3 id="MyISAM-和-InnoDB-如何选择？"><a href="#MyISAM-和-InnoDB-如何选择？" class="headerlink" title="#MyISAM 和 InnoDB 如何选择？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#myisam-%E5%92%8C-innodb-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">#</a>MyISAM 和 InnoDB 如何选择？</h3><p>大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。</p><p>《MySQL 高性能》上面有一句话这样写到:</p><blockquote><p>  不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p></blockquote><p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p><p>因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。</p><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="#MySQL 索引"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%B4%A2%E5%BC%95">#</a>MySQL 索引</h2><p>MySQL 索引相关的问题比较多，对于面试和工作都比较重要，于是，我单独抽了一篇文章专门来总结 MySQL 索引相关的知识点和问题：<a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解</a> 。</p><h2 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="#MySQL 查询缓存"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98">#</a>MySQL 查询缓存</h2><p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p><p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">query_cache_type</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">query_cache_size</span>=<span class="hljs-string">600000</span><br></code></pre></td></tr></table></figure><p>MySQL 执行以下命令也可以开启查询缓存</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">set</span> <span class="hljs-string">global  query_cache_type=1;</span><br><span class="hljs-attr">set</span> <span class="hljs-string">global  query_cache_size=600000;</span><br></code></pre></td></tr></table></figure><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p><p><strong>查询缓存不命中的情况：</strong></p><ol><li>任何两个查询在任何字符上的不同都会导致缓存不命中。</li><li>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li><li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li></ol><p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 <code>sql_cache</code> 和 <code>sql_no_cache</code> 来控制某个查询语句是否需要缓存：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sql_no_cache <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> usr;<br></code></pre></td></tr></table></figure><h2 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="#MySQL 日志"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%97%A5%E5%BF%97">#</a>MySQL 日志</h2><p>MySQL 日志常见的面试题有：</p><ul><li>MySQL 中常见的日志有哪些？</li><li>慢查询日志有什么用？</li><li>binlog 主要记录了什么？</li><li>redo log 如何保证事务的持久性？</li><li>页修改之后为什么不直接刷盘呢？</li><li>binlog 和 redolog 有什么区别？</li><li>undo log 如何保证事务的原子性？</li><li>……</li></ul><p>上诉问题的答案可以在<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》(付费)</a> 的 <strong>「技术面试题篇」</strong> 中找到。</p><p><img src="https://oss.javaguide.cn/javamianshizhibei/technical-interview-questions.png" alt="《Java 面试指北》技术面试题篇">《Java 面试指北》技术面试题篇</p><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="#MySQL 事务"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E4%BA%8B%E5%8A%A1">#</a>MySQL 事务</h2><h3 id="何谓事务？"><a href="#何谓事务？" class="headerlink" title="#何谓事务？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%BD%95%E8%B0%93%E4%BA%8B%E5%8A%A1">#</a>何谓事务？</h3><p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p><ul><li>数据库中途突然因为某些原因挂掉了。</li><li>客户端突然因为网络原因连接不上数据库了。</li><li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li><li>……</li></ul><p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p><ol><li>将小明的余额减少 1000 元</li><li>将小红的余额增加 1000 元。</li></ol><p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="事务示意图">事务示意图</p><h3 id="何谓数据库事务？"><a href="#何谓数据库事务？" class="headerlink" title="#何谓数据库事务？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%BD%95%E8%B0%93%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1">#</a>何谓数据库事务？</h3><p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p><p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p><p><strong>那数据库事务有什么作用呢？</strong></p><p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 开启一个事务<br><span class="hljs-keyword">START</span> TRANSACTION;<br># 多条 <span class="hljs-keyword">SQL</span> 语句<br>SQL1,SQL2...<br>## 提交事务<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="数据库事务示意图">数据库事务示意图</p><p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/ACID.png" alt="ACID">ACID</p><ol><li><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong> 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课<a href="https://time.geekbang.org/opencourse/intro/100064201">《周志明的软件架构课》open in new window</a>才搞清楚的（多看好书！！！）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/AID-%3EC.png" alt="AID-&gt;C">AID-&gt;C</p><p>另外，DDIA 也就是 <a href="https://book.douban.com/subject/30329536/">《Designing Data-Intensive Application（数据密集型应用系统设计）》open in new window</a> 的作者在他的这本书中如是说：</p><blockquote><p>  Atomicity, isolation, and durability are properties of the database, whereas consis‐ tency (in the ACID sense) is a property of the application. The application may rely on the database’s atomicity and isolation properties in order to achieve consistency, but it’s not up to the database alone.</p><p>  翻译过来的意思是：原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。</p></blockquote><p>《Designing Data-Intensive Application（数据密集型应用系统设计）》这本书强推一波，值得读很多遍！豆瓣有接近 90% 的人看了这本书之后给了五星好评。另外，中文翻译版本已经在 GitHub 开源，地址：<a href="https://github.com/Vonng/ddia">https://github.com/Vonng/ddiaopen in new window</a> 。</p><p><img src="https://oss.javaguide.cn/github/javaguide/books/ddia.png" alt="img"></p><h3 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="#并发事务带来了哪些问题?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">#</a>并发事务带来了哪些问题?</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><h4 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="#脏读（Dirty read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%84%8F%E8%AF%BB-dirty-read">#</a>脏读（Dirty read）</h4><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 读取到 A &#x3D; 19,事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading-ee15b0b9.png" alt="脏读">脏读</p><h4 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="#丢失修改（Lost to modify）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9-lost-to-modify">#</a>丢失修改（Lost to modify）</h4><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 先修改 A&#x3D;A-1，事务 2 后来也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-missing-modifications-5b2e2bd8.png" alt="丢失修改">丢失修改</p><h4 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="#不可重复读（Unrepeatable read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-unrepeatable-read">#</a>不可重复读（Unrepeatable read）</h4><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 再次读取 A &#x3D;19，此时读取的结果和第一次读取的结果不同。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-unrepeatable-read-ff9186e1.png" alt="不可重复读">不可重复读</p><h4 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="#幻读（Phantom read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%BB%E8%AF%BB-phantom-read">#</a>幻读（Phantom read）</h4><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-phantom-read-7cba7a85.png" alt="幻读">幻读</p><h3 id="不可重复读和幻读有什么区别？"><a href="#不可重复读和幻读有什么区别？" class="headerlink" title="#不可重复读和幻读有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>不可重复读和幻读有什么区别？</h3><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h3 id="并发事务的控制方式有哪些？"><a href="#并发事务的控制方式有哪些？" class="headerlink" title="#并发事务的控制方式有哪些？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>并发事务的控制方式有哪些？</h3><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p><p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p><p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul><p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html">InnoDB 存储引擎对 MVCC 的实现</a> 。</p><h3 id="SQL-标准定义了哪些事务隔离级别"><a href="#SQL-标准定义了哪些事务隔离级别" class="headerlink" title="#SQL 标准定义了哪些事务隔离级别?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#sql-%E6%A0%87%E5%87%86%E5%AE%9A%E4%B9%89%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">#</a>SQL 标准定义了哪些事务隔离级别?</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h3 id="MySQL-的隔离级别是基于锁实现的吗？"><a href="#MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="#MySQL 的隔离级别是基于锁实现的吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97">#</a>MySQL 的隔离级别是基于锁实现的吗？</h3><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h3 id="MySQL-的默认隔离级别是什么"><a href="#MySQL-的默认隔离级别是什么" class="headerlink" title="#MySQL 的默认隔离级别是什么?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>MySQL 的默认隔离级别是什么?</h3><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@tx_isolation</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@tx_isolation</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br></code></pre></td></tr></table></figure><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解</a>。</p><h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="#MySQL 锁"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E9%94%81">#</a>MySQL 锁</h2><p>锁是一种常见的并发事务的控制方式。</p><h3 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="#表级锁和行级锁了解吗？有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>表级锁和行级锁了解吗？有什么区别？</h3><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p><p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p><p><strong>表级锁和行级锁对比</strong>：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li></ul><h3 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="#行级锁的使用有什么注意事项？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">#</a>行级锁的使用有什么注意事项？</h3><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p><p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p><h3 id="InnoDB-有哪几类行锁？"><a href="#InnoDB-有哪几类行锁？" class="headerlink" title="#InnoDB 有哪几类行锁？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#innodb-%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BB%E8%A1%8C%E9%94%81">#</a>InnoDB 有哪几类行锁？</h3><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p><p>一些大厂面试中可能会问到 Next-Key Lock 的加锁范围，这里推荐一篇文章：<a href="https://segmentfault.com/a/1190000040129107">MySQL next-key lock 加锁范围是什么？ - 程序员小航 - 2021open in new window</a> 。</p><h3 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="#共享锁和排他锁呢？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81%E5%91%A2">#</a>共享锁和排他锁呢？</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th align="left"></th><th align="left">S 锁</th><th align="left">X 锁</th></tr></thead><tbody><tr><td align="left">S 锁</td><td align="left">不冲突</td><td align="left">冲突</td></tr><tr><td align="left">X 锁</td><td align="left">冲突</td><td align="left">冲突</td></tr></tbody></table><p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 共享锁 可以在 MySQL <span class="hljs-number">5.7</span> 和 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 共享锁 可以在 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> SHARE;<br># 排他锁<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><h3 id="意向锁有什么作用？"><a href="#意向锁有什么作用？" class="headerlink" title="#意向锁有什么作用？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E6%84%8F%E5%90%91%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">#</a>意向锁有什么作用？</h3><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p><p>意向锁是表级锁，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><p>《MySQL 技术内幕 InnoDB 存储引擎》这本书对应的描述应该是笔误了。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220511171419081.png" alt="img"></p><h3 id="当前读和快照读有什么区别？"><a href="#当前读和快照读有什么区别？" class="headerlink" title="#当前读和快照读有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>当前读和快照读有什么区别？</h3><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span><br># 共享锁 可以在 MySQL <span class="hljs-number">5.7</span> 和 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 共享锁 可以在 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> SHARE;<br></code></pre></td></tr></table></figure><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p><p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p><p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><p>当前读的一些常见 SQL 语句类型如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 对读的记录加一个X锁<br>SELECT...FOR <span class="hljs-keyword">UPDATE</span><br># 对读的记录加一个S锁<br>SELECT...LOCK <span class="hljs-keyword">IN</span> SHARE MODE<br># 对读的记录加一个S锁<br>SELECT...FOR SHARE<br># 对修改的记录加一个X锁<br>INSERT...<br>UPDATE...<br>DELETE...<br></code></pre></td></tr></table></figure><h3 id="自增锁有了解吗？"><a href="#自增锁有了解吗？" class="headerlink" title="#自增锁有了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%87%AA%E5%A2%9E%E9%94%81%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97">#</a>自增锁有了解吗？</h3><blockquote><p>  不太重要的一个知识点，简单了解即可。</p></blockquote><p>关系型数据库设计表的时候，通常会有一列作为自增主键。InnoDB 中的自增主键会涉及一种比较特殊的表级锁— <strong>自增锁（AUTO-INC Locks）</strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `sequence_id` (<br>  `id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `stub` <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `stub` (`stub`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br></code></pre></td></tr></table></figure><p>更准确点来说，不仅仅是自增主键，<code>AUTO_INCREMENT</code>的列都会涉及到自增锁，毕竟非主键也可以设置自增长。</p><p>如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住。这里的阻塞行为只是自增锁行为的其中一种，可以理解为自增锁就是一个接口，其具体的实现有多种。具体的配置项为 <code>innodb_autoinc_lock_mode</code> （MySQL 5.1.22 引入），可以选择的值如下：</p><table><thead><tr><th align="left">innodb_autoinc_lock_mode</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">传统模式</td></tr><tr><td align="left">1</td><td align="left">连续模式（MySQL 8.0 之前默认）</td></tr><tr><td align="left">2</td><td align="left">交错模式(MySQL 8.0 之后默认)</td></tr></tbody></table><p>交错模式下，所有的“INSERT-LIKE”语句（所有的插入语句，包括：<code>INSERT</code>、<code>REPLACE</code>、<code>INSERT…SELECT</code>、<code>REPLACE…SELECT</code>、<code>LOAD DATA</code>等）都不使用表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行，速度更快，扩展性也更好。</p><p>不过，如果你的 MySQL 数据库有主从同步需求并且 Binlog 存储格式为 Statement 的话，不要将 InnoDB 自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序就无法得到保障。</p><blockquote><p>  如果 MySQL 采用的格式为 Statement ，那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。</p></blockquote><p>最后，再推荐一篇文章：<a href="https://draveness.me/whys-the-design-mysql-auto-increment/">为什么 MySQL 的自增主键不单调也不连续open in new window</a> 。</p><h2 id="MySQL-性能优化"><a href="#MySQL-性能优化" class="headerlink" title="#MySQL 性能优化"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">#</a>MySQL 性能优化</h2><p>关于 MySQL 性能优化的建议总结，请看这篇文章：<a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html">MySQL 高性能优化规范建议总结</a> 。</p><h3 id="能用-MySQL-直接存储文件（比如图片）吗？"><a href="#能用-MySQL-直接存储文件（比如图片）吗？" class="headerlink" title="#能用 MySQL 直接存储文件（比如图片）吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%83%BD%E7%94%A8-mysql-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6-%E6%AF%94%E5%A6%82%E5%9B%BE%E7%89%87-%E5%90%97">#</a>能用 MySQL 直接存储文件（比如图片）吗？</h3><p>可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。</p><p>可以选择使用云服务厂商提供的开箱即用的文件存储服务，成熟稳定，价格也比较低。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/oss-search.png" alt="img"></p><p>也可以选择自建文件存储服务，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。</p><p><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p><p>相关阅读：<a href="https://www.51cto.com/article/716978.html">Spring Boot 整合 MinIO 实现分布式文件服务open in new window</a> 。</p><h3 id="MySQL-如何存储-IP-地址？"><a href="#MySQL-如何存储-IP-地址？" class="headerlink" title="#MySQL 如何存储 IP 地址？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8-ip-%E5%9C%B0%E5%9D%80">#</a>MySQL 如何存储 IP 地址？</h3><p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li><li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><h3 id="有哪些常见的-SQL-优化手段？"><a href="#有哪些常见的-SQL-优化手段？" class="headerlink" title="#有哪些常见的 SQL 优化手段？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84-sql-%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5">#</a>有哪些常见的 SQL 优化手段？</h3><p><a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》(付费)</a> 的 <strong>「技术面试题篇」</strong> 有一篇文章详细介绍了常见的 SQL 优化手段，非常全面，清晰易懂！</p><p><img src="https://oss.javaguide.cn/javamianshizhibei/javamianshizhibei-sql-optimization.png" alt="常见的 SQL 优化手段">常见的 SQL 优化手段</p><h3 id="如何分析-SQL-的性能？"><a href="#如何分析-SQL-的性能？" class="headerlink" title="#如何分析 SQL 的性能？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-sql-%E7%9A%84%E6%80%A7%E8%83%BD">#</a>如何分析 SQL 的性能？</h3><p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 适用于 <code>SELECT</code>, <code>DELETE</code>, <code>INSERT</code>, <code>REPLACE</code>, 和 <code>UPDATE</code>语句，我们一般分析 <code>SELECT</code> 查询较多。</p><p>我们这里简单来演示一下 <code>EXPLAIN</code> 的使用。</p><p><code>EXPLAIN</code> 的输出格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> `score`,`name` <span class="hljs-keyword">FROM</span> `cus_order` <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `score` <span class="hljs-keyword">DESC</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>     <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>   <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> cus_order <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">997572</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> filesort <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>各个字段的含义如下：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的序列标识符</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询类型</td></tr><tr><td>table</td><td>用到的表名</td></tr><tr><td>partitions</td><td>匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td>type</td><td>表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际用到的索引</td></tr><tr><td>key_len</td><td>所选索引的长度</td></tr><tr><td>ref</td><td>当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><p>篇幅问题，我这里只是简单介绍了一下 MySQL 执行计划，详细介绍请看：<a href="https://javaguide.cn/database/mysql/mysql-query-execution-plan.html">SQL 的执行计划</a>这篇文章。</p><h3 id="读写分离和分库分表了解吗？"><a href="#读写分离和分库分表了解吗？" class="headerlink" title="#读写分离和分库分表了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%92%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BA%86%E8%A7%A3%E5%90%97">#</a>读写分离和分库分表了解吗？</h3><p>读写分离和分库分表相关的问题比较多，于是，我单独写了一篇文章来介绍：<a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html">读写分离和分库分表详解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis集群</title>
    <link href="/2021/04/06/DB/Redis/10.%20Redis%E9%9B%86%E7%BE%A4/"/>
    <url>/2021/04/06/DB/Redis/10.%20Redis%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/2021/04/06/DB/Redis/1.%20Redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/06/DB/Redis/1.%20Redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><h3 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="#什么是 Redis？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF-redis">#</a>什么是 Redis？</h3><p><a href="https://redis.io/">Redisopen in new window</a> （<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-overview-of-data-types-2023-09-28.jpg" alt="Redis 数据类型概览">Redis 数据类型概览</p><p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</p><p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的<a href="https://try.redis.io/">在线 Redis 环境open in new window</a>（少部分命令无法使用）来实际体验 Redis。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/try.redis.io.png" alt="try-redis">try-redis</p><p>全世界有非常多的网站使用到了 Redis ，<a href="https://techstacks.io/">techstacks.ioopen in new window</a> 专门维护了一个<a href="https://techstacks.io/tech/redis">使用 Redis 的热门站点列表open in new window</a> ，感兴趣的话可以看看。</p><h3 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="#Redis 为什么这么快？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB">#</a>Redis 为什么这么快？</h3><p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：</p><ol><li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li><li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li><li>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</li></ol><blockquote><p>  下面这张图片总结的挺不错的，分享一下，出自 <a href="https://twitter.com/alexxubyte/status/1498703822528544770">Why is Redis so fast?open in new window</a> 。</p></blockquote><p><img src="https://javaguide.cn/assets/why-redis-so-fast-d3507ae8.png" alt="why-redis-so-fast">why-redis-so-fast</p><h3 id="分布式缓存常见的技术选型方案有哪些？"><a href="#分布式缓存常见的技术选型方案有哪些？" class="headerlink" title="#分布式缓存常见的技术选型方案有哪些？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>分布式缓存常见的技术选型方案有哪些？</h3><p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p><p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p><p>另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 <a href="https://github.com/facebook/rocksdb">RocksDBopen in new window</a> 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 <a href="https://github.com/Tencent/Tendis">Tendisopen in new window</a>。</p><p>关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：<a href="https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ">Redis vs Tendis：冷热混合存储版架构揭秘open in new window</a> ，可以简单参考一下。</p><p>从这个项目的 GitHub 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。</p><h3 id="说一下-Redis-和-Memcached-的区别和共同点"><a href="#说一下-Redis-和-Memcached-的区别和共同点" class="headerlink" title="#说一下 Redis 和 Memcached 的区别和共同点"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E8%AF%B4%E4%B8%80%E4%B8%8B-redis-%E5%92%8C-memcached-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9">#</a>说一下 Redis 和 Memcached 的区别和共同点</h3><p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p><p><strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别</strong>：</p><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 针对网络数据的读写引入了多线程）</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p><h3 id="为什么要用-Redis-为什么要用缓存？"><a href="#为什么要用-Redis-为什么要用缓存？" class="headerlink" title="#为什么要用 Redis&#x2F;为什么要用缓存？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98">#</a>为什么要用 Redis&#x2F;为什么要用缓存？</h3><p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p><p><strong>1、高性能</strong></p><p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p><p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p><p><strong>2、高并发</strong></p><p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p><blockquote><p>  QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p></blockquote><p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p><h3 id="常见的缓存读写策略有哪些？"><a href="#常见的缓存读写策略有哪些？" class="headerlink" title="#常见的缓存读写策略有哪些？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>常见的缓存读写策略有哪些？</h3><p>关于常见的缓存读写策略的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html">3 种常用的缓存读写策略详解open in new window</a> 。</p><h2 id="Redis-应用"><a href="#Redis-应用" class="headerlink" title="#Redis 应用"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%BA%94%E7%94%A8">#</a>Redis 应用</h2><h3 id="Redis-除了做缓存，还能做什么？"><a href="#Redis-除了做缓存，还能做什么？" class="headerlink" title="#Redis 除了做缓存，还能做什么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98-%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88">#</a>Redis 除了做缓存，还能做什么？</h3><ul><li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解open in new window</a> 。</li><li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window</a>。</li><li><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</li><li><strong>分布式 Session</strong> ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</li><li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。</li><li>……</li></ul><h3 id="如何基于-Redis-实现分布式锁？"><a href="#如何基于-Redis-实现分布式锁？" class="headerlink" title="#如何基于 Redis 实现分布式锁？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E-redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">#</a>如何基于 Redis 实现分布式锁？</h3><p>关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解open in new window</a> 。</p><h3 id="Redis-可以做消息队列么？"><a href="#Redis-可以做消息队列么？" class="headerlink" title="#Redis 可以做消息队列么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%88">#</a>Redis 可以做消息队列么？</h3><blockquote><p>  实际项目中也没见谁使用 Redis 来做消息队列，对于这部分知识点大家了解就好了。</p></blockquote><p>先说结论：<strong>可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</strong></p><p><strong>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。</strong></p><p>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>即可实现简易版消息队列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生产者生产消息</span><br>&gt; RPUSH myList msg1 msg2<br>(<span class="hljs-built_in">integer</span>) 2<br>&gt; RPUSH myList msg3<br>(<span class="hljs-built_in">integer</span>) 3<br><span class="hljs-comment"># 消费者消费消息</span><br>&gt; LPOP myList<br><span class="hljs-string">&quot;msg1&quot;</span><br></code></pre></td></tr></table></figure><p>不过，通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>这样的方式存在性能问题，我们需要不断轮询去调用 <code>RPOP</code> 或 <code>LPOP</code> 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p><p>因此，Redis 还提供了 <code>BLPOP</code>、<code>BRPOP</code> 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 超时时间为 10s</span><br><span class="hljs-comment"># 如果有数据立刻返回，否则最多等待10秒</span><br>&gt; BRPOP myList 10<br>null<br></code></pre></td></tr></table></figure><p><strong>List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。</strong></p><p><strong>Redis 2.0 引入了发布订阅 (pub&#x2F;sub) 功能，解决了 List 实现消息队列没有广播机制的问题。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-pub-sub.png" alt="Redis 发布订阅 (pub/sub) 功能">Redis 发布订阅 (pub&#x2F;sub) 功能</p><p>pub&#x2F;sub 中引入了一个概念叫 <strong>channel（频道）</strong>，发布订阅机制的实现就是基于这个 channel 来做的。</p><p>pub&#x2F;sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：</p><ul><li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li><li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li></ul><p>我们这里启动 3 个 Redis 客户端来简单演示一下：</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-pubsub-message-queue.png" alt="pub/sub 实现消息队列演示">pub&#x2F;sub 实现消息队列演示</p><p>pub&#x2F;sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。</p><p>为此，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。<code>Stream</code> 支持：</p><ul><li>发布 &#x2F; 订阅模式</li><li>按照消费者组进行消费</li><li>消息持久化（ RDB 和 AOF）</li></ul><p><code>Stream</code> 使用起来相对要麻烦一些，这里就不演示了。而且，<code>Stream</code> 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p><p>综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p><p>相关阅读：<a href="https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw">Redis 消息队列发展历程 - 阿里开发者 - 2022open in new window</a>。</p><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="#Redis 数据类型"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">#</a>Redis 数据类型</h2><p>关于 Redis 5 种基础数据类型和 3 种特殊数据类型的详细介绍请看下面这两篇文章以及 <a href="https://redis.io/docs/data-types/">Redis 官方文档open in new window</a> ：</p><ul><li><a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据类型详解open in new window</a></li><li><a href="https://javaguide.cn/database/redis/redis-data-structures-02.html">Redis 3 种特殊数据类型详解open in new window</a></li></ul><h3 id="Redis-常用的数据类型有哪些？"><a href="#Redis-常用的数据类型有哪些？" class="headerlink" title="#Redis 常用的数据类型有哪些？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>Redis 常用的数据类型有哪些？</h3><p>Redis 中比较常见的数据类型有下面这些：</p><ul><li><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。</li></ul><p>除了上面提到的之外，还有一些其他的比如 <a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter.html">Bloom filter（布隆过滤器）open in new window</a>、Bitfield（位域）。</p><h3 id="String-的应用场景有哪些？"><a href="#String-的应用场景有哪些？" class="headerlink" title="#String 的应用场景有哪些？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#string-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>String 的应用场景有哪些？</h3><p>String 是 Redis 中最简单同时也是最常用的一个数据类型。它是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p><p>String 的常见应用场景如下：</p><ul><li>常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；</li><li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li><li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li><li>……</li></ul><p>关于 String 的详细介绍请看这篇文章：<a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据类型详解open in new window</a>。</p><h3 id="String-还是-Hash-存储对象数据更好呢？"><a href="#String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="#String 还是 Hash 存储对象数据更好呢？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#string-%E8%BF%98%E6%98%AF-hash-%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%9B%B4%E5%A5%BD%E5%91%A2">#</a>String 还是 Hash 存储对象数据更好呢？</h3><ul><li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li><li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li></ul><p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p><h3 id="String-的底层实现是什么？"><a href="#String-的底层实现是什么？" class="headerlink" title="#String 的底层实现是什么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#string-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88">#</a>String 的底层实现是什么？</h3><p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是自己编写了 <a href="https://github.com/antirez/sds">SDSopen in new window</a>（Simple Dynamic String，简单动态字符串） 来作为底层实现。</p><p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p><p>Redis7.0 的 SDS 的部分源码如下（<a href="https://github.com/redis/redis/blob/7.0/src/sds.h%EF%BC%89%EF%BC%9A">https://github.com/redis/redis/blob/7.0/src/sds.h）：</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span><br><span class="hljs-comment"> * However is here to document the layout of type 5 SDS strings. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr5</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, and 5 msb of string length */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint16_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint32_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr64</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint64_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p><table><thead><tr><th>类型</th><th>字节</th><th>位</th></tr></thead><tbody><tr><td>sdshdr5</td><td>&lt; 1</td><td>&lt;8</td></tr><tr><td>sdshdr8</td><td>1</td><td>8</td></tr><tr><td>sdshdr16</td><td>2</td><td>16</td></tr><tr><td>sdshdr32</td><td>4</td><td>32</td></tr><tr><td>sdshdr64</td><td>8</td><td>64</td></tr></tbody></table><p>对于后四种实现都包含了下面这 4 个属性：</p><ul><li><code>len</code>：字符串的长度也就是已经使用的字节数</li><li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li><li><code>buf[]</code>：实际存储字符串的数组</li><li><code>flags</code>：低三位保存类型标志</li></ul><p>SDS 相比于 C 语言中的字符串有如下提升：</p><ol><li><strong>可以避免缓冲区溢出</strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li><li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li><li><strong>减少内存分配次数</strong>：为了避免修改（增加&#x2F;减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li><li><strong>二进制安全</strong>：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li></ol><p>🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code> 和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p><h3 id="购物车信息用-String-还是-Hash-存储更好呢"><a href="#购物车信息用-String-还是-Hash-存储更好呢" class="headerlink" title="#购物车信息用 String 还是 Hash 存储更好呢?"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%94%A8-string-%E8%BF%98%E6%98%AF-hash-%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A5%BD%E5%91%A2">#</a>购物车信息用 String 还是 Hash 存储更好呢?</h3><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p><ul><li>用户 id 为 key</li><li>商品 id 为 field，商品数量为 value</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/hash-shopping-cart.png" alt="Hash维护简单的购物车信息">Hash维护简单的购物车信息</p><p>那用户购物车信息的维护具体应该怎么操作呢？</p><ul><li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li><li>查询购物车信息就是遍历对应的 Hash；</li><li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li><li>删除商品就是删除 Hash 中对应的 field；</li><li>清空购物车直接删除对应的 key 即可。</li></ul><p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p><h3 id="使用-Redis-实现一个排行榜怎么做？"><a href="#使用-Redis-实现一个排行榜怎么做？" class="headerlink" title="#使用 Redis 实现一个排行榜怎么做？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BD%BF%E7%94%A8-redis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%80%8E%E4%B9%88%E5%81%9A">#</a>使用 Redis 实现一个排行榜怎么做？</h3><p>Redis 中有一个叫做 <code>Sorted Set</code> 的数据类型经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p><p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/2021060714195385.png" alt="img"></p><p><a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》open in new window</a> 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜，感兴趣的小伙伴可以看看。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719071115140.png" alt="img"></p><h3 id="Set-的应用场景是什么？"><a href="#Set-的应用场景是什么？" class="headerlink" title="#Set 的应用场景是什么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#set-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88">#</a>Set 的应用场景是什么？</h3><p>Redis 中 <code>Set</code> 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</p><p><code>Set</code> 的常见应用场景如下：</p><ul><li>存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等等。</li><li>需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。</li><li>需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。</li></ul><h3 id="使用-Set-实现抽奖系统怎么做？"><a href="#使用-Set-实现抽奖系统怎么做？" class="headerlink" title="#使用 Set 实现抽奖系统怎么做？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BD%BF%E7%94%A8-set-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F%E6%80%8E%E4%B9%88%E5%81%9A">#</a>使用 Set 实现抽奖系统怎么做？</h3><p>如果想要使用 <code>Set</code> 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p><ul><li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li><li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><h3 id="使用-Bitmap-统计活跃用户怎么做？"><a href="#使用-Bitmap-统计活跃用户怎么做？" class="headerlink" title="#使用 Bitmap 统计活跃用户怎么做？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BD%BF%E7%94%A8-bitmap-%E7%BB%9F%E8%AE%A1%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E6%80%8E%E4%B9%88%E5%81%9A">#</a>使用 Bitmap 统计活跃用户怎么做？</h3><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p><p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png" alt="img">img</p><p>如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p><p>初始化数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; SETBIT 20210308 1 1<br>(<span class="hljs-built_in">integer</span>) 0<br>&gt; SETBIT 20210308 2 1<br>(<span class="hljs-built_in">integer</span>) 0<br>&gt; SETBIT 20210309 1 1<br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></table></figure><p>统计 20210308~20210309 总活跃用户数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; BITOP and desk1 20210308 20210309<br>(<span class="hljs-built_in">integer</span>) 1<br>&gt; BITCOUNT desk1<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><p>统计 20210308~20210309 在线活跃用户数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; BITOP or desk2 20210308 20210309<br>(<span class="hljs-built_in">integer</span>) 1<br>&gt; BITCOUNT desk2<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><h3 id="使用-HyperLogLog-统计页面-UV-怎么做？"><a href="#使用-HyperLogLog-统计页面-UV-怎么做？" class="headerlink" title="#使用 HyperLogLog 统计页面 UV 怎么做？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BD%BF%E7%94%A8-hyperloglog-%E7%BB%9F%E8%AE%A1%E9%A1%B5%E9%9D%A2-uv-%E6%80%8E%E4%B9%88%E5%81%9A">#</a>使用 HyperLogLog 统计页面 UV 怎么做？</h3><p>使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：</p><ul><li><code>PFADD key element1 element2 ...</code>：添加一个或多个元素到 HyperLogLog 中。</li><li><code>PFCOUNT key1 key2</code>：获取一个或者多个 HyperLogLog 的唯一计数。</li></ul><p>1、将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PFADD PAGE_1:UV USER1 USER2 ...... USERn<br></code></pre></td></tr></table></figure><p>2、统计指定页面的 UV。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PFCOUNT PAGE_1:UV<br></code></pre></td></tr></table></figure><h2 id="Redis-持久化机制（重要）"><a href="#Redis-持久化机制（重要）" class="headerlink" title="#Redis 持久化机制（重要）"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6-%E9%87%8D%E8%A6%81">#</a>Redis 持久化机制（重要）</h2><p>Redis 持久化机制（RDB 持久化、AOF 持久化、RDB 和 AOF 的混合持久化） 相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 Redis 持久化机制相关的知识点和问题：<a href="https://javaguide.cn/database/redis/redis-persistence.html">Redis 持久化机制详解open in new window</a> 。</p><h2 id="Redis-线程模型（重要）"><a href="#Redis-线程模型（重要）" class="headerlink" title="#Redis 线程模型（重要）"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-%E9%87%8D%E8%A6%81">#</a>Redis 线程模型（重要）</h2><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p><h3 id="Redis-单线程模型了解吗？"><a href="#Redis-单线程模型了解吗？" class="headerlink" title="#Redis 单线程模型了解吗？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BA%86%E8%A7%A3%E5%90%97">#</a>Redis 单线程模型了解吗？</h3><p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><p>《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。</p><blockquote><p>  Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p><ul><li>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>  <strong>虽然文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显：<strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-event-handler.png" alt="文件事件处理器（file event handler）">文件事件处理器（file event handler）</p><p>相关阅读：<a href="http://remcarpediem.net/article/1aa2da89/">Redis 事件机制详解open in new window</a> 。</p><h3 id="Redis6-0-之前为什么不使用多线程？"><a href="#Redis6-0-之前为什么不使用多线程？" class="headerlink" title="#Redis6.0 之前为什么不使用多线程？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis6-0-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B">#</a>Redis6.0 之前为什么不使用多线程？</h3><p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p><p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</p><p>为此，Redis 4.0 之后新增了<code>UNLINK</code>（可以看作是 <code>DEL</code> 的异步版本）、<code>FLUSHALL ASYNC</code>（清空所有数据库的所有 key，不仅仅是当前 <code>SELECT</code> 的数据库）、<code>FLUSHDB ASYNC</code>（清空当前 <code>SELECT</code> 数据库中的所有 key）等异步命令。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-more-thread.png" alt="redis4.0 more thread">redis4.0 more thread</p><p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p><p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p><ul><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ul><p>相关阅读：<a href="https://draveness.me/whys-the-design-redis-single-thread/">为什么 Redis 选择单线程模型？open in new window</a> 。</p><h3 id="Redis6-0-之后为何引入了多线程？"><a href="#Redis6-0-之后为何引入了多线程？" class="headerlink" title="#Redis6.0 之后为何引入了多线程？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B">#</a>Redis6.0 之后为何引入了多线程？</h3><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p><p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">io-threads 4 <span class="hljs-comment">#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span><br></code></pre></td></tr></table></figure><p>另外：</p><ul><li>io-threads 的个数一旦设置，不能通过 config 动态设置。</li><li>当设置 ssl 后，io-threads 将不工作。</li></ul><p>开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 <code>redis.conf</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">io-threads-do-reads <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p><p>相关阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw">Redis 6.0 新特性-多线程连环 13 问！open in new window</a></li><li><a href="https://segmentfault.com/a/1190000039223696">Redis 多线程网络模型全面揭秘open in new window</a>（推荐）</li></ul><h3 id="Redis-后台线程了解吗？"><a href="#Redis-后台线程了解吗？" class="headerlink" title="#Redis 后台线程了解吗？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97">#</a>Redis 后台线程了解吗？</h3><p>我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：</p><ul><li>通过 <code>bio_close_file</code> 后台线程来释放 AOF &#x2F; RDB 等过程中产生的临时文件资源。</li><li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li><li>通过 <code>bio_lazy_free</code>后台线程释放大对象（已删除）占用的内存空间.</li></ul><p>在<code>bio.h</code> 文件中有定义（Redis 6.0 版本，源码地址：<a href="https://github.com/redis/redis/blob/6.0/src/bio.h%EF%BC%89%EF%BC%9A">https://github.com/redis/redis/blob/6.0/src/bio.h）：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">#ifndef __BIO_H<br>#define __BIO_H<br><br><span class="hljs-comment">/* Exported API */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">bioInit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">bioCreateBackgroundJob</span><span class="hljs-params">(<span class="hljs-type">int</span> type, <span class="hljs-keyword">void</span> *arg1, <span class="hljs-keyword">void</span> *arg2, <span class="hljs-keyword">void</span> *arg3)</span>;<br>unsigned <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">bioPendingJobsOfType</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span>;<br>unsigned <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">bioWaitStepOfType</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span>;<br>time_t <span class="hljs-title function_">bioOlderJobOfType</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">bioKillThreads</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>;<br><br><span class="hljs-comment">/* Background job opcodes */</span><br>#define BIO_CLOSE_FILE    <span class="hljs-number">0</span> <span class="hljs-comment">/* Deferred close(2) syscall. */</span><br>#define BIO_AOF_FSYNC     <span class="hljs-number">1</span> <span class="hljs-comment">/* Deferred AOF fsync. */</span><br>#define BIO_LAZY_FREE     <span class="hljs-number">2</span> <span class="hljs-comment">/* Deferred objects freeing. */</span><br>#define BIO_NUM_OPS       <span class="hljs-number">3</span><br><br>#endif<br></code></pre></td></tr></table></figure><p>关于 Redis 后台线程的详细介绍可以查看 <a href="https://juejin.cn/post/7102780434739626014">Redis 6.0 后台线程有哪些？open in new window</a> 这篇就文章。</p><h2 id="Redis-内存管理"><a href="#Redis-内存管理" class="headerlink" title="#Redis 内存管理"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">#</a>Redis 内存管理</h2><h3 id="Redis-给缓存数据设置过期时间有啥用？"><a href="#Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="#Redis 给缓存数据设置过期时间有啥用？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E5%95%A5%E7%94%A8">#</a>Redis 给缓存数据设置过期时间有啥用？</h3><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p><p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; expire key 60 <span class="hljs-comment"># 数据在 60s 后过期</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; setex key 60 value <span class="hljs-comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span><br>OK<br>127.0.0.1:6379&gt; ttl key <span class="hljs-comment"># 查看数据还有多久过期</span><br>(<span class="hljs-built_in">integer</span>) 56<br></code></pre></td></tr></table></figure><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p><p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p><p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 Token 可能只在 1 天内有效。</p><p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p><h3 id="Redis-是如何判断数据是否过期的呢？"><a href="#Redis-是如何判断数据是否过期的呢？" class="headerlink" title="#Redis 是如何判断数据是否过期的呢？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84%E5%91%A2">#</a>Redis 是如何判断数据是否过期的呢？</h3><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-expired-dictionary.png" alt="redis过期字典">redis过期字典</p><p>过期字典是存储在 redisDb 这个结构里的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br>    ...<br><br>    dict *dict;     <span class="hljs-comment">//数据库键空间,保存着数据库中所有键值对</span><br>    dict *expires   <span class="hljs-comment">// 过期字典,保存着键的过期时间</span><br>    ...<br>&#125; redisDb;<br></code></pre></td></tr></table></figure><h3 id="过期的数据的删除策略了解么？"><a href="#过期的数据的删除策略了解么？" class="headerlink" title="#过期的数据的删除策略了解么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E4%B9%88">#</a>过期的数据的删除策略了解么？</h3><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p><p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p><ol><li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p><h3 id="Redis-内存淘汰机制了解么？"><a href="#Redis-内存淘汰机制了解么？" class="headerlink" title="#Redis 内存淘汰机制了解么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88">#</a>Redis 内存淘汰机制了解么？</h3><blockquote><p>  相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p></blockquote><p>Redis 提供 6 种数据淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li><li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis使用规范</title>
    <link href="/2021/04/06/DB/Redis/11.%20Redis%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <url>/2021/04/06/DB/Redis/11.%20Redis%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis应用</title>
    <link href="/2021/04/06/DB/Redis/2.%20Redis%E5%BA%94%E7%94%A8/"/>
    <url>/2021/04/06/DB/Redis/2.%20Redis%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis数据类型</title>
    <link href="/2021/04/06/DB/Redis/3.%20Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/06/DB/Redis/3.%20Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化机制</title>
    <link href="/2021/04/06/DB/Redis/4.%20Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E2%98%85%E2%98%85%E2%98%85/"/>
    <url>/2021/04/06/DB/Redis/4.%20Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E2%98%85%E2%98%85%E2%98%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis线程模型</title>
    <link href="/2021/04/06/DB/Redis/5.%20Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E2%98%85%E2%98%85%E2%98%85/"/>
    <url>/2021/04/06/DB/Redis/5.%20Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E2%98%85%E2%98%85%E2%98%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis内存管理</title>
    <link href="/2021/04/06/DB/Redis/6.%20Redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/04/06/DB/Redis/6.%20Redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis性能优化</title>
    <link href="/2021/04/06/DB/Redis/8.%20Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%98%85%E2%98%85%E2%98%85/"/>
    <url>/2021/04/06/DB/Redis/8.%20Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%98%85%E2%98%85%E2%98%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis生产问题</title>
    <link href="/2021/04/06/DB/Redis/9.%20Redis%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E2%98%85%E2%98%85%E2%98%85/"/>
    <url>/2021/04/06/DB/Redis/9.%20Redis%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E2%98%85%E2%98%85%E2%98%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis事务</title>
    <link href="/2021/04/06/DB/Redis/7.%20Redis%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/04/06/DB/Redis/7.%20Redis%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><h3 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="#什么是 Redis 事务？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF-redis-%E4%BA%8B%E5%8A%A1">#</a>什么是 Redis 事务？</h3><p>你可以将 Redis 中的事务理解为：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><p>Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。</p><p>除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p><p>因此，Redis 事务是不建议在日常开发中使用的。</p><h3 id="如何使用-Redis-事务？"><a href="#如何使用-Redis-事务？" class="headerlink" title="#如何使用 Redis 事务？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-redis-%E4%BA%8B%E5%8A%A1">#</a>如何使用 Redis 事务？</h3><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(Transaction)功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br>&gt; GET PROJECT<br>QUEUED<br>&gt; EXEC<br>1) OK<br>2) <span class="hljs-string">&quot;JavaGuide&quot;</span><br></code></pre></td></tr></table></figure><p><a href="https://redis.io/commands/multi"><code>MULTI</code>open in new window</a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec"><code>EXEC</code>open in new window</a> 命令后，再执行所有的命令。</p><p>这个过程是这样的：</p><ol><li>开始事务（<code>MULTI</code>）；</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li><li>执行事务(<code>EXEC</code>)。</li></ol><p>你也可以通过 <a href="https://redis.io/commands/discard"><code>DISCARD</code>open in new window</a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br>&gt; GET PROJECT<br>QUEUED<br>&gt; DISCARD<br>OK<br></code></pre></td></tr></table></figure><p>你可以通过<a href="https://redis.io/commands/watch"><code>WATCH</code>open in new window</a> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端&#x2F;Session</strong> 修改的话，整个事务都不会被执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 客户端 1</span><br>&gt; SET PROJECT <span class="hljs-string">&quot;RustGuide&quot;</span><br>OK<br>&gt; WATCH PROJECT<br>OK<br>&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br><br><span class="hljs-comment"># 客户端 2</span><br><span class="hljs-comment"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span><br>&gt; SET PROJECT <span class="hljs-string">&quot;GoGuide&quot;</span><br><br><span class="hljs-comment"># 客户端 1</span><br><span class="hljs-comment"># 修改失败，因为 PROJECT 的值被客户端2修改了</span><br>&gt; EXEC<br>(nil)<br>&gt; GET PROJECT<br><span class="hljs-string">&quot;GoGuide&quot;</span><br></code></pre></td></tr></table></figure><p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：<a href="https://github.com/Snailclimb/JavaGuide/issues/1714">WATCH 命令碰到 MULTI 命令时的不同效果open in new window</a>）。</p><p>事务内部修改 WATCH 监视的 Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>OK<br>&gt; WATCH PROJECT<br>OK<br>&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide1&quot;</span><br>QUEUED<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide2&quot;</span><br>QUEUED<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide3&quot;</span><br>QUEUED<br>&gt; EXEC<br>1) OK<br>2) OK<br>3) OK<br>127.0.0.1:6379&gt; GET PROJECT<br><span class="hljs-string">&quot;JavaGuide3&quot;</span><br></code></pre></td></tr></table></figure><p>事务外部修改 WATCH 监视的 Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>OK<br>&gt; WATCH PROJECT<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide2&quot;</span><br>OK<br>&gt; MULTI<br>OK<br>&gt; GET USER<br>QUEUED<br>&gt; EXEC<br>(nil)<br></code></pre></td></tr></table></figure><p>Redis 官网相关介绍 <a href="https://redis.io/topics/transactions">https://redis.io/topics/transactionsopen in new window</a> 如下：</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-transactions.png" alt="Redis 事务">Redis 事务</p><h3 id="Redis-事务支持原子性吗？"><a href="#Redis-事务支持原子性吗？" class="headerlink" title="#Redis 事务支持原子性吗？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97">#</a>Redis 事务支持原子性吗？</h3><p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：<strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p><ol><li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li><li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li></ol><p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。</p><p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-rollback.png" alt="Redis 为什么不支持回滚">Redis 为什么不支持回滚</p><p><strong>相关 issue</strong> :</p><ul><li><a href="https://github.com/Snailclimb/JavaGuide/issues/452">issue#452: 关于 Redis 事务不满足原子性的问题open in new window</a> 。</li><li><a href="https://github.com/Snailclimb/JavaGuide/issues/491">Issue#491:关于 Redis 没有事务回滚？open in new window</a></li></ul><h3 id="Redis-事务支持持久性吗？"><a href="#Redis-事务支持持久性吗？" class="headerlink" title="#Redis 事务支持持久性吗？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E6%8C%81%E4%B9%85%E6%80%A7%E5%90%97">#</a>Redis 事务支持持久性吗？</h3><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p><ul><li>快照（snapshotting，RDB）</li><li>只追加文件（append-only file, AOF）</li><li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li></ul><p>与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendfsync always    <span class="hljs-comment">#每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度</span><br>appendfsync everysec  <span class="hljs-comment">#每秒钟调用fsync函数同步一次AOF文件</span><br>appendfsync no        <span class="hljs-comment">#让操作系统决定何时进行同步，一般为30秒一次</span><br></code></pre></td></tr></table></figure><p>AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p><p>因此，Redis 事务的持久性也是没办法保证的。</p><h3 id="如何解决-Redis-事务的缺陷？"><a href="#如何解决-Redis-事务的缺陷？" class="headerlink" title="#如何解决 Redis 事务的缺陷？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-redis-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%BC%BA%E9%99%B7">#</a>如何解决 Redis 事务的缺陷？</h3><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p><p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p><p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p><p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p><p>另外，Redis 7.0 新增了 <a href="https://redis.io/docs/manual/programmability/functions-intro/">Redis functionsopen in new window</a> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p><h2 id="Redis-性能优化（重要）"><a href="#Redis-性能优化（重要）" class="headerlink" title="#Redis 性能优化（重要）"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%87%8D%E8%A6%81">#</a>Redis 性能优化（重要）</h2><p>除了下面介绍的内容之外，再推荐两篇不错的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ">你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者open in new window</a></li><li><a href="https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html">Redis 常见阻塞原因总结 - JavaGuideopen in new window</a></li></ul><h3 id="使用批量操作减少网络传输"><a href="#使用批量操作减少网络传输" class="headerlink" title="#使用批量操作减少网络传输"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BD%BF%E7%94%A8%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93">#</a>使用批量操作减少网络传输</h3><p>一个 Redis 命令的执行可以简化为以下 4 步：</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果</li></ol><p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p><p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p><p>另外，除了能减少 RTT 之外，发送一次命令的 socket I&#x2F;O 成本也比较高（涉及上下文切换，存在<code>read()</code>和<code>write()</code>系统调用），批量操作还可以减少 socket I&#x2F;O 成本。这个在官方对 pipeline 的介绍中有提到：<a href="https://redis.io/docs/manual/pipelining/">https://redis.io/docs/manual/pipelining/</a> 。</p><h4 id="原生批量操作命令"><a href="#原生批量操作命令" class="headerlink" title="#原生批量操作命令"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">#</a>原生批量操作命令</h4><p>Redis 中有一些原生支持批量操作的命令，比如：</p><ul><li><code>MGET</code>(获取一个或多个指定 key 的值)、<code>MSET</code>(设置一个或多个指定 key 的值)、</li><li><code>HMGET</code>(获取指定哈希表中一个或者多个指定字段的值)、<code>HMSET</code>(同时将一个或多个 field-value 对设置到指定哈希表中)、</li><li><code>SADD</code>（向指定集合添加一个或多个元素）</li><li>……</li></ul><p>不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 <code>MGET</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>MGET</code>可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p><p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p><ol><li>找到 key 对应的所有 hash slot；</li><li>分别向对应的 Redis 节点发起 <code>MGET</code> 请求获取数据；</li><li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li></ol><p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p><blockquote><p>  Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p><p>  我在 <a href="https://javaguide.cn/database/redis/redis-cluster.html">Redis 集群详解（付费）open in new window</a> 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。</p></blockquote><h4 id="pipeline"><a href="#pipeline" class="headerlink" title="#pipeline"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#pipeline">#</a>pipeline</h4><p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p><p>与<code>MGET</code>、<code>MSET</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p><p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p><ul><li>原生批量操作命令是原子操作，pipeline 是非原子操作。</li><li>pipeline 可以打包不同的命令，原生批量操作命令不可以。</li><li>原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li></ul><p>顺带补充一下 pipeline 和 Redis 事务的对比：</p><ul><li>事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。</li><li>Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。</li></ul><blockquote><p>  事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。</p></blockquote><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-pipeline-vs-transaction.png" alt="img"></p><p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p><h4 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="#Lua 脚本"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#lua-%E8%84%9A%E6%9C%AC">#</a>Lua 脚本</h4><p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 <strong>原子操作</strong> 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p><p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p><p>不过， Lua 脚本依然存在下面这些缺陷：</p><ul><li>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li><li>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</li></ul><h3 id="大量-key-集中过期问题"><a href="#大量-key-集中过期问题" class="headerlink" title="#大量 key 集中过期问题"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A4%A7%E9%87%8F-key-%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98">#</a>大量 key 集中过期问题</h3><p>我在前面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 策略。</p><p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p><p><strong>如何解决呢？</strong> 下面是两种常见的方法：</p><ol><li>给 key 设置随机过期时间。</li><li>开启 lazy-free（惰性删除&#x2F;延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ol><p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p><h3 id="Redis-bigkey（大-Key）"><a href="#Redis-bigkey（大-Key）" class="headerlink" title="#Redis bigkey（大 Key）"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-bigkey-%E5%A4%A7-key">#</a>Redis bigkey（大 Key）</h3><h4 id="什么是-bigkey？"><a href="#什么是-bigkey？" class="headerlink" title="#什么是 bigkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF-bigkey">#</a>什么是 bigkey？</h4><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p><h4 id="bigkey-有什么危害？"><a href="#bigkey-有什么危害？" class="headerlink" title="#bigkey 有什么危害？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#bigkey-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3">#</a>bigkey 有什么危害？</h4><p>bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。因此，我们应该尽量避免 Redis 中存在 bigkey。</p><h4 id="如何发现-bigkey？"><a href="#如何发现-bigkey？" class="headerlink" title="#如何发现 bigkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0-bigkey">#</a>如何发现 bigkey？</h4><p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># redis-cli -p 6379 --bigkeys</span><br><br><span class="hljs-comment"># Scanning the entire keyspace to find biggest keys as well as</span><br><span class="hljs-comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span><br><span class="hljs-comment"># per 100 SCAN commands (not usually needed).</span><br><br>[00.00%] Biggest string found so far <span class="hljs-string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> with 4437 bytes<br>[00.00%] Biggest list   found so far <span class="hljs-string">&#x27;&quot;my-list&quot;&#x27;</span> with 17 items<br><br>-------- summary -------<br><br>Sampled 5 keys <span class="hljs-keyword">in</span> the keyspace!<br>Total key length <span class="hljs-keyword">in</span> bytes is 264 (avg len 52.80)<br><br>Biggest   list found <span class="hljs-string">&#x27;&quot;my-list&quot;&#x27;</span> has 17 items<br>Biggest string found <span class="hljs-string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> has 4437 bytes<br><br>1 lists with 17 items (20.00% of keys, avg size 17.00)<br>0 hashs with 0 fields (00.00% of keys, avg size 0.00)<br>4 strings with 4831 bytes (80.00% of keys, avg size 1207.75)<br>0 streams with 0 entries (00.00% of keys, avg size 0.00)<br>0 sets with 0 members (00.00% of keys, avg size 0.00)<br>0 zsets with 0 members (00.00% of keys, avg size 0.00<br></code></pre></td></tr></table></figure><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。然而，一个 key 的元素多并不代表占用内存也多，需要我们根据具体的业务情况来进一步判断。</p><p>在线上执行该命令时，为了降低对 Redis 的影响，需要指定 <code>-i</code> 参数控制扫描的频率。<code>redis-cli -p 6379 --bigkeys -i 3</code> 表示扫描过程中每次扫描后休息的时间间隔为 3 秒。</p><p><strong>2、借助开源工具分析 RDB 文件。</strong></p><p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p><p>网上有现成的代码&#x2F;工具可以直接拿来使用：</p><ul><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools">redis-rdb-toolsopen in new window</a>：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li><li><a href="https://github.com/weiyanwei412/rdb_bigkeys">rdb_bigkeysopen in new window</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li></ul><p><strong>3、借助公有云的 Redis 分析服务。</strong></p><p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p><p>这里以阿里云 Redis 为例说明，它支持 bigkey 实时分析、发现，文档地址：<a href="https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-featureopen in new window</a> 。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/aliyun-key-analysis.png" alt="阿里云Key分析">阿里云Key分析</p><h4 id="如何处理-bigkey？"><a href="#如何处理-bigkey？" class="headerlink" title="#如何处理 bigkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-bigkey">#</a>如何处理 bigkey？</h4><p>bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p><ul><li><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。这种方式需要修改业务层的代码，一般不推荐这样做。</li><li><strong>手动清理</strong>：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li><li><strong>采用合适的数据结构</strong>：比如使用 HyperLogLog 统计页面 UV。</li><li><strong>开启 lazy-free（惰性删除&#x2F;延迟释放）</strong> ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ul><h3 id="Redis-hotkey（热-Key）"><a href="#Redis-hotkey（热-Key）" class="headerlink" title="#Redis hotkey（热 Key）"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-hotkey-%E7%83%AD-key">#</a>Redis hotkey（热 Key）</h3><h4 id="什么是-hotkey？"><a href="#什么是-hotkey？" class="headerlink" title="#什么是 hotkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF-hotkey">#</a>什么是 hotkey？</h4><p>如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 <strong>hotkey（热 Key）</strong>。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。</p><p>hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p><h4 id="hotkey-有什么危害？"><a href="#hotkey-有什么危害？" class="headerlink" title="#hotkey 有什么危害？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#hotkey-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3">#</a>hotkey 有什么危害？</h4><p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</p><p>因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p><h4 id="如何发现-hotkey？"><a href="#如何发现-hotkey？" class="headerlink" title="#如何发现 hotkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0-hotkey">#</a>如何发现 hotkey？</h4><p><strong>1、使用 Redis 自带的 <code>--hotkeys</code> 参数来查找。</strong></p><p>Redis 4.0.3 版本中新增了 <code>hotkeys</code> 参数，该参数能够返回所有 key 的被访问次数。</p><p>使用该方案的前提条件是 Redis Server 的 <code>maxmemory-policy</code> 参数设置为 LFU 算法，不然就会出现如下所示的错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># redis-cli -p 6379 --hotkeys</span><br><br><span class="hljs-comment"># Scanning the entire keyspace to find hot keys as well as</span><br><span class="hljs-comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span><br><span class="hljs-comment"># per 100 SCAN commands (not usually needed).</span><br><br>Error: ERR An LFU maxmemory policy is not selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust.<br></code></pre></td></tr></table></figure><p>Redis 中有两种 LFU 算法：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li></ol><p>以下是配置文件 <code>redis.conf</code> 中的示例：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 使用 volatile-lfu 策略</span><br><span class="hljs-attr">maxmemory-policy</span> <span class="hljs-string">volatile-lfu</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 或者使用 allkeys-lfu 策略</span><br><span class="hljs-attr">maxmemory-policy</span> <span class="hljs-string">allkeys-lfu</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>hotkeys</code> 参数命令也会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。</p><p><strong>2、使用<code>MONITOR</code> 命令。</strong></p><p><code>MONITOR</code> 命令是 Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。</p><p>由于该命令对 Redis 性能的影响比较大，因此禁止长时间开启 <code>MONITOR</code>（生产环境中建议谨慎使用该命令）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"># redis-cli<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; MONITOR<br>OK<br><span class="hljs-number">1683638260.637378</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61516</span>] <span class="hljs-string">&quot;ping&quot;</span><br><span class="hljs-number">1683638267.144236</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br><span class="hljs-number">1683638268.941863</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br><span class="hljs-number">1683638269.551671</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br><span class="hljs-number">1683638270.646256</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61516</span>] <span class="hljs-string">&quot;ping&quot;</span><br><span class="hljs-number">1683638270.849551</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br><span class="hljs-number">1683638271.926945</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br><span class="hljs-number">1683638274.276599</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet2&quot;</span><br><span class="hljs-number">1683638276.327234</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br></code></pre></td></tr></table></figure><p>在发生紧急情况时，我们可以选择在合适的时机短暂执行 <code>MONITOR</code> 命令并将输出重定向至文件，在关闭 <code>MONITOR</code> 命令后通过对文件中请求进行归类分析即可找出这段时间中的 hotkey。</p><p><strong>3、借助开源项目。</strong></p><p>京东零售的 <a href="https://gitee.com/jd-platform-opensource/hotkey">hotkeyopen in new window</a> 这个项目不光支持 hotkey 的发现，还支持 hotkey 的处理。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/jd-hotkey.png" alt="京东零售开源的 hotkey">京东零售开源的 hotkey</p><p><strong>4、根据业务情况提前预估。</strong></p><p>可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。</p><p><strong>5、业务代码中记录分析。</strong></p><p>在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。</p><p><strong>6、借助公有云的 Redis 分析服务。</strong></p><p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p><p>这里以阿里云 Redis 为例说明，它支持 hotkey 实时分析、发现，文档地址：<a href="https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-featureopen in new window</a> 。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/aliyun-key-analysis.png" alt="阿里云Key分析">阿里云Key分析</p><h4 id="如何解决-hotkey？"><a href="#如何解决-hotkey？" class="headerlink" title="#如何解决 hotkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-hotkey">#</a>如何解决 hotkey？</h4><p>hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p><ul><li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</li><li><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</li><li><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</li></ul><p>除了这些方法之外，如果你使用的公有云的 Redis 服务话，还可以留意其提供的开箱即用的解决方案。</p><p>这里以阿里云 Redis 为例说明，它支持通过代理查询缓存功能（Proxy Query Cache）优化热点 Key 问题。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/aliyun-hotkey-proxy-query-cache.png" alt="通过阿里云的Proxy Query Cache优化热点Key问题">通过阿里云的Proxy Query Cache优化热点Key问题</p><h3 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="#慢查询命令"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4">#</a>慢查询命令</h3><h4 id="为什么会有慢查询命令？"><a href="#为什么会有慢查询命令？" class="headerlink" title="#为什么会有慢查询命令？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4">#</a>为什么会有慢查询命令？</h4><p>我们知道一个 Redis 命令的执行可以简化为以下 4 步：</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果</li></ol><p>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</p><p>Redis 为什么会有慢查询命令呢？</p><p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p><ul><li><code>KEYS *</code>：会返回所有符合规则的 key。</li><li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li><li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li><li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li><li><code>SINTER</code>&#x2F;<code>SUNION</code>&#x2F;<code>SDIFF</code>：计算多个 Set 的交集&#x2F;并集&#x2F;差集。</li><li>……</li></ul><p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p><p>除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p><ul><li><code>ZRANGE</code>&#x2F;<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li><li><code>ZREMRANGEBYRANK</code>&#x2F;<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围&#x2F;指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li><li>……</li></ul><h4 id="如何找到慢查询命令？"><a href="#如何找到慢查询命令？" class="headerlink" title="#如何找到慢查询命令？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4">#</a>如何找到慢查询命令？</h4><p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。</p><p>当 Redis 服务器检测到执行时间超过 <code>slowlog-log-slower-than</code>阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。</p><p>⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</p><p><code>slowlog-log-slower-than</code>和<code>slowlog-max-len</code>的默认配置如下(可以自行修改)：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="hljs-comment"># to one second. Note that a negative number disables the slow log, while</span><br><span class="hljs-comment"># a value of zero forces the logging of every command.</span><br>slowlog-log-slower-<span class="hljs-attribute">than</span> <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="hljs-comment"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br>slowlog-max-len <span class="hljs-number">128</span><br></code></pre></td></tr></table></figure><p>除了修改配置文件之外，你也可以直接通过 <code>CONFIG</code> 命令直接设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令执行耗时超过 10000 微妙（即10毫秒）就会被记录</span><br>CONFIG SET slowlog-log-slower-than 10000<br><span class="hljs-comment"># 只保留最近 128 条耗时命令</span><br>CONFIG SET slowlog-max-len 128<br></code></pre></td></tr></table></figure><p>获取慢查询日志的内容很简单，直接使用<code>SLOWLOG GET</code> 命令即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SLOWLOG GET #慢日志查询<br> <span class="hljs-number">1</span>) <span class="hljs-number">1</span>) (integer) <span class="hljs-number">5</span><br>   <span class="hljs-number">2</span>) (integer) <span class="hljs-number">1684326682</span><br>   <span class="hljs-number">3</span>) (integer) <span class="hljs-number">12000</span><br>   <span class="hljs-number">4</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;KEYS&quot;</span><br>      <span class="hljs-number">2</span>) <span class="hljs-string">&quot;*&quot;</span><br>   <span class="hljs-number">5</span>) <span class="hljs-string">&quot;172.17.0.1:61152&quot;</span><br>   <span class="hljs-number">6</span>) <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>慢查询日志中的每个条目都由以下六个值组成：</p><ol><li>唯一渐进的日志标识符。</li><li>处理记录命令的 Unix 时间戳。</li><li>执行所需的时间量，以微秒为单位。</li><li>组成命令参数的数组。</li><li>客户端 IP 地址和端口。</li><li>客户端名称。</li></ol><p><code>SLOWLOG GET</code> 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 <code>SLOWLOG GET N</code>。</p><p>下面是其他比较常用的慢查询相关的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 返回慢查询命令的数量</span><br>127.0.0.1:6379&gt; SLOWLOG LEN<br>(<span class="hljs-built_in">integer</span>) 128<br><span class="hljs-comment"># 清空慢查询命令</span><br>127.0.0.1:6379&gt; SLOWLOG RESET<br>OK<br></code></pre></td></tr></table></figure><h3 id="Redis-内存碎片"><a href="#Redis-内存碎片" class="headerlink" title="#Redis 内存碎片"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87">#</a>Redis 内存碎片</h3><p><strong>相关问题</strong>：</p><ol><li>什么是内存碎片?为什么会有 Redis 内存碎片?</li><li>如何清理 Redis 内存碎片？</li></ol><p><strong>参考答案</strong>：<a href="https://javaguide.cn/database/redis/redis-memory-fragmentation.html">Redis 内存碎片详解open in new window</a>。</p><h2 id="Redis-生产问题（重要）"><a href="#Redis-生产问题（重要）" class="headerlink" title="#Redis 生产问题（重要）"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-%E9%87%8D%E8%A6%81">#</a>Redis 生产问题（重要）</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="#缓存穿透"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">#</a>缓存穿透</h3><h4 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="#什么是缓存穿透？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">#</a>什么是缓存穿透？</h4><p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-penetration.png" alt="缓存穿透">缓存穿透</p><p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p><h4 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="#有哪些解决办法？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">#</a>有哪些解决办法？</h4><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的：<code>表名:列名:主键名:主键值</code> 。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObjectInclNullById</span><span class="hljs-params">(Integer id)</span> &#123;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheValue</span> <span class="hljs-operator">=</span> cache.get(id);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (cacheValue == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 从数据库中获取</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">storageValue</span> <span class="hljs-operator">=</span> storage.get(key);<br>        <span class="hljs-comment">// 缓存空对象</span><br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span><br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 必须设置过期时间，否则有被攻击的风险</span><br>            cache.expire(key, <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cacheValue;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-penetration-bloom-filter.png" alt="加入布隆过滤器之后的缓存处理流程图">加入布隆过滤器之后的缓存处理流程图</p><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter/">《不了解布隆过滤器？一文给你整的明明白白！》open in new window</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="#缓存击穿"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">#</a>缓存击穿</h3><h4 id="什么是缓存击穿？"><a href="#什么是缓存击穿？" class="headerlink" title="#什么是缓存击穿？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">#</a>什么是缓存击穿？</h4><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-breakdown.png" alt="缓存击穿">缓存击穿</p><p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h4 id="有哪些解决办法？-1"><a href="#有哪些解决办法？-1" class="headerlink" title="#有哪些解决办法？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-1">#</a>有哪些解决办法？</h4><ul><li>设置热点数据永不过期或者过期时间比较长。</li><li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li></ul><h4 id="缓存穿透和缓存击穿有什么区别？"><a href="#缓存穿透和缓存击穿有什么区别？" class="headerlink" title="#缓存穿透和缓存击穿有什么区别？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>缓存穿透和缓存击穿有什么区别？</h4><p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="#缓存雪崩"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">#</a>缓存雪崩</h3><h4 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="#什么是缓存雪崩？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">#</a>什么是缓存雪崩？</h4><p>我发现缓存雪崩这名字起的有点意思，哈哈。</p><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-avalanche.png" alt="缓存雪崩">缓存雪崩</p><p>举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h4 id="有哪些解决办法？-2"><a href="#有哪些解决办法？-2" class="headerlink" title="#有哪些解决办法？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-2">#</a>有哪些解决办法？</h4><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效（不太推荐，实用性太差）。</li><li>设置二级缓存。</li></ol><h4 id="缓存雪崩和缓存击穿有什么区别？"><a href="#缓存雪崩和缓存击穿有什么区别？" class="headerlink" title="#缓存雪崩和缓存击穿有什么区别？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>缓存雪崩和缓存击穿有什么区别？</h4><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p><h3 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="#如何保证缓存和数据库数据的一致性？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7">#</a>如何保证缓存和数据库数据的一致性？</h3><p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p><p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p><p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加 cache 更新重试机制（常用）</strong>：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li></ol><p>相关文章推荐：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹open in new window</a>。</p><h3 id="哪些情况可能会导致-Redis-阻塞？"><a href="#哪些情况可能会导致-Redis-阻塞？" class="headerlink" title="#哪些情况可能会导致 Redis 阻塞？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4-redis-%E9%98%BB%E5%A1%9E">#</a>哪些情况可能会导致 Redis 阻塞？</h3><p>单独抽了一篇文章来总结可能会导致 Redis 阻塞的情况：<a href="https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html">Redis 常见阻塞原因总结open in new window</a>。</p><h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="#Redis 集群"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E9%9B%86%E7%BE%A4">#</a>Redis 集群</h2><p><strong>Redis Sentinel</strong>：</p><ol><li>什么是 Sentinel？ 有什么用？</li><li>Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</li><li>Sentinel 是如何实现故障转移的？</li><li>为什么建议部署多个 sentinel 节点（哨兵集群）？</li><li>Sentinel 如何选择出新的 master（选举机制）?</li><li>如何从 Sentinel 集群中选择出 Leader ？</li><li>Sentinel 可以防止脑裂吗？</li></ol><p><strong>Redis Cluster</strong>：</p><ol><li>为什么需要 Redis Cluster？解决了什么问题？有什么优势？</li><li>Redis Cluster 是如何分片的？</li><li>为什么 Redis Cluster 的哈希槽是 16384 个?</li><li>如何确定给定 key 的应该分布到哪个哈希槽中？</li><li>Redis Cluster 支持重新分配哈希槽吗？</li><li>Redis Cluster 扩容缩容期间可以提供服务吗？</li><li>Redis Cluster 中的节点是怎么进行通信的？</li></ol><p><strong>参考答案</strong>：<a href="https://javaguide.cn/database/redis/redis-cluster.html">Redis 集群详解（付费）open in new window</a>。</p><h2 id="Redis-使用规范"><a href="#Redis-使用规范" class="headerlink" title="#Redis 使用规范"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83">#</a>Redis 使用规范</h2><p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p><ol><li>使用连接池：避免频繁创建关闭客户端连接。</li><li>尽量不使用 O(n)指令，使用 O(n) 命令时要关注 n 的数量：像 <code>KEYS *</code>、<code>HGETALL</code>、<code>LRANGE</code>、<code>SMEMBERS</code>、<code>SINTER</code>&#x2F;<code>SUNION</code>&#x2F;<code>SDIFF</code>等 O(n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</li><li>使用批量操作减少网络传输：原生批量操作命令（比如 <code>MGET</code>、<code>MSET</code>等等）、pipeline、Lua 脚本。</li><li>尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li><li>禁止长时间开启 monitor：对性能影响比较大。</li><li>控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。</li><li>……</li></ol><p>相关文章推荐：<a href="https://developer.aliyun.com/article/531067">阿里云 Redis 开发规范open in new window</a> </p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis缓存</title>
    <link href="/2021/04/06/DB/Redis/%E7%BC%93%E5%AD%98/"/>
    <url>/2021/04/06/DB/Redis/%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><ol><li>导入依赖</li><li>配置redis主机地址</li><li>自动注入RedisTemplate</li><li>使用RedisTemplate的方法将缓存放到数据库</li></ol><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><ul><li>缓存穿透：缓存和数据库都没有的数据被大量请求，导致数据库压力过大<ul><li>解决方案：缓存空对象、布隆过滤器</li></ul></li><li>缓存雪崩：缓存在某一时刻大量失效，请求全部转发到数据库，导致数据库压力过大<ul><li>解决方案：过期时间设置随机部分、设置热点数据永不过期、降级熔断</li></ul></li><li>缓存击穿：并发的查询同一条  缓存中没有（缓存到期）但数据库中有 的数据，同时查询数据库导致击穿<ul><li>解决方案：设置热点数据永不过期、互斥锁</li><li>可以选择加锁，竞争到锁后，确认缓存中是否有数据，没有的情况下再查数据库，然后加入缓存，解锁。</li></ul></li></ul><blockquote><p>雪崩是：不同数据过期</p><p>击穿是：某条热点数据过期</p></blockquote><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><blockquote><p>本地缓存的问题所在：每个微服务都要有缓存，然而缓存的数据可能不一致</p></blockquote><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式的项目，本地锁只能锁住当前服务，所以需要分布式锁。</p><blockquote><p>分布式锁的过程：</p><ul><li>没获得锁 -&gt; 阻塞或者sleep一会   （或者自旋？）</li><li>加锁，但解锁之前服务挂掉，没有执行解锁的逻辑，造成死锁<ul><li>解决方法：设置过期时间，时间到了自动解锁</li></ul></li><li>业务没有执行完的时候锁过期了，其它线程拿到了锁，本进程执行完之后，将其他进程的锁删了<ul><li>解决方法：锁续期（Redisson有看门狗），删锁的时候确认是自己的锁（对锁加上UUID）</li></ul></li><li>确认是自己的锁，但在将要删除的时候锁过期了换了别人的锁，即想要删除的时候锁被掉包了<ul><li>解决方法：删除锁的时候必须保证原子性（判断锁和删锁是原子的），使用redis+Lua脚本完成，脚本是原子的。但比较麻烦，所以可以考虑使用现有框架，比如Redisson。</li></ul></li></ul></blockquote><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;!- 练习使用，更推荐使用redisson-spring-boot-starter -&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>开启配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRedisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;ipAddr&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String ipAddr;<br><br>    <span class="hljs-comment">// redission通过redissonClient对象使用 // 如果是多个redis集群，可以配置</span><br>    <span class="hljs-meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redisson</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        <span class="hljs-comment">// 创建单例模式的配置</span><br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://&quot;</span> + ipAddr + <span class="hljs-string">&quot;:6379&quot;</span>);<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注入RedissonClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br></code></pre></td></tr></table></figure></li><li><p>使用方法进行加锁、解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;锁名称，尽量保持唯一性，所以可以写的具体一点&quot;</span>)；<br>lock.lock(); <span class="hljs-comment">//阻塞等待，内为死循环</span><br>lock.unlock();<span class="hljs-comment">//推荐放入到finally。如果解锁之前，程序宕机也没关系，因为Redisson有看门狗</span><br></code></pre></td></tr></table></figure><blockquote><p>看门狗：在业务执行完之前，不断延长锁的有效期。默认情况下，锁的超时时间是30s，而看门狗会在时间过去三分之一的时候，即剩余20s的时候将锁的有效期延长成为30s。这个期限可以通过Config.lockWatchdoyTimeout来另行修改。</p></blockquote></li><li><p><code>推荐用法</code>：自己指定锁时间，时间长点即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">lock.lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<span class="hljs-comment">//指定过期时间后，超时自动解锁，看门狗不会延长锁的有效期。</span><br>lock.tryLock(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<span class="hljs-comment">//尝试加锁，不会阻塞等待。最多等待100秒，10秒后自动解锁</span><br><span class="hljs-comment">//内部逻辑：</span><br><span class="hljs-comment">//如果设置了锁的超时时间，就执行脚本占锁，</span><br><span class="hljs-comment">//如果没设置锁的超时时间，使用开门狗的时间去占锁，然后根据进程id判断线程没结束？就调用看门狗的定时任务，重新给锁设置过期时间。</span><br><span class="hljs-comment">//定时任务的周期为：锁时间 / 3 </span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*基于Redis的Redisson分布式可重入读写锁RReadWriteLock Java对象实现了java.util.concurrent.locks.ReadWriteLock接口。其中读锁和写锁都继承了RLock接口。</span><br><span class="hljs-comment">分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">RReadWriteLock</span> <span class="hljs-variable">rwlock</span> <span class="hljs-operator">=</span> redisson.getReadWriteLock(<span class="hljs-string">&quot;anyRWLock&quot;</span>);<br><span class="hljs-comment">// 最常见的使用方法</span><br>rwlock.readLock().lock();<br><span class="hljs-comment">// 或</span><br>rwlock.writeLock().lock();<br><span class="hljs-comment">// 10秒钟以后自动解锁</span><br><span class="hljs-comment">// 无需调用unlock方法手动解锁</span><br>rwlock.readLock().lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br><span class="hljs-comment">// 或</span><br>rwlock.writeLock().lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> rwlock.readLock().tryLock(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br><span class="hljs-comment">// 或</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> rwlock.writeLock().tryLock(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure></li></ol><h3 id="分布式信号量Semaphore"><a href="#分布式信号量Semaphore" class="headerlink" title="分布式信号量Semaphore"></a>分布式信号量Semaphore</h3><blockquote><p>RLock对象完全符合Java的Lock规范，即只有拥有锁的进程才能解锁，如果其他进程尝试解锁会抛出IllegalMonitorStateException的异常。如果需要其他进程也能解锁，可以使用分布式信号量Semaphore。</p></blockquote><blockquote><p>信号量为存储在redis中的一个数字，当这个数字大于0时，即可以调用<code>acquire()</code>方法减少数量，也可以调用<code>release()</code>方法增加数量，但是当调用<code>release()</code>之后小于0的话方法就会阻塞，直到数字大于0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RSemaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> redisson.getSemaphore(<span class="hljs-string">&quot;semaphore&quot;</span>);<br>semaphore.acquire();<br><span class="hljs-comment">//或</span><br>semaphore.acquireAsync();<br>semaphore.acquire(<span class="hljs-number">23</span>);<br>semaphore.tryAcquire();<br><span class="hljs-comment">//或</span><br>semaphore.tryAcquireAsync();<br>semaphore.tryAcquire(<span class="hljs-number">23</span>, TimeUnit.SECONDS);<br><span class="hljs-comment">//或</span><br>semaphore.tryAcquireAsync(<span class="hljs-number">23</span>, TimeUnit.SECONDS);<br>semaphore.release(<span class="hljs-number">10</span>);<br>semaphore.release();<br><span class="hljs-comment">//或</span><br>semaphore.releaseAsync();<br></code></pre></td></tr></table></figure><h3 id="闭锁（CountDownLatch）"><a href="#闭锁（CountDownLatch）" class="headerlink" title="闭锁（CountDownLatch）"></a>闭锁（CountDownLatch）</h3><blockquote><p>基于Redisson的Redisson分布式闭锁CountDownLatch，Java对象<code>RCountDownLatch</code>采用了与<code>java.util.concurrent.CountDownLatch</code>相似的接口和用法。</p></blockquote><blockquote><p>只有在某个方法调用了n次之后，另一个方法才能执行。比如商品被卖了100次，调用卖完了这个方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockDoor</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">RCountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> redisson.getCountDownLatch(<span class="hljs-string">&quot;anyCountDownLatch&quot;</span>);<br>    latch.trySetCount(<span class="hljs-number">10</span>);<br>    latch.await();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gogo</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">RCountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> redisson.getCountDownLatch(<span class="hljs-string">&quot;anyCountDownLatch&quot;</span>);<br>    latch.countDown();<span class="hljs-comment">//只有lockDoor被调用了10次，这个gogo方法才能执行完</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缓存和数据库一致性问题"><a href="#缓存和数据库一致性问题" class="headerlink" title="缓存和数据库一致性问题"></a>缓存和数据库一致性问题</h3><ul><li>双写模式：写数据库后，写缓存<ul><li>问题：并发时，2写进入，写完DB后都写缓存，1写完库，2写完库，2写缓存，1写缓存，有暂时的脏数据</li></ul></li><li>失效模式：写完数据库后，删缓存<ul><li>问题：1写完删完，2正在写，此时3开始读，只能读到1，而3读到1之后，2把缓存删了，3把1更新到缓存</li><li>解决：缓存设置过期时间，定期更新</li><li>解决：写数据写时，加分布式的读写锁。</li></ul></li></ul><blockquote><p>解决方案：</p><ul><li>如果是用户纬度数据（订单数据、用户数据），这种并发几率非常小，不用考虑这个问题，缓存数据加上过期时间，每隔一段时间触发读的主动更新即可</li><li>如果是菜单，商品介绍等基础数据，也可以去使用canal订阅binlog的方式（数据更新后canal得到日志的消息去更新缓存）<br>缓存数据+过期时间也足够解决大部分业务对于缓存的要求。</li><li>通过加锁保证并发读写，写写的时候按顺序排好队。读读无所谓。所以适合使用读写锁。（业务不关心脏数据，允许临时脏数据可忽略）</li></ul><p>总结：我们<code>能放入缓存的数据本就不应该是实时性、一致性要求超高的</code>。所以缓存数据的时候加上过期时间，保证每天拿到当前最新数据即可。我们<code>不应该过度设计，增加系统的复杂性</code>。遇到<code>实时性、一致性要求高的数据，就应该查数据库</code>，即使慢点。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CountDownLatch</title>
    <link href="/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/CountDownLatch/"/>
    <url>/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/CountDownLatch/</url>
    
    <content type="html"><![CDATA[<h3 id="CountDownLatch-倒计时器"><a href="#CountDownLatch-倒计时器" class="headerlink" title="CountDownLatch 倒计时器"></a>CountDownLatch 倒计时器</h3><h4 id="CountDownLatch-有什么用？"><a href="#CountDownLatch-有什么用？" class="headerlink" title="CountDownLatch 有什么用？"></a>CountDownLatch 有什么用？</h4><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><h4 id="CountDownLatch-的原理是什么？"><a href="#CountDownLatch-的原理是什么？" class="headerlink" title="CountDownLatch 的原理是什么？"></a>CountDownLatch 的原理是什么？</h4><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到<code>count</code> 个线程调用了<code>countDown()</code>使state值被减为0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</p><h4 id="CountDownLatch-是在什么场景下用的？"><a href="#CountDownLatch-是在什么场景下用的？" class="headerlink" title="CountDownLatch 是在什么场景下用的？"></a>CountDownLatch 是在什么场景下用的？</h4><p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p><p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p><p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Semaphore</title>
    <link href="/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/Semaphore/"/>
    <url>/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/Semaphore/</url>
    
    <content type="html"><![CDATA[<h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h3><h4 id="Semaphore（信号量）有什么用？"><a href="#Semaphore（信号量）有什么用？" class="headerlink" title="Semaphore（信号量）有什么用？"></a>Semaphore（信号量）有什么用？</h4><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p><p>Semaphore 的使用简单，我们这里假设有 N(N&gt;5) 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始共享资源数量</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 获取1个许可</span><br>semaphore.acquire();<br><span class="hljs-comment">// 释放1个许可</span><br>semaphore.release();<br></code></pre></td></tr></table></figure><p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p><p><code>Semaphore</code> 有两种模式：。</p><ul><li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li><li><strong>非公平模式：</strong> 抢占式的。</li></ul><p><code>Semaphore</code> 对应的两个构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>  sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>  sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p><p><code>Semaphore</code> 通常用于那些资源有明确访问数量限制的场景比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）。</p><p>Semaphore 的原理是什么？</p><p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p><p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt; 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state &lt;= 0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  获取1个许可证</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 共享模式下获取许可证，获取成功则返回，失败则加入阻塞队列，挂起线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <span class="hljs-comment">// 尝试获取许可证，arg为获取许可证个数，当可用许可证数减当前获取的许可证数结果小于0,则创建一个节点加入阻塞队列，挂起当前线程。</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>      doAcquireSharedInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 释放一个许可证</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>  sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 释放共享锁，同时会唤醒同步队列中的一个线程。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//释放共享锁</span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>      <span class="hljs-comment">//唤醒同步队列中的一个线程</span><br>      doReleaseShared();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentLinkedQueue</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentLinkedQueue/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentLinkedQueue/</url>
    
    <content type="html"><![CDATA[<p>Java 提供的线程安全的 <code>Queue</code> 可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，其中阻塞队列的典型例子是 <code>BlockingQueue</code>，非阻塞队列的典型例子是 <code>ConcurrentLinkedQueue</code>，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 <strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p><p>从名字可以看出，<code>ConcurrentLinkedQueue</code>这个队列使用链表作为其数据结构．<code>ConcurrentLinkedQueue</code> 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p><p><code>ConcurrentLinkedQueue</code> 内部代码我们就不分析了，大家知道 <code>ConcurrentLinkedQueue</code> 主要使用 CAS 非阻塞算法来实现线程安全就好了。</p><p><code>ConcurrentLinkedQueue</code> 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 <code>ConcurrentLinkedQueue</code> 来替代。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CyclicBarrier</title>
    <link href="/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/CyclicBarrier/"/>
    <url>/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/CyclicBarrier/</url>
    
    <content type="html"><![CDATA[<h3 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier 循环栅栏"></a>CyclicBarrier 循环栅栏</h3><h4 id="CyclicBarrier-有什么用？"><a href="#CyclicBarrier-有什么用？" class="headerlink" title="CyclicBarrier 有什么用？"></a>CyclicBarrier 有什么用？</h4><p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p><blockquote><p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p></blockquote><p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><blockquote><p>  2023.10.17补充：当所有线程都通过了屏障后，屏障会重新关闭，并且计数器也会被重置为初始化值。</p><p>  可以理解为，循环栅栏始终为某批线程服务，线程运行的中间有一些需要等待所有线程都抵达才能执行下一段任务的点。</p></blockquote><h4 id="CyclicBarrier-的原理是什么？"><a href="#CyclicBarrier-的原理是什么？" class="headerlink" title="CyclicBarrier 的原理是什么？"></a>CyclicBarrier 的原理是什么？</h4><p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//每次拦截的线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;<br><span class="hljs-comment">//计数器</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br></code></pre></td></tr></table></figure><p>1、<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p><p>2、当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentHashMap/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ConcurrentHashMap-1-7"><a href="#1-ConcurrentHashMap-1-7" class="headerlink" title="1. ConcurrentHashMap 1.7"></a>1. ConcurrentHashMap 1.7</h2><p><code>HashMap</code> 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 <code>Collections.synchronizedMap()</code> 方法来包装我们的 <code>HashMap</code>。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p><p>所以就有了 <code>HashMap</code> 的线程安全版本—— <code>ConcurrentHashMap</code> 的诞生。</p><p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p><p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p><h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231011160536836.png" alt="image-20231011160536836"></p><p>Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code> 组合，而每一个 <code>Segment</code> 是一个类似于 <code>HashMap</code> 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p><blockquote><p>个人理解：将一个map分割为N块，最多允许N个线程分别访问每块的数据</p></blockquote><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h3><p>通过 <code>ConcurrentHashMap</code> 的无参构造探寻 <code>ConcurrentHashMap</code> 的初始化流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new, empty map with a default initial capacity (16),</span><br><span class="hljs-comment"> * load factor (0.75) and concurrencyLevel (16).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);<br>&#125;<br></code></pre></td></tr></table></figure><p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认初始化容量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认负载因子</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认并发级别</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure><p>接着看下这个有参构造函数的内部实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,<span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>    <span class="hljs-comment">// 参数校验</span><br>    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span><br>    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)<br>        concurrencyLevel = MAX_SEGMENTS;<br>    <span class="hljs-comment">// Find power-of-two sizes best matching arguments</span><br>    <span class="hljs-comment">// 2的多少次方</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sshift</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ssize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span><br>    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;<br>        ++sshift;<br>        ssize &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 记录段偏移量</span><br>    <span class="hljs-built_in">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;<br>    <span class="hljs-comment">// 记录段掩码</span><br>    <span class="hljs-built_in">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 设置容量</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> initialCapacity / ssize;<br>    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)<br>        ++c;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;<br>    <span class="hljs-comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span><br>    <span class="hljs-keyword">while</span> (cap &lt; c)<br>        cap &lt;&lt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// create segments and segments[0]</span><br>    <span class="hljs-comment">// 创建 Segment 数组，设置 segments[0]</span><br>    Segment&lt;K,V&gt; s0 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="hljs-type">int</span>)(cap * loadFactor),<br>                         (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap]);<br>    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>[ssize];<br>    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span><br>    <span class="hljs-built_in">this</span>.segments = ss;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下在 Java 7 中 ConcurrentHashMap 的初始化逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 <code>concurrencyLevel</code> 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li><li>寻找并发级别 <code>concurrencyLevel</code> 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 <code>segmentShift</code> 偏移量，这个值为【容量 &#x3D; 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift &#x3D; 28</strong>.</li><li>记录 <code>segmentMask</code>，默认是 ssize - 1 &#x3D; 16 -1 &#x3D; 15.</li><li><strong>初始化 <code>segments[0]</code><strong>，</strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75&#x3D;1.5</strong>，插入第二个值时才会进行扩容。</li></ol><h3 id="3-put"><a href="#3-put" class="headerlink" title="3. put"></a>3. put</h3><p>接着上面的初始化参数继续查看 put 方法源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Maps the specified key to the specified value in this table.</span><br><span class="hljs-comment"> * Neither the key nor the value can be null.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span><br><span class="hljs-comment"> * with a key that is equal to the original key.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key key with which the specified value is to be associated</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value value to be associated with the specified key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br><span class="hljs-comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified key or value is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    Segment&lt;K,V&gt; s;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span><br>    <span class="hljs-comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="hljs-comment">// nonvolatile; recheck</span><br>         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-literal">null</span>) <span class="hljs-comment">//  in ensureSegment</span><br>        <span class="hljs-comment">// 如果查找到的 Segment 为空，初始化</span><br>        s = ensureSegment(j);<br>    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the segment for the given index, creating it and</span><br><span class="hljs-comment"> * recording in segment table (via CAS) if not already present.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k the index</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the segment</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">private</span> Segment&lt;K,V&gt; <span class="hljs-title function_">ensureSegment</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="hljs-built_in">this</span>.segments;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="hljs-comment">// raw offset</span><br>    Segment&lt;K,V&gt; seg;<br>    <span class="hljs-comment">// 判断 u 位置的 Segment 是否为null</span><br>    <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="hljs-literal">null</span>) &#123;<br>        Segment&lt;K,V&gt; proto = ss[<span class="hljs-number">0</span>]; <span class="hljs-comment">// use segment 0 as prototype</span><br>        <span class="hljs-comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> proto.table.length;<br>        <span class="hljs-comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> proto.loadFactor;<br>        <span class="hljs-comment">// 计算扩容阀值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(cap * lf);<br>        <span class="hljs-comment">// 创建一个 cap 容量的 HashEntry 数组</span><br>        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap];<br>        <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// recheck</span><br>            <span class="hljs-comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span><br>            Segment&lt;K,V&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);<br>            <span class="hljs-comment">// 自旋检查 u 位置的 Segment 是否为null</span><br>            <span class="hljs-keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                   == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 使用CAS 赋值，只会成功一次</span><br>                <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="hljs-literal">null</span>, seg = s))<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> seg;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的源码分析了 <code>ConcurrentHashMap</code> 在 put 一个数据时的处理流程，下面梳理下具体流程。</p><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 <code>Segment</code>。</p></li><li><p>如果指定位置的 <code>Segment</code> 为空，则初始化这个 <code>Segment</code>.</p><p><strong>初始化 Segment 流程：</strong></p><ol><li>检查计算得到的位置的 <code>Segment</code> 是否为 null.</li><li>为 null 继续初始化，使用 <code>Segment[0]</code> 的容量和负载因子创建一个 <code>HashEntry</code> 数组。</li><li>再次检查计算得到的指定位置的 <code>Segment</code> 是否为 null.</li><li>使用创建的 <code>HashEntry</code> 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 <code>Segment</code> 是否为 null，使用 CAS 在这个位置赋值为 <code>Segment</code>.</li></ol></li><li><p><code>Segment.put</code> 插入 key,value 值。</p></li></ol><p>上面探究了获取 <code>Segment</code> 段和初始化 <code>Segment</code> 段的操作。最后一行的 <code>Segment</code> 的 put 方法还没有查看，继续分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span><br>    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-literal">null</span> : scanAndLockForPut(key, hash, value);<br>    V oldValue;<br>    <span class="hljs-keyword">try</span> &#123;<br>        HashEntry&lt;K,V&gt;[] tab = table;<br>        <span class="hljs-comment">// 计算要put的数据位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (tab.length - <span class="hljs-number">1</span>) &amp; hash;<br>        <span class="hljs-comment">// CAS 获取 index 坐标的值</span><br>        HashEntry&lt;K,V&gt; first = entryAt(tab, index);<br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span><br>                K k;<br>                <span class="hljs-keyword">if</span> ((k = e.key) == key ||<br>                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;<br>                    oldValue = e.value;<br>                    <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                        e.value = value;<br>                        ++modCount;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                e = e.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span><br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>                    node.setNext(first);<br>                <span class="hljs-keyword">else</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span><br>                <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)<br>                    rehash(node);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span><br>                    setEntryAt(tab, index, node);<br>                ++modCount;<br>                count = c;<br>                oldValue = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>Segment</code> 继承了 <code>ReentrantLock</code>，所以 <code>Segment</code> 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p><code>tryLock()</code> 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p></li><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 <code>HashEntry</code> 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 <code>HashEntry</code> 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p><p>如果这个位置上的 <strong><code>HashEntry</code> 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接头插法插入。</li></ol><p>如果这个位置上的 <strong><code>HashEntry</code> 存在</strong>：</p><ol><li>判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li><li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表头插法插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p></li></ol><p>这里面的第一步中的 <code>scanAndLockForPut</code> 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 <code>HashEntry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashEntry&lt;K,V&gt; <span class="hljs-title function_">scanAndLockForPut</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value)</span> &#123;<br>    HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-built_in">this</span>, hash);<br>    HashEntry&lt;K,V&gt; e = first;<br>    HashEntry&lt;K,V&gt; node = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">retries</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// negative while locating node</span><br>    <span class="hljs-comment">// 自旋获取锁</span><br>    <span class="hljs-keyword">while</span> (!tryLock()) &#123;<br>        HashEntry&lt;K,V&gt; f; <span class="hljs-comment">// to recheck first below</span><br>        <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-comment">// speculatively create node</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>);<br>                retries = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.equals(e.key))<br>                retries = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                e = e.next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;<br>            <span class="hljs-comment">// 自旋达到指定次数后，阻塞等到只到获取到锁</span><br>            lock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp;<br>                 (f = entryForHash(<span class="hljs-built_in">this</span>, hash)) != first) &#123;<br>            e = first = f; <span class="hljs-comment">// re-traverse if entry changed</span><br>            retries = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-扩容-rehash"><a href="#4-扩容-rehash" class="headerlink" title="4. 扩容 rehash"></a>4. 扩容 rehash</h3><p><code>ConcurrentHashMap</code> 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 <code>index+ oldSize</code>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">(HashEntry&lt;K,V&gt; node)</span> &#123;<br>    HashEntry&lt;K,V&gt;[] oldTable = table;<br>    <span class="hljs-comment">// 老容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-comment">// 新容量，扩大两倍</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 新的扩容阀值</span><br>    threshold = (<span class="hljs-type">int</span>)(newCapacity * loadFactor);<br>    <span class="hljs-comment">// 创建新的数组</span><br>    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[newCapacity];<br>    <span class="hljs-comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sizeMask</span> <span class="hljs-operator">=</span> newCapacity - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; oldCapacity ; i++) &#123;<br>        <span class="hljs-comment">// 遍历老数组</span><br>        HashEntry&lt;K,V&gt; e = oldTable[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            HashEntry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-comment">// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> e.hash &amp; sizeMask;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)   <span class="hljs-comment">//  Single node on list</span><br>                <span class="hljs-comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span><br>                newTable[idx] = e;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Reuse consecutive sequence at same slot</span><br>                <span class="hljs-comment">// 如果是链表了</span><br>                HashEntry&lt;K,V&gt; lastRun = e;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">lastIdx</span> <span class="hljs-operator">=</span> idx;<br>                <span class="hljs-comment">// 新的位置只可能是不便或者是老的位置+老的容量。</span><br>                <span class="hljs-comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="hljs-literal">null</span>; last = last.next) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> last.hash &amp; sizeMask;<br>                    <span class="hljs-keyword">if</span> (k != lastIdx) &#123;<br>                        lastIdx = k;<br>                        lastRun = last;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span><br>                newTable[lastIdx] = lastRun;<br>                <span class="hljs-comment">// Clone remaining nodes</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;<br>                    <span class="hljs-comment">// 遍历剩余元素，头插法到指定 k 位置。</span><br>                    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> p.value;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> p.hash;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> h &amp; sizeMask;<br>                    HashEntry&lt;K,V&gt; n = newTable[k];<br>                    newTable[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 头插法插入新的节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nodeIndex</span> <span class="hljs-operator">=</span> node.hash &amp; sizeMask; <span class="hljs-comment">// add the new node</span><br>    node.setNext(newTable[nodeIndex]);<br>    newTable[nodeIndex] = node;<br>    table = newTable;<br>&#125;<br></code></pre></td></tr></table></figure><p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p><h3 id="5-get"><a href="#5-get" class="headerlink" title="5. get"></a>5. get</h3><p>到这里就很简单了，get 方法只需要两步即可。</p><ol><li>计算得到 key 的存放位置。</li><li>遍历指定位置查找相同 key 的 value 值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Segment&lt;K,V&gt; s; <span class="hljs-comment">// manually integrate access methods to reduce overhead</span><br>    HashEntry&lt;K,V&gt;[] tab;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;<br>    <span class="hljs-comment">// 计算得到 key 的存放位置</span><br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-literal">null</span> &amp;&amp;<br>        (tab = s.table) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile<br>                 (tab, ((<span class="hljs-type">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);<br>             e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>            <span class="hljs-comment">// 如果是链表，遍历查找到相同 key 的 value。</span><br>            K k;<br>            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))<br>                <span class="hljs-keyword">return</span> e.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-ConcurrentHashMap-1-8"><a href="#2-ConcurrentHashMap-1-8" class="headerlink" title="2. ConcurrentHashMap 1.8"></a>2. ConcurrentHashMap 1.8</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231011161137885.png" alt="image-20231011161137885"></p><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h3 id="2-初始化-initTable"><a href="#2-初始化-initTable" class="headerlink" title="2. 初始化 initTable"></a>2. 初始化 initTable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initializes table, using the size recorded in sizeCtl.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//正在初始化或者正在扩容</span><br>            <span class="hljs-comment">//使当前线程从执行状态变为可执行状态（就绪状态）即自旋</span><br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//sc没变置为-1返回true,否则直接false</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从源码中可以发现 <code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化</li><li>-N 说明有 N-1 个线程正在进行扩容</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</li></ol><h3 id="3-put-1"><a href="#3-put-1" class="headerlink" title="3. put"></a>3. put</h3><p>直接过一遍 put 源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// key 和 value 不能为空</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        <span class="hljs-comment">// f = 目标位置元素</span><br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<span class="hljs-comment">// fh 后面存放目标位置的元素 hash 值</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span><br>            tab = initTable();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 使用 synchronized 加锁加入节点</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">// 说明是链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">// 循环加入新的或者覆盖节点</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        <span class="hljs-comment">// 红黑树</span><br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>根据 key 计算出 hashcode 。</p></li><li><p>判断是否需要进行初始化。</p></li><li><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p></li><li><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据。</p></li><li><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</p></li></ol><h3 id="4-get"><a href="#4-get" class="headerlink" title="4. get"></a>4. get</h3><p>get 流程比较简单，直接过一遍源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br>    <span class="hljs-comment">// key 所在的 hash 位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果指定位置元素存在，头结点hash值相同</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-comment">// key hash 值相等，key值相同，直接返回元素 value</span><br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span><br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 是链表，遍历查找</span><br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下 get 过程：</p><ol><li>根据 hash 值计算位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li><li>如果是链表，遍历查找之。</li></ol><p>总结：</p><p>总的来说 <code>ConcurrentHashMap</code> 在 Java8 中相对于 Java7 来说变化还是挺大的。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Java7 中 <code>ConcurrentHashMap</code> 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 <code>Segment</code> 都是一个类似 <code>HashMap</code> 数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code>Segment</code> 的个数一但初始化就不能改变。</p><p>Java8 中的 <code>ConcurrentHashMap</code> 使用的 <code>Synchronized</code> 锁加 CAS 的机制。结构也由 Java7 中的 <strong><code>Segment</code> 数组 + <code>HashEntry</code> 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突在达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><p><code>Synchronized</code> 锁自从引入锁升级策略后，性能不再是问题</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentSkipListMap</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentSkipListMap/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentSkipListMap/</url>
    
    <content type="html"><![CDATA[<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p>跳表：是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 <strong>O(logn)</strong> 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p><p>跳表的本质是同时维护了多个链表，并且链表是分层的，</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231015200039484.png" alt="image-20231015200039484">2级索引跳表</p><p>最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</p><p>跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素 18。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231015200136478.png" alt="image-20231015200136478">在跳表中查找元素18</p><p>查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</p><p>从上面很容易看出，<strong>跳表是一种利用空间换时间的算法。</strong></p><p>使用跳表实现 <code>Map</code> 和使用哈希算法实现 <code>Map</code> 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。</p><p>所以当需要有序的结果时，使用ConcurrentSkipListMap。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CopyOnWriteArrayList</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/CopyOnWriteArrayList/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/CopyOnWriteArrayList/</url>
    
    <content type="html"><![CDATA[<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>JDK1.5之前，线程安全的List只有Vector，但是Vector过于老旧（CRUD都加了synchronized，性能非常低）。</p><p>JDK1.5 引入了 JUC，其中唯一的线程安全List实现就是 <code>CopyOnWriteArrayList</code> 。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>对于大部分业务场景而言，读的操作都是多于写的操作的，而对读的操作加锁其实就是浪费资源（读操作不会更改数据），所以我们应该允许多个线程同时访问 <code>List</code> 的内部数据（对读操作是安全的）。</p><p>为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。</p><p><code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，从 <code>CopyOnWriteArrayList</code> 的名字就能看出了。</p><h3 id="Copy-On-Write-的思想是什么？"><a href="#Copy-On-Write-的思想是什么？" class="headerlink" title="Copy-On-Write 的思想是什么？"></a>Copy-On-Write 的思想是什么？</h3><p><code>CopyOnWriteArrayList</code>名字中的“Copy-On-Write”即写时复制，简称 COW。</p><p>核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p><blockquote><p>写的时候，写线程写自己的，读线程读原数组，等待写线程修改完数据副本后，再将数据赋值回原数据。</p></blockquote><p>可以看出，写时复制机制非常适合读多写少的并发场景，能够极大地提高系统的并发性能。</p><p>COW 的缺点：</p><ol><li>写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。</li><li>内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。</li><li>数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。</li></ol><h2 id="CopyOnWriteArrayList-源码分析"><a href="#CopyOnWriteArrayList-源码分析" class="headerlink" title="CopyOnWriteArrayList 源码分析"></a>CopyOnWriteArrayList 源码分析</h2><p>JDK1.8 为例，CopyOnWriteArrayList 的底层核心源码。</p><p><code>CopyOnWriteArrayList</code> 实现了以下接口：</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>RandomAccess</code> ：这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li></ul><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231015184956043.png" alt="image-20231015184956043"></p><p>CopyOnWriteArrayList 类图</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>CopyOnWriteArrayList</code> 中有一个无参构造函数和两个有参构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个空的 CopyOnWriteArrayList</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArrayList</span><span class="hljs-params">()</span> &#123;<br>    setArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-comment">// 按照集合的迭代器返回的顺序创建一个包含指定集合元素的 CopyOnWriteArrayList</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    Object[] elements;<br>    <span class="hljs-keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)<br>        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();<br>    <span class="hljs-keyword">else</span> &#123;<br>        elements = c.toArray();<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elements.getClass() != Object[].class)<br>            elements = Arrays.copyOf(elements, elements.length, Object[].class);<br>    &#125;<br>    setArray(elements);<br>&#125;<br><br><span class="hljs-comment">// 创建一个包含指定数组的副本的列表</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArrayList</span><span class="hljs-params">(E[] toCopyIn)</span> &#123;<br>    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p><code>CopyOnWriteArrayList</code> 的 <code>add()</code>方法有三个版本：</p><ul><li><code>add(E e)</code>：在 <code>CopyOnWriteArrayList</code> 的尾部插入元素。</li><li><code>add(int index, E element)</code>：在 <code>CopyOnWriteArrayList</code> 的指定位置插入元素。</li><li><code>addIfAbsent(E e)</code>：如果指定元素不存在，那么添加该元素。如果成功添加元素则返回 true。</li></ul><p>这里以<code>add(E e)</code>为例进行介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 加锁</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取原来的数组</span><br>        Object[] elements = getArray();<br>        <span class="hljs-comment">// 原来数组的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 元素放在新数组末尾</span><br>        newElements[len] = e;<br>        <span class="hljs-comment">// array指向新数组</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的源码可以看出：</p><ul><li><code>add</code>方法内部用到了 <code>ReentrantLock</code> 加锁，保证了同步，避免了多线程写的时候会复制出多个副本出来。锁被修饰保证了锁的内存地址肯定不会被修改，并且，释放锁的逻辑放在 finally 中，可以保证锁能被释放。</li><li><code>CopyOnWriteArrayList</code> 通过复制底层数组的方式实现写操作。</li><li>每次写操作都需要通过 <code>Arrays.copyOf</code> 复制底层数组，时间复杂度是 O(n) 的，且会占用额外的内存空间。因此，CopyOnWriteArrayList 适用于读多写少的场景，在写操作不频繁且内存资源充足的情况下，可以提升系统的性能表现（更适用）。</li><li><code>CopyOnWriteArrayList</code> 中并没有类似于 <code>ArrayList</code> 的 <code>grow()</code> 方法扩容的操作。</li></ul><blockquote><p><code>Arrays.copyOf</code> 方法的时间复杂度是 O(n)，其中 n 表示需要复制的数组长度。因为这个方法的实现原理是先创建一个新的数组，然后将源数组中的数据复制到新数组中，最后返回新数组。这个方法会复制整个数组，因此其时间复杂度与数组长度成正比，即 O(n)。值得注意的是，由于底层调用了系统级别的拷贝指令，因此在实际应用中这个方法的性能表现比较优秀，但是也需要注意控制复制的数据量，避免出现内存占用过高的情况。</p></blockquote><h3 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h3><p><code>CopyOnWriteArrayList</code> 的读取操作是基于内部数组 <code>array</code> ，并不会发生实际的修改。（因此在读取操作时不需要进行同步控制和锁操作，可以保证数据的安全性。这种机制下，多个线程可以同时读取列表中的元素）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 底层数组，只能通过getArray和setArray方法访问</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br><br><span class="hljs-keyword">final</span> Object[] getArray() &#123;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(Object[] a, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，<code>get</code>方法是弱一致性的，在某些情况下可能读到旧的元素值。</p><blockquote><p><code>get(int index)</code>方法是分两步进行的：</p><ol><li>通过<code>getArray()</code>获取当前数组的引用；</li><li>直接从数组中获取下标为 index 的元素。</li></ol><p>这个过程并没有加锁，所以在并发环境下可能出现如下情况：</p><ol><li>线程 1 调用<code>get(int index)</code>方法获取值，内部通过<code>getArray()</code>方法获取到了 array 属性值；</li><li>线程 2 调用<code>CopyOnWriteArrayList</code>的<code>add</code>、<code>set</code>、<code>remove</code> 等修改方法时，内部通过<code>setArray</code>方法修改了<code>array</code>属性的值；</li><li>线程 1 还是从旧的 <code>array</code> 数组中取值。</li></ol></blockquote><h3 id="获取列表中元素的个数"><a href="#获取列表中元素的个数" class="headerlink" title="获取列表中元素的个数"></a>获取列表中元素的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getArray().length;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CopyOnWriteArrayList</code>中的<code>array</code>数组每次复制都刚好能够容纳下所有元素，并不像<code>ArrayList</code>那样会预留一定的空间，因此 CopyOnWriteArrayList 中并没有<code>size</code>属性。CopyOnWriteArrayList 的底层数组的长度就是元素个数，因此<code>size()</code>方法只要返回数组长度就可以了。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><code>CopyOnWriteArrayList</code>删除元素相关的方法一共有 4 个：</p><ol><li><code>remove(int index)</code>：移除此列表中指定位置上的元素。将任何后续元素向左移动（从它们的索引中减去 1）。</li><li><code>boolean remove(Object o)</code>：删除此列表中首次出现的指定元素，如果不存在该元素则返回 false。</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>：从此列表中删除指定集合中包含的所有元素。</li><li><code>void clear()</code>：移除此列表中的所有元素。</li></ol><p>这里以<code>remove(int index)</code>为例进行介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 获取可重入锁</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 加锁</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取当前array数组</span><br>        Object[] elements = getArray();<br>        <span class="hljs-comment">// 获取当前array长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">//获取指定索引的元素(旧值)</span><br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> get(elements, index);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> len - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 判断删除的是否是最后一个元素</span><br>        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 如果删除的是最后一个元素，直接复制该元素前的所有元素到新的数组</span><br>            setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 分段复制，将index前的元素和index+1后的元素复制到新数组</span><br>            <span class="hljs-comment">// 新数组长度为旧数组长度-1</span><br>            Object[] newElements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[len - <span class="hljs-number">1</span>];<br>            System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);<br>            System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,<br>                             numMoved);<br>            <span class="hljs-comment">//将新数组赋值给array引用</span><br>            setArray(newElements);<br>        &#125;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>       <span class="hljs-comment">// 解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h3><p><code>CopyOnWriteArrayList</code>提供了两个用于判断指定元素是否在列表中的方法：</p><ul><li><code>contains(Object o)</code>：判断是否包含指定元素。</li><li><code>containsAll(Collection&lt;?&gt; c)</code>：判断是否保证指定集合的全部元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否包含指定元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">//获取当前array数组</span><br>    Object[] elements = getArray();<br>    <span class="hljs-comment">//调用index尝试查找指定元素，如果返回值大于等于0，则返回true，否则返回false</span><br>    <span class="hljs-keyword">return</span> indexOf(o, elements, <span class="hljs-number">0</span>, elements.length) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断是否保证指定集合的全部元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>    <span class="hljs-comment">//获取当前array数组</span><br>    Object[] elements = getArray();<br>    <span class="hljs-comment">//获取数组长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>    <span class="hljs-comment">//遍历指定集合</span><br>    <span class="hljs-keyword">for</span> (Object e : c) &#123;<br>        <span class="hljs-comment">//循环调用indexOf方法判断，只要有一个没有包含就直接返回false</span><br>        <span class="hljs-keyword">if</span> (indexOf(e, elements, <span class="hljs-number">0</span>, len) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//最后表示全部包含或者制定集合为空集合，那么返回true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CopyOnWriteArrayList-常用方法测试"><a href="#CopyOnWriteArrayList-常用方法测试" class="headerlink" title="CopyOnWriteArrayList 常用方法测试"></a>CopyOnWriteArrayList 常用方法测试</h2><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个 CopyOnWriteArrayList 对象</span><br>CopyOnWriteArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 向列表中添加元素</span><br>list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;初始列表：&quot;</span> + list);<br><br><span class="hljs-comment">// 使用 get 方法获取指定位置的元素</span><br>System.out.println(<span class="hljs-string">&quot;列表第二个元素为：&quot;</span> + list.get(<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">// 使用 remove 方法删除指定元素</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-string">&quot;C++&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;删除结果：&quot;</span> + result);<br>System.out.println(<span class="hljs-string">&quot;列表删除元素后为：&quot;</span> + list);<br><br><span class="hljs-comment">// 使用 set 方法更新指定位置的元素</span><br>list.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Golang&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;列表更新后为：&quot;</span> + list);<br><br><span class="hljs-comment">// 使用 add 方法在指定位置插入元素</span><br>list.add(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;PHP&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;列表插入元素后为：&quot;</span> + list);<br><br><span class="hljs-comment">// 使用 size 方法获取列表大小</span><br>System.out.println(<span class="hljs-string">&quot;列表大小为：&quot;</span> + list.size());<br><br><span class="hljs-comment">// 使用 removeAll 方法删除指定集合中所有出现的元素</span><br>result = list.removeAll(List.of(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Golang&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;批量删除结果：&quot;</span> + result);<br>System.out.println(<span class="hljs-string">&quot;列表批量删除元素后为：&quot;</span> + list);<br><br><span class="hljs-comment">// 使用 clear 方法清空列表中所有元素</span><br>list.clear();<br>System.out.println(<span class="hljs-string">&quot;列表清空后为：&quot;</span> + list);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">列表更新后为：[Java, Golang]<br>列表插入元素后为：[PHP, Java, Golang]<br>列表大小为：3<br>批量删除结果：true<br>列表批量删除元素后为：[PHP]<br>列表清空后为：[]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayBlockingQueue</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/ArrayBlockingQueue/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/ArrayBlockingQueue/</url>
    
    <content type="html"><![CDATA[<p>阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><p><code>BlockingQueue</code> 是一个接口，继承自 <code>Queue</code>，所以其实现类也可以作为 <code>Queue</code> 的实现来使用，而 <code>Queue</code> 又继承自 <code>Collection</code> 接口。下面是 <code>BlockingQueue</code> 的相关实现类。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231015192213401.png" alt="image-20231015192213401"></p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p> <code>BlockingQueue</code> 接口的有界队列实现类，底层采用数组来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;E&gt;<br><span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, Serializable&#123;&#125;<br></code></pre></td></tr></table></figure><p><code>ArrayBlockingQueue</code> 一旦创建，容量不能改变。其并发控制采用可重入锁 <code>ReentrantLock</code> ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p><p>当队列容量满时，尝试将元素放入队列将导致操作阻塞; 尝试从一个空队列中取一个元素也会同样阻塞。</p><p><code>ArrayBlockingQueue</code> 默认情况下不能保证线程访问队列的公平性(即最先等待的线程能够最先访问到)。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置公平性d</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="hljs-number">10</span>,<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedBlockingQueue</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/LinkedBlockingQueue/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/LinkedBlockingQueue/</url>
    
    <content type="html"><![CDATA[<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p><code>LinkedBlockingQueue</code> 底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，满足 FIFO 的特性.</p><p>与 <code>ArrayBlockingQueue</code> 相比起来具有更高的吞吐量。</p><blockquote><p><strong>在大部分并发场景下，LinkedBlockingQueue的吞吐量比ArrayBlockingQueue更高</strong>。这主要是因为LinkedBlockingQueue使用双锁可并行读写，而ArrayBlockingQueue在插入或删除元素时需要直接操作数组，可能会产生额外的开销。</p></blockquote><p>通常在创建 <code>LinkedBlockingQueue</code> 对象时，会指定其大小，如果未指定，容量等于 <code>Integer.MAX_VALUE</code> (可能会导致损耗大量内存，所以一般都会初始化大小)。</p><p><strong>相关构造方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *某种意义上的无界队列</span><br><span class="hljs-comment"> * Creates a &#123;<span class="hljs-doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Integer#MAX_VALUE&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(Integer.MAX_VALUE);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *有界队列</span><br><span class="hljs-comment"> * Creates a &#123;<span class="hljs-doctag">@code</span> LinkedBlockingQueue&#125; with the given (fixed) capacity.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> capacity the capacity of this queue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if &#123;<span class="hljs-doctag">@code</span> capacity&#125; is not greater</span><br><span class="hljs-comment"> *         than zero</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.capacity = capacity;<br>    last = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PriorityBlockingQueue</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/PriorityBlockingQueue/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/PriorityBlockingQueue/</url>
    
    <content type="html"><![CDATA[<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。</p><p><code>PriorityBlockingQueue</code> 并发控制采用的是可重入锁 <code>ReentrantLock</code>，队列为无界队列（<code>ArrayBlockingQueue</code> 是有界队列，<code>LinkedBlockingQueue</code> 也可以通过在构造函数中传入 <code>capacity</code> 指定队列最大的容量，但是 <code>PriorityBlockingQueue</code> 只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>，即无界队列）。</p><p>简单地说，它就是 <code>PriorityQueue</code> 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 <code>ClassCastException</code> 异常。</p><p>它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据处理之Matplotlib-入门篇</title>
    <link href="/2021/04/06/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BMatplotlib-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <url>/2021/04/06/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BMatplotlib-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="实验二、数据处理之Matplotlib"><a href="#实验二、数据处理之Matplotlib" class="headerlink" title="实验二、数据处理之Matplotlib"></a>实验二、数据处理之Matplotlib</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><h4 id="1-了解matplotlib库的基本功能"><a href="#1-了解matplotlib库的基本功能" class="headerlink" title="1. 了解matplotlib库的基本功能"></a>1. 了解matplotlib库的基本功能</h4><h4 id="2-掌握matplotlib库的使用方法"><a href="#2-掌握matplotlib库的使用方法" class="headerlink" title="2. 掌握matplotlib库的使用方法"></a>2. 掌握matplotlib库的使用方法</h4><h3 id="二、实验工具："><a href="#二、实验工具：" class="headerlink" title="二、实验工具："></a>二、实验工具：</h3><h4 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h4><h4 id="2-Numpy，matplotlib"><a href="#2-Numpy，matplotlib" class="headerlink" title="2. Numpy，matplotlib"></a>2. Numpy，matplotlib</h4><h3 id="三、Matplotlib简介"><a href="#三、Matplotlib简介" class="headerlink" title="三、Matplotlib简介"></a>三、Matplotlib简介</h3><p>Matplotlib 包含了几十个不同的模块， 如 matlab、mathtext、finance、dates 等，而 pylot 则是我们最常用的绘图模块</p><h3 id="四、实验内容"><a href="#四、实验内容" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-绘制正弦曲线，并设置标题、坐标轴名称、坐标轴范围"><a href="#1-绘制正弦曲线，并设置标题、坐标轴名称、坐标轴范围" class="headerlink" title="1.绘制正弦曲线，并设置标题、坐标轴名称、坐标轴范围"></a>1.绘制正弦曲线，并设置标题、坐标轴名称、坐标轴范围</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> mpl<br>mpl.<span class="hljs-property">rcParams</span>[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;FangSong&#x27;</span>]<br>mpl.<span class="hljs-property">rcParams</span>[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-title class_">False</span><br>x=np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>*np.<span class="hljs-property">pi</span>, <span class="hljs-number">0.01</span>)<br>y=np.<span class="hljs-title function_">sin</span>(x)<br>plt.<span class="hljs-title function_">plot</span>(x, y)<br>plt.<span class="hljs-title function_">title</span>(u<span class="hljs-string">&#x27;正弦曲线&#x27;</span>, fontdict=&#123;<span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">20</span>&#125;)<br>plt.<span class="hljs-title function_">xlabel</span>(u<span class="hljs-string">&#x27;弧度&#x27;</span>, fontdict=&#123;<span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">16</span>&#125;)<br>plt.<span class="hljs-title function_">ylabel</span>(u<span class="hljs-string">&#x27;正弦值&#x27;</span>, fontdict=&#123;<span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">16</span>&#125;)<br>plt.<span class="hljs-title function_">axis</span>([-<span class="hljs-number">0.1</span>*np.<span class="hljs-property">pi</span>, <span class="hljs-number">2.1</span>*np.<span class="hljs-property">pi</span>, -<span class="hljs-number">1.1</span>, <span class="hljs-number">1.1</span>])<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/743812c8-1d7b-47e0-9c35-d998c65ed92c.png" alt="在这里插入图片描述"></p><h4 id="2-同一坐标系中绘制多种曲线并通过样式、宽度、颜色加以区分"><a href="#2-同一坐标系中绘制多种曲线并通过样式、宽度、颜色加以区分" class="headerlink" title="2. 同一坐标系中绘制多种曲线并通过样式、宽度、颜色加以区分"></a>2. 同一坐标系中绘制多种曲线并通过样式、宽度、颜色加以区分</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> mpl<br>mpl.<span class="hljs-property">rcParams</span>[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;FangSong&#x27;</span>]<br>mpl.<span class="hljs-property">rcParams</span>[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-title class_">False</span><br>x = np.<span class="hljs-title function_">linspace</span>(-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">200</span>)<br>f1 =  np.<span class="hljs-title function_">power</span>(<span class="hljs-number">10</span>, x)<br>f2 = np.<span class="hljs-title function_">power</span>(np.<span class="hljs-property">e</span>, x)<br>f3 = np.<span class="hljs-title function_">power</span>(<span class="hljs-number">2</span>, x)<br>plt.<span class="hljs-title function_">plot</span>(x, f1, <span class="hljs-string">&#x27;r&#x27;</span>, ls=<span class="hljs-string">&#x27;-&#x27;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;$10^x$&#x27;</span>)<br>plt.<span class="hljs-title function_">plot</span>(x, f2, <span class="hljs-string">&#x27;b&#x27;</span>, ls=<span class="hljs-string">&#x27;--&#x27;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;$e^x$&#x27;</span>)<br>plt.<span class="hljs-title function_">plot</span>(x, f3, <span class="hljs-string">&#x27;g&#x27;</span>, ls=<span class="hljs-string">&#x27;:&#x27;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;$2^x$&#x27;</span>)<br>plt.<span class="hljs-title function_">axis</span>([-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">0.5</span>, <span class="hljs-number">8</span>])<br>plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">&#x27;幂函数曲线&#x27;</span>, fontsize=<span class="hljs-number">16</span>)<br>plt.<span class="hljs-title function_">legend</span>(loc=<span class="hljs-string">&#x27;lower right&#x27;</span>)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/4ddd2da8-542b-492f-86a7-abd2f7a137f5.png" alt="在这里插入图片描述"></p><h4 id="3-绘制多轴图，即将多幅子图绘制在同一画板。"><a href="#3-绘制多轴图，即将多幅子图绘制在同一画板。" class="headerlink" title="3.绘制多轴图，即将多幅子图绘制在同一画板。"></a>3.绘制多轴图，即将多幅子图绘制在同一画板。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br>plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">221</span>)<br>x = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>*np.<span class="hljs-property">pi</span>, <span class="hljs-number">0.01</span>)<br>y = np.<span class="hljs-title function_">cos</span>(x)<br>plt.<span class="hljs-title function_">plot</span>(x, y)<br>plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">222</span>)<br>plt.<span class="hljs-title function_">axis</span>([-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>plt.<span class="hljs-title function_">axvline</span>(x=<span class="hljs-number">0</span>, ymin=<span class="hljs-number">0</span>, linewidth=<span class="hljs-number">4</span>, color=<span class="hljs-string">&#x27;g&#x27;</span>)<br>plt.<span class="hljs-title function_">axvline</span>(x=<span class="hljs-number">1.0</span>, ymin=-<span class="hljs-number">0.5</span>, ymax=<span class="hljs-number">0.5</span>, linewidth=<span class="hljs-number">4</span>, color=<span class="hljs-string">&#x27;y&#x27;</span>)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/27a39cd0-9e1c-49a0-bbca-24a6e89f8112.png" alt="image.png"></p><h4 id="4-直方图的绘制-数据自己定义）"><a href="#4-直方图的绘制-数据自己定义）" class="headerlink" title="4.直方图的绘制(数据自己定义）"></a>4.直方图的绘制(数据自己定义）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br>bins = np.<span class="hljs-title function_">arange</span>(-<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)<br>plt.<span class="hljs-title function_">hist</span>(bins)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/5e0672f1-e3a7-421e-a7a5-da23eca2efc2.png" alt="image.png"></p><h4 id="5-绘制散点图"><a href="#5-绘制散点图" class="headerlink" title="5.绘制散点图"></a>5.绘制散点图</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br>x = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">rand</span>(<span class="hljs-number">30</span>)<br>y = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">rand</span>(<span class="hljs-number">30</span>)<br>area = np.<span class="hljs-property">pi</span>*(<span class="hljs-number">15</span>*np.<span class="hljs-property">random</span>.<span class="hljs-title function_">rand</span>(<span class="hljs-number">30</span>))**<span class="hljs-number">2</span><br>color = <span class="hljs-number">2</span>*np.<span class="hljs-property">pi</span>*np.<span class="hljs-property">random</span>.<span class="hljs-title function_">rand</span>(<span class="hljs-number">30</span>)<br>plt.<span class="hljs-title function_">scatter</span>(x, y, s=area, c=color, alpha=<span class="hljs-number">0.5</span>, cmap=plt.<span class="hljs-property">cm</span>.<span class="hljs-property">hsv</span>)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/9e0e5204-ce44-4e69-8735-4034466896be.png" alt="在这里插入图片描述"></p><h4 id="6-绘制盒状图"><a href="#6-绘制盒状图" class="headerlink" title="6.绘制盒状图"></a>6.绘制盒状图</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br>data = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randn</span>(<span class="hljs-number">200</span>)<br>fig, (ax2) = plt.<span class="hljs-title function_">subplots</span>(<span class="hljs-number">1</span>, figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>))<br>ax2.<span class="hljs-title function_">boxplot</span>(data)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/099c75eb-f805-4e69-9a76-62a8fcf6afcc.png" alt="在这里插入图片描述"></p><h4 id="7-尝试matplotlib库的其它功能，如2D-3D等"><a href="#7-尝试matplotlib库的其它功能，如2D-3D等" class="headerlink" title="7.尝试matplotlib库的其它功能，如2D,3D等"></a>7.尝试matplotlib库的其它功能，如2D,3D等</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br>y,x = np.<span class="hljs-property">ogrid</span>[-<span class="hljs-number">2</span>:<span class="hljs-number">2</span>:200j, -<span class="hljs-number">3</span>:<span class="hljs-number">3</span>:300j]<br>z = x*np.<span class="hljs-title function_">exp</span>(-x**<span class="hljs-number">2</span> - y**<span class="hljs-number">2</span>)<br>extent = [np.<span class="hljs-title function_">min</span>(x), np.<span class="hljs-title function_">max</span>(x), np.<span class="hljs-title function_">min</span>(y), np.<span class="hljs-title function_">max</span>(y)]<br>plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">211</span>)<br>cs = plt.<span class="hljs-title function_">contour</span>(z, <span class="hljs-number">10</span>, extent=extent)<br>plt.<span class="hljs-title function_">clabel</span>(cs)<br>plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">111</span>)<br>plt.<span class="hljs-title function_">contourf</span>(x.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>), y.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>), z, <span class="hljs-number">20</span>)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/1a7561d1-dfa9-4595-9ec1-1fd8c97edec9.png" alt="在这里插入图片描述"></p><h3 id="五、实验总结（写出本次实验的收获，遇到的问题等"><a href="#五、实验总结（写出本次实验的收获，遇到的问题等" class="headerlink" title="五、实验总结（写出本次实验的收获，遇到的问题等)"></a>五、实验总结（写出本次实验的收获，遇到的问题等)</h3><p>了解到matplotlib库不是只要你安装了numpy就有了这个库，刚开始做的时候因为没有导入matplotlib库而频频报错。在网上搜索了简易的安装matplotlib库的办法，直接在电脑cmd里面敲两行命令安装即可，不用再很繁琐的在电脑上还要配置环境变量。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据处理之Numpy-入门篇</title>
    <link href="/2021/04/06/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BNumpy-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <url>/2021/04/06/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BNumpy-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="实验一、数据处理之Numpy"><a href="#实验一、数据处理之Numpy" class="headerlink" title="实验一、数据处理之Numpy"></a>实验一、数据处理之Numpy</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><h4 id="1-了解numpy库的基本功能"><a href="#1-了解numpy库的基本功能" class="headerlink" title="1. 了解numpy库的基本功能"></a>1. 了解numpy库的基本功能</h4><h4 id="2-掌握Numpy库的对数组的操作与运算"><a href="#2-掌握Numpy库的对数组的操作与运算" class="headerlink" title="2. 掌握Numpy库的对数组的操作与运算"></a>2. 掌握Numpy库的对数组的操作与运算</h4><h3 id="二、实验工具："><a href="#二、实验工具：" class="headerlink" title="二、实验工具："></a>二、实验工具：</h3><h4 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h4><h4 id="2-Numpy"><a href="#2-Numpy" class="headerlink" title="2. Numpy"></a>2. Numpy</h4><h3 id="三、Numpy简介"><a href="#三、Numpy简介" class="headerlink" title="三、Numpy简介"></a>三、Numpy简介</h3><p>Numpy 的英文全称为 Numerical Python，指Python 面向数值计算的第三方库。Numpy 的特点在于，针对 Python 内建的数组类型做了扩充，支持更高维度的数组和矩阵运算，以及更丰富的数学函数。Numpy 是 Scipy.org 中最重要的库之一，它同时也被 Pandas，Matplotlib 等我们熟知的第三方库作为核心计算库。<br>NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库。专为进行严格的数字处理而产生。多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence Livermore，NASA用其处理一些本来使用C++，Fortran或Matlab等所做的任务。<br>Numpy包括了：1、一个强大的N维数组对象Array；2、比较成熟的（广播）函数库；3、用于整合C&#x2F;C++和Fortran代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数。Numpy和稀疏矩阵运算包scipy配合使用更加方便。</p><h3 id="四、实验内容"><a href="#四、实验内容" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-数组的创建（创建全0数组，全1数组，随机数数组）"><a href="#1-数组的创建（创建全0数组，全1数组，随机数数组）" class="headerlink" title="1. 数组的创建（创建全0数组，全1数组，随机数数组）"></a>1. 数组的创建（创建全0数组，全1数组，随机数数组）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.<span class="hljs-title function_">ones</span>(<span class="hljs-number">5</span>, int)<br><br>b = np.<span class="hljs-title function_">zeros</span>(<span class="hljs-number">5</span>, int)<br><br>f = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;全1数组：\n&quot;</span>, a)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;全0数组:\n&quot;</span>, b)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;随机数数组:\n&quot;</span>, f)<br></code></pre></td></tr></table></figure><p><img src="/../images/87f3125a-a033-417d-bb13-21c84bfcee11.png" alt="image.png"></p><h4 id="2-数组的属性（查看数组的维度，数组元素的个数）"><a href="#2-数组的属性（查看数组的维度，数组元素的个数）" class="headerlink" title="2. 数组的属性（查看数组的维度，数组元素的个数）"></a>2. 数组的属性（查看数组的维度，数组元素的个数）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.<span class="hljs-title function_">ones</span>(<span class="hljs-number">5</span>, int)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;全1数组维度：\n&quot;</span>, a.<span class="hljs-property">ndim</span>)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;全1数组元素个数：\n&quot;</span>, a.<span class="hljs-property">shape</span>)<br></code></pre></td></tr></table></figure><p><img src="/../images/ca928bd1-73d5-47e1-9176-b6f79ad795ad.png" alt="image.png"></p><h4 id="3-数组的维度操作（将数组的行变列，返回最后一个元素，返回第2到第4个元素，返回逆序的数组）"><a href="#3-数组的维度操作（将数组的行变列，返回最后一个元素，返回第2到第4个元素，返回逆序的数组）" class="headerlink" title="3. 数组的维度操作（将数组的行变列，返回最后一个元素，返回第2到第4个元素，返回逆序的数组）"></a>3. 数组的维度操作（将数组的行变列，返回最后一个元素，返回第2到第4个元素，返回逆序的数组）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>c = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">reshape</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;转置前：\n&quot;</span>, c)<br>d = c.<span class="hljs-property">T</span><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;转置后：\n&quot;</span>, d)<br><br>e = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">10</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组为：\n&quot;</span>, e)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;最后一个元素为：\n&quot;</span>, e[-<span class="hljs-number">1</span>])<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;第2到第4元素为：\n&quot;</span>, e[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;逆序数组为：\n&quot;</span>, e[::-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p><img src="/../images/2ae999a3-1cf1-45ff-82ba-e568181a191b.png" alt="image.png"></p><h4 id="4-数组的合并（数组的水平合并，垂直合并，深度合并）"><a href="#4-数组的合并（数组的水平合并，垂直合并，深度合并）" class="headerlink" title="4. 数组的合并（数组的水平合并，垂直合并，深度合并）"></a>4. 数组的合并（数组的水平合并，垂直合并，深度合并）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>c = np.<span class="hljs-title function_">arange</span>(-<span class="hljs-number">9</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_">reshape</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>d = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>).<span class="hljs-title function_">reshape</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;第一个数组为：\n&quot;</span>, c)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;第二个数组为：\n&quot;</span>, d)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;水平合并：\n&quot;</span>, np.<span class="hljs-title function_">hstack</span>((c, d)))<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;垂直合并：\n&quot;</span>, np.<span class="hljs-title function_">hstack</span>((c, d)))<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;深度合并：\n&quot;</span>, np.<span class="hljs-title function_">hstack</span>((c, d)))<br></code></pre></td></tr></table></figure><p><img src="/../images/ae93e798-4d4b-4c8e-9ddf-7d62545b91ab.png" alt="image.png"></p><h4 id="5-数组的拆分（数组的水平拆分，垂直拆分，深度拆分）"><a href="#5-数组的拆分（数组的水平拆分，垂直拆分，深度拆分）" class="headerlink" title="5. 数组的拆分（数组的水平拆分，垂直拆分，深度拆分）"></a>5. 数组的拆分（数组的水平拆分，垂直拆分，深度拆分）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>c = np.<span class="hljs-title function_">arange</span>(-<span class="hljs-number">9</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_">reshape</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组为：\n&quot;</span>, c)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;水平拆分为：\n&quot;</span>, np.<span class="hljs-title function_">hsplit</span>(c, <span class="hljs-number">3</span>))<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;垂直拆分为：\n&quot;</span>, np.<span class="hljs-title function_">vsplit</span>(c, <span class="hljs-number">3</span>))<br><br>d = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">8</span>).<span class="hljs-title function_">reshape</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;待深度拆分数组为：\n&quot;</span>, d)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;深度拆分为：\n&quot;</span>, np.<span class="hljs-title function_">dsplit</span>(d, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p><img src="/../images/fae48d94-2ad6-43c8-aa72-0aed94a6e4bc.png" alt="image.png"><br><img src="/../images/d26678d3-6653-4773-9861-0f972849d3a8.png" alt="image.png"><br><img src="/../images/5fa351ca-284e-4e2c-a03e-bceaebee7270.png" alt="image.png"></p><h4 id="6-数组运算（与常的四则运算，与数组的四则运算，判断数组是否相等）"><a href="#6-数组运算（与常的四则运算，与数组的四则运算，判断数组是否相等）" class="headerlink" title="6. 数组运算（与常的四则运算，与数组的四则运算，判断数组是否相等）"></a>6. 数组运算（与常的四则运算，与数组的四则运算，判断数组是否相等）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">4</span>)<br>b = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;两个数组分别为：\n&quot;</span>, a, b)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;a+2为：\n&quot;</span>, a + <span class="hljs-number">2</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;a+b为：\n&quot;</span>, a+b)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;a-b为：\n&quot;</span>, a-b)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;a*b为：\n&quot;</span>, a*b)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;a/b为：\n&quot;</span>, a/b)<br></code></pre></td></tr></table></figure><p><img src="/../images/ede66728-e054-4b2d-b5ec-ad2353f92c68.png" alt="image.png"></p><h4 id="7-数组的常用函数（数组所有元素的和、积、平均值、最大值、最小值、元素替换、方差、标准差）"><a href="#7-数组的常用函数（数组所有元素的和、积、平均值、最大值、最小值、元素替换、方差、标准差）" class="headerlink" title="7. 数组的常用函数（数组所有元素的和、积、平均值、最大值、最小值、元素替换、方差、标准差）"></a>7. 数组的常用函数（数组所有元素的和、积、平均值、最大值、最小值、元素替换、方差、标准差）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">7</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组为：&quot;</span>, a)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的和为：&quot;</span>, a.<span class="hljs-title function_">sum</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的积为：&quot;</span>, a.<span class="hljs-title function_">prod</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的平均值为：&quot;</span>, a.<span class="hljs-title function_">mean</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的最大值为：&quot;</span>, a.<span class="hljs-title function_">max</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的最小值为：&quot;</span>, a.<span class="hljs-title function_">min</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的元素小于3的元素替换为3，大于4的元素替换为4：&quot;</span>, a.<span class="hljs-title function_">clip</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的方差为：&quot;</span>, a.<span class="hljs-title function_">var</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的标准差为：&quot;</span>, a.<span class="hljs-title function_">std</span>())<br></code></pre></td></tr></table></figure><p><img src="/../images/8d128c0a-6c80-423b-8092-c2ef51f7dd5f.png" alt="image.png"></p><h3 id="五、实验总结（写出本次实验的收获，遇到的问题等）"><a href="#五、实验总结（写出本次实验的收获，遇到的问题等）" class="headerlink" title="五、实验总结（写出本次实验的收获，遇到的问题等）"></a>五、实验总结（写出本次实验的收获，遇到的问题等）</h3><p>学习到了numpy库中的一些函数的使用方法。受益良多，感觉到python库的强大之处，日后一定多加练习，以求对python的常用库的使用更加熟练。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 316. 去除重复字母</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20316.%20%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20316.%20%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="题目-去除重复字母"><a href="#题目-去除重复字母" class="headerlink" title="题目 去除重复字母"></a>题目 去除重复字母</h3><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p>输入：s &#x3D; “bcabc”<br>输出：“abc”</p><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><p>输入：s &#x3D; “cbacdcbc”<br>输出：“acdb”</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s 由小写英文字母组成</p><p>来源：力扣（LeetCode）<br><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">https://leetcode-cn.com/problems/remove-duplicate-letters/</a></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 算法思想</span><br><span class="hljs-comment"> * 当字典序最小时，即12341 12351 主要看4，5的位置</span><br><span class="hljs-comment"> * 用栈存储，当栈空时直接入栈</span><br><span class="hljs-comment"> * 栈不为空时，</span><br><span class="hljs-comment"> * 若栈中包含当前要入栈的元素直接跳到下一次循环。（结果字符串每个字符只含有一次）</span><br><span class="hljs-comment"> * 若当前要入栈的字母比栈顶字母大时，考虑是否栈顶元素出栈</span><br><span class="hljs-comment"> * 若栈顶元素在剩余字符串中仍然存在，那么就可以出栈，出栈后继续判断新的栈顶元素是否出栈。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Stack</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveDuplicateLetters</span> &#123;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">removeDuplicateLetters</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)&#123;<br>        <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-title class_">Character</span>&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-title class_">Character</span>&gt;();<br>            <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-title function_">length</span>(); i++) &#123;<br>                char c=s.<span class="hljs-title function_">charAt</span>(i);<br>                <span class="hljs-keyword">if</span>(stack.<span class="hljs-title function_">contains</span>(c))<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">while</span>(!stack.<span class="hljs-title function_">isEmpty</span>() &amp;&amp; stack.<span class="hljs-title function_">peek</span>()&gt;c &amp;&amp; s.<span class="hljs-title function_">indexOf</span>(stack.<span class="hljs-title function_">peek</span>(),i)!=-<span class="hljs-number">1</span>)<br>                    stack.<span class="hljs-title function_">pop</span>();<br>                stack.<span class="hljs-title function_">push</span>(c);<br>            &#125;<br>            char chars[]=<span class="hljs-keyword">new</span> char[stack.<span class="hljs-title function_">size</span>()];<br>            <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; stack.<span class="hljs-title function_">size</span>(); i++) &#123;<br>                chars[i]=stack.<span class="hljs-title function_">get</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">String</span> string = <span class="hljs-string">&quot;bbcaac&quot;</span>;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-title function_">removeDuplicateLetters</span>(string));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeeCode 103. 二叉树的锯齿形层序遍历</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br>&#x2F;#&#x2F;#&#x2F;#示例<br>给定二叉树 [3,9,20,null,null,15,7],<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161542127.png"></p><p>返回锯齿形层序遍历如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/</a></p><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">ArrayDeque</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">ArrayList</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">List</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    int val;<br>    <span class="hljs-title class_">TreeNode</span> left;<br>    <span class="hljs-title class_">TreeNode</span> right;<br>    <span class="hljs-title class_">TreeNode</span>(int x) &#123; val = x; &#125;<br>&#125;<br> <br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span>(<span class="hljs-params">TreeNode root</span>) &#123;<br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt;&gt;();<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//二叉树为空，直接返回空结果</span><br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-title class_">TreeNode</span>&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-title class_">TreeNode</span>&gt;();<br>    deque.<span class="hljs-title function_">add</span>(root);<br>    <span class="hljs-title function_">leverOrder</span>(res, deque, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 参数列表说明：</span><br><span class="hljs-comment">     * res 结果集</span><br><span class="hljs-comment">     * deque 双向队列存储当前层次遍历的结点</span><br><span class="hljs-comment">     * flag 记录当前遍历的层数，用来控制层序遍历的方向</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">leverOrder</span>(<span class="hljs-params">List&lt;List&lt;Integer&gt;&gt; res,ArrayDeque&lt;TreeNode&gt; deque,int flag</span>) &#123;<br>    int size = deque.<span class="hljs-title function_">size</span>();<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">Integer</span>&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">Integer</span>&gt;(); <br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">while</span>(size-- != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title class_">TreeNode</span> root = deque.<span class="hljs-title function_">pollFirst</span>();<br>    arrayList.<span class="hljs-title function_">add</span>(root.<span class="hljs-property">val</span>);<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">left</span> != <span class="hljs-literal">null</span>) &#123;<br>    deque.<span class="hljs-title function_">offer</span>(root.<span class="hljs-property">left</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">right</span> != <span class="hljs-literal">null</span>) &#123;<br>    deque.<span class="hljs-title function_">offer</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>    &#125;<br>    <span class="hljs-comment">//加入结果集，递归下一层</span><br>    res.<span class="hljs-title function_">add</span>(arrayList);<br>    <span class="hljs-title function_">leverOrder</span>(res, deque, <span class="hljs-number">2</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">while</span>(size-- != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title class_">TreeNode</span> root = deque.<span class="hljs-title function_">pollLast</span>();<br>    arrayList.<span class="hljs-title function_">add</span>(root.<span class="hljs-property">val</span>);<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">right</span> != <span class="hljs-literal">null</span>) &#123;<br>    deque.<span class="hljs-title function_">offerFirst</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">left</span> != <span class="hljs-literal">null</span>) &#123;<br>    deque.<span class="hljs-title function_">offerFirst</span>(root.<span class="hljs-property">left</span>);<br>    &#125;<br>    &#125;<br>    <span class="hljs-comment">//加入结果集，//递归下一层</span><br>    res.<span class="hljs-title function_">add</span>(arrayList);<br>    <span class="hljs-title function_">leverOrder</span>(res, deque, <span class="hljs-number">1</span>);<br>&#125;<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 135. 分发糖果</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20135.%20%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20135.%20%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/candy">https://leetcode-cn.com/problems/candy</a></p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入: [1,0,2]<br>输出: 5<br>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入: [1,2,2]<br>输出: 4<br>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>第三个孩子只得到 1 颗糖果，这已满足上述两个条件</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>两个数组left和right分别记录从左向右规则和从右向左规则时，每个孩子应该分的糖果数。<br>题目要求即为同时满足两个方向的规则，即两个数组按位取max。<br>最终结果要加上每个孩子至少一个糖果。（或者left，right数组初始化为1）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">candy</span>(<span class="hljs-params">int[] ratings</span>) &#123;<br>        int len = ratings.<span class="hljs-property">length</span>;<br>    int sum = len;<br>    int[] left = <span class="hljs-keyword">new</span> int[len];<br>    int[] right = <span class="hljs-keyword">new</span> int[len];<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i-<span class="hljs-number">1</span>]) &#123;<br>                left[i] = left[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">for</span> (int i = len-<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]) &#123;<br>                right[i] = right[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    <br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            sum += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left[i], right[i]);<br>        &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA换源</title>
    <link href="/2021/04/06/Java/IDEA%E6%8D%A2%E6%BA%90/"/>
    <url>/2021/04/06/Java/IDEA%E6%8D%A2%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h4 id="IDEA打开setting，搜索maven"><a href="#IDEA打开setting，搜索maven" class="headerlink" title="IDEA打开setting，搜索maven"></a>IDEA打开setting，搜索maven</h4><p>如图：<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403181807222.png"></p><p>右侧两个override</p><ul><li>第一个是配置文件的路径重写</li><li>第二个是仓库路径重写</li></ul><p>更改为自己的setting.xml的路径即可</p><p>setting.xml的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;settings xmlns=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span><br>    <span class="hljs-attr">xmlns</span>:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>    <span class="hljs-attr">xsi</span>:schemaLocation=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span><br><span class="hljs-string">                        https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;<br> <br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span></span><br><br><br>&lt;/settings&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>识别图中模糊的手写数字（菜鸟做法）</title>
    <link href="/2020/11/29/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%AF%86%E5%88%AB%E5%9B%BE%E4%B8%AD%E6%A8%A1%E7%B3%8A%E7%9A%84%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%EF%BC%88%E8%8F%9C%E9%B8%9F%E5%81%9A%E6%B3%95%EF%BC%89/"/>
    <url>/2020/11/29/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%AF%86%E5%88%AB%E5%9B%BE%E4%B8%AD%E6%A8%A1%E7%B3%8A%E7%9A%84%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%EF%BC%88%E8%8F%9C%E9%B8%9F%E5%81%9A%E6%B3%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>python语言基础</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>导入图片数据集，分析图片的特点、定义变量，构建模型，训练模型并输出中间状态参数，测试、保存、读取模型</p><h4 id="如何搞定它"><a href="#如何搞定它" class="headerlink" title="如何搞定它"></a>如何搞定它</h4><h5 id="1-1导入图片数据集"><a href="#1-1导入图片数据集" class="headerlink" title="1.1导入图片数据集"></a>1.1导入图片数据集</h5><p>首先来看看数据集是什么样的。<br>MNIST是一个入门级的计算机视觉数据集。当我们开始学习编程时，第一件事往往是学习打印Hello World。在机器学习入门的领域里，我们会用MNIST数据集来实验各种模型。</p><p>1.1.1数据集介绍</p><p>MNIST里包含各种手写数字图片，如图所示。<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546895.png" alt="在这里插入图片描述"><br>它也包含每一张图片对应的标签，告诉我们这个是数字几。例如，上面这4张图片的标签分别是5、0、4、1。</p><p>1.1.2下载并安装MNIST数据集</p><p>介绍完MNIST数据集后，下面来演示一下如何通过代码来对其操作。</p><p>（1）利用TensorFlow代码下载MNIST</p><p>TensorFlow提供了一个库，可以直接用来自动下载与安装MNIST，见如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>数据集<br><span class="hljs-keyword">from</span> tensorflow.<span class="hljs-property">examples</span>.<span class="hljs-property">tutorials</span>.<span class="hljs-property">mnist</span> <span class="hljs-keyword">import</span> input_data<br>mnist=input_data.<span class="hljs-title function_">read_data_sets</span>(<span class="hljs-string">&quot;MNIST_data/&quot;</span>,one_hot=<span class="hljs-title class_">True</span>))<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">运行上面的代码，会自动下载数据集并将文件解压到当前代码所在同级目录下的MNIST_data文件夹下。<br>注意：代码中的one_hot=<span class="hljs-title class_">True</span>，表示将样本标签转化为one_hot编码。<br></code></pre></td></tr></table></figure><p>举例来解释one_hot编码：<br>假如一共10类。0的one_hot为1000000000，1的one_hot为0100000000，2的one_hot为0010000000，3的one_hot为0001000000……依此类推。只有一个位为1，1所在的位置就代表着第几类。</p><p>MNIST数据集中的图片是28×28像素，所以，每一幅图就是1行784（28×28）列的数据，括号中的每一个值代表一个像素。</p><ul><li>如果是黑白的图片，图片中黑色的地方数值为0；有图案的地方，数值为0～255之间的数字，代表其颜色的深度。</li><li>如果是彩色的图片，一个像素会由3个值来表示RGB（红、黄、蓝）。在后面讲解其他数据集时会具体讲到。</li></ul><p>接下来通过几行代码将MNIST里面的信息打印出来，看看它的具体内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>数据集（续）<br>print (<span class="hljs-string">&#x27;输入数据:&#x27;</span>,mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>)<br>print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br><span class="hljs-keyword">import</span> pylab<br>im = mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>[<span class="hljs-number">1</span>]<br>im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>pylab.<span class="hljs-title function_">imshow</span>(im)<br>pylab.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p>运行上面的代码，输出信息如下：</p><p>输出结果如图所示<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546896.png" alt="在这里插入图片描述"><br>刚开始的打印信息是解压数据集的意思。如果是第一次运行，还会显示下载数据的相关信息。<br>接着打印出来的是训练集的图片信息，是一个55000行、784列的矩阵。即，训练集里有55000张图片。</p><p>（2）MNIST数据集组成</p><p>在MNIST训练数据集中，mnist.train.images是一个形状为[55000，784]的张量。其中，第1个维度数字用来索引图片，第2个维度数字用来索引每张图片中的像素点。此张量里的每一个元素，都表示某张图片里的某个像素的强度值，值介于0～255之间。<br>MNIST里包含3个数据集：第一个是训练数据集，另外两个分别是测试数据集（mnist.test）和验证数据集（mnist.validation）。可使用如下命令查看里面的数据信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">MNIST</span>数据集（续）<br>print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br>print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">validation</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br></code></pre></td></tr></table></figure><p>运行完上面的命令，可以发现在测试数据集里有10000条样本图片，验证数据集里有5000个图片。</p><p>在实际的机器学习模型设计时，样本一般分为3部分：</p><ul><li>一部分用于训练；</li><li>一部分用于评估训练过程中的准确度（测试数据集）；</li><li>一部分用于评估最终模型的准确度（验证数据集）。</li></ul><p>训练过程中，模型并没有遇到过验证数据集中的数据，所以利用验证数据集可以评估出模型的准确度。这个准确度越高，代表模型的泛化能力越强。</p><p>另外，这3个数据集还有分别对应的3个文件（标签文件），用来标注每个图片上的数字是几。把图片和标签放在一起，称为“样本”。通过样本来就可以实现一个有监督信号的深度学习模型。</p><p>相对应的，MNIST数据集的标签是介于0～9之间的数字，用来描述给定图片里表示的数字。标签数据是“one-hot vectors”：一个one-hot向量，除了某一位的数字是1外，其余各维度数字都是0。例如，标签0将表示为（[1，0，0，0，0，0，0，0，0，0，0]）。因此，mnist.train.labels是一个[55000，10]的数字矩阵。</p><h5 id="1-2分析图片的特点，定义变量"><a href="#1-2分析图片的特点，定义变量" class="headerlink" title="1.2分析图片的特点，定义变量"></a>1.2分析图片的特点，定义变量</h5><p>由于输入图片是个55000×784的矩阵，所以先创建一个[None，784]的占位符x和一个[None，10]的占位符y，然后使用feed机制将图片和标签输入进去。具体代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>分类<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf  # 导入tensorflow库<br><span class="hljs-keyword">from</span> tensorflow.<span class="hljs-property">examples</span>.<span class="hljs-property">tutorials</span>.<span class="hljs-property">mnist</span> <span class="hljs-keyword">import</span> input_data<br>mnist = input_data.<span class="hljs-title function_">read_data_sets</span>(<span class="hljs-string">&quot;MNIST_data/&quot;</span>,one_hot=<span class="hljs-title class_">True</span>)<br><span class="hljs-keyword">import</span> pylab <br>tf.<span class="hljs-title function_">reset_default_graph</span>()<br># 定义占位符<br>x = tf.<span class="hljs-title function_">placeholder</span>(tf.<span class="hljs-property">float32</span>, [<span class="hljs-title class_">None</span>, <span class="hljs-number">784</span>]) # <span class="hljs-variable constant_">MNIST</span>数据集的维度是  <span class="hljs-number">28</span>×<span class="hljs-number">28</span>=<span class="hljs-number">784</span><br>y = tf.<span class="hljs-title function_">placeholder</span>(tf.<span class="hljs-property">float32</span>, [<span class="hljs-title class_">None</span>, <span class="hljs-number">10</span>])  # 数字<span class="hljs-number">0</span>～<span class="hljs-number">9</span> ，共<span class="hljs-number">10</span>个类别<br>#代码中第<span class="hljs-number">8</span>行的<span class="hljs-title class_">None</span>，表示此张量的第一个维度可以是任何长度的。x就代表能够输入任意数量的<span class="hljs-variable constant_">MNIST</span>图像，每一张图展平成<span class="hljs-number">784</span>维的向量。<br></code></pre></td></tr></table></figure><h5 id="1-3构建模型"><a href="#1-3构建模型" class="headerlink" title="1.3构建模型"></a>1.3构建模型</h5><p>样本完成后就可以构建模型了。下面列出了构建模型的相关步骤。</p><p>1.3.1　定义学习参数</p><p>模型也需要权重值和偏置量，它们被统一叫做学习参数。在TensorFlow里，使用Variable来定义学习参数。<br>一个Variable代表一个可修改的张量，定义在TensorFlow的图（一个执行任务）中，其本身也是一种变量。使用Variable定义的学习参数可以用于计算输入值，也可以在计算中被修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>分类（续）<br>W = tf.<span class="hljs-title class_">Variable</span>(tf.<span class="hljs-title function_">random_normal</span>(([<span class="hljs-number">784</span>,<span class="hljs-number">10</span>]))<br>b = tf.<span class="hljs-title class_">Variable</span>(tf.<span class="hljs-title function_">zeros</span>([<span class="hljs-number">10</span>]))<br></code></pre></td></tr></table></figure><p>在这里赋予tf.Variable不同的初值来创建不同的参数。一般将W设为一个随机值，将b设为0。<br>注意：W的维度是[784，10]，因为想要用784维的图片向量乘以它，以得到一个10维的证据值向量，每一位对应不同数字类。b的形状是[10]，所以可以直接把它加到输出上面。</p><p>1.3.2　定义输出节点</p><p>有了输入和模型参数，接着便可以将它们串起来构建成真正的模型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>分类（续）<br>pred = tf.<span class="hljs-property">nn</span>.<span class="hljs-title function_">softmax</span>(tf.<span class="hljs-title function_">matmul</span>(x, W) + b) # <span class="hljs-title class_">Softmax</span>分类<br></code></pre></td></tr></table></figure><p>首先，用tf.matmul（x，W）表示x乘以W，这里x是一个二维张量，拥有多个输入。然后再加上b，把它们的和输入到tf.nn.softmax函数里。<br>至此就构建好了正向传播的结构。也就是表明，只要模型中的参数合适，通过具体的数据输入，就能得到我们想要的分类。</p><p>1.3.3　定义反向传播的结构</p><p>下面定义一个反向传播的结构，编译训练模型，以得到合适的参数。<br>这里涉及一个“学习率”的概念。学习率，是指每次改变学习参数的大小。在这里读者只要先有个概念即可，后面章节还会详细介绍。<br>先看下面代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">代码<span class="hljs-number">1</span>-<span class="hljs-number">2</span>　<span class="hljs-variable constant_">MNIST</span>分类（续）<br># 损失函数<br>cost=tf.<span class="hljs-title function_">reduce_mean</span>(-tf.<span class="hljs-title function_">reduce_sum</span>(y*tf.<span class="hljs-title function_">log</span>(pred),reduction_indices=<span class="hljs-number">1</span>))<br>  <br># 定义参数<br>learning_rate = <span class="hljs-number">0.01</span><br># 使用梯度下降优化器<br>optimizer=tf.<span class="hljs-property">train</span>.<span class="hljs-title class_">GradientDescentOptimizer</span>(learning_rate).<span class="hljs-title function_">minimize</span>(cost)<br></code></pre></td></tr></table></figure><p>上面的代码可以这样来理解：<br>（1）将生成的pred与样本标签y进行一次交叉熵的运算，然后取平均值。<br>（2）将这个结果作为一次正向传播的误差，通过梯度下降的优化方法找到能够使这个误差最小化的b和W的偏移量。<br>（3）更新b和W，使其调整为合适的参数。<br>整个过程就是不断地让损失值（误差值cost）变小。因为损失值越小，才能表明输出的结果跟标签数据越相近。当cost小到我们的需求时，这时的b和W就是训练出来的合适值。</p><h5 id="1-4-训练模型并输出中间状态参数"><a href="#1-4-训练模型并输出中间状态参数" class="headerlink" title="1.4　训练模型并输出中间状态参数"></a>1.4　训练模型并输出中间状态参数</h5><p>现在开始真正地训练模型了，先定义训练相关的参数。<br>下面代码中</p><ul><li>第1行中，training_epochs代表要把整个训练样本集迭代25次；</li><li>第2行中，batch_size代表在训练过程中一次取100条数据进行训练</li><li>第3行中，display_step代表每训练一次就把具体的中间状态显示出来。</li></ul><p>注意：batch_size参数代表的意义很关键，在深度学习中，都是将数据按批次地向里面放的。在后面章节中还会详细介绍这么做的目的。<br>参数定义好后，启动一个session就可以开始训练过程了。session中有两个run，第一个run是运行初始化，第二个run是运行具体的运算模型。模型运算之后便将里面的状态打印出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">training_epochs = <span class="hljs-number">25</span><br>batch_size = <span class="hljs-number">100</span><br>display_step = <span class="hljs-number">1</span><br><br>saver = tf.<span class="hljs-property">train</span>.<span class="hljs-title class_">Saver</span>()<br>model_path = <span class="hljs-string">&quot;log/521model.ckpt&quot;</span><br><br># 启动session<br><span class="hljs-keyword">with</span> tf.<span class="hljs-title class_">Session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">sess</span>:<br>    sess.<span class="hljs-title function_">run</span>(tf.<span class="hljs-title function_">global_variables_initializer</span>())# <span class="hljs-title class_">Initializing</span> <span class="hljs-variable constant_">OP</span><br>    # 启动循环开始训练<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(training_epochs):<br>        avg_cost = <span class="hljs-number">0.</span><br>        total_batch = <span class="hljs-title function_">int</span>(mnist.<span class="hljs-property">train</span>.<span class="hljs-property">num_examples</span>/batch_size)<br>        # 循环所有数据集<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(total_batch):<br>            batch_xs, batch_ys = mnist.<span class="hljs-property">train</span>.<span class="hljs-title function_">next_batch</span>(batch_size)<br>            # 运行优化器<br>            _, c = sess.<span class="hljs-title function_">run</span>([optimizer, cost], feed_dict=&#123;<br>    <span class="hljs-attr">x</span>: batch_xs,<br>                                                       <span class="hljs-attr">y</span>: batch_ys&#125;)<br>            # 计算平均loss值<br>            avg_cost += c / total_batch<br>        # 显示训练中的详细信息<br>        <span class="hljs-keyword">if</span> (epoch+<span class="hljs-number">1</span>) % display_step == <span class="hljs-number">0</span>:<br>           print (<span class="hljs-string">&quot;Epoch:&quot;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;cost=&quot;</span>, <span class="hljs-string">&quot;&#123;:.9f&#125;&quot;</span>.            <span class="hljs-title function_">format</span>(avg_cost))<br><br>    <span class="hljs-title function_">print</span>( <span class="hljs-string">&quot; Finished!&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行上面的代码，会输出如下信息：<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546897.png" alt="在这里插入图片描述"></p><p>这里输出的中间状态是cost损失值。读者也可以把自己关心的内容打印出来。可以看到，从第1次迭代到第25次迭代的损失值在逐渐减小，最终的误差只有0.8。</p><h5 id="1-5-测试模型"><a href="#1-5-测试模型" class="headerlink" title="1.5　测试模型"></a>1.5　测试模型</h5><p>还记得MNIST里面有测试数据吗？现在我们使用测试数据来测试一下训练完的模型吧。<br>与前面的过程类似，也是先将计算测试的网络结构建立起来，然后通过最终节点的eval将测试值运算出来。<br>注意：这个过程仍然是在session里进行的。<br>测试错误率的算法是：直接判断预测的结果与真实的标签是否相同，如是相同的就表明是正确的，如是不相同的就表示是错误的。然后将正确的个数除以总个数，得到的值即为正确率。由于是onehot编码，这里使用了tf.argmax函数返回onehot编码中数值为1的那个元素的下标。下面是具体代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">#<span class="hljs-variable constant_">MNIST</span>分类（续）<br>    correct_prediction = tf.<span class="hljs-title function_">equal</span>(tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>), tf.<span class="hljs-title function_">argmax</span>(y, <span class="hljs-number">1</span>))<br>    # 计算准确率<br>    accuracy = tf.<span class="hljs-title function_">reduce_mean</span>(tf.<span class="hljs-title function_">cast</span>(correct_prediction, tf.<span class="hljs-property">float32</span>))<br>    print (<span class="hljs-string">&quot;Accuracy:&quot;</span>, accuracy.<span class="hljs-built_in">eval</span>(&#123;<br>    <span class="hljs-attr">x</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>, <span class="hljs-attr">y</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">labels</span>&#125;))<br></code></pre></td></tr></table></figure><p>上面代码执行后，显示信息如下：<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546898.png" alt="在这里插入图片描述"></p><p>测试正确率的算法与损失值的算法略有差别，但代表的意义却很类似。当然，也可以直接拿计算损失值的交叉熵结果来代表模型测试的错误率。<br>注意：<br>（1）并不是所有模型的测试错误率和训练时的最后一次损失值都很接近，这取决于训练样本和测试样本的分布情况，也取决于模型本身的拟合质量。关于拟合质量问题，将在后面章节详细介绍。<br>（2）读者自己运行时，得到的值可能和本书中的值不一样。甚至每次运行时，得到的值也不一样。原因是每次初始的权重w都是随机的。由于初始权重不同，而且每次训练的批次数据也不同，所以最终生成的模型也不会完全相同。但如果核心算法保持一致，则会保证最终的结果不会有太大的偏差。</p><h5 id="1-6-保存模型"><a href="#1-6-保存模型" class="headerlink" title="1.6　保存模型"></a>1.6　保存模型</h5><p>下面开始讲解如何保存模型。<br>首先要建立一个saver和一个路径，然后通过调用save，自动将session中的参数保存起来，见如下代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>分类（续）   <br># 保存模型<br>    save_path = saver.<span class="hljs-title function_">save</span>(sess, model_path)<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;Model saved in file: %s&quot;</span> % save_path)<br></code></pre></td></tr></table></figure><p>上面代码的作用是保存模型，并将模型保存的路径打印出来。当然，在这段代码运行之前，需要添加saver和model_path的定义。来到前面session创建之前添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>分类（续）<br>saver = tf.<span class="hljs-property">train</span>.<span class="hljs-title class_">Saver</span>()<br>model_path = <span class="hljs-string">&quot;log/521model.ckpt&quot;</span><br></code></pre></td></tr></table></figure><p>执行上述的全部代码后，会打印出存储位置<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546899.png" alt="在这里插入图片描述"></p><h5 id="1-7-读取模型"><a href="#1-7-读取模型" class="headerlink" title="1.7　读取模型"></a>1.7　读取模型</h5><p>将模型存储好后，下面来做一个实验：读取模型并将两张图片放进去让模型预测结果，然后将两张图片极其对应的标签一并显示出来。<br>在整个代码执行过程中，对于网络模型的定义不变，只是重新建立一个session而已，所有的操作都在这个新的session中完成。具体细节见代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">#　<span class="hljs-variable constant_">MNIST</span>分类（续）<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;Starting 2nd session...&quot;</span>)<br><span class="hljs-keyword">with</span> tf.<span class="hljs-title class_">Session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">sess</span>:<br>    # 初始化变量<br>    sess.<span class="hljs-title function_">run</span>(tf.<span class="hljs-title function_">global_variables_initializer</span>())<br>    # 恢复模型变量<br>    saver.<span class="hljs-title function_">restore</span>(sess, model_path)<br><br>    # 测试 model<br>    correct_prediction = tf.<span class="hljs-title function_">equal</span>(tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>), tf.<span class="hljs-title function_">argmax</span>(y, <span class="hljs-number">1</span>))<br>    # 计算准确率<br>    accuracy = tf.<span class="hljs-title function_">reduce_mean</span>(tf.<span class="hljs-title function_">cast</span>(correct_prediction, tf.<span class="hljs-property">float32</span>))<br>    print (<span class="hljs-string">&quot;Accuracy:&quot;</span>, accuracy.<span class="hljs-built_in">eval</span>(&#123;<br>    <span class="hljs-attr">x</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>, <span class="hljs-attr">y</span>: mnist.      test.<span class="hljs-property">labels</span>&#125;))<br><br>    output = tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>)<br>    batch_xs, batch_ys = mnist.<span class="hljs-property">train</span>.<span class="hljs-title function_">next_batch</span>(<span class="hljs-number">2</span>)<br>    outputval,predv = sess.<span class="hljs-title function_">run</span>([output,pred], feed_dict=&#123;<br>    <span class="hljs-attr">x</span>: batch_xs&#125;)<br>    <span class="hljs-title function_">print</span>(outputval,predv,batch_ys)<br>    im = batch_xs[<span class="hljs-number">0</span>]<br>    im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.<span class="hljs-title function_">imshow</span>(im)<br>    pylab.<span class="hljs-title function_">show</span>()<br><br>    im = batch_xs[<span class="hljs-number">1</span>]<br>    im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.<span class="hljs-title function_">imshow</span>(im)<br>    pylab.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p>以上代码可以替代原来的session，也可以直接放到代码后面，将前面的session注释掉。<br>输出结果<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546900.png" alt="在这里插入图片描述"></p><ul><li>第一行是模型的准确率，接下来是3个数组。</li><li>第一个数组是输出的预测结果[3,6]</li><li>第二个大的数组比较大，是预测出来的真实输出值，哪一项数值越大，代表对应的概率越大.</li><li>第三个大的数组元素都是0和1，是图片实际的标签值onehot编码表示的数字</li></ul><p>完整代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> tensorflow.<span class="hljs-property">compat</span>.<span class="hljs-property">v1</span> <span class="hljs-keyword">as</span> tf  # 导入tensorflow库#<br>tf.<span class="hljs-title function_">disable_v2_behavior</span>()<br><br><span class="hljs-keyword">from</span> tensorflow.<span class="hljs-property">examples</span>.<span class="hljs-property">tutorials</span>.<span class="hljs-property">mnist</span> <span class="hljs-keyword">import</span> input_data<br>mnist = input_data.<span class="hljs-title function_">read_data_sets</span>(<span class="hljs-string">&quot;MNIST_data/&quot;</span>, one_hot=<span class="hljs-title class_">True</span>)<br><br># print (<span class="hljs-string">&#x27;输入数据:&#x27;</span>,mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>)<br># print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br><br><span class="hljs-keyword">import</span> pylab<br>im = mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>[<span class="hljs-number">1</span>]<br>im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>pylab.<span class="hljs-title function_">imshow</span>(im)<br>pylab.<span class="hljs-title function_">show</span>()<br># print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br># print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">validation</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br><br>tf.<span class="hljs-title function_">reset_default_graph</span>()<br># 定义占位符<br>x = tf.<span class="hljs-title function_">placeholder</span>(tf.<span class="hljs-property">float32</span>, [<span class="hljs-title class_">None</span>, <span class="hljs-number">784</span>]) # <span class="hljs-variable constant_">MNIST</span>数据集的维度是  <span class="hljs-number">28</span>×<span class="hljs-number">28</span>=<span class="hljs-number">784</span><br>y = tf.<span class="hljs-title function_">placeholder</span>(tf.<span class="hljs-property">float32</span>, [<span class="hljs-title class_">None</span>, <span class="hljs-number">10</span>])  # 数字<span class="hljs-number">0</span>～<span class="hljs-number">9</span> ，共<span class="hljs-number">10</span>个类别<br>W = tf.<span class="hljs-title class_">Variable</span>(tf.<span class="hljs-title function_">random_normal</span>([<span class="hljs-number">784</span>,<span class="hljs-number">10</span>]))<br>b = tf.<span class="hljs-title class_">Variable</span>(tf.<span class="hljs-title function_">zeros</span>([<span class="hljs-number">10</span>]))<br>pred = tf.<span class="hljs-property">nn</span>.<span class="hljs-title function_">softmax</span>(tf.<span class="hljs-title function_">matmul</span>(x, W) + b) # <span class="hljs-title class_">Softmax</span>分类<br><br># 损失函数<br>cost=tf.<span class="hljs-title function_">reduce_mean</span>(-tf.<span class="hljs-title function_">reduce_sum</span>(y*tf.<span class="hljs-title function_">log</span>(pred),reduction_indices=<span class="hljs-number">1</span>))<br><br># 定义参数<br>learning_rate = <span class="hljs-number">0.01</span><br># 使用梯度下降优化器<br>optimizer=tf.<span class="hljs-property">train</span>.<span class="hljs-title class_">GradientDescentOptimizer</span>(learning_rate).<span class="hljs-title function_">minimize</span>(cost)<br>training_epochs = <span class="hljs-number">25</span><br>batch_size = <span class="hljs-number">100</span><br>display_step = <span class="hljs-number">1</span><br><br>saver = tf.<span class="hljs-property">train</span>.<span class="hljs-title class_">Saver</span>()<br>model_path = <span class="hljs-string">&quot;log/521model.ckpt&quot;</span><br><br># 启动session<br><span class="hljs-keyword">with</span> tf.<span class="hljs-title class_">Session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">sess</span>:<br>    sess.<span class="hljs-title function_">run</span>(tf.<span class="hljs-title function_">global_variables_initializer</span>())# <span class="hljs-title class_">Initializing</span> <span class="hljs-variable constant_">OP</span><br>    # 启动循环开始训练<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(training_epochs):<br>        avg_cost = <span class="hljs-number">0.</span><br>        total_batch = <span class="hljs-title function_">int</span>(mnist.<span class="hljs-property">train</span>.<span class="hljs-property">num_examples</span>/batch_size)<br>        # 循环所有数据集<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(total_batch):<br>            batch_xs, batch_ys = mnist.<span class="hljs-property">train</span>.<span class="hljs-title function_">next_batch</span>(batch_size)<br>            # 运行优化器<br>            _, c = sess.<span class="hljs-title function_">run</span>([optimizer, cost], feed_dict=&#123;<br>    <span class="hljs-attr">x</span>: batch_xs,<br>                                                       <span class="hljs-attr">y</span>: batch_ys&#125;)<br>            # 计算平均loss值<br>            avg_cost += c / total_batch<br>        # 显示训练中的详细信息<br>        <span class="hljs-keyword">if</span> (epoch+<span class="hljs-number">1</span>) % display_step == <span class="hljs-number">0</span>:<br>           print (<span class="hljs-string">&quot;Epoch:&quot;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;cost=&quot;</span>, <span class="hljs-string">&quot;&#123;:.9f&#125;&quot;</span>.            <span class="hljs-title function_">format</span>(avg_cost))<br><br>    <span class="hljs-title function_">print</span>( <span class="hljs-string">&quot; Finished!&quot;</span>)<br>    # 测试 model<br>    correct_prediction = tf.<span class="hljs-title function_">equal</span>(tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>), tf.<span class="hljs-title function_">argmax</span>(y, <span class="hljs-number">1</span>))<br>    # 计算准确率<br>    accuracy = tf.<span class="hljs-title function_">reduce_mean</span>(tf.<span class="hljs-title function_">cast</span>(correct_prediction, tf.<span class="hljs-property">float32</span>))<br>    print (<span class="hljs-string">&quot;Accuracy:&quot;</span>, accuracy.<span class="hljs-built_in">eval</span>(&#123;<br>    <span class="hljs-attr">x</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>, <span class="hljs-attr">y</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">labels</span>&#125;))<br><br>    #     # 保存模型<br>    save_path = saver.<span class="hljs-title function_">save</span>(sess, model_path)<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;Model saved in file: %s&quot;</span> % save_path)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;Starting 2nd session...&quot;</span>)<br><span class="hljs-keyword">with</span> tf.<span class="hljs-title class_">Session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">sess</span>:<br>    # 初始化变量<br>    sess.<span class="hljs-title function_">run</span>(tf.<span class="hljs-title function_">global_variables_initializer</span>())<br>    # 恢复模型变量<br>    saver.<span class="hljs-title function_">restore</span>(sess, model_path)<br><br>    # 测试 model<br>    correct_prediction = tf.<span class="hljs-title function_">equal</span>(tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>), tf.<span class="hljs-title function_">argmax</span>(y, <span class="hljs-number">1</span>))<br>    # 计算准确率<br>    accuracy = tf.<span class="hljs-title function_">reduce_mean</span>(tf.<span class="hljs-title function_">cast</span>(correct_prediction, tf.<span class="hljs-property">float32</span>))<br>    print (<span class="hljs-string">&quot;Accuracy:&quot;</span>, accuracy.<span class="hljs-built_in">eval</span>(&#123;<br>    <span class="hljs-attr">x</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>, <span class="hljs-attr">y</span>: mnist.      test.<span class="hljs-property">labels</span>&#125;))<br><br>    output = tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>)<br>    batch_xs, batch_ys = mnist.<span class="hljs-property">train</span>.<span class="hljs-title function_">next_batch</span>(<span class="hljs-number">2</span>)<br>    outputval,predv = sess.<span class="hljs-title function_">run</span>([output,pred], feed_dict=&#123;<br>    <span class="hljs-attr">x</span>: batch_xs&#125;)<br>    <span class="hljs-title function_">print</span>(outputval,predv,batch_ys)<br>    im = batch_xs[<span class="hljs-number">0</span>]<br>    im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.<span class="hljs-title function_">imshow</span>(im)<br>    pylab.<span class="hljs-title function_">show</span>()<br><br>    im = batch_xs[<span class="hljs-number">1</span>]<br>    im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.<span class="hljs-title function_">imshow</span>(im)<br>    pylab.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 463. 岛屿的周长</title>
    <link href="/2020/11/01/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20463.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <url>/2020/11/01/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20463.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p><strong>来源：力扣（LeetCode）</strong><br><strong>输入:</strong><br>[[0,1,0,0],<br>[1,1,1,0],<br>[0,1,0,0],<br>[1,1,0,0]]</p><p><strong>输出: 16</strong></p><p>解释: 它的周长是下面图片中的 16 个黄色的边：</p><p><img src="/../images/93d311ab-1d1d-4d82-90cd-729bdfe3b289.png" alt="在这里插入图片描述"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">islandPerimeter</span>(<span class="hljs-params">int[][] grid</span>) &#123;<br>    <br>        int m = grid.<span class="hljs-property">length</span>;<br>        int n = grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>        int res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>    <br>            <span class="hljs-keyword">for</span>(int j=<span class="hljs-number">0</span>; j&lt;n;j++)&#123;<br>    <br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>    <br>                <span class="hljs-comment">//如果是岛屿，判断其四个方向有没有岛屿，没有周长++</span><br>                    <span class="hljs-keyword">if</span>(i-<span class="hljs-number">1</span>&lt;<span class="hljs-number">0</span>)&#123;<br>    <br>                        res++;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>                        <span class="hljs-keyword">if</span>(grid[i-<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>)&#123;<br>    <br>                            res++;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(j-<span class="hljs-number">1</span>&lt;<span class="hljs-number">0</span>)&#123;<br>    <br>                        res++;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>                        <span class="hljs-keyword">if</span>(grid[i][j-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>    <br>                            res++;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&gt;=m)&#123;<br>    <br>                        res++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>    <br>                        <span class="hljs-keyword">if</span>(grid[i+<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>)&#123;<br>    <br>                            res++;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&gt;=n)&#123;<br>    <br>                        res++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>    <br>                        <span class="hljs-keyword">if</span>(grid[i][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>    <br>                            res++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写的时候直接暴力统计每一个岛屿的四个方向是否与其他岛屿相连，<br>使用了一堆的if…；<br>看到别人的题解是先统计周长为有几块岛屿&#x2F;*4，再判断如果岛屿两两相连，那么周长-2；</p>]]></content>
    
    
    <categories>
      
      <category>LeeCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeeCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python爬取51job的招聘信息</title>
    <link href="/2020/04/29/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/python%E7%88%AC%E5%8F%9651job%E7%9A%84%E6%8B%9B%E8%81%98%E4%BF%A1%E6%81%AF/"/>
    <url>/2020/04/29/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/python%E7%88%AC%E5%8F%9651job%E7%9A%84%E6%8B%9B%E8%81%98%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong><br>最近的脚本课程有了新的作业。爬取51job上的一些招聘信息，包括城市 薪资最大最小值等。</p><p>这里示例的是 济南、北京、上海、广州、深圳的招聘信息<br><strong>求助</strong><br>薪资有些招聘信息并没有填写，也就是说薪资所在标签的值为空值，这些空值无法在集合中占位，进而导致薪资和招聘信息不匹配，如果有大佬会，能不能指点一下啊 ，555 -.-||</p><p>招聘信息包括<br>职位 公司 工作地点 薪水 发布时间 最低薪资 最高薪资 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> xlwt<br><span class="hljs-keyword">import</span> string<br>#workbook = xlwt.<span class="hljs-title class_">Workbook</span>(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)#创建 workbook 即新建 excel 文件/工作簿，<br>myxls = xlwt.<span class="hljs-title class_">Workbook</span>()<br>#worksheet = workbook.<span class="hljs-title function_">add_sheet</span>(<span class="hljs-string">&#x27;my_worksheet&#x27;</span>) #创建工作表，如果想创建多个工作表，直接在后面再 add_sheet<br>sheet1 = myxls.<span class="hljs-title function_">add_sheet</span>(u<span class="hljs-string">&#x27;top250&#x27;</span>, cell_overwrite_ok=<span class="hljs-title class_">True</span>)<br><br>#请求头<br><span class="hljs-variable constant_">HEADERS</span> = &#123;<br>    <br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&#x27;</span>,<br>&#125;<br><br>base_urls = <span class="hljs-string">&#x27;https://search.51job.com/list/120200%252C010000%252C020000%252C030200%252C040000,000000,0000,00,9,99,python,2,&#123;&#125;.html&#x27;</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">51</span>):<br>    url = base_urls.<span class="hljs-title function_">format</span>(x)<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;第%s页爬取完成&#x27;</span> % x)<br>    response = requests.<span class="hljs-title function_">get</span>(url,<span class="hljs-variable constant_">HEADERS</span>)<br>    text = response.<span class="hljs-property">content</span>.<span class="hljs-title function_">decode</span>(<span class="hljs-string">&#x27;gbk&#x27;</span>)<br>    tree = etree.<span class="hljs-title function_">HTML</span>(text)<br><br>    <span class="hljs-title class_">PositionAndCompany</span> = tree.<span class="hljs-title function_">xpath</span>(<span class="hljs-string">&quot;//div[@class=&#x27;el&#x27;]//span/a/@title&quot;</span>)<br>    positions = <span class="hljs-title class_">PositionAndCompany</span>[::<span class="hljs-number">2</span>]<br>    companys = <span class="hljs-title class_">PositionAndCompany</span>[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]<br>    workplaces = tree.<span class="hljs-title function_">xpath</span>(<span class="hljs-string">&#x27;//div[@class=&quot;el&quot;]//span[@class=&quot;t3&quot;]/text()&#x27;</span>)<br>    salarys = tree.<span class="hljs-title function_">xpath</span>(<span class="hljs-string">&#x27;//div[@class=&quot;el&quot;]/span[@class=&quot;t4&quot;]/text()&#x27;</span>)<br>    times = tree.<span class="hljs-title function_">xpath</span>(<span class="hljs-string">&#x27;//div[@class=&quot;el&quot;]/span[@class=&quot;t5&quot;]/text()&#x27;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;职位&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;公司&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&quot;工作地方&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;薪水&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;时间&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;最低薪水&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;最高薪水&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>,<span class="hljs-title function_">len</span>(salarys)):<br>        pos = positions[i].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;\t&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        sheet1.<span class="hljs-title function_">write</span>((x-<span class="hljs-number">1</span>)*<span class="hljs-number">50</span> + i, <span class="hljs-number">1</span>, pos)<br>        com = companys[i]<br>        sheet1.<span class="hljs-title function_">write</span>((x-<span class="hljs-number">1</span>)*<span class="hljs-number">50</span> +i, <span class="hljs-number">5</span>, com)<br>        workplace = workplaces[i]<br>        sheet1.<span class="hljs-title function_">write</span>((x-<span class="hljs-number">1</span>)*<span class="hljs-number">50</span> +i, <span class="hljs-number">8</span>, workplace)<br>        salary = salarys[i]<br>        sheet1.<span class="hljs-title function_">write</span>((x-<span class="hljs-number">1</span>)*<span class="hljs-number">50</span> +i, <span class="hljs-number">10</span>, salary)<br>        time = times[i]<br>        sheet1.<span class="hljs-title function_">write</span>((x-<span class="hljs-number">1</span>)*<span class="hljs-number">50</span> +i,<span class="hljs-number">12</span>,time)<br>        peace = salary.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>        #将数值与单位分离<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_">len</span>(peace)&gt; <span class="hljs-number">1</span>):<br>            peace[<span class="hljs-number">0</span>] = <span class="hljs-title function_">float</span>(peace[<span class="hljs-number">0</span>])<br>            #unit 是薪资的单位<br>            unit = peace[<span class="hljs-number">1</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>            data1 = peace[<span class="hljs-number">1</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;元&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;千&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;万&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;小时&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;天&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;月&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;年&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;以上&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>            num = <span class="hljs-title function_">float</span>(data1)<br>            #这里是将薪资的单位统一为 万/月<br>            <span class="hljs-keyword">if</span> (unit == <span class="hljs-string">&quot;元/小时&quot;</span>):<br>                salary_1 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((data2 * <span class="hljs-number">24</span> * <span class="hljs-number">30</span> / <span class="hljs-number">10000</span>),<span class="hljs-number">2</span>))<br>                salary_2 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((num * <span class="hljs-number">24</span> * <span class="hljs-number">30</span> / <span class="hljs-number">10000</span>),<span class="hljs-number">2</span>))<br>            elif (unit == <span class="hljs-string">&quot;元/天&quot;</span>):<br>                salary_1 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((peace[<span class="hljs-number">0</span>] * <span class="hljs-number">30</span> / <span class="hljs-number">10000</span>),<span class="hljs-number">2</span>))<br>                salary_2 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((num *<span class="hljs-number">30</span> / <span class="hljs-number">10000</span>),<span class="hljs-number">2</span>))<br>            <span class="hljs-title function_">elif</span>(unit == <span class="hljs-string">&quot;千/月&quot;</span>):<br>                salary_1 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((peace[<span class="hljs-number">0</span>]/<span class="hljs-number">10</span>),<span class="hljs-number">2</span>))<br>                salary_2 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((num/<span class="hljs-number">10</span>),<span class="hljs-number">2</span>))<br>            elif (unit == <span class="hljs-string">&quot;万/年&quot;</span>):<br>                salary_1 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((peace[<span class="hljs-number">0</span>] / <span class="hljs-number">12</span>),<span class="hljs-number">2</span>))<br>                salary_2 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((num / <span class="hljs-number">12</span>),<span class="hljs-number">2</span>))<br>            <span class="hljs-attr">else</span>:<br>                salary_1 = <span class="hljs-title function_">str</span>(peace[<span class="hljs-number">0</span>])<br>                salary_2 = <span class="hljs-title function_">str</span>(num)<br>            sheet1.<span class="hljs-title function_">write</span>((x - <span class="hljs-number">1</span>) * <span class="hljs-number">50</span> + i, <span class="hljs-number">14</span>, salary_1 + <span class="hljs-string">&quot;万/月&quot;</span>)<br>            sheet1.<span class="hljs-title function_">write</span>((x - <span class="hljs-number">1</span>) * <span class="hljs-number">50</span> + i, <span class="hljs-number">16</span>, salary_2 + <span class="hljs-string">&quot;万/月&quot;</span>)<br>        <span class="hljs-attr">else</span>:<br>            #unit 是薪资的单位<br>            unit = peace[<span class="hljs-number">0</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            data2 = peace[<span class="hljs-number">0</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;元&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;千&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;万&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;小时&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;天&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;月&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;年&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;以上&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>            num = <span class="hljs-title function_">float</span>(data2)<br>            <span class="hljs-keyword">if</span> (unit == <span class="hljs-string">&quot;元/小时&quot;</span>):<br>                salary_3 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((num * <span class="hljs-number">24</span> * <span class="hljs-number">30</span> / <span class="hljs-number">10000</span>),<span class="hljs-number">2</span>))<br><br>            <span class="hljs-title function_">elif</span>(unit == <span class="hljs-string">&quot;元/天&quot;</span>):<br>                salary_3 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>(num * <span class="hljs-number">30</span> / <span class="hljs-number">10000</span>))<br><br>            elif (unit == <span class="hljs-string">&quot;千/月&quot;</span>):<br>                salary_3 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>(num/<span class="hljs-number">10</span>))<br><br>            <span class="hljs-title function_">elif</span>(unit == <span class="hljs-string">&quot;万/年&quot;</span> or unit == <span class="hljs-string">&quot;万以上/年&quot;</span>):<br>                salary_3 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>(num / <span class="hljs-number">12</span>))<br><br>            elif (unit == <span class="hljs-string">&quot;万/月&quot;</span>):<br>                salary_3 = <span class="hljs-title function_">str</span>(num)<br>#如果提供的单位不是这几个中的一个，输出标记可自行查看！哈哈哈哈<br>            <span class="hljs-attr">else</span>:<br>                <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;我也没辙了&quot;</span>)<br>            sheet1.<span class="hljs-title function_">write</span>((x - <span class="hljs-number">1</span>) * <span class="hljs-number">50</span> + i, <span class="hljs-number">14</span>, salary_3 + <span class="hljs-string">&quot;万/月&quot;</span>)<br>            sheet1.<span class="hljs-title function_">write</span>((x - <span class="hljs-number">1</span>) * <span class="hljs-number">50</span> + i, <span class="hljs-number">16</span>, salary_3 + <span class="hljs-string">&quot;万/月&quot;</span>)<br><br>        #<span class="hljs-title function_">print</span>(<span class="hljs-title function_">len</span>(pos),<span class="hljs-title function_">len</span>(com),<span class="hljs-title function_">len</span>(workplace),<span class="hljs-title function_">len</span>(salary),<span class="hljs-title function_">len</span>(time))<br>    myxls.<span class="hljs-title function_">save</span>(<span class="hljs-string">&#x27;爬取结果.xls&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Expe 02 线程的同步</title>
    <link href="/2020/04/21/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/OS%20Expe%2002%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/"/>
    <url>/2020/04/21/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/OS%20Expe%2002%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="实验二-线程的同步"><a href="#实验二-线程的同步" class="headerlink" title="实验二:线程的同步"></a>实验二:线程的同步</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>1）进一步掌握windows系统环境下线程的创建和撤销<br>2）熟悉windows系统提供的线程同步API（是WINDOWS提供给应用程序与操作系统的接口）<br>3）使用windows系统提供的线程同步API解决实际问题</p><h3 id="二、实验准备"><a href="#二、实验准备" class="headerlink" title="二、实验准备"></a>二、实验准备</h3><h5 id="1-进程同步机制的主要任务："><a href="#1-进程同步机制的主要任务：" class="headerlink" title="1. 进程同步机制的主要任务："></a>1. 进程同步机制的主要任务：</h5><p>对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能够按照一定的规则（或时序）共享系统资源，并能很好地相互合作，从而使程序执行具有可再现性。</p><h5 id="2-线程和进程的发展历程"><a href="#2-线程和进程的发展历程" class="headerlink" title="2. 线程和进程的发展历程"></a>2. 线程和进程的发展历程</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">在<span class="hljs-number">20</span>世纪<span class="hljs-number">60</span>年代中期，人们在设计多道程序<span class="hljs-variable constant_">OS</span>时，引入了进程的概念，从而解决了在单处理机环境下的程序并发执行问题。此后在长达<span class="hljs-number">20</span>年的时间里，在多道程序<span class="hljs-variable constant_">OS</span>中一直以进程作为能拥有资源和独立调度的（运行）的基本单位。<br><br>直到<span class="hljs-number">80</span>年代中期，人们又提出了比进程更小的基本单位 线程 的概念，试图用它来提高程序并发执行的程度，以进一步改善系统的服务质量。特别是在进入<span class="hljs-number">20</span>世纪<span class="hljs-number">90</span>年代后，多处理机系统得到迅速发展，由于线程能更好的提高程序的并发执行程度，因而近几年推出的多处理机<span class="hljs-variable constant_">OS</span>无一例外地都引入了进程，用以改善<span class="hljs-variable constant_">OS</span>的性能。<br></code></pre></td></tr></table></figure><p>由于<strong>线程具有许多传统进程所具有的特征</strong>，所以又称之为轻型进程或进程元，相应的，把传统进程称之为重型进程。传统进程相当于只有一个线程的任务，</p><h5 id="3-等待对象函数"><a href="#3-等待对象函数" class="headerlink" title="3. 等待对象函数"></a>3. 等待对象函数</h5><p>等待一个对象 等待多个对象 WaitForSingleObject() WaitForMultipleObjects() 在指定时间内等待一个对象 在指定时间内等待多个对象</p><p><strong>原型：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">WaitForSingleObject</span>(<br><span class="hljs-variable constant_">HANDLE</span> hHandle,<span class="hljs-comment">//对象句柄</span><br><span class="hljs-variable constant_">DWORD</span> dwMilliseconds <span class="hljs-comment">//等待时间，以毫秒为单位</span><br>);<br></code></pre></td></tr></table></figure><p><strong>原型：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">WaitForMultipleObjects</span>(<br><span class="hljs-variable constant_">DWORD</span> nCount,<span class="hljs-comment">//句柄数组中的句柄数</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">HANDLE</span> *lpHandles,<span class="hljs-comment">//指向对象句柄数组的指针</span><br><span class="hljs-variable constant_">BOOL</span> fWaitAll<span class="hljs-comment">//等待类型 1/true表示等待所有的任务完成后进行下一个操作，0/flase 只等待任何一个的完成</span><br><span class="hljs-variable constant_">DWORD</span> dwMilliseconds <span class="hljs-comment">//等待时间，以毫秒为单位</span><br>);<br></code></pre></td></tr></table></figure><p><strong>可等待的对象列表</strong></p><ul><li>Change notification：变化通知</li><li>Console input：控制台输入</li><li>Events：事件</li><li>Job：作业</li><li>Mutex：互斥信号量</li><li>Process：进程</li><li><strong>Semaphore：计数信号量</strong> （<em>本次主要用到）</em></li><li><strong>Thread：线程</strong> <em>（本次主要用到）</em></li><li>Wait-able timer：定时器</li></ul><h4 id="如何去等待一个对象"><a href="#如何去等待一个对象" class="headerlink" title="如何去等待一个对象"></a>如何去等待一个对象</h4><ol><li><p>我们需要立一个Flag，用于在主子线程之间相互告知运行状态。</p></li><li><p>Flag &#x3D; 信号量</p></li><li><p>创建一个信号量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hHandle1 = <span class="hljs-title class_">CreateSemaphore</span>(<span class="hljs-variable constant_">NULL</span>, <span class="hljs-number">0</span>，<span class="hljs-number">1</span>, <span class="hljs-string">&quot;SemaphoreName1&quot;</span>);<span class="hljs-comment">//创建一个信号量（安全标识符，信号量初始态，信号量最大值，信号量名称）</span><br></code></pre></td></tr></table></figure></li><li><p>打开一个信号量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hHandle1 = <span class="hljs-title class_">OpenSemaphore</span>( <span class="hljs-variable constant_">SYNCHRONIZE</span> <span class="hljs-variable constant_">ISEMAPHORE_</span> <span class="hljs-variable constant_">MODIFY_</span> <span class="hljs-variable constant_">STATE</span>, <span class="hljs-variable constant_">NULL</span>,<span class="hljs-string">&quot;SemaphoreName1&quot;</span> );<span class="hljs-comment">//（访问标志，继承标志，信号量名）</span><br></code></pre></td></tr></table></figure></li><li><p>释放信号量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">rc = <span class="hljs-title class_">ReleaseSemaphore</span> (hHandle1, <span class="hljs-number">1</span>, <span class="hljs-variable constant_">NULL</span>)（我们需要释放哪一个信号量，对信号量进行增几的操作，信号量要增加数值地址）;<br></code></pre></td></tr></table></figure></li><li><p>等待单个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dRes = <span class="hljs-title class_">WaitForSingleObject</span>(hHandle1 , <span class="hljs-variable constant_">INFINITE</span>); <span class="hljs-comment">// 主线程无限期地等待子线程结束（信号量的句柄，如果没有释放无限运行）  如果对操作时长有限制，可在第二个参数设置等待的最大值</span><br></code></pre></td></tr></table></figure></li><li><p>等待多个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dRes = <span class="hljs-title class_">WaitForMultiple0</span>bjects(<span class="hljs-number">3</span>, hHandles, <span class="hljs-number">1</span>, <span class="hljs-variable constant_">INFINITE</span>); <span class="hljs-comment">//第三个参数为1或true时，等待数组中所有对象完成，为0或者false时满足一个任务结束就可继续执行</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h3><p><strong>实验一 线程的同步之等待单个对象</strong><br>子线程 主线程 用于制作麻辣香锅，制作用时5秒 等待子线程执行完毕，打印“麻辣香锅上菜完毕，请开动吧！”</p><p><strong>实验二 线程的同步之等待多个对象</strong></p><p>子线程1 子线程2 子线程3 主线程 用于制作麻辣香锅，制作用时5秒 用于制作什锦菇，制作用时3秒 用于制作米饭，制作用时6秒 等待多个子线程执行完毕，打印”所有菜品上菜完毕，请开动吧！“</p><h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><p>能正确使用等待对象、WaitForSingleObject（）或WaitForMultipleObject（)及信号量对象CreateSemaphore（）、OpenSemaphore（）、ReleaseSemaphore（）等系统调用，进一步理解线程的同步。</p><h4 id="实验指导"><a href="#实验指导" class="headerlink" title="实验指导"></a>实验指导</h4><p>1.在Microsoft visual C++6.0环境下建立一个MFC支持的控制台文件，编写C程序。<br>2.在程序中使用CreateSemaphore（NULL，0，1，”SemaphoreName1”）创建一个名为“SemaphoreName1”的信号量，信号量的初始值为0。<br>之后使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">OpenSemaphore</span>（<span class="hljs-variable constant_">SYNCHRONIZE</span>|<span class="hljs-variable constant_">SEMAPHORE_MODIFY_STARTE</span>,<span class="hljs-variable constant_">NULL</span>, ”<span class="hljs-title class_">SemaphoreName1</span>）<br></code></pre></td></tr></table></figure><p>打开该信号量，这里访问标志使用“SYNCHRONIZE|SEMAPHORE_MODIFY_STARTE”，<br>以便之后可以使用WaitForSingleObject（）等待该信号量及使用ReleaseSemaphore（）释放该信号量，然后创建一个子线程。</p><p>3.主线程创建子线程后调用WaitForSingleObject（hHandle1，INFINITE），这里等待时间设置为INFINITE表示一直等待下去，直到该信号量被唤醒为止。</p><p>4.子线程结束，调用ReleaseSemaphore（hHandle1，1，NULL）释放信号量，使信号量的值加1。</p><h4 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h4><p><strong>实验一主要内容及代码</strong></p><ul><li>创建一个信号量并打开，创建一个线程，主线程等待子线程结束，释放信号量。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">static</span> <span class="hljs-variable constant_">HANDLE</span> hHandle1 = <span class="hljs-variable constant_">NULL</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">chef</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;麻辣香锅开始制作，预计等待时间5秒。\n&quot;</span>);<br><span class="hljs-title class_">Sleep</span>(<span class="hljs-number">5000</span>);<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;麻辣香锅制作完成！\n&quot;</span>);<br><br><span class="hljs-variable constant_">BOOL</span> rc;<br><span class="hljs-variable constant_">DWORD</span> err;<br><br>rc = <span class="hljs-title class_">ReleaseSemaphore</span>(hHandle1,<span class="hljs-number">1</span>,<span class="hljs-variable constant_">NULL</span>);<br>err = <span class="hljs-title class_">GetLastError</span>();<br><br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;ReleaseSemaphore err=%d\n&quot;</span>,err);<br><span class="hljs-keyword">if</span>(rc == <span class="hljs-number">0</span>)&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphore Release Fail!\n&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphore Release Success! rc=%d\n&quot;</span>,rc);<br>&#125;<br>&#125;<br><br><br>int <span class="hljs-title function_">_tmain</span>(<span class="hljs-params">int argc, TCHAR* argv[], TCHAR* envp[]</span>)<br>&#123;<br>    <br><br>int nRetCode = <span class="hljs-number">0</span>;<br><br><span class="hljs-variable constant_">DWORD</span> dRes,err;<br><br>hHandle1 = <span class="hljs-title class_">CreateSemaphore</span>(<span class="hljs-variable constant_">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;SemaphoreName1&quot;</span>);<span class="hljs-comment">//创建一个信号量</span><br><span class="hljs-keyword">if</span>(hHandle1 == <span class="hljs-variable constant_">NULL</span>)&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphore Create Fail!\n&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphore Create Success!\n&quot;</span>);<br>&#125;<br><br>hHandle1 = <span class="hljs-title class_">OpenSemaphore</span>(<span class="hljs-variable constant_">SYNCHRONIZE</span>|<span class="hljs-variable constant_">SEMAPHORE_MODIFY_STATE</span>,<br><span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-string">&quot;SemaphoreName1&quot;</span>);<br><span class="hljs-keyword">if</span>(hHandle1 == <span class="hljs-variable constant_">NULL</span>)&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphor Open Fail!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphor Open Success!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-variable constant_">HANDLE</span> handle1 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID1</span> = <span class="hljs-variable constant_">NULL</span>;<br><br>handle1 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) chef,<br>(<span class="hljs-variable constant_">LPVOID</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID1</span>);<br><br>dRes = <span class="hljs-title class_">WaitForSingleObject</span>(hHandle1,<span class="hljs-variable constant_">INFINITE</span>);<br><br>err = <span class="hljs-title class_">GetLastError</span>();<br><br><span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>)&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;麻辣香锅上菜完毕，请开动吧。\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;WaitForSingleObject err = %d\n&quot;</span>,err);<br>&#125;<br><br><span class="hljs-keyword">return</span> nRetCode;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>效果图</strong><br><img src="/../images/56e1d34c-0c4a-4f71-907f-71ca2ee11143.png" alt="在这里插入图片描述"></p><p><strong>实验二主要内容及代码</strong></p><ul><li>创建三个线程，当三个线程都执行完毕时，执行主线程<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">chef</span>(<span class="hljs-params">int meal_code</span>)<br>&#123;<br>    <br><br><span class="hljs-keyword">if</span>(meal_code == <span class="hljs-number">0</span>)&#123;<br>    <br><span class="hljs-title class_">Sleep</span>(<span class="hljs-number">5000</span>);<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;麻辣香锅制作完成！\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(meal_code == <span class="hljs-number">1</span>)&#123;<br>    <br><span class="hljs-title class_">Sleep</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;什锦菇制作完成！\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(meal_code == <span class="hljs-number">2</span>)&#123;<br>    <br><span class="hljs-title class_">Sleep</span>(<span class="hljs-number">6000</span>);<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;米饭制作完成！\n&quot;</span>);<br>&#125;<br><br>&#125;<br><br><br>int <span class="hljs-title function_">_tmain</span>(<span class="hljs-params">int argc, TCHAR* argv[], TCHAR* envp[]</span>)<br>&#123;<br>    <br><br>int nRetCode = <span class="hljs-number">0</span>;<br><br><span class="hljs-variable constant_">DWORD</span> dRes,err;<br><br><span class="hljs-variable constant_">HANDLE</span> handle1 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">HANDLE</span> handle2 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">HANDLE</span> handle3 = <span class="hljs-variable constant_">NULL</span>;<br><br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID1</span> = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID2</span> = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID3</span> = <span class="hljs-variable constant_">NULL</span>;<br><br>int a = <span class="hljs-number">0</span>;<br>int b = <span class="hljs-number">1</span>;<br>int c = <span class="hljs-number">2</span>;<br><br>handle1 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) chef,<br>(<span class="hljs-variable constant_">LPVOID</span>) a,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID1</span>);<br><br>handle2 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) chef,<br>(<span class="hljs-variable constant_">LPVOID</span>) b,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID2</span>);<br><br>handle3 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) chef,<br>(<span class="hljs-variable constant_">LPVOID</span>) c,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID3</span>);<br><br><span class="hljs-variable constant_">HANDLE</span> hHandles[<span class="hljs-number">3</span>];<br>hHandles[<span class="hljs-number">0</span>] = handle1;<br>hHandles[<span class="hljs-number">1</span>] = handle2;<br>hHandles[<span class="hljs-number">2</span>] = handle3;<br><br>dRes = <span class="hljs-title class_">WaitForMultipleObjects</span>(<span class="hljs-number">3</span>,hHandles,<span class="hljs-number">0</span>,<span class="hljs-variable constant_">INFINITE</span>);<br><br>err = <span class="hljs-title class_">GetLastError</span>();<br><br><span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>)&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;所有菜品上菜完毕，请开动吧。\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;WaitForSingleObject err = %d\n&quot;</span>,err);<br>&#125;<br><br><span class="hljs-keyword">return</span> nRetCode;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>效果图</strong><br><img src="/../images/b98bdea7-4a78-4795-a55d-49ff2e963d84.png" alt="在这里插入图片描述"><br>但是当我们的选择等待的对象为任意一个，即第三个参数为0时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dRes = <span class="hljs-title class_">WaitForMultipleObjects</span>(<span class="hljs-number">3</span>,hHandles,<span class="hljs-number">0</span>,<span class="hljs-variable constant_">INFINITE</span>);<br></code></pre></td></tr></table></figure><p><strong>效果图为：</strong><br><img src="/../images/d1b0d65d-7900-46f6-94db-c01fa5a0b819.png" alt="在这里插入图片描述"></p><h3 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h3><p>实验完成了主、子线程的同步，主线程创建子线程后，主线程塞，让子线程先执行，等子线程执行完后，由子线程唤醒主线程。是使我们了解如何使用使用等待对象WaitForSingleObject（）或WaitForMultipleObjects（)及信号量对象CreateSemaphore（）、OpenSemaphore（）、ReleaseSemaphore（）等系统调用，进一步理解线程的同步。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的创建与撤销 c++</title>
    <link href="/2020/04/18/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%92%A4%E9%94%80%20c++/"/>
    <url>/2020/04/18/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%92%A4%E9%94%80%20c++/</url>
    
    <content type="html"><![CDATA[<h2 id="线程的创建与撤销"><a href="#线程的创建与撤销" class="headerlink" title="线程的创建与撤销"></a>线程的创建与撤销</h2><h3 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h3><p>(1)熟悉windows系统提供的线程创建与撤销系统调用.<br>(2)掌握windows系统环境下线程的创建与撤销方法.</p><h3 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h3><h5 id="1-线程的创建"><a href="#1-线程的创建" class="headerlink" title="1. 线程的创建"></a>1. 线程的创建</h5><p>CeateThread()完成线程的创建.它在调用进程的地址空间上创建一个线程,执行指定的函数,并返回新建立的线程的句柄.<br>原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">HANDLE</span> <span class="hljs-title class_">CeateThread</span>(<br><span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span> lpThreadAttributes,<br><span class="hljs-variable constant_">DWORD</span> dwStackSize,<br><span class="hljs-variable constant_">LPSECURITY_START_ROUTINE</span> lpStartAddress,<br><span class="hljs-variable constant_">LPVOID</span> lpparameter,<br><span class="hljs-variable constant_">DWORD</span> dwCreationFlags,<br><span class="hljs-variable constant_">LPDWORD</span> lpThreadId<br>);<br></code></pre></td></tr></table></figure><p>参数说明:</p><ol><li>lpThreadAttributes:为线程指定安全属性.为NULL时,线程得到一个默认的安全描述符.</li><li>dwStackSize:线程堆栈的大小.其值为0时,其大小与调用该线程的线程堆栈大小相同.</li><li>lpStartAddress:指定线程要执行的函数.</li><li>lpparameter:函数中要传递的参数.</li><li>dwCreationFlags:指定线程创建后所处的状态.若为CRRATE_SUSPENDED,表示创建后出于挂起状态,用ResumeThread()激活线程才可以执行.若该值为0，表示线程创建后立即执行.</li><li>lpThreadId:用一个32位的变量接受系统返回的线程标识符.若该值设为NULL,系统不返回线程标识符.<br>返回值:<br>如果线程创建成功,将返回线程的句柄;如果失败,系统返回NULL,可以调用函数GetLastError查询失败的原因.<br>用法举例:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">static</span> <span class="hljs-variable constant_">HANDLE</span> hHandle1=<span class="hljs-variable constant_">NULL</span>; <span class="hljs-comment">//用于存储线程返回句柄的变量</span><br><span class="hljs-variable constant_">DWORD</span> dwThreadID1;           <span class="hljs-comment">//用于存储线程标识符的变量</span><br><span class="hljs-comment">//创建一个名为ThreadName1的线程</span><br>hHandle1=<span class="hljs-title class_">CeateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>)) <span class="hljs-variable constant_">NULL</span><br>                     <span class="hljs-number">0</span>,<br> (<span class="hljs-variable constant_">LPSECURITY_START_ROUTINE</span>)<span class="hljs-title class_">ThreadName1</span>,<br> (<span class="hljs-variable constant_">LPDWORD</span>)<span class="hljs-variable constant_">NULL</span>,<br> <span class="hljs-number">0</span>,&amp;dwThreadID1);<br></code></pre></td></tr></table></figure></li></ol><h5 id="2-撤销线程"><a href="#2-撤销线程" class="headerlink" title="2. 撤销线程"></a>2. 撤销线程</h5><p>ExitThread()用于撤销当前进程.<br>原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">VOID</span> <span class="hljs-title class_">ExitThread</span>(<br><span class="hljs-variable constant_">DWORD</span> dwExitCode);   <span class="hljs-comment">//线程返回码</span><br></code></pre></td></tr></table></figure><p>参数说明:<br>dwExitCode:指定线程返回码,可以调用GetExitCodeThread()查询返回码的含义.<br>返回值:<br>该函数没有返回值.<br>用法举例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ExitThread</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h5 id="3-终止线程"><a href="#3-终止线程" class="headerlink" title="3.终止线程"></a>3.终止线程</h5><p>TerminateThread()用于终止当前线程.该函数与ExitThread()的区别在于,ExitThread()在撤销线程时将该线程所拥有的资源全部归还给系统,而TerminateThread()不归还资源.<br>原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">BOOL</span> <span class="hljs-title class_">TerminateThread</span>(<br><span class="hljs-variable constant_">HANDLE</span> hHandle,       <span class="hljs-comment">//线程句柄</span><br><span class="hljs-variable constant_">DWORD</span> dwExitCode);    <span class="hljs-comment">//线程返回码</span><br></code></pre></td></tr></table></figure><p>参数说明:<br>(1)hThread:要终止线程的线程句柄.<br>(2)dwExitCode:指定线程返回码,可以调用GetExitCodeThread()查询返回码的含义.<br>返回值:<br>函数调用成功,将返回一个非0值;若失败,返回0，可以调用函数GetLastError()查询失败的原因.</p><h5 id="4-挂起线程"><a href="#4-挂起线程" class="headerlink" title="4.挂起线程"></a>4.挂起线程</h5><p>Sleep()用于挂起当前正在执行的线程.<br>原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">VOID</span> <span class="hljs-title class_">Sleep</span>(<span class="hljs-variable constant_">DWORD</span> dwMilliseconds);<br></code></pre></td></tr></table></figure><p>参数说明:<br>dwMilliseconds;指定挂起时间,单位为ms(毫秒).<br>返回值:<br>该函数没有返回值.</p><h5 id="5-关闭句柄"><a href="#5-关闭句柄" class="headerlink" title="5.关闭句柄"></a>5.关闭句柄</h5><p>函数CloseHandle()用于关闭已打开的对象的句柄,其作用与释放动态申请的内存空间类似,这样可以释放系统资源,使线程安全运行.<br>原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">BOOL</span> <span class="hljs-title class_">CloseHandle</span>(<span class="hljs-variable constant_">HANDLE</span> hObject);<br></code></pre></td></tr></table></figure><p>参数说明:<br>hObject:已打开对象的句柄.<br>返回值:<br>如果函数调用成功,则返回值为非0值;如果函数调用失败,则返回值为0.若要得到更多的错误信息,调用函数GetLastError()查询.</p><h3 id="三、内容"><a href="#三、内容" class="headerlink" title="三、内容"></a>三、内容</h3><p>使用系统调用CreatThread()创建一个子线程,并在子线程中显示;Thread is Running!.为了能让用户清楚地看到线程的运行情况,使用Sleep()使线程挂起5s,之后使用ExitThread(0)撤销进程.</p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>能正确使用CreatThread(),ExitThread()及Sleep()等系统调用,进一步理解进程与线程理论.</p><h4 id="指导"><a href="#指导" class="headerlink" title="指导"></a>指导</h4><p>本实验在WindowsXP,Microsoft Visual C++ 6.0环境下实现,利用Windows SDK提供的API完成程序的功能.实验在Windows XP环境下安装由于WindowsXP,Microsoft Visual C++ 6.0是一个集成开发环境,其中包含了Windows SDK 所有工具和定义,所以安装了WindowsXP,Microsoft Visual C++ 6.0后不用特意安装SDK.试验中所有的API是操作系统提供的用来进行应用程序开发的系统功能接口.</p><ol><li>首先启动安装好的,Microsoft Visual C++ 6.0.</li><li>在,Microsoft Visual C++ 6.0环境下选择File-&gt;new命令,然后在Project选项卡中选择Win32 Console Application建立一个控制台工程文件.</li><li>由于CreatThread()等函数是Microsoft Windows操作系统的系统调用,因此,在下图中选择An application that supports MFC,之后单击Finish按钮.</li></ol><p><img src="/../images/3a56ea2c-e9ac-4e39-8510-a4bf2277cdac.png" alt="在这里插入图片描述"></p><ol><li>创建一个单线程操作并观看结果<br><img src="/../images/8b825336-db16-432a-af97-2a961f3c9dfc.png" alt="在这里插入图片描述"><br><img src="/../images/a38b8e46-8195-4b9c-97a0-5476671a1daa.png" alt="在这里插入图片描述"></li><li>创建一个多线程操作，并观看结果<br><img src="/../images/3febb261-ea76-43e1-8974-57491f16d10f.png" alt="在这里插入图片描述"><br><img src="/../images/a2173715-7f80-4543-97a3-75fa46bb6377.png" alt="在这里插入图片描述"></li></ol><h4 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// test1.cpp : Defines the entry point for the console application.</span><br><span class="hljs-comment">//</span><br><br>#include <span class="hljs-string">&quot;stdafx.h&quot;</span><br>#include <span class="hljs-string">&quot;test1.h&quot;</span><br><br>#ifdef _DEBUG<br>#define <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">DEBUG_NEW</span><br>#undef <span class="hljs-variable constant_">THIS_FILE</span><br><span class="hljs-keyword">static</span> char <span class="hljs-variable constant_">THIS_FILE</span>[] = __FILE__;<br>#endif<br><br>/<br><span class="hljs-comment">// The one and only application object</span><br><br><span class="hljs-title class_">CWinApp</span> theApp;<br><br>using namespace std;<br><br><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">eatApple</span>(<span class="hljs-params">int apple_number</span>)<br>&#123;<br>    <br><span class="hljs-title class_">Sleep</span>((<span class="hljs-number">3</span>-apple_number)*<span class="hljs-number">1000</span>);<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;i&#x27;m eating apple #%d.\n&quot;</span>, apple_number);<br>&#125;<br><br><br>int <span class="hljs-title function_">_tmain</span>(<span class="hljs-params">int argc, TCHAR* argv[], TCHAR* envp[]</span>)<br>&#123;<br>    <br><span class="hljs-variable constant_">HANDLE</span> handle1 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">HANDLE</span> handle2 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">HANDLE</span> handle3 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID1</span> = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID2</span> = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID3</span> = <span class="hljs-variable constant_">NULL</span>;<br><br>int nRetCode;<br><br>int a = <span class="hljs-number">0</span>;<br>int b = <span class="hljs-number">1</span>;<br>int c = <span class="hljs-number">2</span>;<br><br>handle1 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) eatApple,<br>(<span class="hljs-variable constant_">LPVOID</span>) a,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID1</span>);<br><br>handle2 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) eatApple,<br>(<span class="hljs-variable constant_">LPVOID</span>) b,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID2</span>);<br><br>handle3 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) eatApple,<br>(<span class="hljs-variable constant_">LPVOID</span>) c,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID3</span>);<br><span class="hljs-title class_">Sleep</span>(<span class="hljs-number">10000</span>);<br><span class="hljs-keyword">return</span> nRetCode;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>在Windows系统中进程是资源的拥有者,线程是系统调用的单位.进程创建后,其主线程也随即被创建.但是单线程只能执行完一个之后再执行另外一个线程，而多线程在一定程度上是多个线程一起执行的。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三角形最大周长算法</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF%E7%AE%97%E6%B3%95/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161542552.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161542553.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161542554.png" alt="在这里插入图片描述"></p><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">largestPerimeter</span>(<span class="hljs-params">int[] A</span>) &#123;<br>    <br>        int len = A.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">3</span>)&#123;<br>    <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">sort</span>(A);<br>        <span class="hljs-keyword">while</span>(len-<span class="hljs-number">3</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>    <br>            <span class="hljs-keyword">if</span>(A[len-<span class="hljs-number">1</span>]-A[len-<span class="hljs-number">2</span>] &lt; A[len-<span class="hljs-number">3</span>])&#123;<br>    <br>                <span class="hljs-keyword">return</span> A[len-<span class="hljs-number">1</span>]+A[len-<span class="hljs-number">2</span>]+A[len-<span class="hljs-number">3</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>    <br>                len = len-<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法之八皇后问题（Java实现）</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B9%8B%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B9%8B%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="要求用回溯法求解-8-皇后问题"><a href="#要求用回溯法求解-8-皇后问题" class="headerlink" title="要求用回溯法求解 8-皇后问题"></a>要求用回溯法求解 8-皇后问题</h4><p>八皇后问题：使放置在 8&#x2F;*8 棋盘上的 8 个皇后彼此不受攻击。</p><p>即：任何两个皇后都不在同一行、同一列或同一斜线上。</p><p>请输出 8 皇后问题的所有可行解的总数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">EightQueen</span> &#123;<br><br>    public <span class="hljs-keyword">static</span> int[][] array = <span class="hljs-keyword">new</span> int[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br>    public <span class="hljs-keyword">static</span> int sum;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br><br>        <span class="hljs-title function_">search</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(sum);<br><br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">int i</span>)&#123;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">7</span>)&#123;<br>            sum++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-title function_">check</span>(i, j))&#123;<br>                array[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-title function_">search</span>(i+<span class="hljs-number">1</span>);<br>                array[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> boolean <span class="hljs-title function_">check</span>(<span class="hljs-params">int i, int j</span>)&#123;<br>        <span class="hljs-keyword">for</span>(int k = <span class="hljs-number">0</span>; k &lt; i; k++)&#123;<br>            <span class="hljs-keyword">if</span>(array[k][j] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(int m = i-<span class="hljs-number">1</span>, n = j-<span class="hljs-number">1</span>; m&gt;=<span class="hljs-number">0</span>&amp;&amp; n&gt;=<span class="hljs-number">0</span>; m--, n--)&#123;<br>            <span class="hljs-keyword">if</span>(array[m][n] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(int m = i-<span class="hljs-number">1</span>, n = j+<span class="hljs-number">1</span>; m&gt;=<span class="hljs-number">0</span>&amp;&amp; n&lt;=<span class="hljs-number">7</span>; m--, n++)&#123;<br>            <span class="hljs-keyword">if</span>(array[m][n] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】变进制数</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%8F%98%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%8F%98%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161542724.png" alt="在这里插入图片描述"></p><p>答案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br>int[] jinzhi = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>&#125;;<br><span class="hljs-title class_">String</span> string = scanner.<span class="hljs-title function_">next</span>();<br>int len = string.<span class="hljs-title function_">length</span>();<br>int res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;<br>    <br>char ch = string.<span class="hljs-title function_">charAt</span>(i);<br>int x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(ch &lt;= <span class="hljs-number">57</span>) &#123;<br>    <br>x = ch-<span class="hljs-number">48</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <br>x = ch-<span class="hljs-number">97</span>;<br>&#125;<br>res = (res+x) * jinzhi[len-i-<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(res);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】完美的代价</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="试题-基础练习-完美的代价"><a href="#试题-基础练习-完美的代价" class="headerlink" title="试题 基础练习 完美的代价"></a>试题 基础练习 完美的代价</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><strong>问题描述</strong><br>回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。<br>交换的定义是：交换两个相邻的字符<br>例如mamad<br>第一次交换 ad : mamda<br>第二次交换 md : madma<br>第三次交换 ma : madam (回文！完美！)</p><p><strong>输入格式</strong><br>第一行是一个整数N，表示接下来的字符串的长度(N &lt;&#x3D; 8000)<br>第二行是一个字符串，长度为N.只包含小写字母<br><strong>输出格式</strong><br>如果可能，输出最少的交换次数。<br>否则输出Impossible<br><strong>样例输入</strong><br>5<br>mamad</p><p><strong>样例输出</strong><br>3</p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>字符串的长度有奇数和偶数两种可能。</p><p>Impossible有两种可能：<br>1，字符串长度为奇数，且至少含有两个只出现一次的字符<br>2，字符串长度为偶数，且含有一个或多个只出现一次的字符</p><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><p>-》从字符数组的第一个位置开始，从后向前遍历寻找与其相同的字符。<br>-》》》如果出现该字符，且并不是本身位置，那么将字符移到回文相对应的位置。<br>-》》》如果找到该字符，且为本身位置，那么这个字符只出现了一次<br>-》》》》》如若数组长度为偶数或曾经出现过单个字符，则打印impossible<br>-》》》》》如若数组长度为奇数，记录曾出现过单个字符，并且该字符移向字符数组中间</p><h5 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br><br>int n;<br>n = scanner.<span class="hljs-title function_">nextInt</span>();<br><span class="hljs-title class_">String</span> str;<br>str = scanner.<span class="hljs-title function_">next</span>();<br>scanner.<span class="hljs-title function_">close</span>();<br>char[] chs = str.<span class="hljs-title function_">toCharArray</span>();<br>int j = n-<span class="hljs-number">1</span>,count=<span class="hljs-number">0</span>,flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>    <br><span class="hljs-keyword">for</span>(int k=j; k &gt;= i; k--) &#123;<br>    <br><span class="hljs-keyword">if</span>(i==k) &#123;<br>    <br><span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> || flag==<span class="hljs-number">1</span>) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Impossible&quot;</span>);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>flag = <span class="hljs-number">1</span>;<br>count += n / <span class="hljs-number">2</span> - i;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(chs[i] == chs[k])&#123;<br>    <br><span class="hljs-keyword">for</span>(int l = k; l &lt; j; l++)&#123;<br>    <br><span class="hljs-title function_">swap</span>(chs,l,l+<span class="hljs-number">1</span>);<br>count++;<span class="hljs-comment">//统计交换次数</span><br>            &#125;<br>            j--;<br>            <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(count);<br>&#125;<br><br>private <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">char chs[],int i,int j</span>) &#123;<br>    <br>char temp = chs[i];<br>chs[i] = chs[j];<br>chs[j] = temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】 回溯算法之装载问题</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B9%8B%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B9%8B%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>用回溯法编写一个递归程序解决如下装载问题：<br>有 n 个集装箱要装上 2 艘载重分别为 c1 和 c2的轮船，其中集装箱 i 的<br>重量为 wi（1≤ i ≤ n），且∑ 𝑤𝑖 ≤ 𝑐1 + 𝑐2 。<br>问是否有一个合理的装载方案可以将这 n 个集装箱装上这 2 艘轮船？如果有，请给出装载方案。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>当 n&#x3D;3，c1&#x3D;c2&#x3D;50，且 w&#x3D;[10,40,40]时，可以将集装箱 1 和 2 装到第一艘轮船上，集装箱3装到第二艘轮船上；<br>如果 w&#x3D;[20,40,40]时，无法将这 3 个集装箱都装上轮船。</p><p>Java代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">ArrayList</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">List</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Load</span> &#123;<br><br>    public <span class="hljs-keyword">static</span> int weight1;  <span class="hljs-comment">//记录第一艘船的载重能力</span><br>    public <span class="hljs-keyword">static</span> int weight2;  <span class="hljs-comment">//记录第二艘船的载重能力</span><br><br>    public <span class="hljs-keyword">static</span> int sum1 = <span class="hljs-number">0</span>,sum2 = <span class="hljs-number">0</span>;        <span class="hljs-comment">//分别代表此时第一艘船的载重和所有集装箱的总重量</span><br>    public <span class="hljs-keyword">static</span> int[] arr;                    <span class="hljs-comment">//记录集装箱的重量</span><br>    public <span class="hljs-keyword">static</span> int n;                        <span class="hljs-comment">//集装箱的个数</span><br>    public <span class="hljs-keyword">static</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">Integer</span>&gt;(); <span class="hljs-comment">//第一艘船的集装箱的装载的重量</span><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br>        n = scanner.<span class="hljs-title function_">nextInt</span>();<br>        arr = <span class="hljs-keyword">new</span> int[n];<br>        weight1 = scanner.<span class="hljs-title function_">nextInt</span>();<br>        weight2 = scanner.<span class="hljs-title function_">nextInt</span>();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            arr[i] = scanner.<span class="hljs-title function_">nextInt</span>();<br>            sum2 += arr[i];<br>        &#125;<br>        scanner.<span class="hljs-title function_">close</span>();<br>        <span class="hljs-title function_">backtrack</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">int i</span>) &#123;<br>        <span class="hljs-keyword">if</span>(sum1 &gt; weight1) &#123;   <span class="hljs-comment">// 如若超载，则回溯</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == n) &#123;<br>            <span class="hljs-keyword">if</span>(sum2 - sum1 &lt; weight2) &#123;      <br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(list);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        sum1 += arr[i];<br>        list.<span class="hljs-title function_">add</span>(arr[i]);<br>        <span class="hljs-title function_">backtrack</span>(i+<span class="hljs-number">1</span>);<br>        sum1 -= arr[i];<br>        list.<span class="hljs-title function_">remove</span>(list.<span class="hljs-title function_">size</span>()-<span class="hljs-number">1</span>);<br>        <span class="hljs-title function_">backtrack</span>(i+<span class="hljs-number">1</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】报数问题</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E6%8A%A5%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E6%8A%A5%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>哈哈哈，决定9月份考一下CCF认证，不知道能考50分还是100分，开始练习啦。</p><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543913.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543914.png" alt="在这里插入图片描述"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>题目中说了不计入被跳过的数，也就是虽然你要报n个数，但是你最后报的数一定是大于等于n的。比如题目说明n小于等于666，但加上跳过的数字，其实报的数已经超过了700。所以我们需要考虑到百位甚至千位为7的情况。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br>int n;<br>n = scanner.<span class="hljs-title function_">nextInt</span>();<br>scanner.<span class="hljs-title function_">close</span>();<br><br>int[] arr = <span class="hljs-keyword">new</span> int[<span class="hljs-number">5</span>];<span class="hljs-comment">//用来记录四个人跳过的次数</span><br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">//初始化为0</span><br>arr[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>,flag=<span class="hljs-number">0</span>; flag &lt;n; i++) &#123;<br>    <span class="hljs-comment">//flag记录有效报数，即没有跳过的个数</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title class_">ContainSeven</span>(i)) &#123;<br>    <span class="hljs-comment">//如果跳过</span><br>arr[i%<span class="hljs-number">4</span>]++;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//如果不跳过，那么有效报数次数加一</span><br>flag++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-comment">//打印甲乙丙丁</span><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(arr[i]);<br>&#125;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br>public <span class="hljs-keyword">static</span> <span class="hljs-title class_">Boolean</span> <span class="hljs-title class_">ContainSeven</span>(int num)&#123;<br>    <span class="hljs-comment">//判断是否需要跳过函数，参数为当前数字</span><br>    <span class="hljs-keyword">if</span>(num%<span class="hljs-number">7</span>==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>    <br>    int t=num;<br>    <span class="hljs-keyword">while</span>(t&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>    <br>    <span class="hljs-keyword">if</span>(t%<span class="hljs-number">10</span>==<span class="hljs-number">7</span>)<span class="hljs-comment">//含有数字7</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】矩形面积重叠</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E9%87%8D%E5%8F%A0/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E9%87%8D%E5%8F%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="试题-基础练习-矩形面积交"><a href="#试题-基础练习-矩形面积交" class="headerlink" title="试题 基础练习 矩形面积交"></a>试题 基础练习 矩形面积交</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><strong>资源限制</strong><br>时间限制：1.0s 内存限制：512.0MB</p><p><strong>问题描述</strong><br>平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。<br><strong>输入格式</strong><br>输入仅包含两行，每行描述一个矩形。<br>在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。<br><strong>输出格式</strong><br>输出仅包含一个实数，为交的面积，保留到小数后两位。<br><strong>样例输入</strong><br>1 1 3 3<br>2 2 4 4</p><p><strong>样例输出</strong><br>1.00</p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p><img src="/../images/fbdb7a27-da62-45ca-b71d-dfb50755060e.png" alt="在这里插入图片描述"><br><img src="/../images/f1a01d92-4921-431b-942e-8f0f48b74711.png" alt="在这里插入图片描述"></p><p>经过简单的画图我们可以得知，我们需要的其实至少两个五角星位置的坐标。</p><p>那么这两个五角星的位置是什么呢？</p><p>其实就是两个矩形各自靠左的x坐标里面的右边的那一个，<br>俩矩形各自靠右的x坐标的左边那一个。<br>俩矩形各自靠上的y坐标的下面那一个，<br>俩矩形各自靠下的y坐标的上面那一个。</p><h5 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br>double x1 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double y1 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double x2 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double y2 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double x3 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double y3 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double x4 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double y4 = scanner.<span class="hljs-title function_">nextDouble</span>();<br><br>double a1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(x1, x2), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(x3, x4));<br>double b1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(y1, y2), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(y3, y4));<br>double a2 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(x1, x2), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(x3, x4));<br>double b2 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(y1, y2), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(y3, y4));<br><br><span class="hljs-keyword">if</span>((a1 &lt; a2) &amp;&amp; (b1 &lt; b2)) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%.2f&quot;</span>,(b2-b1)*(a2-a1));<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;0.00&quot;</span>);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】矩阵的幂运算</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E7%9F%A9%E9%98%B5%E7%9A%84%E5%B9%82%E8%BF%90%E7%AE%97/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E7%9F%A9%E9%98%B5%E7%9A%84%E5%B9%82%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="试题-基础练习-矩阵乘法"><a href="#试题-基础练习-矩阵乘法" class="headerlink" title="试题 基础练习 矩阵乘法"></a>试题 基础练习 矩阵乘法</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><strong>资源限制</strong><br>时间限制：1.0s 内存限制：512.0MB<br><strong>问题描述</strong><br>给定一个N阶矩阵A，输出A的M次幂（M是非负整数）<br>例如：<br>A &#x3D;<br>1 2<br>3 4<br>A的2次幂<br>7 10<br>15 22<br><strong>输入格式</strong><br>第一行是一个正整数N、M（1&lt;&#x3D;N&lt;&#x3D;30, 0&lt;&#x3D;M&lt;&#x3D;5），表示矩阵A的阶数和要求的幂数<br>接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值<br><strong>输出格式</strong><br>输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开<br><strong>样例输入</strong><br>2 2<br>1 2<br>3 4<br><strong>样例输出</strong><br>7 10<br>15 22</p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>这里我们需要注意，矩阵的幂可能为0，也就是说，我们需要考虑到输出01对角矩阵的情况。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>-》建立三个矩阵的二维数组，<br>-》如果幂为0，打印01对角矩阵<br>-》否则<br>-》》》循环<br>-》》》》》第一，二个矩阵相乘得第三个矩阵，而后将第三个矩阵赋值给第二个矩阵<br>-》》》打印输出第二个矩阵</p><h3 id="Java实现代码"><a href="#Java实现代码" class="headerlink" title="Java实现代码"></a>Java实现代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br>int n = scanner.<span class="hljs-title function_">nextInt</span>();<br>int m = scanner.<span class="hljs-title function_">nextInt</span>();<br>int[][] arr1 = <span class="hljs-keyword">new</span> int[n][n];<br>int[][] arr2 = <span class="hljs-keyword">new</span> int[n][n];<br>int[][] arr3 = <span class="hljs-keyword">new</span> int[n][n];<br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <br>arr1[i][j] = scanner.<span class="hljs-title function_">nextInt</span>();<br>arr2[i][j] = arr1[i][j];<br>&#125;<br>&#125;<br>scanner.<span class="hljs-title function_">close</span>();<br><br><span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) &#123;<br>    <br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <br><span class="hljs-keyword">if</span>( i == j ) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;1 &quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;0 &quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>();<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (int h = <span class="hljs-number">1</span>; h &lt; m; h++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <br>arr3[i][j] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (int k = <span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>; k &lt; n &amp;&amp; t&lt;n; k++,t++) &#123;<br>    <br>arr3[i][j] += arr1[i][t] * arr2[k][j];  <br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <br>arr2[i][j] = arr3[i][j];<br>&#125;<br>&#125;<br>&#125; <br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(arr2[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】螺旋矩阵</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>问题描述</p><p>对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。<br>例如，一个 4 行 5 列的螺旋矩阵如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">6</span><br><span class="hljs-number">13</span> <span class="hljs-number">20</span> <span class="hljs-number">19</span> <span class="hljs-number">18</span> <span class="hljs-number">7</span><br><span class="hljs-number">12</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span>  <span class="hljs-number">9</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>输入格式</p><p>输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。<br>第二行包含两个整数 r, c，表示要求的行号和列号。</p><p>输出格式</p><p>输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。</p><p>样例输入</p><p>4 5<br>2 2</p><p>样例输出</p><p>15</p><p>评测用例规模与约定</p><p>对于 30% 的评测用例，2 &lt;&#x3D; n, m &lt;&#x3D; 20。<br>对于 70% 的评测用例，2 &lt;&#x3D; n, m &lt;&#x3D; 100。<br>对于所有评测用例，2 &lt;&#x3D; n, m &lt;&#x3D; 1000，1 &lt;&#x3D; r &lt;&#x3D; n，1 &lt;&#x3D; c &lt;&#x3D; m。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们只需要知道某个特定位置的值，所以我们并不需要建立二维数组去存储每一个值。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>按照矩阵螺旋的方向去遍历每一个行列的坐标，直到找到我们想要的坐标，然后输出相对应的值。</p><p>利用for循环遍历行，列，行，列，并且使用 k 表示当前位置的值。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br><br>int n,m,r,c;  <br>int i,j,k;<br>int flag1,flag2;<br>n = scanner.<span class="hljs-title function_">nextInt</span>();<br>m = scanner.<span class="hljs-title function_">nextInt</span>();<br>r = scanner.<span class="hljs-title function_">nextInt</span>();<br>c = scanner.<span class="hljs-title function_">nextInt</span>();<br>scanner.<span class="hljs-title function_">close</span>();<br><br>flag1 = n;<span class="hljs-comment">//flag1用来控制行数范围</span><br>flag2 = m;<span class="hljs-comment">//flag2用来控制列数范围</span><br><br><br><span class="hljs-comment">//k表示当前位置的值</span><br><span class="hljs-comment">//i表示当前所在行</span><br><span class="hljs-comment">//j表示当前所在列</span><br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>, i=<span class="hljs-number">1</span>, j=<span class="hljs-number">1</span>; k &lt;= n*m ; ) &#123;<br>    <br><span class="hljs-keyword">for</span>( ; j &lt;= flag2; j++) &#123;<br>       <span class="hljs-comment">//行从左向右开始遍历</span><br><span class="hljs-keyword">if</span>( (i == r) &amp;&amp; (j == c)) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(k);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>k++;<br>&#125;<br>j--;<br><span class="hljs-keyword">for</span>(i = i+<span class="hljs-number">1</span> ; i &lt;= flag1; i++) &#123;<br>    <span class="hljs-comment">//列从上向下开始遍历</span><br><span class="hljs-keyword">if</span>( (i == r) &amp;&amp; (j == c)) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(k);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>k++;<br>&#125;<br>i--;<br><span class="hljs-keyword">for</span>(j = j-<span class="hljs-number">1</span>; j &gt; m-flag2 ; j--) &#123;<br>    <span class="hljs-comment">//行从右向左开始遍历</span><br><span class="hljs-keyword">if</span>( (i == r) &amp;&amp; (j == c)) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(k);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>k++;<br>&#125;<br>j++;<br><span class="hljs-keyword">for</span>(i = i-<span class="hljs-number">1</span>; i &gt; n-flag1+<span class="hljs-number">1</span>; i--) &#123;<br>    <span class="hljs-comment">//列从下向上开始遍历</span><br><span class="hljs-keyword">if</span>( (i == r) &amp;&amp; (j == c)) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(k);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>k++;<br>&#125;<br>i++;<br>j++;<br>flag1--;<br>flag2--;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>因为写这篇博客的时候还不知道这题过没过，仅测试了部分数据，如果问题，call me</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
