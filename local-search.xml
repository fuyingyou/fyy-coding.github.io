<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/2024/03/26/Redis/Redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/26/Redis/Redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redi面试题整理</title>
    <link href="/2024/03/26/Redis/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2024/03/26/Redis/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><blockquote><p>  发现Redis好像变慢了</p><p>  可能的原因有两个</p><ul><li>网络问题：业务服务器到Redis服务器的网络质量问题</li><li>Redis本身的问题</li></ul></blockquote><h2 id="基准性能"><a href="#基准性能" class="headerlink" title="基准性能"></a>基准性能</h2><p>首先了解Redis在生产环境服务器上的基准性能：直接在 Redis 服务器上测试实例的响应延迟情况。</p><p>60 秒内的最大响应延迟：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h127.0.0.1 -p6379 --intrinsic-latency<br><br>Max latency so far: 1 microseconds.<br>Max latency so far: 15 microseconds.<br>Max latency so far: 53 microseconds.<br>Max latency so far: 60 microseconds.<br>Max latency so far: 99 microseconds.<br></code></pre></td></tr></table></figure><p>查看一段时间内 Redis 的最小、最大、平均访问延迟：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 127.0.0.1 -p 6379 --latency-history -i 1<br><br>min: 0, max: 1, avg: 0.39 (66 samples) -- 1.01 seconds range<br>min: 0, max: 1, avg: 0.43 (65 samples) -- 1.01 seconds range<br>min: 0, max: 1, avg: 0.40 (65 samples) -- 1.00 seconds range<br>min: 0, max: 2, avg: 0.54 (65 samples) -- 1.01 seconds range<br></code></pre></td></tr></table></figure><p>判断你的 Redis 是否真的变慢了：</p><ul><li>在相同配置的服务器上，测试一个正常 Redis 实例的基准性能</li><li>找到你认为可能变慢的 Redis 实例，测试这个实例的基准性能</li><li>如果这个实例的运行延迟是正常 Redis 基准性能的 2 倍以上，即可认为这个 Redis 实例确实变慢了</li></ul><h2 id="Redis-变慢的因素"><a href="#Redis-变慢的因素" class="headerlink" title="Redis 变慢的因素"></a>Redis 变慢的因素</h2><h3 id="使用复杂度过高的命令"><a href="#使用复杂度过高的命令" class="headerlink" title="使用复杂度过高的命令"></a>使用复杂度过高的命令</h3><h4 id="慢日志查询"><a href="#慢日志查询" class="headerlink" title="慢日志查询"></a>慢日志查询</h4><ol><li><p>查询慢日志，首先配置慢日志的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令执行耗时超过 5 毫秒，记录慢日志（单位微秒）</span><br>CONFIG SET slowlog-log-slower-than 5000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">只保留最近 500 条慢日志</span><br>CONFIG SET slowlog-max-len 500<br></code></pre></td></tr></table></figure></li><li><p>查询到最近记录的慢日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">单位毫秒</span><br>SLOWLOG get 5<br></code></pre></td></tr></table></figure><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20240325145953718.png" alt="image-20240325145953718"></p></li><li><p>可能会导致操作延迟变大：</p><ul><li>经常使用 O(N) 以上复杂度的命令，例如 SORT、SUNION、ZUNIONSTORE 聚合类命令</li><li>使用 O(N) 复杂度的命令，但 N 的值非常大</li></ul><p>第一种情况导致变慢的原因在于，Redis 在操作内存数据时，时间复杂度过高，要花费更多的 CPU 资源。</p><p>第二种情况导致变慢的原因在于，Redis 一次需要返回给客户端的数据过多，更多时间花费在数据协议的组装和网络传输过程中。</p><p>另外，我们还可以从资源使用率层面来分析，如果你的应用程序操作 Redis 的 OPS 不是很大，但 Redis 实例的 CPU 使用率却很高，那么很有可能是使用了复杂度过高的命令导致的。</p><p>除此之外，我们都知道，Redis 是单线程处理客户端请求的，如果你经常使用以上命令，那么当 Redis 处理客户端请求时，一旦前面某个命令发生耗时，就会导致后面的请求发生排队，对于客户端来说，响应延迟也会变长。</p></li></ol><h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><ul><li>尽量不使用 O(N) 以上复杂度过高的命令，对于数据的聚合操作，放在客户端做</li><li>执行 O(N) 命令，保证 N 尽量的小（推荐 N &lt;&#x3D; 300），每次获取尽量少的数据，让 Redis 可以及时处理返回</li></ul><h3 id="BigKey"><a href="#BigKey" class="headerlink" title="BigKey"></a>BigKey</h3><blockquote><p>  查询慢日志发现，并不是复杂度过高的命令导致的，而都是 SET &#x2F; DEL 这种简单命令出现在慢日志中，那么你就要怀疑你的实例否写入了 bigkey。</p></blockquote><p>Redis 在写入数据时，需要为新的数据分配内存，相对应的，当从 Redis 中删除数据时，它会释放对应的内存空间。</p><p><strong>如果一个 key 写入的 value 非常大，那么 Redis 在分配内存时就会比较耗时</strong>。同样的，当删除这个 key 时，释放内存也会比较耗时，这种类型的 key 我们一般称之为 bigkey。</p><p>检查业务代码是否存在写入 bigkey 的情况，评估写入一个 key 的数据大小，尽量避免一个 key 存入过大的数据。</p><p><strong>如果已经写入了 bigkey，那有没有什么办法可以扫描出实例中 bigkey 的分布情况呢</strong>？</p><p>答案是可以的。</p><h4 id="扫描-BigKey"><a href="#扫描-BigKey" class="headerlink" title="扫描 BigKey"></a>扫描 BigKey</h4><p>Redis 提供了扫描 bigkey 的命令，执行以下命令就可以扫描出，一个实例中 bigkey 的分布情况，输出结果是以类型维度展示的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01<br><br><br>[00.00%] Biggest zset   found so far &#x27;&quot;shop:geo:1&quot;&#x27; with 9 members<br><br>-------- summary -------<br><br>Sampled 3 keys in the keyspace!<br>Total key length in bytes is 33 (avg len 11.00)<br><br>Biggest   zset found &#x27;&quot;shop:geo:1&quot;&#x27; has 9 members<br><br>0 lists with 0 items (00.00% of keys, avg size 0.00)<br>0 hashs with 0 fields (00.00% of keys, avg size 0.00)<br>0 strings with 0 bytes (00.00% of keys, avg size 0.00)<br>1 streams with 0 entries (33.33% of keys, avg size 0.00)<br>0 sets with 0 members (00.00% of keys, avg size 0.00)<br>2 zsets with 14 members (66.67% of keys, avg size 7.00)<br></code></pre></td></tr></table></figure><p>可以看到每种数据类型所占用的最大内存 &#x2F; 拥有最多元素的 key 是哪一个，以及每种数据类型在整个实例中的占比和平均大小 &#x2F; 元素数量。原理是 Redis 在内部执行了 SCAN 命令，遍历整个实例中所有的 key，然后针对 key 的类型，分别执行 STRLEN、LLEN、HLEN、SCARD、ZCARD 命令，来获取 String 类型的长度、容器类型（List、Hash、Set、ZSet）的元素个数。</p><p>当执行这个命令时，要注意 2 个问题：</p><ul><li>对线上实例进行 bigkey 扫描时，Redis 的 OPS 会突增，为了降低扫描过程中对 Redis 的影响，最好控制一下扫描的频率，指定 -i 参数即可，它表示扫描过程中每次扫描后休息的时间间隔，单位是秒</li><li>扫描结果中，对于容器类型（List、Hash、Set、ZSet）的 key，<strong>只能扫描出元素最多的 key</strong>。但一个 key 的元素多，<strong>不一定表示占用内存也多</strong>，你还需要根据业务情况，进一步评估内存占用情况。</li></ul><h4 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h4><ul><li><p>尽量避免写入 bigkey</p></li><li><p>如果你使用的 Redis 是 4.0 以上版本，用 UNLINK 命令替代 DEL，此命令可以把释放 key 内存的操作，放到后台线程中去执行，从而降低对 Redis 的影响</p></li><li><p>如果你使用的 Redis 是 6.0 以上版本，可以开启 lazy-free 机制（lazyfree-lazy-user-del &#x3D; yes），在执行 DEL 命令时，释放内存也会放到后台线程中执行</p></li></ul><blockquote><p>  bigkey 在很多场景下，依旧会产生性能问题。例如，bigkey 在分片集群模式下，对于数据的迁移也会有性能影响，以及我后面即将讲到的数据过期、数据淘汰、透明大页，都会受到 bigkey 的影响。</p></blockquote><h3 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h3><blockquote><p>  平时在操作 Redis 时，并没有延迟很大的情况发生，但在某个时间点突然出现一波延时，其现象表现为：<strong>变慢的时间点很有规律，例如某个整点，或者每间隔多久就会发生一波延迟</strong>。如果是出现这种情况，那么你需要排查一下，业务代码中是否存在设置大量 key 集中过期的情况。</p></blockquote><p>如果有大量的 key 在某个固定时间点集中过期，在这个时间点访问 Redis 时，就有可能导致延时变大。</p><p><strong>为什么集中过期会导致 Redis 延迟变大</strong>？</p><p>Redis 的过期数据采用被动过期 + 主动过期两种策略：</p><ul><li><strong>被动过期</strong>：只有当访问某个 key 时，才判断这个 key 是否已过期，如果已过期，则从实例中删除</li><li><strong>主动过期</strong>：Redis 内部维护了一个定时任务，默认每隔 100 毫秒（1秒10次）就会从全局的过期哈希表中随机取出 20 个 key，然后删除其中过期的 key，如果过期 key 的比例超过了 25%，则继续重复此过程，直到过期 key 的比例下降到 25% 以下，或者这次任务的执行耗时超过了 25 毫秒，才会退出循环。</li></ul><p>注意，<strong>这个主动过期 key 的定时任务，是在 Redis 主线程中执行的</strong>。</p><p>也就是说如果在执行主动过期的过程中，出现了需要大量删除过期 key 的情况，那么此时应用程序在访问 Redis 时，必须要等待这个定时任务执行结束，Redis 才可以服务这个客户端请求。此时就会出现，应用访问 Redis 延时变大。</p><p>如果此时过期需要删除的是一个 bigkey，那么这个耗时会更久。而且，这个<strong>操作延迟的命令并不会记录在慢日志</strong>中。</p><p>因为<strong>慢日志中只记录一个命令真正操作内存数据的耗时</strong>，而 Redis 主动删除过期 key 的逻辑，是在命令真正执行之前执行的。</p><p>所以，此时你会看到，<strong>慢日志中没有操作耗时的命令，但我们的应用程序却感知到了延迟变大，其实时间都花费在了删除过期 key 上</strong>。</p><h4 id="分析与排查"><a href="#分析与排查" class="headerlink" title="分析与排查"></a>分析与排查</h4><p>业务层面： 一般集中过期使用的是 expireat &#x2F; pexpireat 命令，你需要在代码中搜索这个关键字，检查是否存在会导致key集中过期的逻辑。</p><p>运维层面： 监控Redis实例的运行状态，查看expired_keys的大小，<strong>当这个指标在很短时间内出现了突增，需要及时报警出来</strong>，然后与业务应用报慢的时间点进行对比分析，确认时间是否一致，如果一致，则可以确认确实是因为集中过期 key 导致的延迟变大。</p><h4 id="优化方案-2"><a href="#优化方案-2" class="headerlink" title="优化方案"></a>优化方案</h4><ul><li><p>随机过期时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在过期时间点之后的 5 分钟内随机过期掉</span><br>redis.expireat(key, expire_time + random(300))<br></code></pre></td></tr></table></figure></li><li><p>Redis 4.0以上，可以开启 lazy-free 机制，当删除过期 key 时，把释放内存的操作放到后台线程中执行，避免阻塞主线程</p></li></ul><pre><code class="hljs"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">释放过期 key 的内存，放到后台线程执行</span><br>lazyfree-lazy-expire yes<br></code></pre></td></tr></table></figure></code></pre><h3 id="实例内存达到上限"><a href="#实例内存达到上限" class="headerlink" title="实例内存达到上限"></a>实例内存达到上限</h3><blockquote><p>  当 Redis 内存达到 maxmemory 后，每次写入新的数据之前，<strong>Redis 必须先从实例中踢出一部分数据，让整个实例的内存维持在 maxmemory 之下，然后才能把新数据写进来</strong>。踢出旧数据的逻辑也是需要消耗时间的，而具体耗时的长短，要取决于你配置的淘汰策略。</p></blockquote><h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><ul><li><p>不淘汰任何 key</p><ul><li>noeviction：不淘汰任何 key，实例内存达到 maxmeory 后，再写入新数据直接返回错误</li></ul></li><li><p>只选择设置了过期时间的key</p><ul><li><p>volatile-lru：只淘汰<strong>最近最少访问</strong>、并设置了过期时间的 key</p></li><li><p>volatile-random：只<strong>随机</strong>淘汰设置了过期时间的 key</p></li><li><p>volatile-lfu：只淘汰<strong>访问频率最低</strong>、并设置了过期时间 key（4.0+版本支持）</p></li><li><p>ttl：淘汰<strong>即将过期</strong>的 key，比随机删除时多进行一步过期时间的排序</p></li></ul></li><li><p>所有key</p><ul><li><p>allkeys-lru：不管 key 是否设置了过期，淘汰<strong>最近最少访问</strong>的 key</p></li><li><p>allkeys-random：不管 key 是否设置了过期，<strong>随机</strong>淘汰 key</p></li><li><p>allkeys-lfu：不管 key 是否设置了过期，淘汰<strong>访问频率最低</strong>的 key（4.0+版本支持）</p></li></ul><p>一般最常使用的是 allkeys-lru &#x2F; volatile-lru 淘汰策略，它们的处理逻辑是，每次从实例中随机取出一批 key（这个数量可配置），然后淘汰一个最少访问的 key，之后把剩下的 key 暂存到一个池子中，继续随机取一批 key，并与之前池子中的 key 比较，再淘汰一个最少访问的 key。以此往复，直到实例内存降到 maxmemory 之下。</p><p>需要注意的是，Redis 的淘汰数据的逻辑与删除过期 key 的一样，也是在命令真正执行之前执行的，也就是说它也会增加我们操作 Redis 的延迟，而且，写 OPS 越高，延迟也会越明显。</p></li></ul><h4 id="优化方案-3"><a href="#优化方案-3" class="headerlink" title="优化方案"></a>优化方案</h4><ul><li><p>避免存储 bigkey，降低释放内存的耗时</p></li><li><p>淘汰策略改为随机淘汰，随机淘汰比 LRU 要快很多（视业务情况调整）</p></li><li><p>拆分实例，把淘汰 key 的压力分摊到多个实例上</p></li><li><p>Redis 4.0 以上版本，开启 layz-free 机制，把淘汰 key 释放内存的操作放到后台线程中执行（配置 lazyfree-lazy-eviction &#x3D; yes）</p></li></ul><h3 id="fork耗时严重"><a href="#fork耗时严重" class="headerlink" title="fork耗时严重"></a>fork耗时严重</h3><blockquote><p>  为了保证 Redis 数据的安全性，可能会开启后台定时 RDB 和 AOF rewrite 功能。但如果Redis 延迟变大都发生在 Redis 后台 RDB 和 AOF rewrite 期间，需要排查，在这期间有可能导致变慢的情况。</p></blockquote><p>当 Redis 开启了后台 RDB 和 AOF rewrite 后，在执行时，它们都需要主进程创建出一个子进程进行数据的持久化。</p><p><strong>主进程创建子进程，会调用操作系统提供的 fork 函数</strong>。</p><p>而 fork 在执行过程中，主进程需要拷贝自己的内存页表给子进程，如果这个实例很大，那么这个拷贝的过程也会比较耗时。而且这个 fork 过程会消耗大量的 CPU 资源，在完成 fork 之前，整个 Redis 实例会被阻塞住，无法处理任何客户端请求。</p><p>如果此时你的 CPU 资源本来就很紧张，那么 fork 的耗时会更长，甚至达到秒级，这会严重影响 Redis 的性能。</p><p>那如何确认确实是因为 fork 耗时导致的 Redis 延迟变大呢？</p><p>你可以在 Redis 上执行 INFO 命令，查看 latest_fork_usec 项，单位微秒。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 上一次 fork 耗时，单位微秒(整个实例阻塞无法处理客户端请求的时间)</span><br>latest_fork_usec:59477<br></code></pre></td></tr></table></figure><p>除了数据持久化会生成 RDB 之外，当主从节点第一次建立数据同步时，主节点也创建子进程生成 RDB，然后发给从节点进行一次全量同步，所以，这个过程也会对 Redis 产生性能影响。</p><h5 id="优化方案-4"><a href="#优化方案-4" class="headerlink" title="优化方案"></a>优化方案</h5><ul><li><p>控制 Redis 实例的内存：尽量在 10G 以下，执行 fork 的耗时与实例大小有关，实例越大，耗时越久</p></li><li><p>合理配置数据持久化策略：在 slave 节点执行 RDB 备份，推荐在低峰期执行，而对于丢失数据不敏感的业务（例如把 Redis 当做纯缓存使用），可以关闭 AOF 和 AOF rewrite</p></li><li><p>Redis 实例不要部署在虚拟机上：fork 的耗时也与系统也有关，虚拟机比物理机耗时更久</p></li><li><p>降低主从库全量同步的概率：适当调大 repl-backlog-size 参数，避免主从全量同步</p></li><li><p>RDB和AOF混合使用，在两次RDB之间使用AOF。</p></li></ul><h2 id="开启内存大页"><a href="#开启内存大页" class="headerlink" title="开启内存大页"></a>开启内存大页</h2><h2 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h2><h2 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h2><h2 id="使用Swap"><a href="#使用Swap" class="headerlink" title="使用Swap"></a>使用Swap</h2><h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><h3 id="网络带宽过载"><a href="#网络带宽过载" class="headerlink" title="网络带宽过载"></a>网络带宽过载</h3><h3 id="其他原因"><a href="#其他原因" class="headerlink" title="其他原因"></a>其他原因</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL语法基础知识.md</title>
    <link href="/2024/02/27/DB/basic_knowledge/SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/02/27/DB/basic_knowledge/SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h3><ul><li><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li><li><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</li><li><code>模式（schema）</code> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。<code>// 模式到底是什么？？？</code></li><li><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</li><li><code>行（row）</code> - 表中的一个记录。</li><li><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</li></ul><h3 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h3><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL&#x2F;SQL、Transact-SQL 等。</p><h4 id="SQL-语法结构"><a href="#SQL-语法结构" class="headerlink" title="SQL 语法结构"></a>SQL 语法结构</h4><p><img src="https://oss.javaguide.cn/p3-juejin/cb684d4c75fc430e92aaee226069c7da~tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p><p>SQL 语法结构包括：</p><ul><li><strong><code>子句</code></strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li><li><strong><code>表达式</code></strong> - 可以产生任何标量值，或由列和行的数据库表</li><li><strong><code>谓词</code></strong> - 给需要评估的 SQL 三值逻辑（3VL）（true&#x2F;false&#x2F;unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li><li><strong><code>查询</code></strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li><li><strong><code>语句</code></strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li></ul><h4 id="SQL-语法要点"><a href="#SQL-语法要点" class="headerlink" title="SQL 语法要点"></a>SQL 语法要点</h4><ul><li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如：<code>SELECT</code> 与 <code>select</code>、<code>Select</code> 是相同的。</li><li><strong>多条 SQL 语句必须以分号（<code>;</code>）分隔</strong>。</li><li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li></ul><p>SQL 语句可以写成一行，也可以分写为多行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 一行 SQL 语句</span><br><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span>, password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br><br><span class="hljs-comment">-- 多行 SQL 语句</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">SET</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span>, password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span><br><span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><p>SQL 支持三种注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">## 注释<span class="hljs-number">1</span><br><span class="hljs-comment">-- 注释2</span><br><span class="hljs-comment">/* 注释3 */</span><br></code></pre></td></tr></table></figure><h3 id="SQL-分类"><a href="#SQL-分类" class="headerlink" title="SQL 分类"></a>SQL 分类</h3><h4 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h4><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p><p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p><p>DDL 的核心指令是 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>。</p><h4 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h4><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p><p>DML 的主要功能是 <strong>访问数据</strong>，因此其语法都是以<strong>读写数据库</strong>为主。</p><p>DML 的核心指令是 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</p><h4 id="事务控制语言（TCL）"><a href="#事务控制语言（TCL）" class="headerlink" title="事务控制语言（TCL）"></a>事务控制语言（TCL）</h4><p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p><p>TCL 的核心指令是 <code>COMMIT</code>、<code>ROLLBACK</code>。</p><h4 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="#数据控制语言（DCL）"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80-dcl">#</a>数据控制语言（DCL）</h4><p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p><p>DCL 的核心指令是 <code>GRANT</code>、<code>REVOKE</code>。</p><p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：<code>CONNECT</code>、<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>EXECUTE</code>、<code>USAGE</code>、<code>REFERENCES</code>。</p><p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p><p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="#增删改查"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">#</a>增删改查</h2><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="#插入数据"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">#</a>插入数据</h3><p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p><p><strong>插入完整的行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 插入一行<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br># 插入多行<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>), (<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>), (<span class="hljs-number">18</span>, <span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>插入行的一部分</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span>(username, password, email)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>插入查询出来的数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span>(username)<br><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> account;<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="#更新数据"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE">#</a>更新数据</h3><p><code>UPDATE</code> 语句用于更新表中的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">SET</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span>, password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span><br><span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="#删除数据"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">#</a>删除数据</h3><ul><li><code>DELETE</code> 语句用于删除表中的记录。</li><li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li></ul><p><strong>删除表中的指定数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;robot&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>清空表中的数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="#查询数据"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">#</a>查询数据</h3><p><code>SELECT</code> 语句用于从数据库中查询数据。</p><p><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</p><p><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><ul><li><code>ASC</code>：升序（默认）</li><li><code>DESC</code>：降序</li></ul><p><strong>查询单列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name<br><span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>查询多列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>查询所有列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>查询不同的值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><br>vend_id <span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>限制查询结果</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 返回前 5 行</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> mytable LIMIT <span class="hljs-number">5</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> mytable LIMIT <span class="hljs-number">0</span>, <span class="hljs-number">5</span>;<br><span class="hljs-comment">-- 返回第 3 ~ 5 行</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> mytable LIMIT <span class="hljs-number">2</span>, <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="#排序"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%8E%92%E5%BA%8F">#</a>排序</h2><p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p><p><code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_price <span class="hljs-keyword">DESC</span>, prod_name <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="#分组"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%86%E7%BB%84">#</a>分组</h2><p>**<code>group by</code>**：</p><ul><li><code>group by</code> 子句将记录分组到汇总行中。</li><li><code>group by</code> 为每个组返回一个记录。</li><li><code>group by</code> 通常还涉及聚合<code>count</code>，<code>max</code>，<code>sum</code>，<code>avg</code> 等。</li><li><code>group by</code> 可以按一列或多列进行分组。</li><li><code>group by</code> 按分组字段进行排序后，<code>order by</code> 可以以汇总字段来进行排序。</li></ul><p><strong>分组</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <span class="hljs-built_in">COUNT</span>(cust_address) <span class="hljs-keyword">AS</span> addr_num<br><span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cust_name;<br></code></pre></td></tr></table></figure><p><strong>分组后排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <span class="hljs-built_in">COUNT</span>(cust_address) <span class="hljs-keyword">AS</span> addr_num<br><span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cust_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cust_name <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p>**<code>having</code>**：</p><ul><li><code>having</code> 用于对汇总的 <code>group by</code> 结果进行过滤。</li><li><code>having</code> 一般都是和 <code>group by</code> 连用。</li><li><code>where</code> 和 <code>having</code> 可以在相同的查询中。</li></ul><p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num<br><span class="hljs-keyword">FROM</span> Customers<br><span class="hljs-keyword">WHERE</span> cust_email <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cust_name<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>**<code>having</code> vs <code>where</code>**：</p><ul><li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。<code>where</code> 在<code>group by</code> 前。</li><li><code>having</code>：过滤分组，一般都是和 <code>group by</code> 连用，不能单独使用。<code>having</code> 在 <code>group by</code> 之后。</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="#子查询"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%AD%90%E6%9F%A5%E8%AF%A2">#</a>子查询</h2><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p><p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p><p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p><ul><li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。</li><li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</li></ul><blockquote><p>  注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p></blockquote><p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> column_name [, column_name ]<br><span class="hljs-keyword">from</span>   table1 [, table2 ]<br><span class="hljs-keyword">where</span>  column_name operator<br>    (<span class="hljs-keyword">select</span> column_name [, column_name ]<br>    <span class="hljs-keyword">from</span> table1 [, table2 ]<br>    [<span class="hljs-keyword">where</span>])<br></code></pre></td></tr></table></figure><ul><li>子查询需要放在括号<code>( )</code>内。</li><li><code>operator</code> 表示用于 where 子句的运算符。</li></ul><p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> column_name [, column_name ]<br><span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> column_name [, column_name ]<br>      <span class="hljs-keyword">from</span> table1 [, table2 ]<br>      [<span class="hljs-keyword">where</span>]) <span class="hljs-keyword">as</span> temp_table_name<br><span class="hljs-keyword">where</span>  <span class="hljs-keyword">condition</span><br></code></pre></td></tr></table></figure><p>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</p><p><strong>子查询的子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, cust_contact<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> cust_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> cust_id<br>                  <span class="hljs-keyword">FROM</span> orders<br>                  <span class="hljs-keyword">WHERE</span> order_num <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> order_num<br>                                      <span class="hljs-keyword">FROM</span> orderitems<br>                                      <span class="hljs-keyword">WHERE</span> prod_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;RGAN01&#x27;</span>));<br></code></pre></td></tr></table></figure><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p><p><img src="https://oss.javaguide.cn/p3-juejin/c439da1f5d4e4b00bdfa4316b933d764~tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="#WHERE"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#where">#</a>WHERE</h3><ul><li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li><li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li><li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。</li><li>可以在 <code>WHERE</code> 子句中使用的操作符。</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr><tr><td>IN</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><p><strong><code>SELECT</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">SELECT * FROM Customers<br>WHERE <span class="hljs-attr">cust_name</span> = <span class="hljs-string">&#x27;Kids Place&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong><code>UPDATE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">UPDATE Customers<br>SET <span class="hljs-attr">cust_name</span> = <span class="hljs-string">&#x27;Jack Jones&#x27;</span><br>WHERE <span class="hljs-attr">cust_name</span> = <span class="hljs-string">&#x27;Kids Place&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong><code>DELETE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">DELETE FROM Customers<br>WHERE <span class="hljs-attr">cust_name</span> = <span class="hljs-string">&#x27;Kids Place&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="IN-和-BETWEEN"><a href="#IN-和-BETWEEN" class="headerlink" title="#IN 和 BETWEEN"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#in-%E5%92%8C-between">#</a>IN 和 BETWEEN</h3><ul><li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li><li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li></ul><p><strong>IN 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;DLL01&#x27;</span>, <span class="hljs-string">&#x27;BRS01&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>BETWEEN 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h3 id="AND、OR、NOT"><a href="#AND、OR、NOT" class="headerlink" title="#AND、OR、NOT"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#and%E3%80%81or%E3%80%81not">#</a>AND、OR、NOT</h3><ul><li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li><li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li><li><code>AND</code> 操作符表示左右条件都要满足。</li><li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li><li><code>NOT</code> 操作符用于否定一个条件。</li></ul><p><strong>AND 示例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">SELECT prod_id, prod_name, prod_price<br>FROM products<br>WHERE <span class="hljs-attr">vend_id</span> = <span class="hljs-string">&#x27;DLL01&#x27;</span> AND prod_price &lt;= <span class="hljs-number">4</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>OR 示例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">SELECT prod_id, prod_name, prod_price<br>FROM products<br>WHERE <span class="hljs-attr">vend_id</span> = <span class="hljs-string">&#x27;DLL01&#x27;</span> OR vend_id = <span class="hljs-string">&#x27;BRS01&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>NOT 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="#LIKE"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#like">#</a>LIKE</h3><ul><li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li><li>只有字段是文本值时才使用 <code>LIKE</code>。</li><li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li><li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li><li><code>%</code> 表示任何字符出现任意次数。</li><li><code>_</code> 表示任何字符出现一次。</li></ul><p><strong>% 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%bean bag%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>_ 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;__ inch teddy bear&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="#连接"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E8%BF%9E%E6%8E%A5">#</a>连接</h2><p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p><p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p><p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> table1.column1, table2.column2...<br><span class="hljs-keyword">from</span> table1<br><span class="hljs-keyword">join</span> table2<br><span class="hljs-keyword">on</span> table1.common_column1 <span class="hljs-operator">=</span> table2.common_column2;<br></code></pre></td></tr></table></figure><p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 &#x3D;、&gt;、&lt;、&lt;&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 &#x3D;。</p><p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p><p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># join....on<br><span class="hljs-keyword">select</span> c.cust_name, o.order_num<br><span class="hljs-keyword">from</span> Customers c<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> Orders o<br><span class="hljs-keyword">on</span> c.cust_id <span class="hljs-operator">=</span> o.cust_id<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c.cust_name;<br><br># 如果两张表的关联字段名相同，也可以使用<span class="hljs-keyword">USING</span>子句：join....using()<br><span class="hljs-keyword">select</span> c.cust_name, o.order_num<br><span class="hljs-keyword">from</span> Customers c<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> Orders o<br><span class="hljs-keyword">using</span>(cust_id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c.cust_name;<br></code></pre></td></tr></table></figure><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p><ul><li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li><li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li></ul><p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p><p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p><table><thead><tr><th>连接类型</th><th>说明</th></tr></thead><tbody><tr><td>INNER JOIN 内连接</td><td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td></tr><tr><td>LEFT JOIN &#x2F; LEFT OUTER JOIN 左(外)连接</td><td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td></tr><tr><td>RIGHT JOIN &#x2F; RIGHT OUTER JOIN 右(外)连接</td><td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td></tr><tr><td>FULL JOIN &#x2F; FULL OUTER JOIN 全(外)连接</td><td>只要其中有一个表存在满足条件的记录，就返回行。</td></tr><tr><td>SELF JOIN</td><td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td></tr><tr><td>CROSS JOIN</td><td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td></tr></tbody></table><p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><p><img src="https://oss.javaguide.cn/p3-juejin/701670942f0f45d3a3a2187cd04a12ad~tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p><p>如果不加任何修饰词，只写 <code>JOIN</code>，那么默认为 <code>INNER JOIN</code></p><p>对于 <code>INNER JOIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>INNER JOIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 隐式内连接<br><span class="hljs-keyword">select</span> c.cust_name, o.order_num<br><span class="hljs-keyword">from</span> Customers c, Orders o<br><span class="hljs-keyword">where</span> c.cust_id <span class="hljs-operator">=</span> o.cust_id<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c.cust_name;<br><br># 显式内连接<br><span class="hljs-keyword">select</span> c.cust_name, o.order_num<br><span class="hljs-keyword">from</span> Customers c <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> Orders o<br><span class="hljs-keyword">using</span>(cust_id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c.cust_name;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="#组合"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E7%BB%84%E5%90%88">#</a>组合</h2><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p><p><code>UNION</code> 基本规则：</p><ul><li>所有查询的列数和列顺序必须相同。</li><li>每个查询中涉及表的列的数据类型必须相同或兼容。</li><li>通常返回的列名取自第一个查询。</li></ul><p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name(s) <span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> column_name(s) <span class="hljs-keyword">FROM</span> table2;<br></code></pre></td></tr></table></figure><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p><p><code>JOIN</code> vs <code>UNION</code>：</p><ul><li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li><li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="#函数"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%87%BD%E6%95%B0">#</a>函数</h2><p>不同数据库的函数往往各不相同，因此不可移植。本节主要以 MySQL 的函数为例。</p><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="#文本处理"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86">#</a>文本处理</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>LEFT()</code>、<code>RIGHT()</code></td><td>左边或者右边的字符</td></tr><tr><td><code>LOWER()</code>、<code>UPPER()</code></td><td>转换为小写或者大写</td></tr><tr><td><code>LTRIM()</code>、<code>RTRIM()</code></td><td>去除左边或者右边的空格</td></tr><tr><td><code>LENGTH()</code></td><td>长度，以字节为单位</td></tr><tr><td><code>SOUNDEX()</code></td><td>转换为语音值</td></tr></tbody></table><p>其中， <strong><code>SOUNDEX()</code></strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> mytable<br><span class="hljs-keyword">WHERE</span> SOUNDEX(col1) <span class="hljs-operator">=</span> SOUNDEX(<span class="hljs-string">&#x27;apple&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="#日期和时间处理"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86">#</a>日期和时间处理</h3><ul><li>日期格式：<code>YYYY-MM-DD</code></li><li>时间格式：<code>HH:MM:SS</code></li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AddDate()</code></td><td>增加一个日期（天、周等）</td></tr><tr><td><code>AddTime()</code></td><td>增加一个时间（时、分等）</td></tr><tr><td><code>CurDate()</code></td><td>返回当前日期</td></tr><tr><td><code>CurTime()</code></td><td>返回当前时间</td></tr><tr><td><code>Date()</code></td><td>返回日期时间的日期部分</td></tr><tr><td><code>DateDiff()</code></td><td>计算两个日期之差</td></tr><tr><td><code>Date_Add()</code></td><td>高度灵活的日期运算函数</td></tr><tr><td><code>Date_Format()</code></td><td>返回一个格式化的日期或时间串</td></tr><tr><td><code>Day()</code></td><td>返回一个日期的天数部分</td></tr><tr><td><code>DayOfWeek()</code></td><td>对于一个日期，返回对应的星期几</td></tr><tr><td><code>Hour()</code></td><td>返回一个时间的小时部分</td></tr><tr><td><code>Minute()</code></td><td>返回一个时间的分钟部分</td></tr><tr><td><code>Month()</code></td><td>返回一个日期的月份部分</td></tr><tr><td><code>Now()</code></td><td>返回当前日期和时间</td></tr><tr><td><code>Second()</code></td><td>返回一个时间的秒部分</td></tr><tr><td><code>Time()</code></td><td>返回一个日期时间的时间部分</td></tr><tr><td><code>Year()</code></td><td>返回一个日期的年份部分</td></tr></tbody></table><h3 id="数值处理"><a href="#数值处理" class="headerlink" title="#数值处理"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86">#</a>数值处理</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h3 id="汇总"><a href="#汇总" class="headerlink" title="#汇总"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%B1%87%E6%80%BB">#</a>汇总</h3><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AVG()</code></td><td>返回某列的平均值</td></tr><tr><td><code>COUNT()</code></td><td>返回某列的行数</td></tr><tr><td><code>MAX()</code></td><td>返回某列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回某列的最小值</td></tr><tr><td><code>SUM()</code></td><td>返回某列值之和</td></tr></tbody></table><p><code>AVG()</code> 会忽略 NULL 行。</p><p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(<span class="hljs-keyword">DISTINCT</span> col1) <span class="hljs-keyword">AS</span> avg_col<br><span class="hljs-keyword">FROM</span> mytable<br></code></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）</strong></p><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="#数据定义"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89">#</a>数据定义</h2><h3 id="数据库（DATABASE）"><a href="#数据库（DATABASE）" class="headerlink" title="#数据库（DATABASE）"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%95%B0%E6%8D%AE%E5%BA%93-database">#</a>数据库（DATABASE）</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="#创建数据库"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">#</a>创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE test;<br></code></pre></td></tr></table></figure><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="#删除数据库"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">#</a>删除数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE test;<br></code></pre></td></tr></table></figure><h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="#选择数据库"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93">#</a>选择数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE test;<br></code></pre></td></tr></table></figure><h3 id="数据表（TABLE）"><a href="#数据表（TABLE）" class="headerlink" title="#数据表（TABLE）"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%95%B0%E6%8D%AE%E8%A1%A8-table">#</a>数据表（TABLE）</h3><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="#创建数据表"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8">#</a>创建数据表</h4><p><strong>普通创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;Id&#x27;</span>,<br>  username <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>  password <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;密码&#x27;</span>,<br>  email <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;邮箱&#x27;</span><br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>根据已有的表创建新表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> vip_user <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="#删除数据表"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%A1%A8">#</a>删除数据表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h4 id="修改数据表"><a href="#修改数据表" class="headerlink" title="#修改数据表"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8">#</a>修改数据表</h4><p><strong>添加列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">ADD</span> age <span class="hljs-type">int</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><strong>删除列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> age;<br></code></pre></td></tr></table></figure><p><strong>修改列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>`<br>MODIFY <span class="hljs-keyword">COLUMN</span> age tinyint;<br></code></pre></td></tr></table></figure><p><strong>添加主键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (id);<br></code></pre></td></tr></table></figure><p><strong>删除主键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br></code></pre></td></tr></table></figure><h3 id="视图（VIEW）"><a href="#视图（VIEW）" class="headerlink" title="#视图（VIEW）"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E8%A7%86%E5%9B%BE-view">#</a>视图（VIEW）</h3><p>定义：</p><ul><li>视图是基于 SQL 语句的结果集的可视化的表。</li><li>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li></ul><p>作用：</p><ul><li>简化复杂的 SQL 操作，比如复杂的联结；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><p><img src="https://oss.javaguide.cn/p3-juejin/ec4c975296ea4a7097879dac7c353878~tplv-k3u1fbpfcp-zoom-1.jpeg" alt="mysql视图">mysql视图</p><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="#创建视图"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE">#</a>创建视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> top_10_user_view <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> id, username<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="#删除视图"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE">#</a>删除视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> top_10_user_view;<br></code></pre></td></tr></table></figure><h3 id="索引（INDEX）"><a href="#索引（INDEX）" class="headerlink" title="#索引（INDEX）"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E7%B4%A2%E5%BC%95-index">#</a>索引（INDEX）</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><p><strong>优点</strong>：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong>：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><p>关于索引的详细介绍，请看我写的 <a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解open in new window</a> 这篇文章。</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="#创建索引"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">#</a>创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX user_index<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span> (id);<br></code></pre></td></tr></table></figure><h4 id="添加索引"><a href="#添加索引" class="headerlink" title="#添加索引"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95">#</a>添加索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ADD</span> INDEX user_index(id)<br></code></pre></td></tr></table></figure><h4 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="#创建唯一索引"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95">#</a>创建唯一索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX user_index<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span> (id);<br></code></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="#删除索引"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95">#</a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">DROP</span> INDEX user_index;<br></code></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="#约束"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E7%BA%A6%E6%9D%9F">#</a>约束</h3><p>SQL 约束用于规定表中的数据规则。</p><p>如果存在违反约束的数据行为，行为会被约束终止。</p><p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p><p>约束类型：</p><ul><li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li><li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li><li><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li><li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li><code>CHECK</code> - 保证列中的值符合指定的条件。</li><li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li></ul><p>创建表时使用约束条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Users (<br>  Id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;自增Id&#x27;</span>,<br>  Username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>  Password <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;密码&#x27;</span>,<br>  Email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;邮箱地址&#x27;</span>,<br>  Enabled TINYINT(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;是否有效&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (Id)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。</strong></p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="#事务处理"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86">#</a>事务处理</h2><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p><p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p><p>指令：</p><ul><li><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</li><li><code>SAVEPOINT</code> - 指令用于创建保留点。</li><li><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li><li><code>COMMIT</code> - 提交事务。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开始事务</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><br><span class="hljs-comment">-- 插入操作 A</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;root1&#x27;</span>, <span class="hljs-string">&#x27;root1&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br><br><span class="hljs-comment">-- 创建保留点 updateA</span><br><span class="hljs-keyword">SAVEPOINT</span> updateA;<br><br><span class="hljs-comment">-- 插入操作 B</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;root2&#x27;</span>, <span class="hljs-string">&#x27;root2&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br><br><span class="hljs-comment">-- 回滚到保留点 updateA</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> updateA;<br><br><span class="hljs-comment">-- 提交事务，只有操作 A 生效</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p><strong>接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。</strong></p><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="#权限控制"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">#</a>权限控制</h2><p>要授予用户帐户权限，可以用<code>GRANT</code>命令。有撤销用户的权限，可以用<code>REVOKE</code>命令。这里以 MySQl 为例，介绍权限控制实际应用。</p><p><code>GRANT</code>授予权限语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> privilege,[privilege],.. <span class="hljs-keyword">ON</span> privilege_level<br><span class="hljs-keyword">TO</span> <span class="hljs-keyword">user</span> [IDENTIFIED <span class="hljs-keyword">BY</span> password]<br>[REQUIRE tsl_option]<br>[<span class="hljs-keyword">WITH</span> [GRANT_OPTION <span class="hljs-operator">|</span> resource_option]];<br></code></pre></td></tr></table></figure><p>简单解释一下：</p><ol><li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li><li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global（<code>*.*</code>），database（<code>database.*</code>），table（<code>database.table</code>）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。</li><li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li><li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li><li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li></ol><p><code>REVOKE</code> 撤销权限语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span>   privilege_type [(column_list)]<br>        [, priv_type [(column_list)]]...<br><span class="hljs-keyword">ON</span> [object_type] privilege_level<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> [, <span class="hljs-keyword">user</span>]...<br></code></pre></td></tr></table></figure><p>简单解释一下：</p><ol><li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li><li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li><li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li></ol><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li><li>整个数据库，使用 <code>ON database.*</code>；</li><li>特定的表，使用 <code>ON database.table</code>；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p>新创建的账户没有任何权限。账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE mysql;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p>下表说明了可用于<code>GRANT</code>和<code>REVOKE</code>语句的所有允许权限：</p><table><thead><tr><th><strong>特权</strong></th><th><strong>说明</strong></th><th><strong>级别</strong></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>全局</strong></td><td>数据库</td><td><strong>表</strong></td><td><strong>列</strong></td><td><strong>程序</strong></td><td><strong>代理</strong></td><td></td><td></td></tr><tr><td>ALL [PRIVILEGES]</td><td>授予除 GRANT OPTION 之外的指定访问级别的所有权限</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALTER</td><td>允许用户使用 ALTER TABLE 语句</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>ALTER ROUTINE</td><td>允许用户更改或删除存储的例程</td><td>X</td><td>X</td><td></td><td></td><td>X</td><td></td></tr><tr><td>CREATE</td><td>允许用户创建数据库和表</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>CREATE ROUTINE</td><td>允许用户创建存储的例程</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE TABLESPACE</td><td>允许用户创建，更改或删除表空间和日志文件组</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE TEMPORARY TABLES</td><td>允许用户使用 CREATE TEMPORARY TABLE 创建临时表</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE USER</td><td>允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CREATE VIEW</td><td>允许用户创建或修改视图。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>DELETE</td><td>允许用户使用 DELETE</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>DROP</td><td>允许用户删除数据库，表和视图</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>EVENT</td><td>启用事件计划程序的事件使用。</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>EXECUTE</td><td>允许用户执行存储的例程</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>FILE</td><td>允许用户读取数据库目录中的任何文件。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>GRANT OPTION</td><td>允许用户拥有授予或撤消其他帐户权限的权限。</td><td>X</td><td>X</td><td>X</td><td></td><td>X</td><td>X</td></tr><tr><td>INDEX</td><td>允许用户创建或删除索引。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>INSERT</td><td>允许用户使用 INSERT 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>LOCK TABLES</td><td>允许用户对具有 SELECT 权限的表使用 LOCK TABLES</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>PROCESS</td><td>允许用户使用 SHOW PROCESSLIST 语句查看所有进程。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>PROXY</td><td>启用用户代理。</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REFERENCES</td><td>允许用户创建外键</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>RELOAD</td><td>允许用户使用 FLUSH 操作</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REPLICATION CLIENT</td><td>允许用户查询以查看主服务器或从属服务器的位置</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>REPLICATION SLAVE</td><td>允许用户使用复制从属从主服务器读取二进制日志事件。</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SELECT</td><td>允许用户使用 SELECT 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>SHOW DATABASES</td><td>允许用户显示所有数据库</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SHOW VIEW</td><td>允许用户使用 SHOW CREATE VIEW 语句</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>SHUTDOWN</td><td>允许用户使用 mysqladmin shutdown 命令</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SUPER</td><td>允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>TRIGGER</td><td>允许用户使用 TRIGGER 操作。</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td></tr><tr><td>UPDATE</td><td>允许用户使用 UPDATE 语句</td><td>X</td><td>X</td><td>X</td><td>X</td><td></td><td></td></tr><tr><td>USAGE</td><td>相当于“没有特权”</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="创建账户"><a href="#创建账户" class="headerlink" title="#创建账户"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7">#</a>创建账户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> myuser IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;mypassword&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="修改账户名"><a href="#修改账户名" class="headerlink" title="#修改账户名"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E4%BF%AE%E6%94%B9%E8%B4%A6%E6%88%B7%E5%90%8D">#</a>修改账户名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;newuser&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;myuser&#x27;</span>;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><h3 id="删除账户"><a href="#删除账户" class="headerlink" title="#删除账户"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E8%B4%A6%E6%88%B7">#</a>删除账户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="#查看权限"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90">#</a>查看权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="授予权限"><a href="#授予权限" class="headerlink" title="#授予权限"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90">#</a>授予权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="删除权限"><a href="#删除权限" class="headerlink" title="#删除权限"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E6%9D%83%E9%99%90">#</a>删除权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="更改密码"><a href="#更改密码" class="headerlink" title="#更改密码"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9B%B4%E6%94%B9%E5%AF%86%E7%A0%81">#</a>更改密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-keyword">FOR</span> myuser <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;mypass&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="#存储过程"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">#</a>存储过程</h2><p>存储过程可以看成是对一系列 SQL 操作的批处理。存储过程可以由触发器，其他存储过程以及 Java， Python，PHP 等应用程序调用。</p><p><img src="https://oss.javaguide.cn/p3-juejin/60afdc9c9a594f079727ec64a2e698a3~tplv-k3u1fbpfcp-zoom-1.jpeg" alt="mysql存储过程">mysql存储过程</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>创建存储过程：</p><ul><li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 <code>;</code> 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li><li>包含 <code>in</code>、<code>out</code> 和 <code>inout</code> 三种参数。</li><li>给变量赋值都需要用 <code>select into</code> 语句。</li><li>每次只能给一个变量赋值，不支持集合的操作。</li></ul><p>需要注意的是：<strong>阿里巴巴《Java 开发手册》强制禁止使用存储过程。因为存储过程难以调试和扩展，更没有移植性。</strong></p><p><img src="https://oss.javaguide.cn/p3-juejin/93a5e011ade4450ebfa5d82057532a49~tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p><p>至于到底要不要在项目中使用，还是要看项目实际需求，权衡好利弊即可！</p><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="#创建存储过程"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">#</a>创建存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> IF <span class="hljs-keyword">EXISTS</span> `proc_adder`;<br>DELIMITER ;;<br><span class="hljs-keyword">CREATE</span> DEFINER<span class="hljs-operator">=</span>`root`@`localhost` <span class="hljs-keyword">PROCEDURE</span> `proc_adder`(<span class="hljs-keyword">IN</span> a <span class="hljs-type">int</span>, <span class="hljs-keyword">IN</span> b <span class="hljs-type">int</span>, <span class="hljs-keyword">OUT</span> sum <span class="hljs-type">int</span>)<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> c <span class="hljs-type">int</span>;<br>    if a <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">set</span> a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span> if;<br><br>    if b <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">set</span> b <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span> if;<br><br>    <span class="hljs-keyword">set</span> sum  <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> b;<br><span class="hljs-keyword">END</span><br>;;<br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="#使用存储过程"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">#</a>使用存储过程</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">set</span> @<span class="hljs-selector-tag">b</span>=<span class="hljs-number">5</span>;<br><span class="hljs-selector-tag">call</span> <span class="hljs-selector-tag">proc_adder</span>(<span class="hljs-number">2</span>,<span class="hljs-variable">@b</span>,<span class="hljs-variable">@s</span>);<br><span class="hljs-selector-tag">select</span> @<span class="hljs-selector-tag">s</span> <span class="hljs-selector-tag">as</span> <span class="hljs-selector-tag">sum</span>;<br></code></pre></td></tr></table></figure><h2 id="游标"><a href="#游标" class="headerlink" title="#游标"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%B8%B8%E6%A0%87">#</a>游标</h2><p>游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。</p><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p><p>使用游标的几个明确步骤：</p><ul><li><p>在使用游标前，必须声明(定义)它。这个过程实际上没有检索数据， 它只是定义要使用的 <code>SELECT</code> 语句和游标选项。</p></li><li><p>一旦声明，就必须打开游标以供使用。这个过程用前面定义的 SELECT 语句把数据实际检索出来。</p></li><li><p>对于填有数据的游标，根据需要取出(检索)各行。</p></li><li><p>在结束游标使用时，必须关闭游标，可能的话，释放游标(有赖于具</p><p>体的 DBMS)。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">PROCEDURE</span> getTotal()<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> total <span class="hljs-type">INT</span>;<br>    <span class="hljs-comment">-- 创建接收游标数据的变量</span><br>    <span class="hljs-keyword">DECLARE</span> sid <span class="hljs-type">INT</span>;<br>    <span class="hljs-keyword">DECLARE</span> sname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">-- 创建总数变量</span><br>    <span class="hljs-keyword">DECLARE</span> sage <span class="hljs-type">INT</span>;<br>    <span class="hljs-comment">-- 创建结束标志变量</span><br>    <span class="hljs-keyword">DECLARE</span> done <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">-- 创建游标</span><br>    <span class="hljs-keyword">DECLARE</span> cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> id,name,age <span class="hljs-keyword">from</span> cursor_table <span class="hljs-keyword">where</span> age<span class="hljs-operator">&gt;</span><span class="hljs-number">30</span>;<br>    <span class="hljs-comment">-- 指定游标循环结束时的返回值</span><br>    <span class="hljs-keyword">DECLARE</span> CONTINUE HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">SET</span> done <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">SET</span> total <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">OPEN</span> cur;<br>    <span class="hljs-keyword">FETCH</span> cur <span class="hljs-keyword">INTO</span> sid, sname, sage;<br>    WHILE(<span class="hljs-keyword">NOT</span> done)<br>    DO<br>        <span class="hljs-keyword">SET</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">FETCH</span> cur <span class="hljs-keyword">INTO</span> sid, sname, sage;<br>    <span class="hljs-keyword">END</span> WHILE;<br><br>    <span class="hljs-keyword">CLOSE</span> cur;<br>    <span class="hljs-keyword">SELECT</span> total;<br><span class="hljs-keyword">END</span> $<br>DELIMITER ;<br><br><span class="hljs-comment">-- 调用存储过程</span><br><span class="hljs-keyword">call</span> getTotal();<br></code></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="#触发器"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E8%A7%A6%E5%8F%91%E5%99%A8">#</a>触发器</h2><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</p><p>我们可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。</p><p>使用触发器的优点：</p><ul><li>SQL 触发器提供了另一种检查数据完整性的方法。</li><li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li><li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li><li>SQL 触发器对于审计表中数据的更改非常有用。</li></ul><p>使用触发器的缺点：</p><ul><li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，ASP.NET，Perl）在服务器端验证用户的输入。</li><li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li><li>SQL 触发器可能会增加数据库服务器的开销。</li></ul><p>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。</p><blockquote><p>  注意：在 MySQL 中，分号 <code>;</code> 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p><p>  这时就会用到 <code>DELIMITER</code> 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：<code>DELIMITER new_delemiter</code>。<code>new_delemiter</code> 可以设为 1 个或多个长度的符号，默认的是分号 <code>;</code>，我们可以把它修改为其他符号，如 <code>$</code> - <code>DELIMITER $</code> 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 <code>$</code>，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p></blockquote><p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器。</p><ul><li><code>BEFORE INSERT</code> - 在将数据插入表格之前激活。</li><li><code>AFTER INSERT</code> - 将数据插入表格后激活。</li><li><code>BEFORE UPDATE</code> - 在更新表中的数据之前激活。</li><li><code>AFTER UPDATE</code> - 更新表中的数据后激活。</li><li><code>BEFORE DELETE</code> - 在从表中删除数据之前激活。</li><li><code>AFTER DELETE</code> - 从表中删除数据后激活。</li></ul><p>但是，从 MySQL 版本 5.7.2+开始，可以为同一触发事件和操作时间定义多个触发器。</p><p>**<code>NEW</code> 和 <code>OLD</code>**：</p><ul><li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li><li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要（<code>BEFORE</code>）或已经（<code>AFTER</code>）插入的新数据；</li><li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li><li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li><li>使用方法：<code>NEW.columnName</code> （columnName 为相应数据表某一列名）</li></ul><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="#创建触发器"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8">#</a>创建触发器</h3><blockquote><p>  提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p></blockquote><p><code>CREATE TRIGGER</code> 指令用于创建触发器。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name<br>trigger_time<br>trigger_event<br><span class="hljs-keyword">ON</span> table_name<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>  trigger_statements<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><code>trigger_name</code>：触发器名</li><li><code>trigger_time</code> : 触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li><li><code>trigger_event</code> : 触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li><li><code>table_name</code> : 触发器的监听目标。指定在哪张表上建立触发器。</li><li><code>FOR EACH ROW</code>: 行级监视，Mysql 固定写法，其他 DBMS 不同。</li><li><code>trigger_statements</code>: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li></ul><p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> `trigger_insert_user`<br>AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `user_history`(user_id, operate_type, operate_time)<br>    <span class="hljs-keyword">VALUES</span> (NEW.id, <span class="hljs-string">&#x27;add a user&#x27;</span>,  now());<br><span class="hljs-keyword">END</span> $<br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="#查看触发器"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E6%9F%A5%E7%9C%8B%E8%A7%A6%E5%8F%91%E5%99%A8">#</a>查看触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TRIGGERS;<br></code></pre></td></tr></table></figure><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="#删除触发器"></a><a href="https://javaguide.cn/database/sql/sql-syntax-summary.html#%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8">#</a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> IF <span class="hljs-keyword">EXISTS</span> trigger_insert_user;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NoSQL基础知识.md</title>
    <link href="/2024/02/27/DB/basic_knowledge/NoSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/02/27/DB/basic_knowledge/NoSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="NoSQL-是什么？"><a href="#NoSQL-是什么？" class="headerlink" title="NoSQL 是什么？"></a>NoSQL 是什么？</h2><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p><p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/sql-nosql-tushi.png" alt="img"></p><h2 id="SQL-和-NoSQL-有什么区别？"><a href="#SQL-和-NoSQL-有什么区别？" class="headerlink" title="SQL 和 NoSQL 有什么区别？"></a>SQL 和 NoSQL 有什么区别？</h2><table><thead><tr><th align="left"></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td align="left">数据存储模型</td><td>结构化存储，具有固定行和列的表格</td><td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td align="left">发展历程</td><td>开发于 1970 年代，重点是减少数据重复</td><td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td></tr><tr><td align="left">例子</td><td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL</td><td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph</td></tr><tr><td align="left">ACID 属性</td><td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td><td>为了可扩展、高性能，通常不支持 ACID 事务，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务的支持和 MySQL 还是有所区别的。</td></tr><tr><td align="left">性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td></tr><tr><td align="left">扩展</td><td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td><td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td></tr><tr><td align="left">用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td align="left">查询语法</td><td>结构化查询语言 (SQL)</td><td>数据访问语法可能因数据库而异</td></tr></tbody></table><h2 id="NoSQL-数据库有什么优势？"><a href="#NoSQL-数据库有什么优势？" class="headerlink" title="NoSQL 数据库有什么优势？"></a>NoSQL 数据库有什么优势？</h2><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p><ul><li><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</li><li><strong>可扩展性：</strong> NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li><li><strong>高性能：</strong> NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li><li><strong>强大的功能：</strong> NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li></ul><h2 id="NoSQL-数据库有哪些类型？"><a href="#NoSQL-数据库有哪些类型？" class="headerlink" title="NoSQL 数据库有哪些类型？"></a>NoSQL 数据库有哪些类型？</h2><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li><li><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li></ul><p>下面这张图片来源于 <a href="https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/relational-vs-nosql-data">微软的官方文档 | 关系数据与 NoSQL 数据open in new window</a>。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231122153605567.png" alt="image-20231122153605567"></p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符集.md</title>
    <link href="/2024/02/27/DB/basic_knowledge/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    <url>/2024/02/27/DB/basic_knowledge/%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  MySQL 字符编码集中有两套 UTF-8 编码实现：**<code>utf8</code>** 和 **<code>utf8mb4</code>**。</p><p>  如果使用 <strong><code>utf8</code></strong> 的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p></blockquote><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，比如说有些字符集是无法表示汉字的。</p><p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p><p>我们要将这些字符和二进制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。我们将字符对应二进制数据的过程称为”<strong>字符编码</strong>“，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p><h2 id="常见的字符集"><a href="#常见的字符集" class="headerlink" title="常见的字符集"></a>常见的字符集</h2><p>常见的字符集有 ASCII、GB2312、GBK、UTF-8……。</p><p>不同的字符集的主要区别在于：</p><ul><li>可以表示的字符范围</li><li>编码方式</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p><p><strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？</strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言。</p><p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p><p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 128（2^7）个字符。</p><p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 256（2^8）个字符。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。</p><p>对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p><p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p><h3 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h3><p>BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。</p><h3 id="Unicode-UTF-8-编码"><a href="#Unicode-UTF-8-编码" class="headerlink" title="Unicode &amp; UTF-8 编码"></a>Unicode &amp; UTF-8 编码</h3><p><strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p><p>乱码的本质：<strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p><p><img src="https://oss.javaguide.cn/javaguide/a8808cbabeea49caa3af27d314fa3c02-1.jpg" alt="img"></p><p>为了解决这个问题<strong>Unicode</strong> 诞生了。</p><p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p><p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p><p>UTF-8 使用 1 到 4 个字节为每个字符编码， UTF-16 使用 2 或 4 个字节为每个字符编码，UTF-32 固定位 4 个字节为每个字符编码。</p><p>UTF-8 可以根据不同的符号自动选择编码的长短，像英文字符只需要 1 个字节就够了，这一点 ASCII 字符集一样 。因此，对于英语字符，UTF-8 编码和 ASCII 码是相同的。</p><p>UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。</p><p><strong>UTF-8</strong> 是目前使用最广的一种字符编码。</p><p><img src="https://oss.javaguide.cn/javaguide/1280px-Utf8webgrowth.svg.png" alt="img"></p><h2 id="MySQL-字符集"><a href="#MySQL-字符集" class="headerlink" title="MySQL 字符集"></a>MySQL 字符集</h2><p>MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5。</p><h3 id="查看支持的字符集"><a href="#查看支持的字符集" class="headerlink" title="查看支持的字符集"></a>查看支持的字符集</h3><p>你可以通过 <code>SHOW CHARSET</code> 命令来查看，支持 like 和 where 子句。</p><h3 id="默认字符集"><a href="#默认字符集" class="headerlink" title="默认字符集"></a>默认字符集</h3><p>在 MySQL5.7 中，默认字符集是 <code>latin1</code> ；在 MySQL8.0 中，默认字符集是 <code>utf8mb4</code></p><h3 id="字符集的层次级别"><a href="#字符集的层次级别" class="headerlink" title="字符集的层次级别"></a>字符集的层次级别</h3><p>MySQL 中的字符集有以下的层次级别：</p><ul><li><code>server</code>（MySQL 实例级别）</li><li><code>database</code>（库级别）</li><li><code>table</code>（表级别）</li><li><code>column</code>（字段级别）</li></ul><p>它们的优先级可以简单的认为是从上往下依次增大，也即 <code>column</code> 的优先级会大于 <code>table</code> 等其余层次的。如指定 MySQL 实例级别字符集是<code>utf8mb4</code>，指定某个表字符集是<code>latin1</code>，那么这个表的所有字段如果不指定的话，编码就是<code>latin1</code>。</p><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>不同版本的 MySQL 其 <code>server</code> 级别的字符集默认值不同，在 MySQL5.7 中，其默认值是 <code>latin1</code> ；在 MySQL8.0 中，其默认值是 <code>utf8mb4</code> 。</p><p>当然也可以通过在启动 <code>mysqld</code> 时指定 <code>--character-set-server</code> 来设置 <code>server</code> 级别的字符集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqld<br>mysqld --character-set-server=utf8mb4<br>mysqld --character-set-server=utf8mb4 \<br>  --collation-server=utf8mb4_0900_ai_ci<br></code></pre></td></tr></table></figure><p>或者如果你是通过源码构建的方式启动的 MySQL，你可以在 <code>cmake</code> 命令中指定选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake . -DDEFAULT_CHARSET=latin1<br>或者<br>cmake . -DDEFAULT_CHARSET=latin1 \<br>  -DDEFAULT_COLLATION=latin1_german1_ci<br></code></pre></td></tr></table></figure><p>此外，你也可<strong>以在运行时改变 <code>character_set_server</code> 的值</strong>，从而达到修改 <code>server</code> 级别的字符集的目的。</p><p><code>server</code> 级别的字符集是 MySQL 服务器的全局设置，它不仅会作为创建或修改数据库时的默认字符集（如果没有指定其他字符集），还会影响到客户端和服务器之间的连接字符集。</p><h4 id="database"><a href="#database" class="headerlink" title="database"></a>database</h4><p><code>database</code> 级别的字符集是我们在创建数据库和修改数据库时指定的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE db_name<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> charset_name]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> collation_name]<br><br><span class="hljs-keyword">ALTER</span> DATABASE db_name<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> charset_name]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> collation_name]<br></code></pre></td></tr></table></figure><p>如前面所说，如果在执行上述语句时未指定字符集，那么 MySQL 将会使用 <code>server</code> 级别的字符集。</p><p>可以通过下面的方式查看某个数据库的字符集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE db_name;<br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@character_set_database</span>, @<span class="hljs-variable">@collation_database</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME<br><span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.SCHEMATA <span class="hljs-keyword">WHERE</span> SCHEMA_NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;db_name&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p><code>table</code> 级别的字符集是在创建表和修改表时指定的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl_name (column_list)<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> charset_name]<br>    [<span class="hljs-keyword">COLLATE</span> collation_name]]<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> charset_name]<br>    [<span class="hljs-keyword">COLLATE</span> collation_name]<br></code></pre></td></tr></table></figure><p>如果在创建表和修改表时未指定字符集，那么将会使用 <code>database</code> 级别的字符集。</p><h4 id="column"><a href="#column" class="headerlink" title="column"></a>column</h4><p><code>column</code> 级别的字符集同样是在创建表和修改表时指定的，只不过它是定义在列中。下面是个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1<br>(<br>    col1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">5</span>)<br>      <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> latin1<br>      <span class="hljs-keyword">COLLATE</span> latin1_german1_ci<br>);<br></code></pre></td></tr></table></figure><p>如果未指定列级别的字符集，那么将会使用表级别的字符集。</p><h3 id="连接字符集"><a href="#连接字符集" class="headerlink" title="连接字符集"></a>连接字符集</h3><p>前面说到了字符集的层次级别，它们是和存储相关的。而连接字符集涉及的是和 MySQL 服务器的通信。</p><p>连接字符集与下面这几个变量息息相关：</p><ul><li><code>character_set_client</code> ：描述了客户端发送给服务器的 SQL 语句使用的是什么字符集。</li><li><code>character_set_connection</code> ：描述了服务器接收到 SQL 语句时使用什么字符集进行翻译。</li><li><code>character_set_results</code> ：描述了服务器返回给客户端的结果使用的是什么字符集。</li></ul><p>它们的值可以通过下面的 SQL 语句查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> performance_schema.session_variables<br><span class="hljs-keyword">WHERE</span> VARIABLE_NAME <span class="hljs-keyword">IN</span> (<br><span class="hljs-string">&#x27;character_set_client&#x27;</span>, <span class="hljs-string">&#x27;character_set_connection&#x27;</span>,<br><span class="hljs-string">&#x27;character_set_results&#x27;</span>, <span class="hljs-string">&#x27;collation_connection&#x27;</span><br>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> VARIABLE_NAME;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> SESSION VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;character\_set\_%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>如果要想修改前面提到的几个变量的值，有以下方式：</p><p>1、修改配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">[mysql]</span><br><span class="hljs-comment"># 只针对MySQL客户端程序</span><br><span class="hljs-attr">default-character-set</span>=<span class="hljs-string">utf8mb4</span><br></code></pre></td></tr></table></figure><p>2、使用 SQL 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> names utf8mb4<br># 或者一个个进行修改<br># <span class="hljs-keyword">SET</span> character_set_client <span class="hljs-operator">=</span> utf8mb4;<br># <span class="hljs-keyword">SET</span> character_set_results <span class="hljs-operator">=</span> utf8mb4;<br># <span class="hljs-keyword">SET</span> collation_connection <span class="hljs-operator">=</span> utf8mb4;<br></code></pre></td></tr></table></figure><h3 id="JDBC-对连接字符集的影响"><a href="#JDBC-对连接字符集的影响" class="headerlink" title="JDBC 对连接字符集的影响"></a>JDBC 对连接字符集的影响</h3><p>存储 emoji 表情正常，但是使用类似 Navicat 之类的软件的进行查询的时候，发现 emoji 表情变成了问号的情况。这个问题很有可能就是 JDBC 驱动引起的。</p><p>根据前面的内容，我们知道连接字符集也是会影响我们存储的数据的，而 JDBC驱动会影响连接字符集。</p><p><code>mysql-connector-java</code> （JDBC驱动）主要通过这几个属性影响连接字符集：</p><ul><li><code>characterEncoding</code></li><li><code>characterSetResults</code></li></ul><p>以 <code>DataGrip 2023.1.2</code> 来说，在它配置数据源的高级对话框中，可以看到 <code>characterSetResults</code> 的默认值是 <code>utf8</code> ，在使用 <code>mysql-connector-java 8.0.25</code> 时，连接字符集最后会被设置成 <code>utf8mb3</code> 。那么这种情况下 emoji 表情就会被显示为问号，并且当前版本驱动还不支持把 <code>characterSetResults</code> 设置为 <code>utf8mb4</code> ，不过换成 <code>mysql-connector-java driver 8.0.29</code> 却是允许的。</p><h3 id="UTF-8-使用"><a href="#UTF-8-使用" class="headerlink" title="UTF-8 使用"></a>UTF-8 使用</h3><p>通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。</p><p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p><ul><li>**<code>utf8</code>**：<code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li><li>**<code>utf8mb4</code>**：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li></ul><p><strong>为什么有两套 UTF-8 编码实现呢？</strong> 原因如下：</p><p><img src="https://oss.javaguide.cn/javaguide/image-20211008164542347.png" alt="img"></p><p>因此，如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code> 而不是<code>utf8</code> ，要不然存储的时候就会报错了。</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基础知识.md</title>
    <link href="/2024/02/27/DB/basic_knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/02/27/DB/basic_knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h2><ul><li><strong>数据库</strong> : 数据库(DataBase 简称 DB) 就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li></ul><h2 id="什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h2><ul><li><strong>元组</strong>：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li><li><strong>码</strong>：码就是能唯一标识实体的属性，对应表中的列。</li><li><strong>候选码</strong>：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li><li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li><li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li><strong>主属性</strong>：候选码中出现过的属性称为主属性。比如关系工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li></ul><h2 id="什么是-ER-图？"><a href="#什么是-ER-图？" class="headerlink" title="什么是 ER 图？"></a>什么是 ER 图？</h2><p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。</p><p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。</p><p>ER 图由下面 3 个要素组成：</p><ul><li><strong>实体</strong>：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li><li><strong>属性</strong>：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。</li><li><strong>联系</strong>：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li></ul><p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img/notes/202403262048749.png" alt="image-20231122134500348">学生与课程之间联系的E-R图</p><h2 id="数据库范式了解吗"><a href="#数据库范式了解吗" class="headerlink" title="数据库范式了解吗?"></a>数据库范式了解吗?</h2><p>数据库范式有 3 种：</p><ul><li>1NF(第一范式)：属性不可再分。</li><li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul><h3 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p><h3 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h3><p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img/notes/202403262048750.png" alt="image-20231122134522783"></p><p>一些重要的概念：</p><ul><li><strong>函数依赖（functional dependency）</strong>：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li><li><strong>部分函数依赖（partial functional dependency）</strong>：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖于（学号，身份证号）；</li><li>**完全函数依赖(Full functional dependency)**：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li><li><strong>传递函数依赖</strong>：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li></ul><h3 id="3NF-第三范式"><a href="#3NF-第三范式" class="headerlink" title="3NF(第三范式)"></a>3NF(第三范式)</h3><p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p><h2 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别?"></a>主键和外键有什么区别?</h2><ul><li>**主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li>**外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h2 id="为什么不推荐使用外键与级联？"><a href="#为什么不推荐使用外键与级联？" class="headerlink" title="为什么不推荐使用外键与级联？"></a>为什么不推荐使用外键与级联？</h2><blockquote><p>  对于外键和级联，阿里巴巴开发手册这样说到：</p><p>  【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p><p>  说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度</p></blockquote><p>为什么不要用外键呢？大部分人可能会这样回答：</p><ol><li><strong>增加了复杂性：</strong> a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li><li><strong>增加了额外工作</strong>：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li><li><strong>对分库分表不友好</strong>：因为分库分表下外键是无法生效的。</li><li>……</li></ol><p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p><ol><li>保证了数据库数据的一致性和完整性；</li><li>级联操作方便，减轻了程序代码量；</li><li>……</li></ol><p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p><h2 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程?"></a>什么是存储过程?</h2><p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p><p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p><p>阿里巴巴 Java 开发手册里要求<strong>禁止使用存储过程</strong>。</p><h2 id="drop、delete-与-truncate-区别？"><a href="#drop、delete-与-truncate-区别？" class="headerlink" title="drop、delete 与 truncate 区别？"></a>drop、delete 与 truncate 区别？</h2><h3 id="用法不同"><a href="#用法不同" class="headerlink" title="用法不同"></a>用法不同</h3><ul><li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li><li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li></ul><p><code>truncate</code> 和不带 <code>where</code>子句的 <code>delete</code>、以及 <code>drop</code> 都会删除表内的数据，但是 <strong><code>truncate</code> 和 <code>delete</code> 只删除数据不删除表的结构(定义)，执行 <code>drop</code> 语句，此表的结构也会删除，也就是执行<code>drop</code> 之后对应的表不复存在。</strong></p><h3 id="属于不同的数据库语言"><a href="#属于不同的数据库语言" class="headerlink" title="属于不同的数据库语言"></a>属于不同的数据库语言</h3><p><code>truncate</code> 和 <code>drop</code> 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 <code>delete</code> 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。</p><p><strong>DML 语句和 DDL 语句区别：</strong></p><ul><li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li><li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li></ul><p>另外，由于<code>select</code>不会对表进行破坏，所以有的地方也会把<code>select</code>单独区分开叫做数据库查询语言 DQL（Data Query Language）。</p><h3 id="执行速度不同"><a href="#执行速度不同" class="headerlink" title="执行速度不同"></a>执行速度不同</h3><p>一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code>（个人没有实际测试过）</p><ul><li><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li><li><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li><li><code>drop</code>命令会把表占用的空间全部释放掉。</li></ul><p>Tips：应该更多地关注在使用场景上，而不是执行效率。</p><h2 id="数据库设计通常分为哪几步"><a href="#数据库设计通常分为哪几步" class="headerlink" title="数据库设计通常分为哪几步?"></a>数据库设计通常分为哪几步?</h2><ol><li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li></ol>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基本语法</title>
    <link href="/2023/08/28/DB/MySQL/MySQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/08/28/DB/MySQL/MySQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 别名 <span class="hljs-keyword">as</span> 可省略，但中间需要空格<br>select name <span class="hljs-keyword">as</span> 员工姓名, position <span class="hljs-keyword">as</span> 职位名称 <span class="hljs-keyword">from</span> employees;<br></code></pre></td></tr></table></figure><h4 id="常量和运算"><a href="#常量和运算" class="headerlink" title="常量和运算"></a>常量和运算</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">select <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;篮球&#x27;</span> <span class="hljs-keyword">as</span> hobby;<br>select order_id, unit_price, quantity, unit_price * quantity <span class="hljs-keyword">as</span> total_amount <span class="hljs-keyword">from</span> orders;<br></code></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">select name, age, salary <span class="hljs-keyword">from</span> employees where age between <span class="hljs-number">25</span> and <span class="hljs-number">30</span>;<br>select name, age, salary <span class="hljs-keyword">from</span> employees where salary &gt; <span class="hljs-number">5500</span>;<br>select name, age, salary <span class="hljs-keyword">from</span> employees where name != <span class="hljs-string">&#x27;小张&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">-- <span class="hljs-variable constant_">SQL</span>查询语句<br>select name, age <span class="hljs-keyword">from</span> employees where hire_date <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NULL</span>;<br><br>select name, age <span class="hljs-keyword">from</span> employees where hire_date <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>;<br></code></pre></td></tr></table></figure><h4 id="模糊查询-like-not-like"><a href="#模糊查询-like-not-like" class="headerlink" title="模糊查询 like, not like _ %"></a>模糊查询 like, not like _ %</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">select name, age, position <span class="hljs-keyword">from</span> employees where name like <span class="hljs-string">&#x27;%张%&#x27;</span>;<br>-- 只查询以 <span class="hljs-string">&quot;张&quot;</span> 开头的数据行<br>select name, age, position <span class="hljs-keyword">from</span> employees where name like <span class="hljs-string">&#x27;张%&#x27;</span>;<br><br>-- 只查询以 <span class="hljs-string">&quot;张&quot;</span> 结尾的数据行<br>select name, age, position <span class="hljs-keyword">from</span> employees where name like <span class="hljs-string">&#x27;%张&#x27;</span>;<br>-- 可以使用 not like 来查询不包含某关键字的信息。<br></code></pre></td></tr></table></figure><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>AND OR NOT</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">-- <span class="hljs-variable constant_">SQL</span>查询语句<br>select name, age, salary <span class="hljs-keyword">from</span> employees where name like <span class="hljs-string">&#x27;%李%&#x27;</span> and age &lt; <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- <span class="hljs-variable constant_">SQL</span> 查询语句 使用<span class="hljs-variable constant_">DISTINCT</span>关键字来找出不同的班级 <span class="hljs-variable constant_">ID</span><br>select distinct class_id <span class="hljs-keyword">from</span> students;<br>-- <span class="hljs-variable constant_">DISTINCT</span> 关键字还支持根据多个字段的组合来进行去重操作，确保多个字段的组合是唯一的。<br></code></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">-- <span class="hljs-variable constant_">SQL</span> 查询语句 <span class="hljs-number">1</span><br>select name, age <span class="hljs-keyword">from</span> students order by age asc;<br><br>-- <span class="hljs-variable constant_">SQL</span> 查询语句 <span class="hljs-number">2</span><br>select name, score <span class="hljs-keyword">from</span> students order by score desc;<br></code></pre></td></tr></table></figure><h4 id="截断、偏移"><a href="#截断、偏移" class="headerlink" title="截断、偏移"></a>截断、偏移</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">-- <span class="hljs-variable constant_">LIMIT</span> 后只跟一个整数，表示要截断的数据条数（一次获取几条）<br>select task_name, due_date <span class="hljs-keyword">from</span> tasks limit <span class="hljs-number">2</span>;<br><br>-- <span class="hljs-variable constant_">LIMIT</span> 后跟 <span class="hljs-number">2</span> 个整数，依次表示从第几条数据开始、一次获取几条<br>select task_name, due_date <span class="hljs-keyword">from</span> tasks limit <span class="hljs-number">2</span>, <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h4 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span><br>  name,<br>  <span class="hljs-variable constant_">CASE</span> <span class="hljs-variable constant_">WHEN</span> (name = <span class="hljs-string">&#x27;鸡哥&#x27;</span>) <span class="hljs-variable constant_">THEN</span> <span class="hljs-string">&#x27;会&#x27;</span> <span class="hljs-variable constant_">ELSE</span> <span class="hljs-string">&#x27;不会&#x27;</span> <span class="hljs-variable constant_">END</span> <span class="hljs-variable constant_">AS</span> can_rap<br><span class="hljs-variable constant_">FROM</span><br>  student;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">CASE</span> <span class="hljs-variable constant_">WHEN</span> (条件<span class="hljs-number">1</span>) <span class="hljs-variable constant_">THEN</span> 结果<span class="hljs-number">1</span><br>   <span class="hljs-variable constant_">WHEN</span> (条件<span class="hljs-number">2</span>) <span class="hljs-variable constant_">THEN</span> 结果<span class="hljs-number">2</span><br>   ...<br>   <span class="hljs-variable constant_">ELSE</span> 其他结果 <span class="hljs-variable constant_">END</span><br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 获取当前日期<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">DATE</span>() <span class="hljs-variable constant_">AS</span> current_date;<br><br>-- 获取当前日期时间<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">DATETIME</span>() <span class="hljs-variable constant_">AS</span> current_datetime;<br><br>-- 获取当前时间<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">TIME</span>() <span class="hljs-variable constant_">AS</span> current_time;<br>-- 这里的日期、日期时间和时间将根据当前的系统时间来生成，实际运行结果可能会因为当前时间而不同。<br></code></pre></td></tr></table></figure><h4 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">round</span>(<span class="hljs-title function_">AVG</span>(grade),<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 将姓名转换为大写<br><span class="hljs-variable constant_">SELECT</span> name, <span class="hljs-title function_">UPPER</span>(name) <span class="hljs-variable constant_">AS</span> upper_name<br><span class="hljs-variable constant_">FROM</span> employees;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 计算姓名长度<br><span class="hljs-variable constant_">SELECT</span> name, <span class="hljs-title function_">LENGTH</span>(name) <span class="hljs-variable constant_">AS</span> name_length<br><span class="hljs-variable constant_">FROM</span> employees;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 将姓名转换为小写并进行条件筛选<br><span class="hljs-variable constant_">SELECT</span> name, <span class="hljs-title function_">LOWER</span>(name) <span class="hljs-variable constant_">AS</span> lower_name<br><span class="hljs-variable constant_">FROM</span> employees;<br></code></pre></td></tr></table></figure><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li><p>COUNT：计算指定列的行数或非空值的数量。<br>当Mysql确认括号内的表达式值不可能为NULL时，实际上就是在统计行数。<br>所以使用条件要加一个COUNT(c.action &#x3D; ‘confirmed’ OR NULL)<br>不为confirmed时用NULL代替，NULL不会被COUNT统计</p></li><li><p>SUM：计算指定列的数值之和。</p></li><li><p>AVG：计算指定列的数值平均值。</p></li><li><p>MAX：找出指定列的最大值。</p></li><li><p>MIN：找出指定列的最小值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用聚合函数 <span class="hljs-variable constant_">COUNT</span> 计算订单表中的总订单数<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">COUNT</span>(*) <span class="hljs-variable constant_">AS</span> order_num<br><span class="hljs-variable constant_">FROM</span> orders;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用聚合函数 <span class="hljs-title function_">COUNT</span>(<span class="hljs-variable constant_">DISTINCT</span> 列名) 计算订单表中不同客户的数量<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">COUNT</span>(<span class="hljs-variable constant_">DISTINCT</span> customer_id) <span class="hljs-variable constant_">AS</span> customer_num<br><span class="hljs-variable constant_">FROM</span> orders;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用聚合函数 <span class="hljs-variable constant_">SUM</span> 计算总订单金额<br><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">SUM</span>(amount) <span class="hljs-variable constant_">AS</span> total_amount<br><span class="hljs-variable constant_">FROM</span> orders;<br></code></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h4 id="字段分组"><a href="#字段分组" class="headerlink" title="字段分组"></a>字段分组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用分组聚合查询中每个客户的编号<br><span class="hljs-variable constant_">SELECT</span> customer_id<br><span class="hljs-variable constant_">FROM</span> orders<br><span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> customer_id;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用分组聚合查询每个客户的下单数<br><span class="hljs-variable constant_">SELECT</span> customer_id, <span class="hljs-title function_">COUNT</span>(order_id) <span class="hljs-variable constant_">AS</span> order_num<br><span class="hljs-variable constant_">FROM</span> orders<br><span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> customer_id;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用多字段分组查询表中 每个客户 购买的 每种商品 的总金额，相当于按照客户编号和商品编号分组<br><span class="hljs-variable constant_">SELECT</span> customer_id, product_id, <span class="hljs-title function_">SUM</span>(amount) <span class="hljs-variable constant_">AS</span> total_amount<br><span class="hljs-variable constant_">FROM</span> orders<br><span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> customer_id, product_id;<br></code></pre></td></tr></table></figure><h4 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用 <span class="hljs-variable constant_">HAVING</span> 子句查询订单数超过 <span class="hljs-number">1</span> 的客户<br><br><span class="hljs-variable constant_">SELECT</span> customer_id, <span class="hljs-title function_">COUNT</span>(order_id) <span class="hljs-variable constant_">AS</span> order_num<br><span class="hljs-variable constant_">FROM</span> orders<br><span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> customer_id<br><span class="hljs-variable constant_">HAVING</span> <span class="hljs-title function_">COUNT</span>(order_id) &gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 使用 <span class="hljs-variable constant_">HAVING</span> 子句查询订单总金额超过 <span class="hljs-number">100</span> 的客户<br><span class="hljs-variable constant_">SELECT</span> customer_id, <span class="hljs-title function_">SUM</span>(amount) <span class="hljs-variable constant_">AS</span> total_amount<br><span class="hljs-variable constant_">FROM</span> orders<br><span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> customer_id<br><span class="hljs-variable constant_">HAVING</span> <span class="hljs-title function_">SUM</span>(amount) &gt; <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><h4 id="CROSS-JOIN"><a href="#CROSS-JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h4><p>是一种简单的关联查询，不需要任何条件来匹配行，它直接将左表的 每一行 与右表的 每一行 进行组合，返回的结果是两个表的笛卡尔积。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> e.<span class="hljs-property">emp_name</span>, e.<span class="hljs-property">salary</span>, e.<span class="hljs-property">department</span>, d.<span class="hljs-property">manager</span><br><span class="hljs-variable constant_">FROM</span> employees e<br><span class="hljs-variable constant_">CROSS</span> <span class="hljs-variable constant_">JOIN</span> departments d;<br></code></pre></td></tr></table></figure><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><p>只返回两个表中满足关联条件的交集部分，即在两个表中都存在的匹配行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> e.<span class="hljs-property">emp_name</span>, e.<span class="hljs-property">salary</span>, e.<span class="hljs-property">department</span>, d.<span class="hljs-property">manager</span><br><span class="hljs-variable constant_">FROM</span> employees e<br><span class="hljs-variable constant_">JOIN</span> departments d <span class="hljs-variable constant_">ON</span> e.<span class="hljs-property">department</span> = d.<span class="hljs-property">department</span>;<br></code></pre></td></tr></table></figure><h4 id="OUTER-JOIN"><a href="#OUTER-JOIN" class="headerlink" title="OUTER JOIN"></a>OUTER JOIN</h4><p>根据指定的关联条件，将两个表中满足条件的行组合在一起，并包含没有匹配的行 。<br>包括 LEFT OUTER JOIN 和 RIGHT OUTER JOIN 两种类型，分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分。有些数据库并不支持 RIGHT JOIN 语法，只需要把主表（from 后面的表）和关联表（LEFT JOIN 后面的表）顺序进行调换即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> e.<span class="hljs-property">emp_name</span>, e.<span class="hljs-property">salary</span>, e.<span class="hljs-property">department</span>, d.<span class="hljs-property">manager</span><br><span class="hljs-variable constant_">FROM</span> employees e<br><span class="hljs-variable constant_">LEFT</span> <span class="hljs-variable constant_">JOIN</span> departments d <span class="hljs-variable constant_">ON</span> e.<span class="hljs-property">department</span> = d.<span class="hljs-property">department</span>;<br></code></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 查询出订单总金额 &gt; <span class="hljs-number">200</span> 的客户的姓名和他们的订单总金额<br>-- 主查询<br><span class="hljs-variable constant_">SELECT</span> name, total_amount<br><span class="hljs-variable constant_">FROM</span> customers<br><span class="hljs-variable constant_">WHERE</span> customer_id <span class="hljs-variable constant_">IN</span> (<br>    -- 子查询<br>    <span class="hljs-variable constant_">SELECT</span> <span class="hljs-variable constant_">DISTINCT</span> customer_id<br>    <span class="hljs-variable constant_">FROM</span> orders<br>    <span class="hljs-variable constant_">WHERE</span> total_amount &gt; <span class="hljs-number">200</span><br>);<br></code></pre></td></tr></table></figure><p><strong>exists</strong><br>用于检查主查询的结果集是否存在满足条件的记录，它返回布尔值（True 或 False），而不返回实际的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 主查询<br><span class="hljs-variable constant_">SELECT</span> name, total_amount<br><span class="hljs-variable constant_">FROM</span> customers<br><span class="hljs-variable constant_">WHERE</span> <span class="hljs-variable constant_">EXISTS</span> (<br>    -- 子查询<br>    <span class="hljs-variable constant_">SELECT</span> <span class="hljs-number">1</span><br>    <span class="hljs-variable constant_">FROM</span> orders<br>    <span class="hljs-variable constant_">WHERE</span> orders.<span class="hljs-property">customer_id</span> = customers.<span class="hljs-property">customer_id</span><br>);<br></code></pre></td></tr></table></figure><h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><ul><li><strong>UNION</strong> 操作：将两个或多个查询的结果集合并， 并去除重复的行 。即如果两个查询的结果有相同的行，则只保留一行。</li><li><strong>UNION ALL</strong> 操作：将两个或多个查询的结果集合并， 但不去除重复的行 。即如果两个查询的结果有相同的行，则全部保留。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> name, age, department<br><span class="hljs-variable constant_">FROM</span> table1<br><span class="hljs-variable constant_">UNION</span><br><span class="hljs-variable constant_">SELECT</span> name, age, department<br><span class="hljs-variable constant_">FROM</span> table2;<br></code></pre></td></tr></table></figure></li></ul><h2 id="开窗函数"><a href="#开窗函数" class="headerlink" title="开窗函数"></a>开窗函数</h2><h4 id="sum-over"><a href="#sum-over" class="headerlink" title="sum over"></a>sum over</h4><p>SUM(计算字段名) OVER (PARTITION BY 分组字段名)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> <br>    order_id, <br>    customer_id, <br>    order_date, <br>    total_amount,<br>    <span class="hljs-title function_">SUM</span>(total_amount) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> customer_id) <span class="hljs-variable constant_">AS</span> customer_total_amount<br><span class="hljs-variable constant_">FROM</span><br>    orders;<br></code></pre></td></tr></table></figure><h4 id="sum-over-order-by"><a href="#sum-over-order-by" class="headerlink" title="sum over order by"></a>sum over order by</h4><p>SUM(计算字段名) OVER (PARTITION BY 分组字段名 ORDER BY 排序字段 排序规则)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">-- 计算每个客户的历史订单累计金额，并显示每个订单的详细信息<br><br><span class="hljs-variable constant_">SELECT</span> <br>    order_id, <br>    customer_id, <br>    order_date, <br>    total_amount,<br>    <span class="hljs-title function_">SUM</span>(total_amount) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> customer_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> order_date <span class="hljs-variable constant_">ASC</span>) <span class="hljs-variable constant_">AS</span> cumulative_total_amount<br><span class="hljs-variable constant_">FROM</span><br>    orders;<br></code></pre></td></tr></table></figure><h4 id="rank"><a href="#rank" class="headerlink" title="rank"></a>rank</h4><p>用于对查询结果集中的行进行 排名 的开窗函数。可以根据指定的列或表达式对结果集中的行进行排序，并为每一行分配一个排名。<br>在排名过程中，相同的值将被赋予相同的排名，而不同的值将被赋予不同的排名。<br>常见用法是在查询结果中查找前几名（Top N）或排名最高的行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">RANK</span>() <span class="hljs-variable constant_">OVER</span> (<br>  <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> 列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>, ... -- 可选，用于指定分组列<br>  <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> 列名<span class="hljs-number">3</span> [<span class="hljs-variable constant_">ASC</span>|<span class="hljs-variable constant_">DESC</span>], 列名<span class="hljs-number">4</span> [<span class="hljs-variable constant_">ASC</span>|<span class="hljs-variable constant_">DESC</span>], ... -- 用于指定排序列及排序方式<br>) <span class="hljs-variable constant_">AS</span> rank_column<br><span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> 子句可选，用于指定分组列，将结果集按照指定列进行分组；<br><span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> 子句用于指定排序列及排序方式，决定了计算 <span class="hljs-title class_">Rank</span> 时的排序规则。<br><span class="hljs-variable constant_">AS</span> rank_column 用于指定生成的 <span class="hljs-title class_">Rank</span> 排名列的别名。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> <br>    order_id, <br>    customer_id, <br>    order_date, <br>    total_amount,<br>    <span class="hljs-title function_">RANK</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> customer_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> total_amount <span class="hljs-variable constant_">DESC</span>) <span class="hljs-variable constant_">AS</span> customer_rank<br><span class="hljs-variable constant_">FROM</span><br>    orders;<br></code></pre></td></tr></table></figure><h4 id="row-number"><a href="#row-number" class="headerlink" title="row_number"></a>row_number</h4><p>用于为查询结果集中的每一行分配唯一连续排名。<br>Row_Number函数为每一行都分配一个唯一的整数值，不管是否存在并列（相同排序值）的情况。<br>每一行都有一个唯一的行号，从 1 开始连续递增。</p><p>Row_Number 开窗函数的语法如下（几乎和 Rank 函数一模一样）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">ROW_NUMBER</span>() <span class="hljs-variable constant_">OVER</span> (<br>  <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column1, column2, ... -- 可选，用于指定分组列<br>  <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column3 [<span class="hljs-variable constant_">ASC</span>|<span class="hljs-variable constant_">DESC</span>], column4 [<span class="hljs-variable constant_">ASC</span>|<span class="hljs-variable constant_">DESC</span>], ... -- 用于指定排序列及排序方式<br>) <span class="hljs-variable constant_">AS</span> row_number_column<br><span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span>子句可选，用于指定分组列，将结果集按照指定列进行分组。<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> 子句用于指定排序列及排序方式，决定了计算 <span class="hljs-title class_">Row</span>_Number 时的排序规则。<span class="hljs-variable constant_">AS</span> row_number_column 用于指定生成的行号列的别名。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> <br>    order_id, <br>    customer_id, <br>    order_date, <br>    total_amount,<br>    <span class="hljs-title function_">ROW_NUMBER</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> customer_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> total_amount <span class="hljs-variable constant_">DESC</span>) <span class="hljs-variable constant_">AS</span> row_number<br><span class="hljs-variable constant_">FROM</span><br>    orders;<br></code></pre></td></tr></table></figure><h4 id="lag-lead"><a href="#lag-lead" class="headerlink" title="lag &#x2F; lead"></a>lag &#x2F; lead</h4><p>在需要比较相邻行数据或进行时间序列分析时非常有用。</p><ul><li><p>Lag 函数用于获取当前行之前的某一列的值。Lag 函数的语法如下：<br>LAG(column_name, offset, default_value) OVER (PARTITION BY partition_column ORDER BY sort_column)<br>参数解释：<br>column_name：要获取值的列名。<br>offset：表示要向上偏移的行数。例如，offset为1表示获取上一行的值，offset为2表示获取上两行的值，以此类推。<br>default_value：可选参数，用于指定当没有前一行时的默认值。<br>PARTITION BY和ORDER BY子句可选，用于分组和排序数据。</p></li><li><p>Lead 函数用于获取 当前行之后 的某一列的值。Lead 函数的语法如下：<br>LEAD(column_name, offset, default_value) OVER (PARTITION BY partition_column ORDER BY sort_column)<br>参数解释：<br>column_name：要获取值的列名。<br>offset：表示要向下偏移的行数。例如，offset为1表示获取下一行的值，offset为2表示获取下两行的值，以此类推。<br>default_value：可选参数，用于指定当没有后一行时的默认值。<br>PARTITION BY和ORDER BY子句可选，用于分组和排序数据。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">SELECT</span> <br>    student_id,<br>    exam_date,<br>    score,<br>    <span class="hljs-title function_">LAG</span>(score, <span class="hljs-number">1</span>, <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> student_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> exam_date) <span class="hljs-variable constant_">AS</span> previous_score,<br>    <span class="hljs-title function_">LEAD</span>(score, <span class="hljs-number">1</span>, <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> student_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> exam_date) <span class="hljs-variable constant_">AS</span> next_score<br><span class="hljs-variable constant_">FROM</span><br>    scores;<br></code></pre></td></tr></table></figure><p>整理自网站SQL之母<a href="http://sqlmother.yupi.icu/#/learn%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%BF%87%EF%BC%8C%E4%BD%86%E8%AE%B0%E4%B8%8D%E4%BD%8F%EF%BC%8C%E5%8D%95%E7%8B%AC%E6%9F%A5%E7%9C%8B%E5%A4%AA%E9%BA%BB%E7%83%A6%EF%BC%8C%E6%89%80%E4%BB%A5%E6%95%B4%E7%90%86%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9C%8B%EF%BC%89">http://sqlmother.yupi.icu/#/learn（学习过，但记不住，单独查看太麻烦，所以整理给自己看）</a></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1578.  使绳子变成彩色的最短时间</title>
    <link href="/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201578.%20%20%E4%BD%BF%E7%BB%B3%E5%AD%90%E5%8F%98%E6%88%90%E5%BD%A9%E8%89%B2%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4/"/>
    <url>/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201578.%20%20%E4%BD%BF%E7%BB%B3%E5%AD%90%E5%8F%98%E6%88%90%E5%BD%A9%E8%89%B2%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>拆除成本 &#x3D; 全部拆除 - 最大的不拆除</li><li>在统计成本的同时，维持一个成本的最大值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">minCost</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> colors, int[] neededTime</span>) &#123;<br>    <br>        int res = <span class="hljs-number">0</span>;<br>        int i = <span class="hljs-number">0</span>;<br>        int len = colors.<span class="hljs-title function_">length</span>();<br>        <span class="hljs-keyword">while</span> (i &lt; len) &#123;<br>    <br>            int max = -<span class="hljs-number">1</span>;<br>            int sum = <span class="hljs-number">0</span>;<br>            char ch = colors.<span class="hljs-title function_">charAt</span>(i);<br>            <span class="hljs-keyword">while</span>(i &lt; len &amp;&amp; colors.<span class="hljs-title function_">charAt</span>(i) == ch) &#123;<br>    <br>                sum += neededTime[i];<br>                max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, neededTime[i]);<br>                i++;<br>            &#125;<br>            res += sum - max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1048. 最长字符串链</title>
    <link href="/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201048.%20%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE/"/>
    <url>/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201048.%20%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>从短到长，增加字母的话，有多个位置，并且每个位置都有26种选择，正难则反。选择从长到短，删除某个字母。</li><li>删除字母得到的新字符串可能已经计算过，所以将计算的结果都记录一下。</li><li>记忆化搜索： 先查表再计算，先存表再返回。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br><span class="hljs-comment">//记忆化</span><br>    <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Integer</span>&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    public int <span class="hljs-title function_">longestStrChain</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] words</span>) &#123;<br>    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> <span class="hljs-attr">str</span>: words) &#123;<br>    <br>            hashMap.<span class="hljs-title function_">put</span>(str, <span class="hljs-number">0</span>);<br>        &#125;<br>        int ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> str : words) &#123;<br>    <br>            ans = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(ans, <span class="hljs-title function_">dfs</span>(str));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    private int <span class="hljs-title function_">dfs</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> str</span>) &#123;<br>    <br>        int res = hashMap.<span class="hljs-title function_">get</span>(str);<br>        <span class="hljs-comment">//大于0代表曾经计算过</span><br>        <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">0</span>) &#123;<br>    <br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-title function_">length</span>(); i++) &#123;<br>    <br>            <span class="hljs-title class_">String</span> tmp = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, i) + str.<span class="hljs-title function_">substring</span>(i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (hashMap.<span class="hljs-title function_">containsKey</span>(tmp)) &#123;<br>    <br>                res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, <span class="hljs-title function_">dfs</span>(tmp));<br>            &#125;<br>        &#125;<br>        hashMap.<span class="hljs-title function_">put</span>(str, res + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1387. 将整数按权重排序</title>
    <link href="/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201387.%20%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201387.%20%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>首先是这种计算权重的方式很有可能出现重复，所以需要记忆化搜索</li><li>记忆化搜索：先查表再计算，先存表再返回。</li><li>将整数 x 和计算的权重分别存储数组的0和1的位置</li><li>重写compare将数组排序按规则排序</li><li>返回结果</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    private <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">Integer</span>, <span class="hljs-title class_">Integer</span>&gt; me = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    public int <span class="hljs-title function_">getKth</span>(<span class="hljs-params">int lo, int hi, int k</span>) &#123;<br>    <br>        int[][] arr = <span class="hljs-keyword">new</span> int[hi - lo + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (int i = lo; i &lt;= hi; i++) &#123;<br>    <br>            int tmp = <span class="hljs-title function_">dfs</span>(i);<br>            me.<span class="hljs-title function_">put</span>(i, tmp);<br>            arr[i - lo][<span class="hljs-number">0</span>] = i;<br>            arr[i - lo][<span class="hljs-number">1</span>] = tmp;<br>        &#125;<br>        <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">sort</span>(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;int[]&gt;() &#123;<br>    <br>            @<span class="hljs-title class_">Override</span><br>            public int <span class="hljs-title function_">compare</span>(<span class="hljs-params">int[] o1, int[] o2</span>) &#123;<br>    <br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] == o2[<span class="hljs-number">1</span>] ? o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>] : o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">return</span> arr[k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br><br>    int <span class="hljs-title function_">dfs</span>(<span class="hljs-params">int x</span>) &#123;<br>    <br>        int res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(me.<span class="hljs-title function_">get</span>(x) != <span class="hljs-literal">null</span>)&#123;<br>    <br>            res = me.<span class="hljs-title function_">get</span>(x);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) &#123;<br>    <br>            res = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>    <br>            res = <span class="hljs-number">1</span> + <span class="hljs-title function_">dfs</span>(x * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>    <br>            res = <span class="hljs-number">1</span> + <span class="hljs-title function_">dfs</span>(x / <span class="hljs-number">2</span>);<br>        &#125;<br>        me.<span class="hljs-title function_">put</span>(x, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1218. 最长定差子序列</title>
    <link href="/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201218.%20%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2023/08/19/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201218.%20%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>因为不能改变顺序，所以后面的元素，直接看它前面的元素就行。</li><li>长度为n的数组 &#x3D; 长度为n - 1的数组 + 第 n 个数</li><li>从前向后遍历，对于每个元素，如果能找到它的前一个元素，就在前一个元素的基础上+1，否则就录入1。</li><li>同时记录录入的数据的最大值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">longestSubsequence</span>(<span class="hljs-params">int[] arr, int difference</span>) &#123;<br>    <br>        <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">Integer</span>, <span class="hljs-title class_">Integer</span>&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        int res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <br>            int temp = hashMap.<span class="hljs-title function_">getOrDefault</span>(arr[i] - difference, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            hashMap.<span class="hljs-title function_">put</span>(arr[i], temp);<br>            res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实战</title>
    <link href="/2023/05/17/Redis/Redis%E5%AE%9E%E6%88%98/"/>
    <url>/2023/05/17/Redis/Redis%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="实战篇Redis"><a href="#实战篇Redis" class="headerlink" title="实战篇Redis"></a>实战篇Redis</h1><h2 id="开篇导读"><a href="#开篇导读" class="headerlink" title="开篇导读"></a>开篇导读</h2><ul><li>短信登录</li></ul><p>使用redis共享session来实现</p><ul><li>商户查询缓存</li></ul><p>理解缓存击穿，缓存穿透，缓存雪崩等问题</p><ul><li>优惠卷秒杀</li></ul><p>Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p><ul><li>附近的商户</li></ul><p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p><ul><li>UV统计</li></ul><p>主要是使用Redis来完成统计功能</p><ul><li>用户签到</li></ul><p>使用Redis的BitMap数据统计功能</p><ul><li>好友关注</li></ul><p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p><ul><li>打人探店</li></ul><p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p><p>以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302007.png" alt="1653056228879"></p><h2 id="1、短信登录"><a href="#1、短信登录" class="headerlink" title="1、短信登录"></a>1、短信登录</h2><h3 id="1-1、导入黑马点评项目"><a href="#1-1、导入黑马点评项目" class="headerlink" title="1.1、导入黑马点评项目"></a>1.1、导入黑马点评项目</h3><h4 id="1-1-1-、导入SQL"><a href="#1-1-1-、导入SQL" class="headerlink" title="1.1.1 、导入SQL"></a>1.1.1 、导入SQL</h4><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302008.png" alt="1653057872536"></p><h4 id="1-1-2、有关当前模型"><a href="#1-1-2、有关当前模型" class="headerlink" title="1.1.2、有关当前模型"></a>1.1.2、有关当前模型</h4><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p><p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302010.png" alt="1653059409865"></p><h4 id="1-1-3、导入后端项目"><a href="#1-1-3、导入后端项目" class="headerlink" title="1.1.3、导入后端项目"></a>1.1.3、导入后端项目</h4><p>在资料中提供了一个项目源码：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302011.png" alt="1653060237073"></p><h4 id="1-1-4、导入前端工程"><a href="#1-1-4、导入前端工程" class="headerlink" title="1.1.4、导入前端工程"></a>1.1.4、导入前端工程</h4><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302012.png" alt="1653060337562"></p><h4 id="1-1-5-运行前端项目"><a href="#1-1-5-运行前端项目" class="headerlink" title="1.1.5 运行前端项目"></a>1.1.5 运行前端项目</h4><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302013.png" alt="1653060588190"></p><h3 id="1-2-、基于Session实现登录流程"><a href="#1-2-、基于Session实现登录流程" class="headerlink" title="1.2 、基于Session实现登录流程"></a>1.2 、基于Session实现登录流程</h3><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户。</p><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302014.png" alt="1653066208144"></p><h3 id="1-3-、实现发送短信验证码功能"><a href="#1-3-、实现发送短信验证码功能" class="headerlink" title="1.3 、实现发送短信验证码功能"></a>1.3 、实现发送短信验证码功能</h3><p><strong>页面流程</strong></p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302015.png" alt="1653067054461"></p><p><strong>具体代码如下</strong></p><p><strong>贴心小提示：</strong></p><p>具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。</p><ul><li>发送验证码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.符合，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br><br>    <span class="hljs-comment">// 4.保存验证码到 session</span><br>    session.setAttribute(<span class="hljs-string">&quot;code&quot;</span>,code);<br>    <span class="hljs-comment">// 5.发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);<br>    <span class="hljs-comment">// 返回ok</span><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>登录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.校验验证码</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;code&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-keyword">if</span>(cacheCode == <span class="hljs-literal">null</span> || !cacheCode.toString().equals(code))&#123;<br>         <span class="hljs-comment">//3.不一致，报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//一致，根据手机号查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br><br>    <span class="hljs-comment">//5.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//不存在，则创建</span><br>        user =  createUserWithPhone(phone);<br>    &#125;<br>    <span class="hljs-comment">//7.保存用户信息到session中</span><br>    session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4、实现登录拦截功能"><a href="#1-4、实现登录拦截功能" class="headerlink" title="1.4、实现登录拦截功能"></a>1.4、实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302017.png" alt="1653068196656"></p><p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p><p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><p><strong>温馨小贴士：关于threadlocal</strong></p><p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302018.png" alt="1653068874258"></p><p>拦截器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-comment">//1.获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">//2.获取session中的用户</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">//3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>              <span class="hljs-comment">//4.不存在，拦截，返回401状态码</span><br>              response.setStatus(<span class="hljs-number">401</span>);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//5.存在，保存用户信息到Threadlocal</span><br>        UserHolder.saveUser((User)user);<br>        <span class="hljs-comment">//6.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>让拦截器生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 登录拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<br>                        <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/voucher/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/login&quot;</span><br>                ).order(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// token刷新的拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5、隐藏用户敏感信息"><a href="#1-5、隐藏用户敏感信息" class="headerlink" title="1.5、隐藏用户敏感信息"></a>1.5、隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p><p><strong>在登录方法处修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//7.保存用户信息到session中</span><br>session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, BeanUtils.copyProperties(user,UserDTO.class));<br></code></pre></td></tr></table></figure><p><strong>在拦截器处：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//5.存在，保存用户信息到Threadlocal</span><br>UserHolder.saveUser((UserDTO) user);<br></code></pre></td></tr></table></figure><p><strong>在UserHolder处：将user对象换成UserDTO</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(UserDTO user)</span>&#123;<br>        tl.set(user);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDTO <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> tl.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeUser</span><span class="hljs-params">()</span>&#123;<br>        tl.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6、session共享问题"><a href="#1-6、session共享问题" class="headerlink" title="1.6、session共享问题"></a>1.6、session共享问题</h3><p><strong>核心思路分析：</strong></p><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p><p>但是这种方案具有两个大问题</p><p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p><p>2、session拷贝数据时，可能会出现延迟</p><p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302019.png" alt="1653069893050"></p><h3 id="1-7-Redis代替session的业务流程"><a href="#1-7-Redis代替session的业务流程" class="headerlink" title="1.7 Redis代替session的业务流程"></a>1.7 Redis代替session的业务流程</h3><h4 id="1-7-1、设计key的结构"><a href="#1-7-1、设计key的结构" class="headerlink" title="1.7.1、设计key的结构"></a>1.7.1、设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302020.png" alt="1653319261433"></p><h4 id="1-7-2、设计key的具体细节"><a href="#1-7-2、设计key的具体细节" class="headerlink" title="1.7.2、设计key的具体细节"></a>1.7.2、设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p><p>在设计这个key的时候，我们之前讲过需要满足两点</p><p>1、key要具有唯一性</p><p>2、key要方便携带</p><p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p><h4 id="1-7-3、整体访问流程"><a href="#1-7-3、整体访问流程" class="headerlink" title="1.7.3、整体访问流程"></a>1.7.3、整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302021.png" alt="1653319474181"></p><h3 id="1-8-基于Redis实现短信登录"><a href="#1-8-基于Redis实现短信登录" class="headerlink" title="1.8 基于Redis实现短信登录"></a>1.8 基于Redis实现短信登录</h3><p>这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。</p><p><strong>UserServiceImpl代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.从redis获取验证码并校验</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code)) &#123;<br>        <span class="hljs-comment">// 不一致，报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br><br>    <span class="hljs-comment">// 5.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 6.不存在，创建新用户并保存</span><br>        user = createUserWithPhone(phone);<br>    &#125;<br><br>    <span class="hljs-comment">// 7.保存用户信息到 redis中</span><br>    <span class="hljs-comment">// 7.1.随机生成token，作为登录令牌</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 7.2.将User对象转为HashMap存储</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>            CopyOptions.create()<br>                    .setIgnoreNullValue(<span class="hljs-literal">true</span>)<br>                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));<br>    <span class="hljs-comment">// 7.3.存储</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);<br>    <span class="hljs-comment">// 7.4.设置token有效期</span><br>    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);<br><br>    <span class="hljs-comment">// 8.返回token</span><br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-9-解决状态登录刷新问题"><a href="#1-9-解决状态登录刷新问题" class="headerlink" title="1.9 解决状态登录刷新问题"></a>1.9 解决状态登录刷新问题</h3><h4 id="1-9-1-初始方案思路总结："><a href="#1-9-1-初始方案思路总结：" class="headerlink" title="1.9.1 初始方案思路总结："></a>1.9.1 初始方案思路总结：</h4><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302022.png" alt="1653320822964"></p><h4 id="1-9-2-优化方案"><a href="#1-9-2-优化方案" class="headerlink" title="1.9.2 优化方案"></a>1.9.2 优化方案</h4><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302023.png" alt="1653320764547"></p><h4 id="1-9-3-代码"><a href="#1-9-3-代码" class="headerlink" title="1.9.3 代码"></a>1.9.3 代码</h4><p><strong>RefreshTokenInterceptor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefreshTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RefreshTokenInterceptor</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.获取请求头中的token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2.基于TOKEN获取redis中的用户</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span>  <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br>        <span class="hljs-comment">// 3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 5.将查询到的hash数据转为UserDTO</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 6.存在，保存用户信息到 ThreadLocal</span><br>        UserHolder.saveUser(userDTO);<br>        <span class="hljs-comment">// 7.刷新token有效期</span><br>        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">// 8.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 移除用户</span><br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>LoginInterceptor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span><br>        <span class="hljs-keyword">if</span> (UserHolder.getUser() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 没有，需要拦截，设置状态码</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-comment">// 拦截</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 有用户，则放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、商户查询缓存"><a href="#2、商户查询缓存" class="headerlink" title="2、商户查询缓存"></a>2、商户查询缓存</h2><h3 id="2-1-什么是缓存"><a href="#2-1-什么是缓存" class="headerlink" title="2.1 什么是缓存?"></a>2.1 什么是缓存?</h3><p><strong>前言</strong>:<strong>什么是缓存?</strong></p><p>就像自行车,越野车的避震器<img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302024.gif"></p><p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p><p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p><p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">例<span class="hljs-number">1</span>:Static <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(); 本地用于高并发<br><br>例<span class="hljs-number">2</span>:<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存<br><br>例<span class="hljs-number">3</span>:Static <span class="hljs-keyword">final</span> Map&lt;K,V&gt; map =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(); 本地缓存<br></code></pre></td></tr></table></figure><p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效;</p><h4 id="2-1-1-为什么要使用缓存"><a href="#2-1-1-为什么要使用缓存" class="headerlink" title="2.1.1 为什么要使用缓存"></a>2.1.1 为什么要使用缓存</h4><p>一句话:因为<strong>速度快,好用</strong></p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p><p>但是缓存也会增加代码复杂度和运营的成本:</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302025.png"></p><h4 id="2-1-2-如何使用缓存"><a href="#2-1-2-如何使用缓存" class="headerlink" title="2.1.2 如何使用缓存"></a>2.1.2 如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302026.png"></p><h3 id="2-2-添加商户缓存"><a href="#2-2-添加商户缓存" class="headerlink" title="2.2 添加商户缓存"></a>2.2 添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)<br>public Result <span class="hljs-built_in">queryShopById</span>(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) Long id) &#123;<br>    <span class="hljs-comment">//这里是直接查询数据库</span><br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">shopService</span><span class="hljs-selector-class">.queryById</span>(id);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-1-、缓存模型和思路"><a href="#2-2-1-、缓存模型和思路" class="headerlink" title="2.2.1 、缓存模型和思路"></a>2.2.1 、缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302027.png" alt="1653322097736"></p><h4 id="2-1-2、代码如下"><a href="#2-1-2、代码如下" class="headerlink" title="2.1.2、代码如下"></a>2.1.2、代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302028.png" alt="1653322190155"></p><h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302029.png" alt="1653322506393"></p><h4 id="2-3-1-、数据库缓存不一致解决方案："><a href="#2-3-1-、数据库缓存不一致解决方案：" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案："></a>2.3.1 、数据库缓存不一致解决方案：</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302030.png" alt="1653322857620"></p><h4 id="2-3-2-、数据库和缓存不一致采用什么方案"><a href="#2-3-2-、数据库和缓存不一致采用什么方案" class="headerlink" title="2.3.2 、数据库和缓存不一致采用什么方案"></a>2.3.2 、数据库和缓存不一致采用什么方案</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302031.png" alt="1653323595206"></p><h3 id="2-4-实现商铺和缓存与数据库双写一致"><a href="#2-4-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p><p>修改ShopController中的业务逻辑，满足下面的需求：</p><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p><p><strong>设置redis缓存时添加过期时间</strong></p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302032.png" alt="1653325871232"></p><p><strong>修改重点代码2</strong></p><p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302033.png" alt="1653325929549"></p><h3 id="2-5-缓存穿透问题的解决思路"><a href="#2-5-缓存穿透问题的解决思路" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302035.png" alt="1653326156516"></p><h3 id="2-6-编码解决商品查询的缓存穿透问题："><a href="#2-6-编码解决商品查询的缓存穿透问题：" class="headerlink" title="2.6 编码解决商品查询的缓存穿透问题："></a>2.6 编码解决商品查询的缓存穿透问题：</h3><p>核心思路如下：</p><p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p><p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302036.png" alt="1653327124561"></p><p><strong>小总结：</strong></p><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="2-7-缓存雪崩问题及解决思路"><a href="#2-7-缓存雪崩问题及解决思路" class="headerlink" title="2.7 缓存雪崩问题及解决思路"></a>2.7 缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302037.png" alt="1653327884526"></p><h3 id="2-8-缓存击穿问题及解决思路"><a href="#2-8-缓存击穿问题及解决思路" class="headerlink" title="2.8 缓存击穿问题及解决思路"></a>2.8 缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302038.png" alt="1653328022622"></p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302039.png" alt="1653328288627"></p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302040.png" alt="1653328663897"></p><p>进行对比</p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302041.png" alt="1653357522914"></p><h3 id="2-9-利用互斥锁解决缓存击穿问题"><a href="#2-9-利用互斥锁解决缓存击穿问题" class="headerlink" title="2.9 利用互斥锁解决缓存击穿问题"></a>2.9 利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302042.png" alt="1653357860001"></p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>    stringRedisTemplate.delete(key);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>操作代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(Long id)</span>  &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>       <span class="hljs-comment">// 1、从redis中查询商铺缓存</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;key&quot;</span>);<br>       <span class="hljs-comment">// 2、判断是否存在</span><br>       <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>           <span class="hljs-comment">// 存在,直接返回</span><br>           <span class="hljs-keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);<br>       &#125;<br>       <span class="hljs-comment">//判断命中的值是否是空值</span><br>       <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">//返回一个错误信息</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-comment">// 4.实现缓存重构</span><br>       <span class="hljs-comment">//4.1 获取互斥锁</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:shop:&quot;</span> + id;<br>       <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>           <span class="hljs-comment">// 4.2 判断否获取成功</span><br>           <span class="hljs-keyword">if</span>(!isLock)&#123;<br>               <span class="hljs-comment">//4.3 失败，则休眠重试</span><br>               Thread.sleep(<span class="hljs-number">50</span>);<br>               <span class="hljs-keyword">return</span> queryWithMutex(id);<br>           &#125;<br>           <span class="hljs-comment">//4.4 成功，根据id查询数据库</span><br>            shop = getById(id);<br>           <span class="hljs-comment">// 5.不存在，返回错误</span><br>           <span class="hljs-keyword">if</span>(shop == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//将空值写入redis</span><br>               stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);<br>               <span class="hljs-comment">//返回错误信息</span><br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>           &#125;<br>           <span class="hljs-comment">//6.写入redis</span><br>           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);<br><br>       &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>       &#125;<br>       <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-comment">//7.释放互斥锁</span><br>           unlock(lockKey);<br>       &#125;<br>       <span class="hljs-keyword">return</span> shop;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="3-0-、利用逻辑过期解决缓存击穿问题"><a href="#3-0-、利用逻辑过期解决缓存击穿问题" class="headerlink" title="3.0 、利用逻辑过期解决缓存击穿问题"></a>3.0 、利用逻辑过期解决缓存击穿问题</h3><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p><p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302043.png" alt="1653360308731"></p><p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p><p><strong>步骤一、</strong></p><p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisData</span> &#123;<br>    <span class="hljs-keyword">private</span> LocalDateTime expireTime;<br>    <span class="hljs-keyword">private</span> Object <span class="hljs-keyword">data</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤二、</strong></p><p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302044.png" alt="1653360807133"></p><p><strong>在测试类中</strong></p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302045.png" alt="1653360864839"></p><p>步骤三：正式代码</p><p><strong>ShopServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">( Long id )</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>        <span class="hljs-comment">// 3.存在，直接返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.命中，需要先把json反序列化为对象</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>    <span class="hljs-comment">// 5.判断是否过期</span><br>    <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 5.1.未过期，直接返回店铺信息</span><br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">// 5.2.已过期，需要缓存重建</span><br>    <span class="hljs-comment">// 6.缓存重建</span><br>    <span class="hljs-comment">// 6.1.获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>    <span class="hljs-comment">// 6.2.判断是否获取锁成功</span><br>    <span class="hljs-keyword">if</span> (isLock)&#123;<br>        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;<br><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//重建缓存</span><br>                <span class="hljs-built_in">this</span>.saveShop2Redis(id,<span class="hljs-number">20L</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                unlock(lockKey);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 6.4.返回过期的商铺信息</span><br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1、封装Redis工具类"><a href="#3-1、封装Redis工具类" class="headerlink" title="3.1、封装Redis工具类"></a>3.1、封装Redis工具类</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li></ul><p>存击穿问题</p><ul><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p>将逻辑进行封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CacheClient</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWithLogicalExpire</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-comment">// 设置逻辑过期</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>        redisData.setData(value);<br>        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));<br>        <span class="hljs-comment">// 写入Redis</span><br>        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R,ID&gt; R <span class="hljs-title function_">queryWithPassThrough</span><span class="hljs-params">(</span><br><span class="hljs-params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>            <span class="hljs-comment">// 3.存在，直接返回</span><br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(json, type);<br>        &#125;<br>        <span class="hljs-comment">// 判断命中的是否是空值</span><br>        <span class="hljs-keyword">if</span> (json != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回一个错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 4.不存在，根据id查询数据库</span><br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>        <span class="hljs-comment">// 5.不存在，返回错误</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 将空值写入redis</span><br>            stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>            <span class="hljs-comment">// 返回错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 6.存在，写入redis</span><br>        <span class="hljs-built_in">this</span>.set(key, r, time, unit);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(</span><br><span class="hljs-params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>            <span class="hljs-comment">// 3.存在，直接返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 4.命中，需要先把json反序列化为对象</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>        <span class="hljs-comment">// 5.判断是否过期</span><br>        <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-comment">// 5.1.未过期，直接返回店铺信息</span><br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-comment">// 5.2.已过期，需要缓存重建</span><br>        <span class="hljs-comment">// 6.缓存重建</span><br>        <span class="hljs-comment">// 6.1.获取互斥锁</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>        <span class="hljs-comment">// 6.2.判断是否获取锁成功</span><br>        <span class="hljs-keyword">if</span> (isLock)&#123;<br>            <span class="hljs-comment">// 6.3.成功，开启独立线程，实现缓存重建</span><br>            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 查询数据库</span><br>                    <span class="hljs-type">R</span> <span class="hljs-variable">newR</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>                    <span class="hljs-comment">// 重建缓存</span><br>                    <span class="hljs-built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 释放锁</span><br>                    unlock(lockKey);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 6.4.返回过期的商铺信息</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(</span><br><span class="hljs-params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>            <span class="hljs-comment">// 3.存在，直接返回</span><br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(shopJson, type);<br>        &#125;<br>        <span class="hljs-comment">// 判断命中的是否是空值</span><br>        <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回一个错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 4.实现缓存重建</span><br>        <span class="hljs-comment">// 4.1.获取互斥锁</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>            <span class="hljs-comment">// 4.2.判断是否获取成功</span><br>            <span class="hljs-keyword">if</span> (!isLock) &#123;<br>                <span class="hljs-comment">// 4.3.获取锁失败，休眠并重试</span><br>                Thread.sleep(<span class="hljs-number">50</span>);<br>                <span class="hljs-keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);<br>            &#125;<br>            <span class="hljs-comment">// 4.4.获取锁成功，根据id查询数据库</span><br>            r = dbFallback.apply(id);<br>            <span class="hljs-comment">// 5.不存在，返回错误</span><br>            <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 将空值写入redis</span><br>                stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>                <span class="hljs-comment">// 返回错误信息</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">// 6.存在，写入redis</span><br>            <span class="hljs-built_in">this</span>.set(key, r, time, unit);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 7.释放锁</span><br>            unlock(lockKey);<br>        &#125;<br>        <span class="hljs-comment">// 8.返回</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>        stringRedisTemplate.delete(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ShopServiceImpl 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> CacheClient cacheClient;<br><br> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">// 解决缓存穿透</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> cacheClient<br>                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="hljs-built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);<br><br>        <span class="hljs-comment">// 互斥锁解决缓存击穿</span><br>        <span class="hljs-comment">// Shop shop = cacheClient</span><br>        <span class="hljs-comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><br>        <span class="hljs-comment">// 逻辑过期解决缓存击穿</span><br>        <span class="hljs-comment">// Shop shop = cacheClient</span><br>        <span class="hljs-comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span><br><br>        <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 7.返回</span><br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="3、优惠卷秒杀"><a href="#3、优惠卷秒杀" class="headerlink" title="3、优惠卷秒杀"></a>3、优惠卷秒杀</h2><h3 id="3-1-全局唯一ID"><a href="#3-1-全局唯一ID" class="headerlink" title="3.1 -全局唯一ID"></a>3.1 -全局唯一ID</h3><p>每个店铺都可以发布优惠券：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302046.png" alt="1653362612286"></p><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制</li></ul><p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p><p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302047.png" alt="1653363100502"></p><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302048.png" alt="1653363172079">ID的组成部分：符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><h3 id="3-2-Redis实现全局唯一Id"><a href="#3-2-Redis实现全局唯一Id" class="headerlink" title="3.2 -Redis实现全局唯一Id"></a>3.2 -Redis实现全局唯一Id</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列号的位数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisIdWorker</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-comment">// 1.生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br><br>        <span class="hljs-comment">// 2.生成序列号</span><br>        <span class="hljs-comment">// 2.1.获取当前日期，精确到天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">// 2.2.自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br><br>        <span class="hljs-comment">// 3.拼接并返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类</p><p>知识小贴士：关于countdownlatch</p><p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p><p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p><p>CountDownLatch 中有两个最重要的方法</p><p>1、countDown</p><p>2、await</p><p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testIdWorker</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">300</span>);<br><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);<br>        &#125;<br>        latch.countDown();<br>    &#125;;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300</span>; i++) &#123;<br>        es.submit(task);<br>    &#125;<br>    latch.await();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;time = &quot;</span> + (end - begin));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-添加优惠卷"><a href="#3-3-添加优惠卷" class="headerlink" title="3.3 添加优惠卷"></a>3.3 添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302049.png" alt="1653365145124"></p><p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p><p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p><p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p><p>**新增普通卷代码：  **VoucherController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">addVoucher</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Voucher voucher)</span> &#123;<br>    voucherService.save(voucher);<br>    <span class="hljs-keyword">return</span> Result.ok(voucher.getId());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>新增秒杀卷代码：</strong></p><p><strong>VoucherController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;seckill&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Voucher voucher)</span> &#123;<br>    voucherService.addSeckillVoucher(voucher);<br>    <span class="hljs-keyword">return</span> Result.ok(voucher.getId());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>VoucherServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;<br>    <span class="hljs-comment">// 保存优惠券</span><br>    save(voucher);<br>    <span class="hljs-comment">// 保存秒杀信息</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();<br>    seckillVoucher.setVoucherId(voucher.getId());<br>    seckillVoucher.setStock(voucher.getStock());<br>    seckillVoucher.setBeginTime(voucher.getBeginTime());<br>    seckillVoucher.setEndTime(voucher.getEndTime());<br>    seckillVoucherService.save(seckillVoucher);<br>    <span class="hljs-comment">// 保存秒杀库存到Redis中</span><br>    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-实现秒杀下单"><a href="#3-4-实现秒杀下单" class="headerlink" title="3.4 实现秒杀下单"></a>3.4 实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302050.png" alt="1653365839526"></p><p>秒杀下单应该思考的内容：</p><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302051.png" alt="1653366238564"></p><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询优惠券</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>    <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>    <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>    <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 库存不足</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5，扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-comment">//扣减库存</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6.创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-comment">// 6.1.订单id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br>    <span class="hljs-comment">// 6.2.用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    voucherOrder.setUserId(userId);<br>    <span class="hljs-comment">// 6.3.代金券id</span><br>    voucherOrder.setVoucherId(voucherId);<br>    save(voucherOrder);<br><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-库存超卖问题分析"><a href="#3-5-库存超卖问题分析" class="headerlink" title="3.5 库存超卖问题分析"></a>3.5 库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-comment">// 库存不足</span><br>       <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>   &#125;<br>   <span class="hljs-comment">//5，扣减库存</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>           .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>           .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br>   <span class="hljs-keyword">if</span> (!success) &#123;<br>       <span class="hljs-comment">//扣减库存</span><br>       <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302052.png" alt="1653368335155"></p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302053.png" alt="1653368562591"></p><p><strong>悲观锁：</strong></p><p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p><p><strong>乐观锁：</strong></p><p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p><p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p><p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> var5;<br><span class="hljs-keyword">do</span> &#123;<br>    var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>&#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br><br><span class="hljs-keyword">return</span> var5;<br></code></pre></td></tr></table></figure><p><strong>课程中的使用方式：</strong></p><p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version&#x3D;1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version &#x3D;1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version&#x3D;1 的条件了，所以线程2无法执行成功</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302054.png" alt="1653369268550"></p><h3 id="3-6-乐观锁解决超卖问题"><a href="#3-6-乐观锁解决超卖问题" class="headerlink" title="3.6 乐观锁解决超卖问题"></a>3.6 乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p><p>VoucherOrderServiceImpl 在扣减库存时，改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>) <span class="hljs-comment">//set stock = stock -1</span><br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="hljs-comment">//where id = ？ and stock = ?</span><br></code></pre></td></tr></table></figure><p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p><p><strong>修改代码方案二、</strong></p><p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="hljs-string">&quot;stock&quot;</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">//where id = ? and stock &gt; 0</span><br></code></pre></td></tr></table></figure><p><strong>知识小扩展：</strong></p><p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p><p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p><p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p><p>所以利用这么一个类，LongAdder来进行优化</p><p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302055.png" alt="1653370271627"></p><h3 id="3-6-优惠券秒杀-一人一单"><a href="#3-6-优惠券秒杀-一人一单" class="headerlink" title="3.6 优惠券秒杀-一人一单"></a>3.6 优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p><strong>现在的问题在于：</strong></p><p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p><p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302056.png" alt="1653371854389"></p><p>VoucherOrderServiceImpl  </p><p><strong>初步代码：增加一人一单逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询优惠券</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>    <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>    <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>    <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 库存不足</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 5.一人一单逻辑</span><br>    <span class="hljs-comment">// 5.1.用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>    <span class="hljs-comment">// 5.2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 用户已经购买过了</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//6，扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-comment">//扣减库存</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//7.创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-comment">// 7.1.订单id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br><br>    voucherOrder.setUserId(userId);<br>    <span class="hljs-comment">// 7.3.代金券id</span><br>    voucherOrder.setVoucherId(voucherId);<br>    save(voucherOrder);<br><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p><p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br><br><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>         <span class="hljs-comment">// 5.1.查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">// 5.2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 用户已经购买过了</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 扣减失败</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">// 7.1.订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setId(orderId);<br>        <span class="hljs-comment">// 7.2.用户id</span><br>        voucherOrder.setUserId(userId);<br>        <span class="hljs-comment">// 7.3.代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        save(voucherOrder);<br><br>        <span class="hljs-comment">// 7.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><p>，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：<br>intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span>  Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-keyword">synchronized</span>(userId.toString().intern())&#123;<br>         <span class="hljs-comment">// 5.1.查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">// 5.2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 用户已经购买过了</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 扣减失败</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">// 7.1.订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setId(orderId);<br>        <span class="hljs-comment">// 7.2.用户id</span><br>        voucherOrder.setUserId(userId);<br>        <span class="hljs-comment">// 7.3.代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        save(voucherOrder);<br><br>        <span class="hljs-comment">// 7.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：</p><p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302057.png" alt="1653373434815"></p><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302058.png" alt="1653383810643"></p><h3 id="3-7-集群环境下的并发问题"><a href="#3-7-集群环境下的并发问题" class="headerlink" title="3.7 集群环境下的并发问题"></a>3.7 集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p>1、我们将服务启动两份，端口分别为8081和8082：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302059.png" alt="1653373887844"></p><p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302060.png" alt="1653373908620"></p><p><strong>具体操作(略)</strong></p><p><strong>有关锁失效原因分析</strong></p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302061.png" alt="1653374044740"></p><h2 id="4、分布式锁"><a href="#4、分布式锁" class="headerlink" title="4、分布式锁"></a>4、分布式锁</h2><h3 id="4-1-、基本原理和实现方式对比"><a href="#4-1-、基本原理和实现方式对比" class="headerlink" title="4.1 、基本原理和实现方式对比"></a>4.1 、基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302062.png" alt="1653374296906"></p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身就需要他较高的加锁性能和释放锁性能</p><p>安全性：安全也是程序中必不可少的一环</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302063.png" alt="1653381992018"></p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以使用mysql作为分布式锁比较少见。</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁。</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案。&#x2F;&#x2F; todo 待学习</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302064.png" alt="1653382219377"></p><h3 id="4-2-、Redis分布式锁的实现核心思路"><a href="#4-2-、Redis分布式锁的实现核心思路" class="headerlink" title="4.2 、Redis分布式锁的实现核心思路"></a>4.2 、Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li><p>手动释放</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Del Key<br></code></pre></td></tr></table></figure></li><li><p>超时释放：获取锁时添加一个超时时间</p></li></ul></li></ul><p>核心思路：</p><p>我们利用redis 的setnx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的线程，等待一定时间后重试即可</p><p> <img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302066.png" alt="1653382830810"></p><h3 id="4-3-实现分布式锁版本一"><a href="#4-3-实现分布式锁版本一" class="headerlink" title="4.3 实现分布式锁版本一"></a>4.3 实现分布式锁版本一</h3><ul><li>加锁逻辑</li></ul><p><strong>锁的基本接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-comment">/**尝试获取锁</span><br><span class="hljs-comment">*<span class="hljs-doctag">@param</span> timeoutSec 锁持有的超时时间，过期后自动释放</span><br><span class="hljs-comment">*<span class="hljs-doctag">@return</span> true代表获取锁成功; false代表获取锁失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*释放锁</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SimpleRedisLock</strong></p><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法<strong>可以保证加锁和增加过期时间具有原子性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_PREFIX=<span class="hljs-string">&quot;lock:&quot;</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId()<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>释放锁逻辑</li></ul><p>SimpleRedisLock</p><p>释放锁，防止删除别人的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//通过del删除锁</span><br>    stringRedisTemplate.delete(KEY_PREFIX + name);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修改业务代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>      <span class="hljs-comment">// 1.查询优惠券</span><br>      <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>      <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>      <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>          <span class="hljs-comment">// 尚未开始</span><br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>      <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>          <span class="hljs-comment">// 尚未开始</span><br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 4.判断库存是否充足</span><br>      <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-comment">// 库存不足</span><br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>      &#125;<br>      <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>      <span class="hljs-comment">//创建锁对象(新增代码)</span><br>      <span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, stringRedisTemplate);<br>      <span class="hljs-comment">//获取锁对象</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1200</span>);<br><span class="hljs-comment">//加锁失败</span><br>      <span class="hljs-keyword">if</span> (!isLock) &#123;<br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//获取代理对象(事务)</span><br>          <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>          <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-comment">//释放锁</span><br>          lock.unlock();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-Redis分布式锁误删情况说明"><a href="#4-4-Redis分布式锁误删情况说明" class="headerlink" title="4.4 Redis分布式锁误删情况说明"></a>4.4 Redis分布式锁误删情况说明</h3><p><strong>逻辑说明</strong>：</p><p>持有锁的线程1在锁的内部出现了阻塞，导致锁自动释放，这时线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是锁误删。</p><p><strong>解决方案</strong>：</p><p>在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果不属于自己，则不进行锁的删除。</p><p>假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1发现锁不属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302069.png" alt="1653385920025"></p><h3 id="4-5-解决Redis分布式锁误删问题"><a href="#4-5-解决Redis分布式锁误删问题" class="headerlink" title="4.5 解决Redis分布式锁误删问题"></a>4.5 解决Redis分布式锁误删问题</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302070.png" alt="1653387398820"></p><p>具体代码如下：</p><p>加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>   <span class="hljs-comment">// 获取线程标示</span><br>   <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>   <span class="hljs-comment">// 获取锁</span><br>   <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>   <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br></code></pre></td></tr></table></figure><p>释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁中的标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>    <span class="hljs-comment">// 判断标示是否一致</span><br>    <span class="hljs-keyword">if</span>(threadId.equals(id)) &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有关代码实操说明：</strong></p><p>启动两个线程，第一个线程持有锁后手动释放锁，第二个线程此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁。</p><h3 id="4-6-分布式锁的原子性问题"><a href="#4-6-分布式锁的原子性问题" class="headerlink" title="4.6 分布式锁的原子性问题"></a>4.6 分布式锁的原子性问题</h3><p>更为极端的误删逻辑说明：条件判断与锁删除操作的原子性</p><p>已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，<strong>相当于条件判断并没有起到作用</strong>，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的<strong>拿锁，比锁，删锁，实际上并不是原子性的</strong>，我们要防止刚才的情况发生，</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302071.png" alt="1653387764938"></p><h3 id="4-7-Lua脚本解决多条命令原子性问题"><a href="#4-7-Lua脚本解决多条命令原子性问题" class="headerlink" title="4.7 Lua脚本解决多条命令原子性问题"></a>4.7 Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，基本语法参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了。</a></p><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis.call(<span class="hljs-string">&#x27;命令名称&#x27;</span>, <span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;其它参数&#x27;</span>, ...)<br></code></pre></td></tr></table></figure><p>例如，我们要执行set name jack，则脚本是这样：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"># 执行 set name jack<br>redis.call(<span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;jack&#x27;</span>)<br></code></pre></td></tr></table></figure><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"># 先执行 set name jack<br>redis.call(<span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>)<br># 再执行 get name<br><span class="hljs-keyword">local</span> name = redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)<br># 返回<br><span class="hljs-keyword">return</span> name<br></code></pre></td></tr></table></figure><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302072.png" alt="1653392181413"></p><p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302073.png" alt="1653392218531"></p><p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302074.png" alt="1653392438917"></p><p>释放锁的业务流程是这样的</p><p>​1、获取锁中的线程标示</p><p>​2、判断是否与指定的标示（当前线程标示）一致</p><p>​3、如果一致则释放锁（删除）</p><p>​4、如果不一致则什么都不做</p><p>如果用Lua脚本来表示则是这样的：</p><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span><br><span class="hljs-comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>  <span class="hljs-comment">-- 一致，则删除锁</span><br>  <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;DEL&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 不一致，则直接返回</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="4-8-利用Java代码调用Lua脚本改造分布式锁"><a href="#4-8-利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="4.8 利用Java代码调用Lua脚本改造分布式锁"></a>4.8 利用Java代码调用Lua脚本改造分布式锁</h3><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302075.png" alt="1653393304844"></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 利用静态变量与静态代码块初始化</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br>    <span class="hljs-keyword">static</span> &#123;<br>        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置脚本地址</span><br>        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>        <span class="hljs-comment">// 设置返回类型</span><br>        UNLOCK_SCRIPT.setResultType(Long.class);<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用lua脚本</span><br>    stringRedisTemplate.execute(<br>            UNLOCK_SCRIPT,<br>            Collections.singletonList(KEY_PREFIX + name),<br>            ID_PREFIX + Thread.currentThread().getId());<br>&#125;<br><span class="hljs-comment">// 经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></code></pre></td></tr></table></figure><p>小总结：</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p><p><strong>测试逻辑：</strong></p><p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一个线程利用lua删除锁时，lua能保证他不能删锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p><h2 id="5、分布式锁-redission"><a href="#5、分布式锁-redission" class="headerlink" title="5、分布式锁-redission"></a>5、分布式锁-redission</h2><h3 id="5-1-分布式锁-redission功能介绍"><a href="#5-1-分布式锁-redission功能介绍" class="headerlink" title="5.1 分布式锁-redission功能介绍"></a>5.1 分布式锁-redission功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以<strong>可重入锁的主要意义是防止死锁</strong>，我们的<strong>synchronized和Lock锁都是可重入的</strong>。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302076.png" alt="1653546070602"></p><p>那么什么是Redission呢</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还<strong>提供了许多分布式服务</strong>，其中就包含了<strong>各种分布式锁的实现</strong>（其实就是一个分布式工具包）。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302077.png" alt="1653546736063"></p><h3 id="5-2-分布式锁-Redission快速入门"><a href="#5-2-分布式锁-Redission快速入门" class="headerlink" title="5.2 分布式锁-Redission快速入门"></a>5.2 分布式锁-Redission快速入门</h3><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>&lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>&lt;artifactId&gt;redisson&lt;/artifactId&gt;<br>&lt;version&gt;<span class="hljs-number">3.13</span><span class="hljs-number">.6</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 配置</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer()<span class="hljs-comment">// Redis为单节点</span><br>            .setAddress(<span class="hljs-string">&quot;redis://192.168.150.101:6379&quot;</span>)<br>            .setPassword(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如何使用Redission的分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissionClient redissonClient;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">// 获取锁(可重入)，指定锁的名称</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);<br>    <span class="hljs-comment">// 尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span><br>    <span class="hljs-comment">// 锁自动释放时间不传参默认为30s</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>    <span class="hljs-comment">// 判断获取锁成功</span><br>    <span class="hljs-keyword">if</span>(isLock)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;执行业务&quot;</span>);          <br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 VoucherOrderServiceImpl</p><p>注入RedissonClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-comment">// 1.查询优惠券</span><br>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>        <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>        <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-comment">// 尚未开始</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>        <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>            <span class="hljs-comment">// 尚未开始</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 4.判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 库存不足</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">// 创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span><br>        <span class="hljs-comment">// SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span><br>    <span class="hljs-comment">// 获取锁对象</span><br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>        <span class="hljs-comment">// 尝试加锁</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>       <br><span class="hljs-comment">// 加锁失败</span><br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取代理对象(事务)</span><br>            <span class="hljs-comment">// 使用代理对象才可以使事务生效</span><br>            <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>            <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放锁</span><br>            lock.unlock();<br>        &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-分布式锁-redission可重入锁原理"><a href="#5-3-分布式锁-redission可重入锁原理" class="headerlink" title="5.3 分布式锁-redission可重入锁原理"></a>5.3 分布式锁-redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p><p>在redission中也支持可重入锁</p><p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式</p><p>这个地方一共有3个参数</p><p><strong>KEYS[1] ： 锁名称</strong></p><p><strong>ARGV[1]：  锁失效时间</strong></p><p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p><p>exists: 判断数据是否存在，如果&#x3D;&#x3D;0，就表示当前这把锁不存在，此时他就开始往redis里边去写数据 ，写成一个hash结构</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>);<br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Lock&#123;<br>id + <span class="hljs-string">&quot;:&quot;</span> + threadId :  1<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前这把锁存在，则第一个条件不满足，再判断</p><p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p><ul><li>将当前这个锁的value进行+1 </li><li>对其设置过期时间</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>);<br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">end</span>; <br></code></pre></td></tr></table></figure><p>如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;pttl&#x27;</span>, KEYS[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +<br>    <span class="hljs-string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>    <span class="hljs-string">&quot;return nil; &quot;</span> +<br><span class="hljs-string">&quot;end; &quot;</span> +<br><span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +<br>    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>    <span class="hljs-string">&quot;return nil; &quot;</span> +<br><span class="hljs-string">&quot;end; &quot;</span> +<br><span class="hljs-string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302078.png" alt="1653548087334"></p><h3 id="5-4-分布式锁-redission锁重试和WatchDog机制"><a href="#5-4-分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="5.4 分布式锁-redission锁重试和WatchDog机制"></a>5.4 分布式锁-redission锁重试和WatchDog机制</h3><p><strong>说明</strong>：由于课程中已经说明了有关tryLock的源码解析以及其看门狗原理，所以笔者在这里给大家分析lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识</p><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br><span class="hljs-type">Long</span> <span class="hljs-variable">ttl</span> <span class="hljs-operator">=</span> tryAcquire(-<span class="hljs-number">1</span>, leaseTime, unit, threadId);<br><span class="hljs-comment">// lock acquired</span><br><span class="hljs-keyword">if</span> (ttl == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果不带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()<br></code></pre></td></tr></table></figure><p>对以上抢锁进行了监听，当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ttlRemainingFuture.onComplete((ttlRemaining, e) <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(<br>        waitTime,<br>        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),<br>        TimeUnit.MILLISECONDS, <br>        threadId, <br>        RedisCommands.EVAL_LONG);<br>ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// lock acquired</span><br>    <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-literal">null</span>) &#123;<br>        scheduleExpirationRenewal(threadId);<br>    &#125;<br>&#125;);<br><span class="hljs-keyword">return</span> ttlRemainingFuture;<br></code></pre></td></tr></table></figure><p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p><p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p><p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renewExpiration</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ee</span> <span class="hljs-operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>    <span class="hljs-keyword">if</span> (ee == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">Timeout</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ent</span> <span class="hljs-operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>            <span class="hljs-keyword">if</span> (ent == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ent.getFirstThreadId();<br>            <span class="hljs-keyword">if</span> (threadId == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);<br>            future.onComplete((res, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                    log.error(<span class="hljs-string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="hljs-string">&quot; expiration&quot;</span>, e);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (res) &#123;<br>                    <span class="hljs-comment">// reschedule itself</span><br>                    renewExpiration();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;, internalLockLeaseTime / <span class="hljs-number">3</span>, TimeUnit.MILLISECONDS);<br>    <br>    ee.setTimeout(task);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-分布式锁-redission锁的MutiLock原理"><a href="#5-5-分布式锁-redission锁的MutiLock原理" class="headerlink" title="5.5 分布式锁-redission锁的MutiLock原理"></a>5.5 分布式锁-redission锁的MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302079.png" alt="1653553998403"></p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302080.png" alt="1653554055048"></p><p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302081.png" alt="1653553093967"></p><h2 id="6、秒杀优化"><a href="#6、秒杀优化" class="headerlink" title="6、秒杀优化"></a>6、秒杀优化</h2><h3 id="6-1-秒杀优化-异步秒杀思路"><a href="#6-1-秒杀优化-异步秒杀思路" class="headerlink" title="6.1 秒杀优化-异步秒杀思路"></a>6.1 秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p><p>1、查询优惠卷</p><p>2、判断秒杀库存是否足够</p><p>3、查询订单</p><p>4、校验是否是一人一单</p><p>5、扣减库存</p><p>6、创建订单</p><p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p><p>在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求。</p><blockquote><p>  总结：对线程池中的线程消耗较大，且提升的仅仅是做完的速度，其实只需要确定可以做就可以了。</p></blockquote><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302082.png" alt="1653560986599"></p><p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p><p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p><p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302083.png" alt="1653561657295"></p><p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要到redis中去根据key找对应stock的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作。</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302084.png" alt="1653562234886"></p><h3 id="6-2-秒杀优化-Redis完成秒杀资格判断"><a href="#6-2-秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="6.2 秒杀优化-Redis完成秒杀资格判断"></a>6.2 秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p><ul><li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中（）</p></li><li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p></li><li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p></li><li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302085.png" alt="1656080546603"></p></li></ul><p>VoucherServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;<br>    <span class="hljs-comment">// 保存优惠券</span><br>    save(voucher);<br>    <span class="hljs-comment">// 保存秒杀信息</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();<br>    seckillVoucher.setVoucherId(voucher.getId());<br>    seckillVoucher.setStock(voucher.getStock());<br>    seckillVoucher.setBeginTime(voucher.getBeginTime());<br>    seckillVoucher.setEndTime(voucher.getEndTime());<br>    seckillVoucherService.save(seckillVoucher);<br>    <span class="hljs-comment">// 保存秒杀库存到Redis中</span><br>    <span class="hljs-comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span><br>    <span class="hljs-comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span><br>    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>完整lua表达式</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><br><span class="hljs-comment">-- 1.1.优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 1.2.用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><span class="hljs-comment">-- 1.3.订单id</span><br><span class="hljs-keyword">local</span> orderId = ARGV[<span class="hljs-number">3</span>]<br><br><span class="hljs-comment">-- 2.数据key</span><br><span class="hljs-comment">-- 2.1.库存key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 2.2.订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br><span class="hljs-comment">-- 3.脚本业务</span><br><span class="hljs-comment">-- 3.1.判断库存是否充足 get stockKey</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.2.库存不足，返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.3.存在，说明是重复下单，返回2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.4.扣库存 incrby stockKey -1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 3.5.下单（保存用户）sadd orderKey userId</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span><br>redis.call(<span class="hljs-string">&#x27;xadd&#x27;</span>, <span class="hljs-string">&#x27;stream.orders&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;userId&#x27;</span>, userId, <span class="hljs-string">&#x27;voucherId&#x27;</span>, voucherId, <span class="hljs-string">&#x27;id&#x27;</span>, orderId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">//获取用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    <span class="hljs-comment">// 1.执行lua脚本</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>            SECKILL_SCRIPT,<br>            Collections.emptyList(),<br>            voucherId.toString(), userId.toString(), String.valueOf(orderId)<br>    );<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>    <span class="hljs-comment">// 2.判断结果是否为0</span><br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 2.1.不为0 ，代表没有购买资格</span><br>        <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//TODO 保存阻塞队列</span><br>    <span class="hljs-comment">// 3.返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-秒杀优化-基于阻塞队列实现秒杀优化"><a href="#6-3-秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="6.3 秒杀优化-基于阻塞队列实现秒杀优化"></a>6.3 秒杀优化-基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p><p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//异步处理线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">SECKILL_ORDER_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><br><span class="hljs-comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>   SECKILL_ORDER_EXECUTOR.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrderHandler</span>());<br>&#125;<br><span class="hljs-comment">// 用于线程池处理的任务</span><br><span class="hljs-comment">// 当初始化完毕后，就会去从对列中去拿信息</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 1.获取队列中的订单信息</span><br>                    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> orderTasks.take();<br>                    <span class="hljs-comment">// 2.创建订单</span><br>                    handleVoucherOrder(voucherOrder);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>                &#125;<br>           &#125;<br>        &#125;<br>     <br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>            <span class="hljs-comment">//1.获取用户</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>            <span class="hljs-comment">// 2.创建锁对象</span><br>            <span class="hljs-type">RLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>            <span class="hljs-comment">// 3.尝试获取锁</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> redisLock.lock();<br>            <span class="hljs-comment">// 4.判断是否获得锁成功</span><br>            <span class="hljs-keyword">if</span> (!isLock) &#123;<br>                <span class="hljs-comment">// 获取锁失败，直接返回失败或者重试</span><br>                log.error(<span class="hljs-string">&quot;不允许重复下单！&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span><br>                proxy.createVoucherOrder(voucherOrder);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                redisLock.unlock();<br>            &#125;<br>    &#125;<br>     <span class="hljs-comment">//a</span><br><span class="hljs-keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="hljs-keyword">new</span>  <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        <span class="hljs-comment">// 1.执行lua脚本</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>                SECKILL_SCRIPT,<br>                Collections.emptyList(),<br>                voucherId.toString(), userId.toString(), String.valueOf(orderId)<br>        );<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>        <span class="hljs-comment">// 2.判断结果是否为0</span><br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 2.1.不为0 ，代表没有购买资格</span><br>            <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">// 2.3.订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setId(orderId);<br>        <span class="hljs-comment">// 2.4.用户id</span><br>        voucherOrder.setUserId(userId);<br>        <span class="hljs-comment">// 2.5.代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        <span class="hljs-comment">// 2.6.放入阻塞队列</span><br>        orderTasks.add(voucherOrder);<br>        <span class="hljs-comment">//3.获取代理对象</span><br>         proxy = (IVoucherOrderService)AopContext.currentProxy();<br>        <span class="hljs-comment">//4.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>     <br>      <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>        <span class="hljs-comment">// 5.1.查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();<br>        <span class="hljs-comment">// 5.2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 用户已经购买过了</span><br>           log.error(<span class="hljs-string">&quot;用户已经购买过了&quot;</span>);<br>           <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">// 6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 扣减失败</span><br>            log.error(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        save(voucherOrder);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><strong>小总结：</strong></p><p>秒杀业务的优化思路是什么？</p><ul><li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li><li>基于阻塞队列的异步秒杀存在哪些问题？<ul><li>内存限制问题</li><li>数据安全问题</li></ul></li></ul><h2 id="7、Redis消息队列"><a href="#7、Redis消息队列" class="headerlink" title="7、Redis消息队列"></a>7、Redis消息队列</h2><h3 id="7-1-Redis消息队列-认识消息队列"><a href="#7-1-Redis消息队列-认识消息队列" class="headerlink" title="7.1 Redis消息队列-认识消息队列"></a>7.1 Redis消息队列-认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302086.png" alt="1653574849336"></p><p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h3 id="7-2-Redis消息队列-基于List实现消息队列"><a href="#7-2-Redis消息队列-基于List实现消息队列" class="headerlink" title="7.2 Redis消息队列-基于List实现消息队列"></a>7.2 Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302087.png" alt="1653575176451"></p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h3 id="7-3-Redis消息队列-基于PubSub的消息队列"><a href="#7-3-Redis消息队列-基于PubSub的消息队列" class="headerlink" title="7.3 Redis消息队列-基于PubSub的消息队列"></a>7.3 Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302088.png" alt="1653575506373"></p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="7-4-Redis消息队列-基于Stream的消息队列"><a href="#7-4-Redis消息队列-基于Stream的消息队列" class="headerlink" title="7.4 Redis消息队列-基于Stream的消息队列"></a>7.4 Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302089.png" alt="1653577301737"></p><p>例如：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302090.png" alt="1653577349691"></p><p>读取消息的方式之一：XREAD</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302091.png" alt="1653577445413"></p><p>例如，使用XREAD读取第一个消息：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302092.png" alt="1653577643629"></p><p>XREAD阻塞方式，读取最新的消息：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302093.png" alt="1653577659166"></p><p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br><span class="hljs-comment">//试读取队列中的消息，最多阻塞2秒</span><br><span class="hljs-built_in">Object</span> msg = redis.execute(<span class="hljs-string">&quot;XREAD COUNT I BLOCK 2000 STREAMS users $&quot;</span>);<br><span class="hljs-keyword">if</span>(msg == <span class="hljs-keyword">null</span>)&#123;<br><br>&#125;<br><span class="hljs-comment">//处理消息</span><br>handleMessage(msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题。</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="7-5-Redis消息队列-基于Stream的消息队列-消费者组"><a href="#7-5-Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="7.5 Redis消息队列-基于Stream的消息队列-消费者组"></a>7.5 Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302095.png" alt="1653577801668"></p><p><strong>创建消费者组：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XGROUP CREATE key groupName ID [MKSTREAM]<br></code></pre></td></tr></table></figure><p>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列</p><p>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XGROUP DESTORY key groupName<br></code></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XGROUP CREATECONSUMER key groupname consumername<br></code></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XGROUP DELCONSUMER key groupname consumername<br></code></pre></td></tr></table></figure><p><strong>从消费者组读取消息：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]<br></code></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：<ul><li>“&gt;”：从下一个未消费的消息开始</li><li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li></ul></li></ul><p>消费者监听消息的基本思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-comment">// 尝试监听队列，使用阻塞模式，最长等待 2000 毫秒</span><br><span class="hljs-type">object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&quot;XRFADGROUP GROUP g1 C1 COUNT 1 BLCK 2000 STRFAMS S1 &gt;&quot;</span>);<br>    <span class="hljs-keyword">if</span>(msg == <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-comment">// null说明没有消息，继续下一次</span><br>    <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 处理消息，完成后需要ACK</span><br>    handleMessage(msg);<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 有异常，查看pendinglist中的异常并进行处理</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0&quot;</span>);<br>    <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// null说明没有异常消息，所有消息都已确认，结束循环</span><br>    <span class="hljs-keyword">break</span>;<br>    &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//说明有异常消息，再次处理</span><br>                handleMessage(msg);<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                <span class="hljs-comment">// 再次出现异常，记录日志，继续循环</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><p>最后我们来个小对比</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302098.png" alt="1653578560691"></p><h3 id="7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p><ul><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li></ul><p>修改lua表达式,新增3.6 </p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302099.png" alt="1656082824939"></p><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br>                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(<br>                    Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),<br>                    StreamReadOptions.empty().count(<span class="hljs-number">1</span>).block(Duration.ofSeconds(<span class="hljs-number">2</span>)),<br>                    StreamOffset.create(<span class="hljs-string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())<br>                );<br>                <span class="hljs-comment">// 2.判断订单信息是否为空</span><br>                <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 如果为null，说明没有消息，继续下一次循环</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 解析数据</span><br>                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="hljs-number">0</span>);<br>                Map&lt;Object, Object&gt; value = record.getValue();<br>                <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(), <span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 3.创建订单</span><br>                createVoucherOrder(voucherOrder);<br>                <span class="hljs-comment">// 4.确认消息 XACK</span><br>                stringRedisTemplate.opsForStream().acknowledge(<span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-string">&quot;g1&quot;</span>, record.getId());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>                <span class="hljs-comment">//处理异常消息</span><br>                handlePendingList();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePendingList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span><br>                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(<br>                    Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),<br>                    StreamReadOptions.empty().count(<span class="hljs-number">1</span>),<br>                    StreamOffset.create(<span class="hljs-string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="hljs-string">&quot;0&quot;</span>))<br>                );<br>                <span class="hljs-comment">// 2.判断订单信息是否为空</span><br>                <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 如果为null，说明没有异常消息，结束循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 解析数据</span><br>                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="hljs-number">0</span>);<br>                Map&lt;Object, Object&gt; value = record.getValue();<br>                <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(), <span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 3.创建订单</span><br>                createVoucherOrder(voucherOrder);<br>                <span class="hljs-comment">// 4.确认消息 XACK</span><br>                stringRedisTemplate.opsForStream().acknowledge(<span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-string">&quot;g1&quot;</span>, record.getId());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理pendding订单异常&quot;</span>, e);<br>                <span class="hljs-keyword">try</span>&#123;<br>                    Thread.sleep(<span class="hljs-number">20</span>);<br>                &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="8、达人探店"><a href="#8、达人探店" class="headerlink" title="8、达人探店"></a>8、达人探店</h2><h3 id="8-1、达人探店-发布探店笔记"><a href="#8-1、达人探店-发布探店笔记" class="headerlink" title="8.1、达人探店-发布探店笔记"></a>8.1、达人探店-发布探店笔记</h3><p>发布探店笔记</p><p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p><p><strong>具体发布流程</strong></p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302100.png" alt="1653578992639"></p><p>上传接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;upload&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;blog&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">uploadImage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取原始文件名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>            <span class="hljs-comment">// 生成新文件名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> createNewFileName(originalFilename);<br>            <span class="hljs-comment">// 保存文件</span><br>            image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));<br>            <span class="hljs-comment">// 返回结果</span><br>            log.debug(<span class="hljs-string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);<br>            <span class="hljs-keyword">return</span> Result.ok(fileName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;文件上传失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p><p>BlogController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/blog&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IBlogService blogService;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Blog blog)</span> &#123;<br>        <span class="hljs-comment">//获取登录用户</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>        blog.setUpdateTime(user.getId());<br>        <span class="hljs-comment">//保存探店博文</span><br>        blogService.saveBlog(blog);<br>        <span class="hljs-comment">//返回id</span><br>        <span class="hljs-keyword">return</span> Result.ok(blog.getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-达人探店-查看探店笔记"><a href="#8-2-达人探店-查看探店笔记" class="headerlink" title="8.2 达人探店-查看探店笔记"></a>8.2 达人探店-查看探店笔记</h3><p>实现查看发布探店笔记的接口</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302101.png" alt="1653579931626"></p><p>实现代码：</p><p>BlogServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.查询blog</span><br>    <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-keyword">if</span> (blog == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;笔记不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2.查询blog有关的用户</span><br>    queryBlogUser(blog);<br>  <br>    <span class="hljs-keyword">return</span> Result.ok(blog);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-3-达人探店-点赞功能"><a href="#8-3-达人探店-点赞功能" class="headerlink" title="8.3 达人探店-点赞功能"></a>8.3 达人探店-点赞功能</h3><p>初始代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-comment">//修改点赞数量</span><br>    blogService.update().setSql(<span class="hljs-string">&quot;liked = liked +1 &quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><p>问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</p><p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302102.png" alt="1653581590453"></p><p>完善点赞功能</p><p>需求：</p><ul><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现步骤：</p><ul><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><p>为什么采用set集合：</p><p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是</p><p>具体步骤：</p><p>1、在Blog 添加一个字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(exist = false)</span><br><span class="hljs-keyword">private</span> Boolean isLike;<br></code></pre></td></tr></table></figure><p>2、修改代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span>&#123;<br>       <span class="hljs-comment">// 1.获取登录用户</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>       <span class="hljs-comment">// 2.判断当前登录用户是否已经点赞</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>       <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());<br>       <span class="hljs-keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;<br>            <span class="hljs-comment">//3.如果未点赞，可以点赞</span><br>           <span class="hljs-comment">//3.1 数据库点赞数+1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>           <span class="hljs-comment">//3.2 保存用户到Redis的set集合</span><br>           <span class="hljs-keyword">if</span>(isSuccess)&#123;<br>               stringRedisTemplate.opsForSet().add(key,userId.toString());<br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//4.如果已点赞，取消点赞</span><br>           <span class="hljs-comment">//4.1 数据库点赞数-1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>           <span class="hljs-comment">//4.2 把用户从Redis的set集合移除</span><br>           <span class="hljs-keyword">if</span>(isSuccess)&#123;<br>               stringRedisTemplate.opsForSet().remove(key,userId.toString());<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><h3 id="8-4-达人探店-点赞排行榜"><a href="#8-4-达人探店-点赞排行榜" class="headerlink" title="8.4 达人探店-点赞排行榜"></a>8.4 达人探店-点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p><p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302103.png" alt="1653805077118"></p><p>我们接下来来对比一下这些集合的区别是什么</p><p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p><p>其次我们需要排序，就可以直接锁定使用sortedSet啦</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302104.png" alt="1653805203758"></p><p>修改代码</p><p>BlogServiceImpl</p><p>点赞逻辑代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>     <span class="hljs-comment">// 1.获取登录用户</span><br>     <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>     <span class="hljs-comment">// 2.判断当前登录用户是否已经点赞</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>     <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>     <span class="hljs-keyword">if</span> (score == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">// 3.如果未点赞，可以点赞</span><br>         <span class="hljs-comment">// 3.1.数据库点赞数 + 1</span><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>         <span class="hljs-comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span><br>         <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>             stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());<br>         &#125;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// 4.如果已点赞，取消点赞</span><br>         <span class="hljs-comment">// 4.1.数据库点赞数 -1</span><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>         <span class="hljs-comment">// 4.2.把用户从Redis的set集合移除</span><br>         <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>             stringRedisTemplate.opsForZSet().remove(key, userId.toString());<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> Result.ok();<br> &#125;<br><br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isBlogLiked</span><span class="hljs-params">(Blog blog)</span> &#123;<br>     <span class="hljs-comment">// 1.获取登录用户</span><br>     <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>     <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">// 用户未登录，无需查询是否点赞</span><br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> user.getId();<br>     <span class="hljs-comment">// 2.判断当前登录用户是否已经点赞</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked:&quot;</span> + blog.getId();<br>     <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>     blog.setIsLike(score != <span class="hljs-literal">null</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>点赞列表查询列表</p><p>BlogController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br><br>    <span class="hljs-keyword">return</span> blogService.queryBlogLikes(id);<br>&#125;<br></code></pre></td></tr></table></figure><p>BlogService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>    <span class="hljs-comment">// 1.查询top5的点赞用户 zrange key 0 4</span><br>    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (top5 == <span class="hljs-literal">null</span> || top5.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 2.解析出其中的用户id</span><br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    <span class="hljs-comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span><br>    List&lt;UserDTO&gt; userDTOS = userService.query()<br>            .in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list()<br>            .stream()<br>            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-comment">// 4.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOS);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9、好友关注"><a href="#9、好友关注" class="headerlink" title="9、好友关注"></a>9、好友关注</h2><h3 id="9-1-好友关注-关注和取消关注"><a href="#9-1-好友关注-关注和取消关注" class="headerlink" title="9.1 好友关注-关注和取消关注"></a>9.1 好友关注-关注和取消关注</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302105.png" alt="1653806140822"></p><p>实现思路：</p><p>需求：基于该表数据结构，实现两个接口：</p><ul><li>关注和取关接口</li><li>判断是否关注的接口</li></ul><p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302106.png" alt="1653806253817"></p><p>注意: 这里需要把主键修改为自增长，简化开发。</p><p>FollowController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//关注</span><br><span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="hljs-meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;<br>    <span class="hljs-keyword">return</span> followService.follow(followUserId, isFollow);<br>&#125;<br><span class="hljs-comment">//取消关注</span><br><span class="hljs-meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;<br>      <span class="hljs-keyword">return</span> followService.isFollow(followUserId);<br>&#125;<br></code></pre></td></tr></table></figure><p>FollowService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//取消关注service</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId).count();<br>    <span class="hljs-comment">// 3.判断</span><br>    <span class="hljs-keyword">return</span> Result.ok(count &gt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//关注service</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;<br>    <span class="hljs-comment">// 1.判断到底是关注还是取关</span><br>    <span class="hljs-keyword">if</span> (isFollow) &#123;<br>        <span class="hljs-comment">// 2.关注，新增数据</span><br>        <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>        follow.setUserId(userId);<br>        follow.setFollowUserId(followUserId);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(follow);<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span><br>        remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>               .eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-2-好友关注-共同关注"><a href="#9-2-好友关注-共同关注" class="headerlink" title="9.2 好友关注-共同关注"></a>9.2 好友关注-共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p><p>1、去查询用户的详情</p><p>2、去查询用户的笔记</p><p>以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302107.png" alt="1653806706296"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// UserController 根据id查询用户</span><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;<br>    <span class="hljs-comment">// 查询详情</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(userId);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>    <span class="hljs-comment">// 返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(userDTO);<br>&#125;<br><br><span class="hljs-comment">// BlogController  根据id查询博主的探店笔记</span><br><span class="hljs-meta">@GetMapping(&quot;/of/user&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogByUserId</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span><br><span class="hljs-params">    <span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-comment">// 根据用户查询</span><br>    Page&lt;Blog&gt; page = blogService.query()<br>        .eq(<span class="hljs-string">&quot;user_id&quot;</span>, id).page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));<br>    <span class="hljs-comment">// 获取当前页数据</span><br>    List&lt;Blog&gt; records = page.getRecords();<br>    <span class="hljs-keyword">return</span> Result.ok(records);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看看共同关注如何实现：</p><p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p><p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302108.png" alt="1653806973212"></p><p>我们先来改造当前的关注列表</p><p>改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除</p><p>FollowServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;<br>    <span class="hljs-comment">// 1.判断到底是关注还是取关</span><br>    <span class="hljs-keyword">if</span> (isFollow) &#123;<br>        <span class="hljs-comment">// 2.关注，新增数据</span><br>        <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>        follow.setUserId(userId);<br>        follow.setFollowUserId(followUserId);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(follow);<br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            <span class="hljs-comment">// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span><br>            stringRedisTemplate.opsForSet().add(key, followUserId.toString());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>                .eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            <span class="hljs-comment">// 把关注用户的id从Redis集合中移除</span><br>            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体的关注代码：</strong></p><p>FollowServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;<br>    <span class="hljs-comment">// 2.求交集</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + id;<br>    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);<br>    <span class="hljs-keyword">if</span> (intersect == <span class="hljs-literal">null</span> || intersect.isEmpty()) &#123;<br>        <span class="hljs-comment">// 无交集</span><br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 3.解析id集合</span><br>    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">// 4.查询用户</span><br>    List&lt;UserDTO&gt; users = userService.listByIds(ids)<br>            .stream()<br>            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> Result.ok(users);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-3-好友关注-Feed流实现方案"><a href="#9-3-好友关注-Feed流实现方案" class="headerlink" title="9.3 好友关注-Feed流实现方案"></a>9.3 好友关注-Feed流实现方案</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302109.png" alt="1653808641260"></p><p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302110.png" alt="1653808993693"></p><p>Feed流的实现有两种模式：</p><p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul><p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li><p>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</p></li><li><p>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，只需要拿到我们关注用户的信息，然后按照时间排序即可，因此采用Timeline的模式。该模式的实现方案有三种：</p></li><li><p>拉模式</p></li><li><p>推模式</p></li><li><p>推拉结合</p></li></ul><p><strong>拉模式</strong>：也叫做读扩散</p><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的写邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人写全部都进行拉取，然后在进行排序</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清除。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302111.png" alt="1653809450816"></p><p><strong>推模式</strong>：也叫做写扩散。</p><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302112.png" alt="1653809875208"></p><p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><h3 id="9-4-好友关注-推送到粉丝收件箱"><a href="#9-4-好友关注-推送到粉丝收件箱" class="headerlink" title="9.4 好友关注-推送到粉丝收件箱"></a>9.4 好友关注-推送到粉丝收件箱</h3><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302114.png" alt="1653813047671"></p><p>Feed流的滚动分页</p><p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302116.png" alt="1653813462834"></p><p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(Blog blog)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    blog.setUserId(user.getId());<br>    <span class="hljs-comment">// 2.保存探店笔记</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(blog);<br>    <span class="hljs-keyword">if</span>(!isSuccess)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;新增笔记失败!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span><br>    List&lt;Follow&gt; follows = followService.query().eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, user.getId()).list();<br>    <span class="hljs-comment">// 4.推送笔记id给所有粉丝</span><br>    <span class="hljs-keyword">for</span> (Follow follow : follows) &#123;<br>        <span class="hljs-comment">// 4.1.获取粉丝id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> follow.getUserId();<br>        <span class="hljs-comment">// 4.2.推送</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> FEED_KEY + userId;<br>        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());<br>    &#125;<br>    <span class="hljs-comment">// 5.返回id</span><br>    <span class="hljs-keyword">return</span> Result.ok(blog.getId());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-5好友关注-实现分页查询收邮箱"><a href="#9-5好友关注-实现分页查询收邮箱" class="headerlink" title="9.5好友关注-实现分页查询收邮箱"></a>9.5好友关注-实现分页查询收邮箱</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p><p>具体操作如下：</p><p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p><p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p><p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p><p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302117.png" alt="1653819821591"></p><p>一、定义出来具体的返回值实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollResult</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;?&gt; list;<br>    <span class="hljs-keyword">private</span> Long minTime;<br>    <span class="hljs-keyword">private</span> Integer offset;<br>&#125;<br></code></pre></td></tr></table></figure><p>BlogController</p><p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/of/follow&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="hljs-meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;<br>    <span class="hljs-keyword">return</span> blogService.queryBlogOfFollow(max, offset);<br>&#125;<br></code></pre></td></tr></table></figure><p>BlogServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(Long max, Integer offset)</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> FEED_KEY + userId;<br>    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()<br>        .reverseRangeByScoreWithScores(key, <span class="hljs-number">0</span>, max, offset, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 3.非空判断</span><br>    <span class="hljs-keyword">if</span> (typedTuples == <span class="hljs-literal">null</span> || typedTuples.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br>    <span class="hljs-comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span><br>    List&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(typedTuples.size());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 2</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="hljs-comment">// 5 4 4 2 2</span><br>        <span class="hljs-comment">// 4.1.获取id</span><br>        ids.add(Long.valueOf(tuple.getValue()));<br>        <span class="hljs-comment">// 4.2.获取分数(时间戳）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> tuple.getScore().longValue();<br>        <span class="hljs-keyword">if</span>(time == minTime)&#123;<br>            os++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            minTime = time;<br>            os = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>os = minTime == max ? os : os + offset;<br>    <span class="hljs-comment">// 5.根据id查询blog</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    List&lt;Blog&gt; blogs = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br><br>    <span class="hljs-keyword">for</span> (Blog blog : blogs) &#123;<br>        <span class="hljs-comment">// 5.1.查询blog有关的用户</span><br>        queryBlogUser(blog);<br>        <span class="hljs-comment">// 5.2.查询blog是否被点赞</span><br>        isBlogLiked(blog);<br>    &#125;<br><br>    <span class="hljs-comment">// 6.封装并返回</span><br>    <span class="hljs-type">ScrollResult</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollResult</span>();<br>    r.setList(blogs);<br>    r.setOffset(os);<br>    r.setMinTime(minTime);<br><br>    <span class="hljs-keyword">return</span> Result.ok(r);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10、附近商户"><a href="#10、附近商户" class="headerlink" title="10、附近商户"></a>10、附近商户</h2><h3 id="10-1、附近商户-GEO数据结构的基本用法"><a href="#10-1、附近商户-GEO数据结构的基本用法" class="headerlink" title="10.1、附近商户-GEO数据结构的基本用法"></a>10.1、附近商户-GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li></ul><h3 id="10-2、-附近商户-导入店铺数据到GEO"><a href="#10-2、-附近商户-导入店铺数据到GEO" class="headerlink" title="10.2、 附近商户-导入店铺数据到GEO"></a>10.2、 附近商户-导入店铺数据到GEO</h3><p>具体场景说明：</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302118.png" alt="1653822036941"></p><p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302119.png" alt="1653822021827"></p><p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p><p>代码</p><p>HmDianPingApplicationTests</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">loadShopData</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.查询店铺信息</span><br>    List&lt;Shop&gt; list = shopService.list();<br>    <span class="hljs-comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span><br>    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));<br>    <span class="hljs-comment">// 3.分批完成写入Redis</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-comment">// 3.1.获取类型id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">typeId</span> <span class="hljs-operator">=</span> entry.getKey();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>        <span class="hljs-comment">// 3.2.获取同类型的店铺的集合</span><br>        List&lt;Shop&gt; value = entry.getValue();<br>        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(value.size());<br>        <span class="hljs-comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span><br>        <span class="hljs-keyword">for</span> (Shop shop : value) &#123;<br>            <span class="hljs-comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span><br>            locations.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(<br>                    shop.getId().toString(),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(shop.getX(), shop.getY())<br>            ));<br>        &#125;<br>        stringRedisTemplate.opsForGeo().add(key, locations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-3-附近商户-实现附近商户功能"><a href="#10-3-附近商户-实现附近商户功能" class="headerlink" title="10.3 附近商户-实现附近商户功能"></a>10.3 附近商户-实现附近商户功能</h3><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p><p>第一步：导入pom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>    &lt;exclusions&gt;<br>        &lt;exclusion&gt;<br>            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;<br>            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;<br>        &lt;/exclusion&gt;<br>        &lt;exclusion&gt;<br>            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;<br>            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;<br>        &lt;/exclusion&gt;<br>    &lt;/exclusions&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">2.6</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;<br>    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">6.1</span><span class="hljs-number">.6</span>.RELEASE&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>第二步：</p><p>ShopController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/of/type&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span><br><span class="hljs-params">)</span> &#123;<br>   <span class="hljs-keyword">return</span> shopService.queryShopByType(typeId, current, x, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>ShopServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;<br>        <span class="hljs-comment">// 1.判断是否需要根据坐标查询</span><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span> || y == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 不需要坐标查询，按数据库查询</span><br>            Page&lt;Shop&gt; page = query()<br>                    .eq(<span class="hljs-string">&quot;type_id&quot;</span>, typeId)<br>                    .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));<br>            <span class="hljs-comment">// 返回数据</span><br>            <span class="hljs-keyword">return</span> Result.ok(page.getRecords());<br>        &#125;<br><br>        <span class="hljs-comment">// 2.计算分页参数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> (current - <span class="hljs-number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;<br><br>        <span class="hljs-comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="hljs-comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span><br>                .search(<br>                        key,<br>                        GeoReference.fromCoordinate(x, y),<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-number">5000</span>),<br>                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)<br>                );<br>        <span class="hljs-comment">// 4.解析出id</span><br>        <span class="hljs-keyword">if</span> (results == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>        &#125;<br>        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();<br>        <span class="hljs-keyword">if</span> (list.size() &lt;= from) &#123;<br>            <span class="hljs-comment">// 没有下一页了，结束</span><br>            <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>        &#125;<br>        <span class="hljs-comment">// 4.1.截取 from ~ end的部分</span><br>        List&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list.size());<br>        Map&lt;String, Distance&gt; distanceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(list.size());<br>        list.stream().skip(from).forEach(result -&gt; &#123;<br>            <span class="hljs-comment">// 4.2.获取店铺id</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">shopIdStr</span> <span class="hljs-operator">=</span> result.getContent().getName();<br>            ids.add(Long.valueOf(shopIdStr));<br>            <span class="hljs-comment">// 4.3.获取距离</span><br>            <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> result.getDistance();<br>            distanceMap.put(shopIdStr, distance);<br>        &#125;);<br>        <span class="hljs-comment">// 5.根据id查询Shop</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>        List&lt;Shop&gt; shops = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br>        <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());<br>        &#125;<br>        <span class="hljs-comment">// 6.返回</span><br>        <span class="hljs-keyword">return</span> Result.ok(shops);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="11、用户签到"><a href="#11、用户签到" class="headerlink" title="11、用户签到"></a>11、用户签到</h2><h4 id="11-1、用户签到-BitMap功能演示"><a href="#11-1、用户签到-BitMap功能演示" class="headerlink" title="11.1、用户签到-BitMap功能演示"></a>11.1、用户签到-BitMap功能演示</h4><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302120.png" alt="1653823145495"></p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302121.png" alt="1653824498278"></p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h4 id="11-2-、用户签到-实现签到功能"><a href="#11-2-、用户签到-实现签到功能" class="headerlink" title="11.2 、用户签到-实现签到功能"></a>11.2 、用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302122.png" alt="1653833970361"></p><p><strong>代码</strong></p><p>UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/sign&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-keyword">return</span> userService.sign();<br>&#125;<br></code></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">// 3.拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">// 4.获取今天是本月的第几天</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">// 5.写入Redis SETBIT key offset 1</span><br>    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-3-用户签到-签到统计"><a href="#11-3-用户签到-签到统计" class="headerlink" title="11.3 用户签到-签到统计"></a>11.3 用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302123.png" alt="1653834455899"></p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>  BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：如何从后向前遍历每个bit位？</strong></p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302124.png" alt="1653835784444"></p><p>代码</p><p><strong>UserController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/sign/count&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> userService.signCount();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UserServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">// 3.拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">// 4.获取今天是本月的第几天</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span><br>    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(<br>            key,<br>            BitFieldSubCommands.create()<br>                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>)<br>    );<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> || result.isEmpty()) &#123;<br>        <span class="hljs-comment">// 没有任何签到结果</span><br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> result.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-literal">null</span> || num == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.循环遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span><br>        <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果为0，说明未签到，结束</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果不为0，说明已签到，计数器+1</span><br>            count++;<br>        &#125;<br>        <span class="hljs-comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span><br>        num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(count);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-4-额外加餐-关于使用bitmap来解决缓存穿透的方案"><a href="#11-4-额外加餐-关于使用bitmap来解决缓存穿透的方案" class="headerlink" title="11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案"></a>11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案</h4><p>回顾<strong>缓存穿透</strong>：</p><p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p><p>解决方案：</p><ul><li><p>判断id&lt;0</p></li><li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p></li></ul><p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p><p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p><p>所以我们如何解决呢？</p><p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302125.png" alt="1653836416586"></p><p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p><p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p><p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p><p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p><p>id % bitmap.size  &#x3D; 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302126.png" alt="1653836578970"></p><h2 id="12、UV统计"><a href="#12、UV统计" class="headerlink" title="12、UV统计"></a>12、UV统计</h2><h3 id="12-1-、UV统计-HyperLogLog"><a href="#12-1-、UV统计-HyperLogLog" class="headerlink" title="12.1 、UV统计-HyperLogLog"></a>12.1 、UV统计-HyperLogLog</h3><p>首先我们搞懂两个概念：</p><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302127.png" alt="1653837988985"></p><h3 id="12-2-UV统计-测试百万数据的统计"><a href="#12-2-UV统计-测试百万数据的统计" class="headerlink" title="12.2 UV统计-测试百万数据的统计"></a>12.2 UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_redis/202403191302128.png" alt="1653838053608"></p><p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1700. 无法吃午餐的学生数量</title>
    <link href="/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201700.%20%E6%97%A0%E6%B3%95%E5%90%83%E5%8D%88%E9%A4%90%E7%9A%84%E5%AD%A6%E7%94%9F%E6%95%B0%E9%87%8F/"/>
    <url>/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201700.%20%E6%97%A0%E6%B3%95%E5%90%83%E5%8D%88%E9%A4%90%E7%9A%84%E5%AD%A6%E7%94%9F%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h5 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h5><p>LeetCode 1700. 无法吃午餐的学生数量<a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/</a></p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。<br>餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：</p><p>如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。<br>否则，这名学生会 放弃这个三明治 并回到队列的尾部。<br>这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p><p>给你两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i 个三明治的类型（i &#x3D; 0 是栈的顶部）， students[j] 是初始队列里第 j 名学生对三明治的喜好（j &#x3D; 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch">https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h5 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h5><ul><li>总的来说就是，食物不能乱碰（厨师洁癖），每个人，只能拿栈顶的三明治。</li><li>如果栈顶是圆形的，你就需要一个喜欢吃圆的人把三明治拿走。</li><li>如果栈顶是方形的，你就需要一个喜欢吃方的人把三明治拿走。</li><li>如果大伙没有喜欢栈顶三明治的人，不好意思，都饿着吧。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">countStudents</span>(<span class="hljs-params">int[] students, int[] sandwiches</span>) &#123;<br>    <br>       int x=<span class="hljs-number">0</span>;<br>       int y=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;students.<span class="hljs-property">length</span>; i++)&#123;<br>    <br>           <span class="hljs-keyword">if</span>(students[i] == <span class="hljs-number">0</span>)&#123;<br>    <br>               x++;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>               y++;<br>           &#125;<br>       &#125;<br><br>        <span class="hljs-keyword">for</span>(int j=<span class="hljs-number">0</span>; j&lt;sandwiches.<span class="hljs-property">length</span>; j++)&#123;<br>    <br>            <span class="hljs-keyword">if</span>(sandwiches[j] == <span class="hljs-number">0</span> &amp;&amp; x&gt;<span class="hljs-number">0</span>)&#123;<br>    <br>                x--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sandwiches[j] == <span class="hljs-number">1</span> &amp;&amp; y&gt;<span class="hljs-number">0</span>)&#123;<br>    <br>                y--;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>                <span class="hljs-keyword">return</span> x+y;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x+y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 901. 股票价格跨度</title>
    <link href="/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20901.%20%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/"/>
    <url>/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20901.%20%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h5 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h5><p>LeetCode 901. 股票价格跨度<a href="https://leetcode.cn/problems/online-stock-span/">https://leetcode.cn/problems/online-stock-span/</a></p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p><p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><p>例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/online-stock-span">https://leetcode.cn/problems/online-stock-span</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h5 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h5><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543877.png" alt="在这里插入图片描述"></p><ul><li>设A为 B之前 最近的 比B大 的元素。</li><li>即A与B之间的任一元素X满足 A&gt;X &amp;&amp; X&lt;&#x3D; B</li><li>若此时在B后添加一元素C</li><li>若C小于B则返回1</li><li>否则，C&gt;&#x3D;B，又因为A与B之间任一元素X&lt;&#x3D;B, 即X&lt;&#x3D;B&lt;&#x3D;C</li><li>所以我们获取A后一共多少个元素就行。即A与B之间的元素在添加B时就可以remove了。</li><li>为了避免没有元素充当A这种情况，在初始化list时添加一个Integer.MAX_VALUE元素。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span> &#123;<br>    <br><br>    private <span class="hljs-title class_">List</span>&lt;int[]&gt; list;<br>    private int index = -<span class="hljs-number">1</span>;<br><br>    public <span class="hljs-title class_">StockSpanner</span>() &#123;<br>    <br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;int[]&gt;();<br>        list.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> int[]&#123;<br>    index,<span class="hljs-title class_">Integer</span>.<span class="hljs-property">MAX_VALUE</span>&#125;);<br>    &#125;<br>    <br>    public int <span class="hljs-title function_">next</span>(<span class="hljs-params">int price</span>) &#123;<br>    <br>        index++;<br>        <span class="hljs-keyword">for</span>(int i=list.<span class="hljs-title function_">size</span>()-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>    <br>            <span class="hljs-keyword">if</span>(list.<span class="hljs-title function_">get</span>(i)[<span class="hljs-number">1</span>] &lt;= price)&#123;<br>    <br>                list.<span class="hljs-title function_">remove</span>(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br><br>        int res = index - list.<span class="hljs-title function_">get</span>(list.<span class="hljs-title function_">size</span>()-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br><br>        list.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> int[]&#123;<br>    index,price&#125;);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your StockSpanner object will be instantiated and called as such:</span><br><span class="hljs-comment"> * StockSpanner obj = new StockSpanner();</span><br><span class="hljs-comment"> * int param_1 = obj.next(price);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 779. 第K个语法符号</title>
    <link href="/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/Leetcode%20779.%20%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/10/21/%E7%AE%97%E6%B3%95/LeetCode/Leetcode%20779.%20%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h5 id="题目来源：-Leetcode-779-第K个语法符号https-leetcode-cn-problems-k-th-symbol-in-grammar"><a href="#题目来源：-Leetcode-779-第K个语法符号https-leetcode-cn-problems-k-th-symbol-in-grammar" class="headerlink" title="题目来源： Leetcode 779. 第K个语法符号https://leetcode.cn/problems/k-th-symbol-in-grammar/"></a>题目来源： Leetcode 779. 第K个语法符号<a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/">https://leetcode.cn/problems/k-th-symbol-in-grammar/</a></h5><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>我们构建了一个包含 n 行( 索引从 1 开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。</p><p>例如，对于 n &#x3D; 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。<br>给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/k-th-symbol-in-grammar">https://leetcode.cn/problems/k-th-symbol-in-grammar</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h5 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h5><ul><li>每一行的前半部分正好为上一行</li><li>每一行的后半部分正好为前半部分的反转。</li><li>后半部分因为相当于上一行的反转，用1-x来达到这种目的</li></ul><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">kthGrammar</span>(<span class="hljs-params">int n, int k</span>) &#123;<br>    <br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>    <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br><span class="hljs-comment">//处于前半部分还是后半部分</span><br>        <span class="hljs-keyword">if</span>(k &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,n-<span class="hljs-number">2</span>))&#123;<br>    <br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>-<span class="hljs-title function_">kthGrammar</span>(n-<span class="hljs-number">1</span>, k-(int)<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,n-<span class="hljs-number">2</span>)));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">kthGrammar</span>(n-<span class="hljs-number">1</span>,k);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没想到这辈子还能赶上一次绿的题。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 6. Z字变换</title>
    <link href="/2022/03/28/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%206.%20Z%E5%AD%97%E5%8F%98%E6%8D%A2/"/>
    <url>/2022/03/28/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%206.%20Z%E5%AD%97%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><p>L C I R<br>E T O E S I I G<br>E D H N</p><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zigzag-conversionhttps://leetcode-cn.com/problems/zigzag-conversion">https://leetcode-cn.com/problems/zigzag-conversionhttps://leetcode-cn.com/problems/zigzag-conversion</a></p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入: s &#x3D; “LEETCODEISHIRING”, numRows &#x3D; 3<br>输出: “LCIRETOESIIGEDHN”</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入: s &#x3D; “LEETCODEISHIRING”, numRows &#x3D; 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:<br>L D R<br>E O E I I<br>E C I H N<br>T S G</p><h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><ol><li>一行或两行可以直接返回</li><li>其余情况先从上往下填满，然后向右上方向填满，重复此步骤</li><li>加起来，toString()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s, int numRows</span>) &#123;<br>        <span class="hljs-keyword">if</span>(numRows &lt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>    &#125;<br>        char[][] chs = <span class="hljs-keyword">new</span> char[numRows][s.<span class="hljs-title function_">length</span>()];<br>        int row = <span class="hljs-number">0</span>,col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-title function_">length</span>();)&#123;<br>            <span class="hljs-keyword">while</span>(row &lt; numRows &amp;&amp; i&lt;s.<span class="hljs-title function_">length</span>())<br>            &#123;<br>                chs[row][col] = s.<span class="hljs-title function_">charAt</span>(i++);<br>                row++;<br>            &#125;<br>            row--;<br>            <span class="hljs-keyword">while</span>(row &gt;= <span class="hljs-number">1</span> &amp;&amp; i&lt;s.<span class="hljs-title function_">length</span>()) &#123;<br>                chs[--row][++col] = s.<span class="hljs-title function_">charAt</span>(i++);<br>            &#125;<br>            row++;<br>        &#125;<br>        <span class="hljs-title class_">StringBuilder</span> stringBuilder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;numRows; i++)&#123;<br>            <span class="hljs-keyword">for</span>(int j=<span class="hljs-number">0</span>; j&lt; chs[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(chs[i][j] != <span class="hljs-number">0</span>) &#123;<br>                    stringBuilder.<span class="hljs-title function_">append</span>(chs[i][j]);<br>            &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stringBuilder.<span class="hljs-title function_">toString</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谷粒商城学习笔记</title>
    <link href="/2022/01/26/%E4%B8%9A%E5%8A%A1%E7%AC%94%E8%AE%B0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/26/%E4%B8%9A%E5%8A%A1%E7%AC%94%E8%AE%B0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="谷粒商城学习笔记"><a href="#谷粒商城学习笔记" class="headerlink" title="谷粒商城学习笔记"></a>谷粒商城学习笔记</h1><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>初始化线程的四种方式</p><ul><li>继承Thread</li><li>实现Runnable接口</li><li>实现Callable接口 + FutureTask （可以拿到返回结果，可以处理异常）</li><li>线程池<ul><li><code>Executors.newFixedThreadPool(10);</code></li><li><code>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</code></li><li>好处：<ul><li>降低资源的消耗：重复利用已经创建好的线程，降低线程的创建和销毁带来的损耗。</li><li>提高响应速度：在有核心线程或者空闲线程未超时时，任务来时可以直接执行，无需创建新的线程。包括CPU不停的在线程中来进行切换，如果线程数较少，那么响应速度就会变快。（比如200线程，很快会被轮到）</li><li>提高线程的可管理性：1、系统资源紧张时，可以直接把非核心任务池优化掉。2、解决了无限创建线程降低系统稳定性的问题</li></ul></li></ul></li></ul><blockquote><p>继承Thread和实现Runnable：无法获取线程的运行结果</p><p>实现Callable接口 + FutureTask：可以获取线程的运算结果，但不利于控制服务器中的线程资源。可能导致服务器资源耗尽。</p><p>线程池：可以控制资源，系统的性能稳定。</p></blockquote><blockquote><p>使用线程池而不是Thread、Runnable、Callable，为了避免系统资源耗尽。</p><p><code>将所有的多线程异步任务都交给线程池</code>，让线程池执行。</p><p>当前系统中的池一般为少数个，比如两个：核心任务池和非核心任务池。(系统资源紧张时，可以直接把非核心任务池优化掉)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize, <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)<br><span class="hljs-comment">//corePoolSize: 核心线程数。[一直存在，除非设置(allowCoreThreadTimeOut)]，创建好以后就准备的线程数量，就等待来接受异步任务去执行</span><br><span class="hljs-comment">//maximumPoolSize: 最大线程数量，控制资源。</span><br><span class="hljs-comment">//keepAliveTime: 存活时间，如果当前线程数量大于核心线程数，只要线程空闲大于指定的时间(keepAliveTime)，就会释放空闲的核心线程外的线程(maximumPoolSize - corePoolSize)。</span><br><span class="hljs-comment">//unit： 时间单位</span><br><span class="hljs-comment">//BlockingQueue workQueue：阻塞队列，如果任务很多，线程都在工作，将目前多的任务放在队列里面。只要有线程空闲，就会去队列里面取出新的任务继续执行。</span><br><span class="hljs-comment">//ThreadFactory： 线程创建的工厂</span><br><span class="hljs-comment">//RejectedExecutionHandler：拒绝策略。如果队列满了，按照我们指定的拒绝策略，拒绝执行任务。</span><br><span class="hljs-comment">//AbortPolicy ：抛出运行时异常RejectedExecutionException。这种策略丢弃任务，并抛出异常。（jdk默认策略）</span><br><span class="hljs-comment">//CallerRunsPolicy : 线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</span><br><span class="hljs-comment">//DiscardOldestPolicy（弃老策略）jdk：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序。</span><br><span class="hljs-comment">//DiscardPolicy ：发生拒绝策略时，不触发任何动作</span><br></code></pre></td></tr></table></figure><h3 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h3><ol><li><p>线程池创建，准备好数量为corePoolSize的核心线程，准备接受任务。</p></li><li><p>新的任务进来，用准备好的核心线程执行</p><ol><li>核心线程满了，进来的任务放入阻塞队列中。空闲下来的核心线程会自己到阻塞队列获取任务执行。</li><li>阻塞队列满了，开新线程执行，最大开启线程的数量为maximumPoolSize<ol><li>new LinkedBlockingDeque&lt;&gt;()：默认是Integer的最大值，可能会导致内存不够</li></ol></li><li>线程数量已满，使用RejectedExecutionHandler拒绝任务。</li></ol></li><li><p>任务都执行完，有很多空闲，在到达keepAliveTime后，释放空闲的线程，但不会释放核心线程。</p><blockquote><p>面试题：一个线程池 core 7, max 20, queue 50, 100并发进来怎么分配的</p><ul><li>7个会立即执行</li><li>50个进入阻塞队列</li><li>再开13个线程进行执行</li><li>剩下的30个就使用拒绝策略</li></ul></blockquote></li></ol><h4 id="常见的四种线程池"><a href="#常见的四种线程池" class="headerlink" title="常见的四种线程池"></a>常见的四种线程池</h4><ul><li>newCachedThreadPool<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。core是0，所有的都可以回收。</li><li>newFixedThreadPool<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在对队列中等待。固定大小，core&#x3D;max。都不可回收。</li><li>newScheduledThreadPool<br>创建一个定长线程池。支持定时及周期性去执行。定时任务的线程池。</li><li>newSingleThreadExecutor<br>创建一个单线程化的线程池，他只会用唯一的工作线程来执行任务，保证所有任务。后台从队列里面获取任务，挨个执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1716. 计算力扣银行的钱</title>
    <link href="/2022/01/15/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201716.%20%E8%AE%A1%E7%AE%97%E5%8A%9B%E6%89%A3%E9%93%B6%E8%A1%8C%E7%9A%84%E9%92%B1/"/>
    <url>/2022/01/15/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%201716.%20%E8%AE%A1%E7%AE%97%E5%8A%9B%E6%89%A3%E9%93%B6%E8%A1%8C%E7%9A%84%E9%92%B1/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>easy题我重拳出击！</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。</p><p>最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。在接下来每一个周一，他都会比 前一个周一 多存入 1 块钱。</p><p>给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank">https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>点击跳转题目<a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/">https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>简单的等差数列公式。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>else语句中<br>第一部分为所有完整周的原始形态的值，<br>第二部分为所有完整周的增加部分的值，<br>第三部分为剩余天数的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">totalMoney</span>(<span class="hljs-params">int n</span>) &#123;<br>    <br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">7</span>)&#123;<br>    <br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>    <br>            <span class="hljs-keyword">return</span> (n/<span class="hljs-number">7</span>*<span class="hljs-number">28</span> + <span class="hljs-number">7</span>*(n/<span class="hljs-number">7</span>-<span class="hljs-number">1</span>)*(n/<span class="hljs-number">7</span>)/<span class="hljs-number">2</span> + (<span class="hljs-number">1</span>+n-n/<span class="hljs-number">7</span>*<span class="hljs-number">7</span> + <span class="hljs-number">2</span>*(n/<span class="hljs-number">7</span>))*(n-n/<span class="hljs-number">7</span>*<span class="hljs-number">7</span>)/<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 169. 多数元素</title>
    <link href="/2022/01/13/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <url>/2022/01/13/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="多数元素leetcode169"><a href="#多数元素leetcode169" class="headerlink" title="多数元素leetcode169"></a>多数元素leetcode169</h3><h5 id="1、题目"><a href="#1、题目" class="headerlink" title="1、题目"></a>1、题目</h5><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/majority-element">https://leetcode-cn.com/problems/majority-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>点击跳转力扣169多数元素<a href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p><h5 id="2、思路"><a href="#2、思路" class="headerlink" title="2、思路"></a>2、思路</h5><p>摩尔投票算法。</p><p>个人理解：</p><p>记录第一个数为flag，初始化count为1，从第二个数开始遍历，当前元素与flag相等时，count++；<br>当前元素与flag不相等时，count–，当count为0时，记录下一个元素为flag，遍历到末尾则flag为最终结果。</p><p>原理</p><p>两两抵消，flag元素和非flag元素。当flag元素全部抵消（count&#x3D;&#x3D;0）时，下一个元素为新的flag。最终剩下的即为多数元素。</p><h5 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">vector&lt;int&gt;&amp; nums</span>) &#123;<br>    <br>        int flag = *nums.<span class="hljs-title function_">begin</span>();<br>        int count=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(auto i=nums.<span class="hljs-title function_">begin</span>()+<span class="hljs-number">1</span>; i&lt;nums.<span class="hljs-title function_">end</span>(); i++)&#123;<br>    <br>            <span class="hljs-keyword">if</span>(flag == *i)&#123;<br>    <br>                count++;<br>                <span class="hljs-keyword">if</span>(count &gt; nums.<span class="hljs-title function_">size</span>()/<span class="hljs-number">2</span>)&#123;<br>    <br>                    <span class="hljs-keyword">return</span> flag;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>                count--;<br>                <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br>    <br>                    flag = *(++i);<br>                    count = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据处理之决策树</title>
    <link href="/2021/04/13/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2021/04/13/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="实验三、数据处理之决策树"><a href="#实验三、数据处理之决策树" class="headerlink" title="实验三、数据处理之决策树"></a>实验三、数据处理之决策树</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><h4 id="1-熟悉掌握决策树的原理，"><a href="#1-熟悉掌握决策树的原理，" class="headerlink" title="1. 熟悉掌握决策树的原理，"></a>1. 熟悉掌握决策树的原理，</h4><h4 id="2-熟练掌握决策树的生成方法与过程"><a href="#2-熟练掌握决策树的生成方法与过程" class="headerlink" title="2. 熟练掌握决策树的生成方法与过程"></a>2. 熟练掌握决策树的生成方法与过程</h4><h3 id="二、实验工具"><a href="#二、实验工具" class="headerlink" title="二、实验工具"></a>二、实验工具</h3><h4 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h4><h4 id="2-sklearn"><a href="#2-sklearn" class="headerlink" title="2. sklearn"></a>2. sklearn</h4><h4 id="3-pydotplus"><a href="#3-pydotplus" class="headerlink" title="3. pydotplus"></a>3. pydotplus</h4><h3 id="三、实验简介"><a href="#三、实验简介" class="headerlink" title="三、实验简介"></a>三、实验简介</h3><p>决策树是一个非参数的监督式学习方法，主要用于分类和回归。算法的目标是通过推断数据特征，学习决策规则从而创建一个预测目标变量的模型。</p><h3 id="四、实验内容"><a href="#四、实验内容" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-自己创建至少2个向量，每个向量至少1个属性和1个类标号，根据向量生成决策树，并利用该决策树进行预测。如："><a href="#1-自己创建至少2个向量，每个向量至少1个属性和1个类标号，根据向量生成决策树，并利用该决策树进行预测。如：" class="headerlink" title="1. 自己创建至少2个向量，每个向量至少1个属性和1个类标号，根据向量生成决策树，并利用该决策树进行预测。如："></a>1. 自己创建至少2个向量，每个向量至少1个属性和1个类标号，根据向量生成决策树，并利用该决策树进行预测。如：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> tree<br>X = [[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>], [<span class="hljs-number">15</span>, <span class="hljs-number">17</span>],[<span class="hljs-number">23</span>,<span class="hljs-number">21</span>],[<span class="hljs-number">50</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">34</span>]]<br>Y = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>clf = tree.<span class="hljs-title class_">DecisionTreeClassifier</span>()<br>clf = clf.<span class="hljs-title function_">fit</span>(X, Y)<br><br>clf.<span class="hljs-title function_">predict</span>([[<span class="hljs-number">22.</span>, <span class="hljs-number">22.</span>]])<br>clf.<span class="hljs-title function_">predict_proba</span>([[<span class="hljs-number">22.</span>, <span class="hljs-number">22.</span>]])       #计算属于每个类的概率<br></code></pre></td></tr></table></figure><p>要求根据要求随机生成数据，并构建决策树，并举例预测。</p><h4 id="2-对鸢尾花数据构建决策树，"><a href="#2-对鸢尾花数据构建决策树，" class="headerlink" title="2. 对鸢尾花数据构建决策树，"></a>2. 对鸢尾花数据构建决策树，</h4><p>(1) 调用数据的方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">datasets</span> <span class="hljs-keyword">import</span> load_iris<br>iris = <span class="hljs-title function_">load_iris</span>()# 从sklearn 数据集中获取鸢尾花数据。<br></code></pre></td></tr></table></figure><p>(2) 利用sklearn中的决策树方法对鸢尾花数据建立决策树<br>(3) 为了能够直观看到建好的决策树，安装 pydotplus, 方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">pip install pydotplus<br></code></pre></td></tr></table></figure><p>pydotplus使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> pydotplus #引入pydotplus<br>dot_data = tree.<span class="hljs-title function_">export_graphviz</span>(clf, out_file=<span class="hljs-title class_">None</span>) <br>graph = pydotplus.<span class="hljs-title function_">graph_from_dot_data</span>(dot_data) <br>graph.<span class="hljs-title function_">write_pdf</span>(<span class="hljs-string">&quot;iris.pdf&quot;</span>)#将图写成pdf文件<br></code></pre></td></tr></table></figure><h3 id="五、实验总结（写出本次实验的收获，遇到的问题等）"><a href="#五、实验总结（写出本次实验的收获，遇到的问题等）" class="headerlink" title="五、实验总结（写出本次实验的收获，遇到的问题等）"></a>五、实验总结（写出本次实验的收获，遇到的问题等）</h3><h4 id="1、自己创建两个变量，建立决策树，并进行预测"><a href="#1、自己创建两个变量，建立决策树，并进行预测" class="headerlink" title="1、自己创建两个变量，建立决策树，并进行预测"></a>1、自己创建两个变量，建立决策树，并进行预测</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> tree<br>X = [[<span class="hljs-number">20</span>, <span class="hljs-number">21</span>], [<span class="hljs-number">22</span>, <span class="hljs-number">23</span>]]<br>Y = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>clf = tree.<span class="hljs-title class_">DecisionTreeClassifier</span>()<br>clf = clf.<span class="hljs-title function_">fit</span>(X, Y)<br><br><span class="hljs-title function_">print</span>(clf.<span class="hljs-title function_">predict</span>([[<span class="hljs-number">22.</span>, <span class="hljs-number">22.</span>]]))<br><span class="hljs-title function_">print</span>(clf.<span class="hljs-title function_">predict_proba</span>([[<span class="hljs-number">22.</span>, <span class="hljs-number">22.</span>]]))     #计算属于每个类的概率<br></code></pre></td></tr></table></figure><p><img src="/../images/e15c7344-c604-4531-bd24-ab95429982c7.png" alt="image.png"></p><h4 id="2、对鸢尾花数据构建决策树，并通过pydotplus，将决策树生成为pdf文件。"><a href="#2、对鸢尾花数据构建决策树，并通过pydotplus，将决策树生成为pdf文件。" class="headerlink" title="2、对鸢尾花数据构建决策树，并通过pydotplus，将决策树生成为pdf文件。"></a>2、对鸢尾花数据构建决策树，并通过pydotplus，将决策树生成为pdf文件。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">datasets</span> <span class="hljs-keyword">import</span> load_iris<br><span class="hljs-keyword">import</span> pydotplus #引入pydotplus<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> tree<br><br>iris = <span class="hljs-title function_">load_iris</span>()# 获取鸢尾花数据。<br><br>mode = tree.<span class="hljs-title class_">DecisionTreeClassifier</span>()<br><br>clf = mode.<span class="hljs-title function_">fit</span>(iris.<span class="hljs-property">data</span>, iris.<span class="hljs-property">target</span>)<br><br>dot_data = tree.<span class="hljs-title function_">export_graphviz</span>(clf, out_file=<span class="hljs-title class_">None</span>)<br>graph = pydotplus.<span class="hljs-title function_">graph_from_dot_data</span>(dot_data)<br>graph.<span class="hljs-title function_">write_pdf</span>(<span class="hljs-string">&quot;iris.pdf&quot;</span>)#将图写成pdf文件<br></code></pre></td></tr></table></figure><p><img src="/../images/95514db3-7533-4fa8-9391-e5a61761f576.png" alt="image.png"></p><h4 id="3、根据给的数据集自己编写决策树构建程序"><a href="#3、根据给的数据集自己编写决策树构建程序" class="headerlink" title="3、根据给的数据集自己编写决策树构建程序"></a>3、根据给的数据集自己编写决策树构建程序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">#  X 每个数组包括 <br>#<span class="hljs-title class_">Refund</span>yes = <span class="hljs-number">1</span>       no=<span class="hljs-number">0</span>,<br>#<span class="hljs-title class_">Marital</span> <span class="hljs-title class_">Status</span>single = <span class="hljs-number">0</span>    married = <span class="hljs-number">1</span>    divorce = <span class="hljs-number">2</span>，<br>#<span class="hljs-title class_">Taxable</span> <span class="hljs-title class_">Income</span>&lt;80k = <span class="hljs-number">0</span>      &gt;=<span class="hljs-number">80</span> = <span class="hljs-number">1</span>、<br>#<span class="hljs-title class_">Cheat</span>yes = <span class="hljs-number">1</span>       no = <span class="hljs-number">0</span><br><br>X = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>]<br><br>Y = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br><br>mode = tree.<span class="hljs-title class_">DecisionTreeClassifier</span>()<br><br>clf = mode.<span class="hljs-title function_">fit</span>(X, Y)<br><br>dot_data = tree.<span class="hljs-title function_">export_graphviz</span>(clf, out_file=<span class="hljs-title class_">None</span>)<br>graph = pydotplus.<span class="hljs-title function_">graph_from_dot_data</span>(dot_data)<br>graph.<span class="hljs-title function_">write_pdf</span>(<span class="hljs-string">&quot;fyy.pdf&quot;</span>)#将图写成pdf文件<br></code></pre></td></tr></table></figure><p><img src="/../images/0379c3ce-7c81-4fd0-878a-6c4b3686c8eb.png" alt="image.png"></p><h3 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h3><ul><li>学会了使用<br>tree.DecisionTreeClassifier()方法<br>tree.DecisionTreeClassifier().fit（）方法<br>tree.export_graphviz()方法，<br>pydotplus.graph_from_dot_data()方法等等。</li><li>成功使用鸢尾花数据生成决策树。</li><li>成功利用pydotplus生成pdf文件。</li><li>自己写构建决策树的算法还有一点问题，主要是逻辑比较复杂，有点弄不明白。</li><li>对决策树的算法有了更深的了解。</li></ul>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其它</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win10在VMware中安装Ubuntu18.04.5</title>
    <link href="/2021/04/09/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/Win10%E5%9C%A8VMware%E4%B8%AD%E5%AE%89%E8%A3%85Ubuntu18.04.5/"/>
    <url>/2021/04/09/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/Win10%E5%9C%A8VMware%E4%B8%AD%E5%AE%89%E8%A3%85Ubuntu18.04.5/</url>
    
    <content type="html"><![CDATA[<h5 id="首先安装VMware"><a href="#首先安装VMware" class="headerlink" title="首先安装VMware"></a>首先安装VMware</h5><h5 id="其次下载Ubuntu18-04-5的iso磁盘。"><a href="#其次下载Ubuntu18-04-5的iso磁盘。" class="headerlink" title="其次下载Ubuntu18.04.5的iso磁盘。"></a>其次下载Ubuntu18.04.5的iso磁盘。</h5><p><strong>没有图片的步骤都选择默认的：</strong><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543082.png" alt="在这里插入图片描述"></p><p>安装完虚拟机之后，编辑虚拟机设置。选择硬件的CD&#x2F;DVD<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543083.png" alt="在这里插入图片描述"></p><h5 id="开启虚拟机"><a href="#开启虚拟机" class="headerlink" title="开启虚拟机"></a>开启虚拟机</h5><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543084.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543085.png" alt="在这里插入图片描述"><br>「正常安装」将安装所有应用程序，包括网络浏览器、办公套件、游戏和媒体播放器。 如果您想要设置完整的桌面，请选择「正常安装」。 如果您只想要最小化的系统，有 Web 浏览器和基本实用程序，请选择「最小安装」。<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543086.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543087.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543088.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543089.png" alt="在这里插入图片描述"><br>选择自己的时区<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543090.png" alt="在这里插入图片描述"><br>输入自己的信息后，选择继续<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543091.png" alt="在这里插入图片描述"><br>此时需要等待系统安装一段时间。<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543092.png" alt="在这里插入图片描述"></p><p>安装完，就可以使用Ubuntu系统啦。</p><p>如果有帮助到你，非常荣幸。</p><p>如果大家有心情的话，鼓励一下我也可以的（我是穷逼大学生）。😁<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543093.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543094.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其它</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO基础知识</title>
    <link href="/2021/04/06/IO/Java%20IO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/06/IO/Java%20IO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="IO-流简介"><a href="#IO-流简介" class="headerlink" title="IO 流简介"></a>IO 流简介</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h3><p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p><p><code>InputStream</code> 常用方法：</p><ul><li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li><li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li><li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li><li><code>available()</code>：返回输入流中可以读取的字节数。</li><li><code>close()</code>：关闭输入流释放相关的系统资源。</li></ul><p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p><ul><li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li><li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li><li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li></ul><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><p><code>FileInputStream</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Number of remaining bytes:&quot;</span><br>            + fis.available());<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> fis.skip(<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;The actual number of bytes skipped:&quot;</span> + skip);<br>    System.out.print(<span class="hljs-string">&quot;The content read from file:&quot;</span>);<br>    <span class="hljs-keyword">while</span> ((content = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，一般我们是不会直接单独使用 <code>FileInputStream</code> ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流）来使用。</p><p>像下面这段代码在我们的项目中就比较常见，我们通过 <code>readAllBytes()</code> 读取输入流所有字节并将其直接赋值给一个 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br><span class="hljs-comment">// 读取文件的内容并复制到 String 对象中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufferedInputStream.readAllBytes());<br>System.out.println(result);<br></code></pre></td></tr></table></figure><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br><span class="hljs-comment">//必须将fileInputStream作为构造参数才能使用</span><br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dataInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(fileInputStream);<br><span class="hljs-comment">//可以读取任意具体的类型数据</span><br>dataInputStream.readBoolean();<br>dataInputStream.readInt();<br>dataInputStream.readUTF();<br></code></pre></td></tr></table></figure><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;object.data&quot;</span>));<br><span class="hljs-type">MyClass</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> (MyClass) input.readObject();<br>input.close();<br></code></pre></td></tr></table></figure><p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p><h3 id="OutputStream（字节输出流）"><a href="#OutputStream（字节输出流）" class="headerlink" title="OutputStream（字节输出流）"></a>OutputStream（字节输出流）</h3><p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p><p><code>OutputStream</code> 常用方法：</p><ul><li><code>write(int b)</code>：将特定字节写入输出流。</li><li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li><li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li><li><code>close()</code>：关闭输出流释放相关的系统资源。</li></ul><p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p><p><code>FileOutputStream</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-string">&quot;test&quot;</span>.getBytes();<br>    output.write(array);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace(<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code>（字节缓冲输出流，后文会讲到）来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fileOutputStream)<br></code></pre></td></tr></table></figure><p><strong><code>DataOutputStream</code></strong> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileOutputStream</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输出流</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;out.txt&quot;</span>);<br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dataOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(fileOutputStream);<br><span class="hljs-comment">// 输出任意数据类型</span><br>dataOutputStream.writeBoolean(<span class="hljs-literal">true</span>);<br>dataOutputStream.writeByte(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（<code>ObjectInputStream</code>,反序列化），<code>ObjectOutputStream</code>将对象写入到输出流(<code>ObjectOutputStream</code>，序列化)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;file.txt&quot;</span>)<br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Guide哥&quot;</span>, <span class="hljs-string">&quot;JavaGuide作者&quot;</span>);<br>output.writeObject(person);<br></code></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>个人认为主要有两点原因：</p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li><li>如果我们不知道编码类型就很容易出现乱码问题。</li></ul><p>乱码问题这个很容易就可以复现，我们只需要将上面提到的 <code>FileInputStream</code> 代码示例中的 <code>input.txt</code> 文件内容改为中文即可，原代码不需要改动。可以很明显地看到读取出来的内容已经变成了乱码。</p><p>因此，I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。</p><p>常用字符编码所占字节数？</p><ul><li><code>utf8</code> :英文占 1 字节，中文占 3 字节</li><li><code>unicode</code>：任何字符都占 2 个字节</li><li><code>gbk</code>：英文占 1 字节，中文占 2 字节</li></ul><h3 id="Reader（字符输入流）"><a href="#Reader（字符输入流）" class="headerlink" title="Reader（字符输入流）"></a>Reader（字符输入流）</h3><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p><p><code>Reader</code> 常用方法：</p><ul><li><code>read()</code> : 从输入流读取一个字符。</li><li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li><li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li><li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li></ul><p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字节流转换为字符流的桥梁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader</span> &#123;<br>&#125;<br><span class="hljs-comment">// 用于读取字符文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStreamReader</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FileReader</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);) &#123;<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> fileReader.skip(<span class="hljs-number">3</span>);<br>    System.out.println(<span class="hljs-string">&quot;The actual number of bytes skipped:&quot;</span> + skip);<br>    System.out.print(<span class="hljs-string">&quot;The content read from file:&quot;</span>);<br>    <span class="hljs-keyword">while</span> ((content = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Writer（字符输出流）"><a href="#Writer（字符输出流）" class="headerlink" title="Writer（字符输出流）"></a>Writer（字符输出流）</h3><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p><p><code>Writer</code> 常用方法：</p><ul><li><code>write(int c)</code> : 写入单个字符。</li><li><code>write(char[] cbuf)</code>：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li><li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>write(String str)</code>：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li><li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li><li><code>append(char c)</code>：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li><li><code>close()</code>:关闭输出流释放相关的系统资源。</li></ul><p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符流转换为字节流的桥梁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Writer</span> &#123;<br>&#125;<br><span class="hljs-comment">// 用于写入字符到文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OutputStreamWriter</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FileWriter</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Writer</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>    output.write(<span class="hljs-string">&quot;你好，我是Guide。&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p><p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br></code></pre></td></tr></table></figure><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p><p>我使用 <code>write(int b)</code> 和 <code>read()</code> 方法，分别通过字节流和字节缓冲流复制一个 <code>524.9 mb</code> 的 PDF 文件耗时对比如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">使用缓冲流复制PDF文件总耗时:15428 毫秒<br>使用普通字节流复制PDF文件总耗时:2555062 毫秒<br></code></pre></td></tr></table></figure><p>两者耗时差别非常大，缓冲流耗费的时间是字节流的 1&#x2F;165。</p><p>测试代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy_pdf_to_another_pdf_buffer_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 记录开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统.pdf&quot;</span>));<br>         <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;<br>        <span class="hljs-type">int</span> content;<br>        <span class="hljs-keyword">while</span> ((content = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(content);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 记录结束时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy_pdf_to_another_pdf_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 记录开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统.pdf&quot;</span>);<br>         <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;<br>        <span class="hljs-type">int</span> content;<br>        <span class="hljs-keyword">while</span> ((content = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            fos.write(content);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 记录结束时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是调用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。</p><p>这次我们使用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 方法，分别通过字节流和字节缓冲流复制一个 524.9 mb 的 PDF 文件耗时对比如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">使用缓冲流复制PDF文件总耗时:695 毫秒<br>使用普通字节流复制PDF文件总耗时:989 毫秒<br></code></pre></td></tr></table></figure><p>两者耗时差别不是很大，缓冲流的性能要略微好一点点。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy_pdf_to_another_pdf_with_byte_array_buffer_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 记录开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统.pdf&quot;</span>));<br>         <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> ((len = bis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(bytes, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 记录结束时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy_pdf_to_another_pdf_with_byte_array_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 记录开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统.pdf&quot;</span>);<br>         <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> ((len = fis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>            fos.write(bytes, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 记录结束时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BufferedInputStream（字节缓冲输入流）"><a href="#BufferedInputStream（字节缓冲输入流）" class="headerlink" title="BufferedInputStream（字节缓冲输入流）"></a>BufferedInputStream（字节缓冲输入流）</h3><p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p><p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 <code>BufferedInputStream</code> 源码即可得到这个结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br>    <span class="hljs-comment">// 内部缓冲区数组</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">byte</span> buf[];<br>    <span class="hljs-comment">// 缓冲区的默认大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8192</span>;<br>    <span class="hljs-comment">// 使用默认的缓冲区大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>(in, DEFAULT_BUFFER_SIZE);<br>    &#125;<br>    <span class="hljs-comment">// 自定义缓冲区大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">super</span>(in);<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>        &#125;<br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缓冲区的大小默认为 <strong>8192</strong> 字节，可以通过 <code>BufferedInputStream(InputStream in, int size)</code> 这个构造方法来指定缓冲区的大小。</p><h3 id="BufferedOutputStream（字节缓冲输出流）"><a href="#BufferedOutputStream（字节缓冲输出流）" class="headerlink" title="BufferedOutputStream（字节缓冲输出流）"></a>BufferedOutputStream（字节缓冲输出流）</h3><p><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>))) &#123;<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-string">&quot;JavaGuide&quot;</span>.getBytes();<br>    bos.write(array);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BufferedOutputStream</code> 内部也维护了一个缓冲区，大小也是 <strong>8192</strong> 字节。</p><h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(<span class="hljs-string">&quot;Hello！&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Hello！&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>System.out</code> 实际是用于获取一个 <code>PrintStream</code> 对象，<code>print</code>方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。</p><p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterOutputStream</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Appendable</span>, Closeable &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Writer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h2><p>这里要介绍的随机访问流指的是支持随意跳转到文件的任意位置进行读写的 <code>RandomAccessFile</code> 。</p><p><code>RandomAccessFile</code> 的构造方法如下，我们可以指定 <code>mode</code>（读写模式）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomAccessFile</span><span class="hljs-params">(File file, String mode)</span><br>    <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <span class="hljs-built_in">this</span>(file, mode, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">// 私有方法</span><br><span class="hljs-comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">RandomAccessFile</span><span class="hljs-params">(File file, String mode, <span class="hljs-type">boolean</span> openAndDelete)</span>  <span class="hljs-keyword">throws</span> FileNotFoundException&#123;<br>  <span class="hljs-comment">// 省略大部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读写模式主要有下面四种：</p><ul><li><code>r</code> : 只读模式。</li><li><code>rw</code>: 读写模式</li><li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code> 同步更新对“文件的内容”的修改到外部存储设备。</li><li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code> 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li></ul><p>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p><p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p><p><code>RandomAccessFile</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;input.txt&quot;</span>), <span class="hljs-string">&quot;rw&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="hljs-string">&quot;,当前读取到的字符&quot;</span> + (<span class="hljs-type">char</span>) randomAccessFile.read() + <span class="hljs-string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());<br><span class="hljs-comment">// 指针当前偏移量为 6</span><br>randomAccessFile.seek(<span class="hljs-number">6</span>);<br>System.out.println(<span class="hljs-string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="hljs-string">&quot;,当前读取到的字符&quot;</span> + (<span class="hljs-type">char</span>) randomAccessFile.read() + <span class="hljs-string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());<br><span class="hljs-comment">// 从偏移量 7 的位置开始往后写入字节数据</span><br>randomAccessFile.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>&#125;);<br><span class="hljs-comment">// 指针当前偏移量为 0，回到起始位置</span><br>randomAccessFile.seek(<span class="hljs-number">0</span>);<br>System.out.println(<span class="hljs-string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="hljs-string">&quot;,当前读取到的字符&quot;</span> + (<span class="hljs-type">char</span>) randomAccessFile.read() + <span class="hljs-string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());<br></code></pre></td></tr></table></figure><p><code>input.txt</code> 文件内容：</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016123203978.png" alt="image-20231016123203978"></p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1<br>读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7<br>读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1<br></code></pre></td></tr></table></figure><p><code>input.txt</code> 文件内容变为 <code>ABCDEFGHIJK</code> 。</p><p><code>RandomAccessFile</code> 的 <code>write</code> 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;input.txt&quot;</span>), <span class="hljs-string">&quot;rw&quot;</span>);<br>randomAccessFile.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure><p>假设运行上面这段程序之前 <code>input.txt</code> 文件内容变为 <code>ABCD</code> ，运行之后则变为 <code>HIJK</code> 。</p><p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。断点续传就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p><p><code>RandomAccessFile</code> 可以帮助我们合并文件分片，示例代码如下：</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/io/20210609164749122.png" alt="img"></p><p><code>RandomAccessFile</code> 的实现依赖于 <code>FileDescriptor</code> (文件描述符) 和 <code>FileChannel</code> （内存映射文件）。</p>]]></content>
    
    
    <categories>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO模型</title>
    <link href="/2021/04/06/IO/Java%20IO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/04/06/IO/Java%20IO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="什么是-I-O"><a href="#什么是-I-O" class="headerlink" title="什么是 I&#x2F;O?"></a>什么是 I&#x2F;O?</h3><h4 id="计算机结构的角度解读I-O"><a href="#计算机结构的角度解读I-O" class="headerlink" title="计算机结构的角度解读I&#x2F;O"></a><strong>计算机结构的角度解读I&#x2F;O</strong></h4><p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p><p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p><p><strong>从计算机结构的视角来看的话， I&#x2F;O 描述了计算机系统与外部设备之间通信的过程。</strong></p><h4 id="应用程序的角度解读-I-O。"><a href="#应用程序的角度解读-I-O。" class="headerlink" title="应用程序的角度解读 I&#x2F;O。"></a><strong>应用程序的角度解读 I&#x2F;O。</strong></h4><p>为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p><p>平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。想要进行 IO 操作，一定是要依赖内核空间的能力。</p><p>并且，用户空间的程序不能直接访问内核空间。</p><p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p><p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p><p>常见IO有：<strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p><p><strong>从应用程序的视角来看的话，应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I&#x2F;O 调用后，会经历两个步骤：</p><ol><li>内核等待 I&#x2F;O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol><h3 id="有哪些常见的-IO-模型"><a href="#有哪些常见的-IO-模型" class="headerlink" title="有哪些常见的 IO 模型?"></a>有哪些常见的 IO 模型?</h3><p>UNIX 系统下， IO 模型一共有 5 种：<strong>同步阻塞 I&#x2F;O</strong>、<strong>同步非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。</p><h2 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I&#x2F;O)"></a>BIO (Blocking I&#x2F;O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><p>在客户端连接数量不高的情况下，是没问题的。但是，高并发情况下传统的 BIO 模型是无能为力的。所以需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p><h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking&#x2F;New I&#x2F;O)"></a>NIO (Non-blocking&#x2F;New I&#x2F;O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I&#x2F;O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><blockquote><p>  目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><strong>select 调用</strong>：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong>：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016161243160.png" alt="image-20231016161243160"><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016161256469.png" alt="image-20231016161256469"></p><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和<code>回调机制</code>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>BIO、NIO 和 AIO 对比</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016160928352.png" alt="image-20231016160928352"></p>]]></content>
    
    
    <categories>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO设计模式</title>
    <link href="/2021/04/06/IO/Java%20IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/04/06/IO/Java%20IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p><strong>装饰器（Decorator）模式</strong> 可以在不改变原有对象的情况下拓展其功能。</p><p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p><p>对于字节流来说， <code>FilterInputStream</code> （对应输入流）和<code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心，分别用于增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>我们常见的<code>BufferedInputStream</code>(字节缓冲输入流)、<code>DataInputStream</code> 等等都是<code>FilterInputStream</code> 的子类，<code>BufferedOutputStream</code>（字节缓冲输出流）、<code>DataOutputStream</code>等等都是<code>FilterOutputStream</code>的子类。</p><p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p><p><code>BufferedInputStream</code> 构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>    <span class="hljs-built_in">this</span>(in, DEFAULT_BUFFER_SIZE);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-built_in">super</span>(in);<br>    <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>    &#125;<br>    buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，<code>BufferedInputStream</code> 的构造函数其中的一个参数就是 <code>InputStream</code> 。</p><p><code>BufferedInputStream</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>))) &#123;<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> bis.skip(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span> ((content = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，你可以会想了：<strong>为啥我们直接不弄一个<code>BufferedFileInputStream</code>（字符缓冲文件输入流）呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedFileInputStream</span> <span class="hljs-variable">bfis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedFileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果 <code>InputStream</code>的子类比较少的话，这样做是没问题的。不过， <code>InputStream</code>的子类实在太多，继承关系也太复杂了。如果我们为每一个子类都定制一个对应的缓冲输入流，那岂不是太麻烦了。</p><p>如果你对 IO 流比较熟悉的话，你会发现<code>ZipInputStream</code> 和<code>ZipOutputStream</code> 还可以分别增强 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName));<br><span class="hljs-type">ZipInputStream</span> <span class="hljs-variable">zis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipInputStream</span>(bis);<br><br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(fileName));<br><span class="hljs-type">ZipOutputStream</span> <span class="hljs-variable">zipOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipOutputStream</span>(bos);<br></code></pre></td></tr></table></figure><p><code>ZipInputStream</code> 和<code>ZipOutputStream</code> 分别继承自<code>InflaterInputStream</code> 和<code>DeflaterOutputStream</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InflaterInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeflaterOutputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterOutputStream</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这也是装饰器模式很重要的一个特征，那就是可以对原始类嵌套使用多个装饰器。</p><p>为了实现这一效果，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。上面介绍到的这些 IO 相关的装饰类和原始类共同的父类是 <code>InputStream</code> 和<code>OutputStream</code>。</p><p>对于字符流来说，<code>BufferedReader</code> 可以用来增加 <code>Reader</code> （字符输入流）子类的功能，<code>BufferedWriter</code> 可以用来增加 <code>Writer</code> （字符输出流）子类的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(fileName), <span class="hljs-string">&quot;UTF-8&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><strong>适配器（Adapter Pattern）模式</strong> 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。</p><p>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong> 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。</p><p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。<code>InputStreamReader</code> 使用 <code>StreamDecoder</code> （流解码器）对字节进行解码，<strong>实现字节流到字符流的转换，</strong> <code>OutputStreamWriter</code> 使用<code>StreamEncoder</code>（流编码器）对字符进行编码，实现字符流到字节流的转换。</p><p><code>InputStream</code> 和 <code>OutputStream</code> 的子类是被适配者， <code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>是适配器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span><br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br></code></pre></td></tr></table></figure><p><code>java.io.InputStreamReader</code> 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader</span> &#123;<br><span class="hljs-comment">//用于解码的对象</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StreamDecoder sd;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">InputStreamReader</span><span class="hljs-params">(InputStream in)</span> &#123;<br>            <span class="hljs-built_in">super</span>(in);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 获取 StreamDecoder 对象</span><br>                sd = StreamDecoder.forInputStreamReader(in, <span class="hljs-built_in">this</span>, (String)<span class="hljs-literal">null</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 使用 StreamDecoder 对象做具体的读取工作</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">return</span> sd.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>java.io.OutputStreamWriter</code> 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Writer</span> &#123;<br>    <span class="hljs-comment">// 用于编码的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StreamEncoder se;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OutputStreamWriter</span><span class="hljs-params">(OutputStream out)</span> &#123;<br>        <span class="hljs-built_in">super</span>(out);<br>        <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 获取 StreamEncoder 对象</span><br>            se = StreamEncoder.forOutputStreamWriter(out, <span class="hljs-built_in">this</span>, (String)<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 使用 StreamEncoder 对象做具体的写入工作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        se.write(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="适配器模式和装饰器模式有什么区别呢？"><a href="#适配器模式和装饰器模式有什么区别呢？" class="headerlink" title="适配器模式和装饰器模式有什么区别呢？"></a><strong>适配器模式和装饰器模式有什么区别呢？</strong></h4><p><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</p><p><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 <code>StreamDecoder</code> （流解码器）和<code>StreamEncoder</code>（流编码器）就是分别基于 <code>InputStream</code> 和 <code>OutputStream</code> 来获取 <code>FileChannel</code>对象并调用对应的 <code>read</code> 方法和 <code>write</code> 方法进行字节数据的读取和写入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">StreamDecoder(InputStream in, Object lock, CharsetDecoder dec) &#123;<br>    <span class="hljs-comment">// 省略大部分代码</span><br>    <span class="hljs-comment">// 根据 InputStream 对象获取 FileChannel 对象</span><br>    ch = getChannel((FileInputStream)in);<br>&#125;<br></code></pre></td></tr></table></figure><p>适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</p><p>另外，<code>FutureTask</code> 类使用了适配器模式，<code>Executors</code> 的内部类 <code>RunnableAdapter</code> 实现属于适配器，用于将 <code>Runnable</code> 适配成 <code>Callable</code>。</p><p><code>FutureTask</code>参数包含 <code>Runnable</code> 的一个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-comment">// 调用 Executors 类的 callable 方法</span><br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>    <span class="hljs-built_in">this</span>.state = NEW;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Executors</code>中对应的方法和适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实际调用的是 Executors 的内部类 RunnableAdapter 的构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);<br>&#125;<br><span class="hljs-comment">// 适配器</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">final</span> Runnable task;<br>    <span class="hljs-keyword">final</span> T result;<br>    RunnableAdapter(Runnable task, T result) &#123;<br>        <span class="hljs-built_in">this</span>.task = task;<br>        <span class="hljs-built_in">this</span>.result = result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        task.run();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如</p><ul><li><code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（静态工厂）</li><li><code>Paths</code> 类的 <code>get</code> 方法创建 <code>Path</code> 对象（静态工厂）</li><li><code>ZipFileSystem</code> 类（<code>sun.nio</code>包下的类，属于 <code>java.nio</code> 相关的一些内部实现）的 <code>getPath</code> 的方法创建 <code>Path</code> 对象（简单工厂）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Files.newInputStream(Paths.get(generatorLogoPath))<br></code></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>NIO 中的文件目录监听服务使用到了观察者模式。</p><p>NIO 中的文件目录监听服务基于 <code>WatchService</code> 接口和 <code>Watchable</code> 接口。<code>WatchService</code> 属于观察者，<code>Watchable</code> 属于被观察者。</p><p><code>Watchable</code> 接口定义了一个用于将对象注册到 <code>WatchService</code>（监控服务） 并绑定监听事件的方法 <code>register</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Path</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Path&gt;, Iterable&lt;Path&gt;, Watchable&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Watchable</span> &#123;<br>        WatchKey <span class="hljs-title function_">register</span><span class="hljs-params">(WatchService watcher,</span><br><span class="hljs-params">                      WatchEvent.Kind&lt;?&gt;[] events,</span><br><span class="hljs-params">                      WatchEvent.Modifier... modifiers)</span><br>        <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>WatchService</code> 用于监听文件目录的变化，同一个 <code>WatchService</code> 对象能够监听多个文件目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 WatchService 对象</span><br><span class="hljs-type">WatchService</span> <span class="hljs-variable">watchService</span> <span class="hljs-operator">=</span> FileSystems.getDefault().newWatchService();<br><br><span class="hljs-comment">// 初始化一个被监控文件夹的 Path 类:</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;workingDirectory&quot;</span>);<br><span class="hljs-comment">// 将这个 path 对象注册到 WatchService（监控服务） 中去</span><br><span class="hljs-type">WatchKey</span> <span class="hljs-variable">watchKey</span> <span class="hljs-operator">=</span> path.register(<br>watchService, StandardWatchEventKinds...);<br></code></pre></td></tr></table></figure><p><code>Path</code> 类 <code>register</code> 方法的第二个参数 <code>events</code> （需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">WatchKey <span class="hljs-title function_">register</span><span class="hljs-params">(WatchService watcher,</span><br><span class="hljs-params">                  WatchEvent.Kind&lt;?&gt;... events)</span><br>    <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><p>常用的监听事件有 3 种：</p><ul><li>StandardWatchEventKinds.ENTRY_CREATE：文件创建。</li><li>StandardWatchEventKinds.ENTRY_DELETE : 文件删除。</li><li>StandardWatchEventKinds.ENTRY_MODIFY : 文件修改。</li></ul><p><code>register</code> 方法返回 <code>WatchKey</code> 对象，通过<code>WatchKey</code> 对象可以获取事件的具体信息比如文件目录下是创建、删除还是修改了文件、创建、删除或者修改的文件的具体名称是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">WatchKey key;<br><span class="hljs-keyword">while</span> ((key = watchService.take()) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;<br><span class="hljs-comment">// 可以调用 WatchEvent 对象的方法做一些事情比如输出事件的具体上下文信息</span><br>        &#125;<br>key.reset();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>WatchService</code> 内部是通过一个 daemon thread（守护线程）采用定期轮询的方式来检测文件的变化，简化后的源码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PollingWatchService</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractWatchService</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个 daemon thread（守护线程）轮询检测文件变化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService scheduledExecutor;<br><br>    PollingWatchService() &#123;<br>        scheduledExecutor = Executors.newSingleThreadScheduledExecutor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>                 <span class="hljs-meta">@Override</span><br>                 <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>                     <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>                     t.setDaemon(<span class="hljs-literal">true</span>);<br>                     <span class="hljs-keyword">return</span> t;<br>                 &#125;&#125;);<br>    &#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">enable</span><span class="hljs-params">(Set&lt;? extends WatchEvent.Kind&lt;?&gt;&gt; events, <span class="hljs-type">long</span> period)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>      <span class="hljs-comment">// 更新监听事件</span><br>      <span class="hljs-built_in">this</span>.events = events;<br>       <br>      <span class="hljs-comment">// 开启定期轮询</span><br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">thunk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; poll(); &#125;&#125;;<br>      <span class="hljs-built_in">this</span>.poller = scheduledExecutor.scheduleAtFixedRate(thunk, period, period, TimeUnit.SECONDS);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO核心知识</title>
    <link href="/2021/04/06/IO/Java%20NIO%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/06/IO/Java%20NIO%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="NIO-简介"><a href="#NIO-简介" class="headerlink" title="NIO 简介"></a>NIO 简介</h2><p>在传统的 Java I&#x2F;O 模型（BIO）中，I&#x2F;O 操作是以阻塞的方式进行的，这种阻塞模型在处理多个并发连接时可能会导致性能瓶颈。</p><p>Java1.4 版本引入了 <strong>NIO</strong> 。NIO 弥补了同步阻塞 I&#x2F;O 的不足，它在标准 Java 代码中提供了非阻塞、面向缓冲、基于通道的 I&#x2F;O，可以使用少量的线程来处理多个连接，大大提高了 I&#x2F;O 效率和并发。</p><p>⚠️需要注意：使用 NIO 并不一定意味着高性能，它的性能优势主要体现在高并发和高延迟的网络环境下。当连接数较少、并发程度较低或者网络传输速度较快时，NIO 的性能并不一定优于传统的 BIO 。</p><h2 id="NIO-核心组件"><a href="#NIO-核心组件" class="headerlink" title="NIO 核心组件"></a>NIO 核心组件</h2><p>NIO 主要包括以下三个核心组件：</p><ul><li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li><li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li><li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I&#x2F;O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li></ul><p>三者的关系</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016175543156.png" alt="image-20231016175543156"></p><h3 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h3><p>在传统的 BIO 中，数据的读写是面向流的， 分为字节流和字符流。</p><p>在 Java 1.4 的 NIO 库中，所有数据都是用缓冲区处理的，这是新库和之前的 BIO 的一个重要区别，有点类似于 BIO 中的缓冲流。NIO 在读取数据时，它是直接读到缓冲区中的。在写入数据时，写入到缓冲区中。 使用 NIO 在读写数据时，都是通过缓冲区进行操作。</p><p><code>Buffer</code> 的子类如下图所示。其中，最常用的是 <code>ByteBuffer</code>，它可以用来存储和操作字节数据。</p><p>Buffer 的子类</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016162106420.png" alt="image-20231016162106420"></p><p>可以将 Buffer 理解为一个数组，<code>IntBuffer</code>、<code>FloatBuffer</code>、<code>CharBuffer</code> 等分别对应 <code>int[]</code>、<code>float[]</code>、<code>char[]</code> 等。</p><p>为了更清晰地认识缓冲区，我们来简单看看<code>Buffer</code> 类中定义的四个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123;<br>    <span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>&#125;<br></code></pre></td></tr></table></figure><p>这四个成员变量的具体含义如下：</p><ol><li>容量（<code>capacity</code>）：<code>Buffer</code>可以存储的最大数据量，<code>Buffer</code>创建时设置且不可改变；</li><li>界限（<code>limit</code>）：<code>Buffer</code> 中可以读&#x2F;写数据的边界。写模式下，<code>limit</code> 代表最多能写入的数据，一般等于 <code>capacity</code>（可以通过<code>limit(int newLimit)</code>方法设置）；读模式下，<code>limit</code> 等于 Buffer 中实际写入的数据大小（所有位置都可以写，只有写的位置才可以读）。</li><li>位置（<code>position</code>）：索引。从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零。</li><li>标记（<code>mark</code>）：<code>Buffer</code>允许将位置直接定位到该标记处，这是一个可选属性；</li></ol><p>并且，上述变量满足如下的关系：<strong>0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong> 。</p><p>另外，Buffer 有读模式和写模式这两种模式，分别用于从 Buffer 中读取数据或者向 Buffer 中写入数据。Buffer 被创建之后默认是写模式，调用 <code>flip()</code> 可以切换到读模式。如果要再次切换回写模式，可以调用 <code>clear()</code> 或者 <code>compact()</code> 方法。</p><p>position 、limit 和 capacity 之前的关系</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016162411413.png" alt="image-20231016162411413"></p><p><code>Buffer</code> 对象不能通过 <code>new</code> 调用构造方法创建对象 ，只能通过静态方法实例化 <code>Buffer</code>。</p><p>以 <code>ByteBuffer</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 分配堆内存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>; <br><span class="hljs-comment">// 分配直接内存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocateDirect</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>; <br></code></pre></td></tr></table></figure><p>Buffer 最核心的两个方法：</p><ol><li><code>get</code> : 读取缓冲区的数据</li><li><code>put</code> ：向缓冲区写入数据</li></ol><p>其他的重要方法：</p><ul><li><code>flip</code> ：将缓冲区从写模式切换到读模式，它会将 <code>limit</code> 的值设置为当前 <code>position</code> 的值，将 <code>position</code> 的值设置为 0。</li><li><code>clear</code>:  清空缓冲区，将缓冲区从读模式切换到写模式，并将 <code>position</code> 的值设置为 0，将 <code>limit</code> 的值设置为 <code>capacity</code> 的值。</li></ul><p>Buffer 中数据变化的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.nio.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharBufferDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 分配一个容量为8的CharBuffer</span><br>        <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> CharBuffer.allocate(<span class="hljs-number">8</span>);<br>        System.out.println(<span class="hljs-string">&quot;初始状态：&quot;</span>); <br>        printState(buffer); <br><br>        <span class="hljs-comment">// 向buffer写入3个字符</span><br>        buffer.put(<span class="hljs-string">&#x27;a&#x27;</span>).put(<span class="hljs-string">&#x27;b&#x27;</span>).put(<span class="hljs-string">&#x27;c&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&quot;写入3个字符后的状态：&quot;</span>);<br>        printState(buffer);<br><br>        <span class="hljs-comment">// 调用flip()方法，准备读取buffer中的数据，将 position 置 0,limit 的置 3</span><br>        buffer.flip();<br>        System.out.println(<span class="hljs-string">&quot;调用flip()方法后的状态：&quot;</span>);<br>        printState(buffer);<br><br>        <span class="hljs-comment">// 读取字符</span><br>        <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123; <br>            System.out.print(buffer.get());<br>        &#125;<br><br>        <span class="hljs-comment">// 调用clear()方法，清空缓冲区，将 position 的值置为 0，将 limit 的值置为 capacity 的值</span><br>        buffer.clear();<br>        System.out.println(<span class="hljs-string">&quot;调用clear()方法后的状态：&quot;</span>);<br>        printState(buffer);<br>        <br>    &#125;<br><br>    <span class="hljs-comment">// 打印buffer的capacity、limit、position、mark的位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printState</span><span class="hljs-params">(CharBuffer buffer)</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;capacity: &quot;</span> + buffer.capacity());<br>        System.out.print(<span class="hljs-string">&quot;, limit: &quot;</span> + buffer.limit());<br>        System.out.print(<span class="hljs-string">&quot;, position: &quot;</span> + buffer.position());<br>        System.out.print(<span class="hljs-string">&quot;, mark 开始读取的字符: &quot;</span> + buffer.mark());<br>        System.out.println(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">初始状态：<br>capacity: 8, <span class="hljs-built_in">limit</span>: 8, position: 0<br><br>写入3个字符后的状态：<br>capacity: 8, <span class="hljs-built_in">limit</span>: 8, position: 3<br><br>准备读取buffer中的数据！<br><br>调用flip()方法后的状态：<br>capacity: 8, <span class="hljs-built_in">limit</span>: 3, position: 0<br><br>读取到的数据：abc<br><br>调用clear()方法后的状态：<br>capacity: 8, <span class="hljs-built_in">limit</span>: 8, position: 0   <br></code></pre></td></tr></table></figure><h3 id="Channel（通道）"><a href="#Channel（通道）" class="headerlink" title="Channel（通道）"></a>Channel（通道）</h3><p>Channel 是一个通道，它建立了与数据源（如文件、网络套接字等）之间的连接。我们可以利用它来读取和写入数据，就像打开了一条自来水管，让数据在 Channel 中自由流动。</p><p>BIO 中的流是单向的，分为各种 <code>InputStream</code>（输入流）和 <code>OutputStream</code>（输出流），数据只是在一个方向上传输。通道与流的不同之处在于通道是双向的，它可以用于读、写或者同时用于读写。</p><p>Channel 与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016190019985.png" alt="image-20231016190019985">Channel 和 Buffer之间的关系</p><p>另外，Channel 是全双工的，它可以比流更好地映射底层操作系统的 API。特别是在 UNIX 网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。</p><p>Channel子类中最常用的几种类型的通道：</p><ul><li><p><code>FileChannel</code>：文件访问通道；</p></li><li><p><code>SocketChannel</code>、<code>ServerSocketChannel</code>：TCP 通信通道；</p></li><li><p><code>DatagramChannel</code>：UDP 通信通道；</p></li></ul><p>Channel 最核心的两个方法：</p><ol><li><p><code>read</code> ：读取数据并写入到 Buffer 中。</p></li><li><p><code>write</code> ：将 Buffer 中的数据写入到 Channel 中。</p></li></ol><p> <code>FileChannel</code> 读取文件数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;/Users/guide/Documents/test_read.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)) <br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> reader.getChannel();<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>channel.read(buffer);<br></code></pre></td></tr></table></figure><h3 id="Selector（选择器）"><a href="#Selector（选择器）" class="headerlink" title="Selector（选择器）"></a>Selector（选择器）</h3><p>Selector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I&#x2F;O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行响应的 I&#x2F;O 操作。</p><p>Selector 选择器工作示意图</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231016190605292.png" alt="image-20231016190605292"></p><p>一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了 <code>epoll()</code> 代替传统的 <code>select</code> 实现，所以它并没有最大连接句柄 <code>1024/2048</code> 的限制。这也就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p><p>Selector 可以监听以下四种事件类型：</p><ol><li><code>SelectionKey.OP_ACCEPT</code>：表示通道接受连接的事件，这通常用于 <code>ServerSocketChannel</code>。</li><li><code>SelectionKey.OP_CONNECT</code>：表示通道完成连接的事件，这通常用于 <code>SocketChannel</code>。</li><li><code>SelectionKey.OP_READ</code>：表示通道准备好进行读取的事件，即有数据可读。</li><li><code>SelectionKey.OP_WRITE</code>：表示通道准备好进行写入的事件，即可以写入数据。</li></ol><p><code>Selector</code>是抽象类，可以通过调用此类的 <code>open()</code> 静态方法来创建 Selector 实例。Selector 可以同时监控多个 <code>SelectableChannel</code> 的 <code>IO</code> 状况，是非阻塞 <code>IO</code> 的核心。</p><p>一个 Selector 实例有三个 <code>SelectionKey</code> 集合：</p><ol><li>所有的 <code>SelectionKey</code> 集合：代表了注册在该 Selector 上的 <code>Channel</code>，这个集合可以通过 <code>keys()</code> 方法返回。</li><li>被选择的 <code>SelectionKey</code> 集合：代表了所有可通过 <code>select()</code> 方法获取的、需要进行 <code>IO</code> 处理的 Channel，这个集合可以通过 <code>selectedKeys()</code> 返回。</li><li>被取消的 <code>SelectionKey</code> 集合：代表了所有被取消注册关系的 <code>Channel</code>，在下一次执行 <code>select()</code> 方法时，这些 <code>Channel</code> 对应的 <code>SelectionKey</code> 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。</li></ol><p>如何遍历被选择的 <code>SelectionKey</code> 集合并进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();<br><span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>    <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>            <span class="hljs-comment">// ServerSocketChannel 接收了一个新连接</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>            <span class="hljs-comment">// 表示一个新连接建立</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            <span class="hljs-comment">// Channel 有准备好的数据，可以读取</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>            <span class="hljs-comment">// Channel 有空闲的 Buffer，可以写入数据</span><br>        &#125;<br>    &#125;<br>    keyIterator.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p>Selector 还提供了一系列和 <code>select()</code> 相关的方法：</p><ul><li><p><code>int select()</code>：监控所有注册的 <code>Channel</code>，当它们中间有需要处理的 <code>IO</code> 操作时，将对应的 <code>SelectionKey</code> 加入被选择的 <code>SelectionKey</code> 集合中，该方法返回这些 <code>Channel</code> 的数量。</p></li><li><p><code>int select(long timeout)</code>：可以设置超时时长的 <code>select()</code> 操作。</p></li><li><p><code>int selectNow()</code>：执行一个立即返回的 <code>select()</code> 操作，相对于无参数的 <code>select()</code> 方法而言，<strong>该方法不会阻塞线程</strong>。</p></li><li><p><code>Selector wakeup()</code>：使一个还未返回的 <code>select()</code> 方法立刻返回。</p></li></ul><p>使用 Selector 实现网络读写的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioSelectorExample</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>      serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>      serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br>      <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>      <span class="hljs-comment">// 将 ServerSocketChannel 注册到 Selector 并监听 OP_ACCEPT 事件</span><br>      serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readyChannels</span> <span class="hljs-operator">=</span> selector.select();<br><br>        <span class="hljs-keyword">if</span> (readyChannels == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>        Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();<br><br>        <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>          <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br><br>          <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>            <span class="hljs-comment">// 处理连接事件</span><br>            <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> server.accept();<br>            client.configureBlocking(<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-comment">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span><br>            client.register(selector, SelectionKey.OP_READ);<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            <span class="hljs-comment">// 处理读事件</span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> client.read(buffer);<br><br>            <span class="hljs-keyword">if</span> (bytesRead &gt; <span class="hljs-number">0</span>) &#123;<br>              buffer.flip();<br>              System.out.println(<span class="hljs-string">&quot;收到数据：&quot;</span> +<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, bytesRead));<br>              <span class="hljs-comment">// 将客户端通道注册到 Selector 并监听 OP_WRITE 事件</span><br>              client.register(selector, SelectionKey.OP_WRITE);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytesRead &lt; <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-comment">// 客户端断开连接</span><br>              client.close();<br>            &#125;<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>            <span class="hljs-comment">// 处理写事件</span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-string">&quot;Hello, Client!&quot;</span>.getBytes());<br>            client.write(buffer);<br><br>            <span class="hljs-comment">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span><br>            client.register(selector, SelectionKey.OP_READ);<br>          &#125;<br><br>          keyIterator.remove();<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在示例中，我们创建了一个简单的服务器，监听 8080 端口，使用 Selector 处理连接、读取和写入事件。当接收到客户端的数据时，服务器将读取数据并将其打印到控制台，然后向客户端回复 “Hello, Client!”。</p><h2 id="NIO-零拷贝"><a href="#NIO-零拷贝" class="headerlink" title="NIO 零拷贝"></a>NIO 零拷贝</h2><p>零拷贝是提升 IO 操作性能的一个常用手段，像 ActiveMQ、Kafka 、RocketMQ、QMQ、Netty 等顶级开源项目都用到了零拷贝。</p><p>零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以<strong>减少上下文切换以及 CPU 的拷贝时间</strong>。也就是说，零拷贝主要解决操作系统在处理 I&#x2F;O 操作时频繁复制数据的问题。零拷贝的常见实现技术有： <code>mmap+write</code>、<code>sendfile</code>和 <code>sendfile + DMA gather copy</code> 。</p><p>下图展示了各种零拷贝技术的对比图：</p><table><thead><tr><th></th><th>CPU 拷贝</th><th>DMA 拷贝</th><th>系统调用</th><th>上下文切换</th></tr></thead><tbody><tr><td>传统方法</td><td>2</td><td>2</td><td>read+write</td><td>4</td></tr><tr><td>mmap+write</td><td>1</td><td>2</td><td>mmap+write</td><td>4</td></tr><tr><td>sendfile</td><td>1</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>sendfile + DMA gather copy</td><td>0</td><td>2</td><td>sendfile</td><td>2</td></tr></tbody></table><p>可以看出，无论是传统的 I&#x2F;O 方式，还是引入了零拷贝之后，2 次 DMA(Direct Memory Access) 拷贝是都少不了的。因为两次 DMA 都是依赖硬件完成的。零拷贝主要是减少了 CPU 拷贝及上下文的切换。</p><p>Java 对零拷贝的支持：</p><ul><li><code>MappedByteBuffer</code> 是 NIO 基于内存映射（<code>mmap</code>）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 <code>mmap</code> 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。</li><li><code>FileChannel</code> 的<code>transferTo()/transferFrom()</code>是 NIO 基于发送文件（<code>sendfile</code>）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 <code>sendfile</code>系统调用。它可以直接将文件数据从磁盘发送到网络，而不需要经过用户空间的缓冲区。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFileIntoMemory</span><span class="hljs-params">(File xmlFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(xmlFile);<br>  <span class="hljs-comment">// 创建 FileChannel 对象</span><br>  <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> fis.getChannel();<br>  <span class="hljs-comment">// FileChannle.map() 将文件映射到直接内存并返回 MappedByteBuffer 对象</span><br>  <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">mmb</span> <span class="hljs-operator">=</span> fc.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, fc.size());<br>  xmlFileBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)fc.size()];<br>  mmb.get(xmlFileBuffer);<br>  fis.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>NIO 的核心知识点，包括 NIO 的核心组件和零拷贝。</p><p>如果我们需要使用 NIO 构建网络程序的话，不建议直接使用原生 NIO，编程复杂且功能性太弱，推荐使用一些成熟的基于 NIO 的网络编程框架比如 Netty。Netty 在 NIO 的基础上进行了一些优化和扩展比如支持多种协议、支持 SSL&#x2F;TLS 等等。</p>]]></content>
    
    
    <categories>
      
      <category>NIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS</title>
    <link href="/2021/04/06/JUC/AQS/"/>
    <url>/2021/04/06/JUC/AQS/</url>
    
    <content type="html"><![CDATA[<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="AQS-是什么？"><a href="#AQS-是什么？" class="headerlink" title="AQS 是什么？"></a>AQS 是什么？</h4><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。AQS 就是一个抽象类，主要用来构建锁和同步器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p><h4 id="AQS-的原理是什么？"><a href="#AQS-的原理是什么？" class="headerlink" title="AQS 的原理是什么？"></a>AQS 的原理是什么？</h4><p>AQS 核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 在AQS中 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p><p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>线程等待队列</strong> 来完成获取资源线程的排队工作。</p><p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 共享变量，使用volatile修饰保证线程可见性</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure><p>另外，状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回同步状态的当前值</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> state;<br>&#125;<br> <span class="hljs-comment">// 设置同步状态的值</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br>     state = newState;<br>&#125;<br><span class="hljs-comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>      <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><p>以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p><p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，<code>state</code> 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code>countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后续动作。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atomic 原子类</title>
    <link href="/2021/04/06/JUC/Atomic%20%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
    <url>/2021/04/06/JUC/Atomic%20%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Atomic-原子类介绍"><a href="#Atomic-原子类介绍" class="headerlink" title="Atomic 原子类介绍"></a>Atomic 原子类介绍</h2><p>Atomic 翻译成中文是原子的意思，指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>原子类就是具有原子&#x2F;原子操作特征的类。</p><p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p><p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p><ul><li><strong>基本类型</strong> （更新基本类型）</li><li><strong>数组类型</strong> （更新数组中的某个元素）</li><li><strong>引用类型</strong></li><li><strong>对象的属性修改类型</strong></li></ul><h2 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h2><p>使用原子的方式更新基本类型</p><ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code>：布尔型原子类</li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicInteger</code> 为例子来介绍。</p><p><strong>AtomicInteger 类常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//获取当前的值，并设置新的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span><span class="hljs-comment">//获取当前的值，并自增</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndDecrement</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前的值，并自减</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span> <span class="hljs-comment">//获取当前的值，并加上预期的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> <span class="hljs-comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySet</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></code></pre></td></tr></table></figure><p><strong><code>AtomicInteger</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temvalue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>        temvalue = i.getAndSet(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i); <span class="hljs-comment">//temvalue:0;  i:3</span><br>        temvalue = i.getAndIncrement();<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i); <span class="hljs-comment">//temvalue:3;  i:4</span><br>        temvalue = i.getAndAdd(<span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i); <span class="hljs-comment">//temvalue:4;  i:9</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本数据类型原子类的优势"><a href="#基本数据类型原子类的优势" class="headerlink" title="基本数据类型原子类的优势"></a>基本数据类型原子类的优势</h3><p><strong>1、多线程环境使用原子类保证线程安全（基本数据类型）不需要加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//若要线程安全执行执行count++，需要加锁</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>                  count++;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>                  <span class="hljs-keyword">return</span> count;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>                  count.incrementAndGet();<br>        &#125;<br>       <span class="hljs-comment">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> count.get();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AtomicInteger-线程安全原理简单分析"><a href="#AtomicInteger-线程安全原理简单分析" class="headerlink" title="AtomicInteger 线程安全原理简单分析"></a>AtomicInteger 线程安全原理简单分析</h3><p><code>AtomicInteger</code> 类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br></code></pre></td></tr></table></figure><p><code>AtomicInteger</code> 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h2 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h2><p>使用原子的方式更新数组里的某个元素</p><ul><li><code>AtomicIntegerArray</code>：整型数组原子类</li><li><code>AtomicLongArray</code>：长整型数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul><p><strong><code>AtomicIntegerArray</code> 类常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//获取 index=i 位置元素的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndDecrement</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> delta)</span> <span class="hljs-comment">//获取 index=i 位置元素的值，并加上预期的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> <span class="hljs-comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></code></pre></td></tr></table></figure><p><strong><code>AtomicIntegerArray</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerArrayTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temvalue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] nums = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br>        <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            System.out.println(i.get(j));<br>        &#125;<br>        temvalue = i.getAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i);<br>        temvalue = i.getAndIncrement(<span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i);<br>        temvalue = i.getAndAdd(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;temvalue:&quot;</span> + temvalue + <span class="hljs-string">&quot;;  i:&quot;</span> + i);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h2><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</li></ul><p><strong><code>AtomicReference</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        AtomicReference &lt; Person &gt; ar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;Person&gt; ();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;SnailClimb&quot;</span>, <span class="hljs-number">22</span>);<br>        ar.set(person);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">updatePerson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Daisy&quot;</span>, <span class="hljs-number">20</span>);<br>        ar.compareAndSet(person, updatePerson);<br><br>        System.out.println(ar.get().getName());<br>        System.out.println(ar.get().getAge());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码首先创建了一个 <code>Person</code> 对象，然后把 <code>Person</code> 对象set进 <code>AtomicReference</code> 对象中，然后调用 <code>compareAndSet</code> 方法，该方法就是通过 CAS 操作设置 ar。实现原理与 <code>AtomicInteger</code> 类中的 <code>compareAndSet</code> 方法相同。运行上面的代码后的输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Daisy<br>20<br></code></pre></td></tr></table></figure><p><strong><code>AtomicStampedReference</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicStampedReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 实例化、取当前值和 stamp 值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">initialRef</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, initialStamp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">final</span> AtomicStampedReference&lt;Integer&gt; asr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(initialRef, initialStamp);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + asr.getStamp());<br><br>        <span class="hljs-comment">// compare and set</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">newReference</span> <span class="hljs-operator">=</span> <span class="hljs-number">666</span>, newStamp = <span class="hljs-number">999</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">casResult</span> <span class="hljs-operator">=</span> asr.compareAndSet(initialRef, newReference, initialStamp, newStamp);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + asr.getReference()<br>                + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + asr.getStamp()<br>                + <span class="hljs-string">&quot;, casResult=&quot;</span> + casResult);<br><br>        <span class="hljs-comment">// 获取当前的值和当前的 stamp 值</span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">currentValue</span> <span class="hljs-operator">=</span> asr.get(arr);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentStamp</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + currentValue + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + currentStamp);<br><br>        <span class="hljs-comment">// 单独设置 stamp 值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">attemptStampResult</span> <span class="hljs-operator">=</span> asr.attemptStamp(newReference, <span class="hljs-number">88</span>);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + asr.getReference()<br>                + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + asr.getStamp()<br>                + <span class="hljs-string">&quot;, attemptStampResult=&quot;</span> + attemptStampResult);<br><br>        <span class="hljs-comment">// 重新设置当前值和 stamp 值</span><br>        asr.set(initialRef, initialStamp);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + asr.getStamp());<br><br>        <span class="hljs-comment">// 不推荐使用  weakCompareAndSet</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">wCasResult</span> <span class="hljs-operator">=</span> asr.weakCompareAndSet(initialRef, newReference, initialStamp, newStamp);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + asr.getReference()<br>                + <span class="hljs-string">&quot;, currentStamp=&quot;</span> + asr.getStamp()<br>                + <span class="hljs-string">&quot;, wCasResult=&quot;</span> + wCasResult);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">currentValue=0, currentStamp=0<br>currentValue=666, currentStamp=999, casResult=true<br>currentValue=666, currentStamp=999<br>currentValue=666, currentStamp=88, attemptStampResult=true<br>currentValue=0, currentStamp=0<br>currentValue=666, currentStamp=999, wCasResult=true<br></code></pre></td></tr></table></figure><p><strong><code>AtomicMarkableReference</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicMarkableReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 实例化、取当前值和 mark 值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">initialRef</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, initialMark = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> AtomicMarkableReference&lt;Boolean&gt; amr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(initialRef, initialMark);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="hljs-string">&quot;, currentMark=&quot;</span> + amr.isMarked());<br><br>        <span class="hljs-comment">// compare and set</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">newReference1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>, newMark1 = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">casResult</span> <span class="hljs-operator">=</span> amr.compareAndSet(initialRef, newReference1, initialMark, newMark1);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + amr.getReference()<br>                + <span class="hljs-string">&quot;, currentMark=&quot;</span> + amr.isMarked()<br>                + <span class="hljs-string">&quot;, casResult=&quot;</span> + casResult);<br><br>        <span class="hljs-comment">// 获取当前的值和当前的 mark 值</span><br>        <span class="hljs-type">boolean</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">currentValue</span> <span class="hljs-operator">=</span> amr.get(arr);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">currentMark</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + currentValue + <span class="hljs-string">&quot;, currentMark=&quot;</span> + currentMark);<br><br>        <span class="hljs-comment">// 单独设置 mark 值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">attemptMarkResult</span> <span class="hljs-operator">=</span> amr.attemptMark(newReference1, <span class="hljs-literal">false</span>);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + amr.getReference()<br>                + <span class="hljs-string">&quot;, currentMark=&quot;</span> + amr.isMarked()<br>                + <span class="hljs-string">&quot;, attemptMarkResult=&quot;</span> + attemptMarkResult);<br><br>        <span class="hljs-comment">// 重新设置当前值和 mark 值</span><br>        amr.set(initialRef, initialMark);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="hljs-string">&quot;, currentMark=&quot;</span> + amr.isMarked());<br><br>        <span class="hljs-comment">// 不推荐使用 weakCompareAndSet</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">wCasResult</span> <span class="hljs-operator">=</span> amr.weakCompareAndSet(initialRef, newReference1, initialMark, newMark1);<br>        System.out.println(<span class="hljs-string">&quot;currentValue=&quot;</span> + amr.getReference()<br>                + <span class="hljs-string">&quot;, currentMark=&quot;</span> + amr.isMarked()<br>                + <span class="hljs-string">&quot;, wCasResult=&quot;</span> + wCasResult);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">currentValue=null, currentMark=false<br>currentValue=true, currentMark=true, casResult=true<br>currentValue=true, currentMark=true<br>currentValue=true, currentMark=false, attemptMarkResult=true<br>currentValue=null, currentMark=false<br>currentValue=true, currentMark=true, wCasResult=true<br></code></pre></td></tr></table></figure><h2 id="对象的属性修改类型原子类"><a href="#对象的属性修改类型原子类" class="headerlink" title="对象的属性修改类型原子类"></a>对象的属性修改类型原子类</h2><p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p><ul><li><code>AtomicIntegerFieldUpdater</code>:原子更新整型字段的更新器</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段的更新器</li></ul><p>要想原子地更新对象的属性需要两步。</p><ul><li>第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</li><li>第二步，更新的对象属性必须使用 public volatile 修饰符。</li></ul><p><strong><code>AtomicIntegerFieldUpdater</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="hljs-string">&quot;age&quot;</span>);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-number">22</span>);<br>System.out.println(a.getAndIncrement(user));<span class="hljs-comment">// 22</span><br>System.out.println(a.get(user));<span class="hljs-comment">// 23</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> age;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">22<br>23<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS算法</title>
    <link href="/2021/04/06/JUC/CAS%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/06/JUC/CAS%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="CAS-算法"><a href="#CAS-算法" class="headerlink" title="CAS 算法"></a>CAS 算法</h4><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p><blockquote><p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p></blockquote><p>CAS 涉及到三个操作数：</p><ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)</li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p><p><strong>举一个简单的例子</strong>：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。</p><ol><li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li><li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li></ol><p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture</title>
    <link href="/2021/04/06/JUC/CompletableFuture/"/>
    <url>/2021/04/06/JUC/CompletableFuture/</url>
    
    <content type="html"><![CDATA[<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><h4 id="Future-类有什么用？"><a href="#Future-类有什么用？" class="headerlink" title="Future 类有什么用？"></a>Future 类有什么用？</h4><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// V 代表了Future执行的任务返回值的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">// 取消任务执行</span><br>    <span class="hljs-comment">// 成功取消返回 true，否则返回 false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br>    <span class="hljs-comment">// 判断任务是否被取消</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 判断任务是否已经执行完成</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取任务执行结果</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    <span class="hljs-comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException<br>&#125;<br></code></pre></td></tr></table></figure><p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</p><p>Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><p>下面我们来简单看看 <code>CompletableFuture</code> 类的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompletableFuture</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。</p><p><code>CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p><p><code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程的能力。</p><p><code>Future</code> 接口有 5 个方法：</p><ul><li><code>boolean cancel(boolean mayInterruptIfRunning)</code>：尝试取消执行任务。</li><li><code>boolean isCancelled()</code>：判断任务是否被取消。</li><li><code>boolean isDone()</code>：判断任务是否已经被执行完成。</li><li><code>get()</code>：等待任务执行完成并获取运算结果。</li><li><code>get(long timeout, TimeUnit unit)</code>：多了一个超时时间。</li></ul><p><code>CompletionStage</code> 接口中的方法比较多，<code>CompletableFuture</code> 的函数式能力就是这个接口赋予的。其大量使用了 Java8 引入的函数式编程。</p><h2 id="CompletableFuture-常见操作"><a href="#CompletableFuture-常见操作" class="headerlink" title="CompletableFuture 常见操作"></a>CompletableFuture 常见操作</h2><h3 id="创建-CompletableFuture"><a href="#创建-CompletableFuture" class="headerlink" title="创建 CompletableFuture"></a>创建 CompletableFuture</h3><p>常见的创建 <code>CompletableFuture</code> 对象的方法如下：</p><ol><li>通过 new 关键字。</li><li>基于 <code>CompletableFuture</code> 自带的静态工厂方法：<code>runAsync()</code>、<code>supplyAsync()</code> 。</li></ol><h4 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h4><p>通过 new 关键字创建 <code>CompletableFuture</code> 对象这种使用方式可以看作是将 <code>CompletableFuture</code> 当做 <code>Future</code> 来使用。</p><p>下面咱们来看一个简单的案例。</p><p>我们通过创建了一个结果值类型为 <code>RpcResponse&lt;Object&gt;</code> 的 <code>CompletableFuture</code>，你可以把 <code>resultFuture</code> 看作是异步运算结果的载体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>你可以通过 <code>isDone()</code> 方法来检查是否已经完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> result != <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取异步计算的结果也非常简单，直接调用 <code>get()</code> 方法即可。调用 <code>get()</code> 方法的线程会阻塞直到 <code>CompletableFuture</code> 完成运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">rpcResponse = completableFuture.get();<br></code></pre></td></tr></table></figure><p>假设在未来的某个时刻，我们得到了最终的结果。这时，我们可以调用 <code>complete()</code> 方法为其传入结果，这表示 <code>resultFuture</code> 已经被完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// complete() 方法只能调用一次，后续调用将被忽略。</span><br>resultFuture.complete(rpcResponse);<br></code></pre></td></tr></table></figure><p>如果你已经知道计算的结果的话，可以使用静态方法 <code>completedFuture()</code> 来创建 <code>CompletableFuture</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="hljs-string">&quot;hello!&quot;</span>);<br>assertEquals(<span class="hljs-string">&quot;hello!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p><code>completedFuture()</code> 方法底层调用的是带参数的 new 方法，只不过，这个方法不对外暴露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">completedFuture</span><span class="hljs-params">(U value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;U&gt;((value == <span class="hljs-literal">null</span>) ? NIL : value);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h4><p>这两个方法可以帮助我们封装计算逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span>;<br><span class="hljs-comment">// 使用自定义线程池(推荐)</span><br><span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;<br><span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable)</span>;<br><span class="hljs-comment">// 使用自定义线程池(推荐)</span><br><span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable, Executor executor)</span>;<br></code></pre></td></tr></table></figure><p><code>runAsync()</code> 方法接受的参数是 <code>Runnable</code> ，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用 <code>runAsync()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>supplyAsync()</code> 方法接受的参数是 <code>Supplier&lt;T&gt;</code> ，这也是一个函数式接口，<code>T</code> 是返回结果值的类型。当你需要异步操作且关心返回结果的时候,可以使用 <code>supplyAsync()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets a result.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a result</span><br><span class="hljs-comment">     */</span><br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>));<br>future.get();<span class="hljs-comment">// 输出 &quot;hello!&quot;</span><br>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;hello!&quot;</span>);<br>assertEquals(<span class="hljs-string">&quot;hello!&quot;</span>, future2.get());<br></code></pre></td></tr></table></figure><h3 id="处理异步结算的结果"><a href="#处理异步结算的结果" class="headerlink" title="处理异步结算的结果"></a>处理异步结算的结果</h3><p>当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：</p><ul><li><code>thenApply()</code></li><li><code>thenAccept()</code></li><li><code>thenRun()</code></li><li><code>whenComplete()</code></li></ul><p><code>thenApply()</code> 方法接受一个 <code>Function</code> 实例，用它来处理结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 沿用上一个任务的线程池</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApply</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br><br><span class="hljs-comment">//使用默认的 ForkJoinPool 线程池（不推荐）</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApplyAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(defaultExecutor(), fn);<br>&#125;<br><span class="hljs-comment">// 使用自定义线程池(推荐)</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApplyAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>thenApply()</code> 方法使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenApply(s -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>);<br>assertEquals(<span class="hljs-string">&quot;hello!world!&quot;</span>, future.get());<br><span class="hljs-comment">// 这次调用将被忽略。（为啥呢？）</span><br>future.thenApply(s -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>);<br>assertEquals(<span class="hljs-string">&quot;hello!world!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p>你还可以进行 <strong>流式调用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenApply(s -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>);<br>assertEquals(<span class="hljs-string">&quot;hello!world!nice!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p><strong>如果你不需要从回调函数中获取返回结果，可以使用 <code>thenAccept()</code> 或者 <code>thenRun()</code>。这两个方法的区别在于 <code>thenRun()</code> 不能访问异步计算的结果。</strong></p><p><code>thenAccept()</code> 方法的参数是 <code>Consumer&lt;? super T&gt;</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAccept</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(<span class="hljs-literal">null</span>, action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(defaultExecutor(), action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p>顾名思义，<code>Consumer</code> 属于消费型接口，它可以接收 1 个输入对象然后进行“消费”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;<br><br>    <span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>thenRun()</code> 的方法的参数是 <code>Runnable</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRun</span><span class="hljs-params">(Runnable action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniRunStage(<span class="hljs-literal">null</span>, action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRunAsync</span><span class="hljs-params">(Runnable action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniRunStage(defaultExecutor(), action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRunAsync</span><span class="hljs-params">(Runnable action, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniRunStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>thenAccept()</code> 和 <code>thenRun()</code> 使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture.completedFuture(<span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenApply(s -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>).thenAccept(System.out::println);<span class="hljs-comment">//hello!world!nice!</span><br><br>CompletableFuture.completedFuture(<span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenApply(s -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>).thenRun(() -&gt; System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>));<span class="hljs-comment">//hello!</span><br></code></pre></td></tr></table></figure><p><code>whenComplete()</code> 的方法的参数是 <code>BiConsumer&lt;? super T, ? super Throwable&gt;</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">whenComplete</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniWhenCompleteStage(<span class="hljs-literal">null</span>, action);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniWhenCompleteStage(defaultExecutor(), action);<br>&#125;<br><span class="hljs-comment">// 使用自定义线程池(推荐)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p>相对于 <code>Consumer</code> ， <code>BiConsumer</code> 可以接收 2 个输入对象然后进行“消费”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BiConsumer</span>&lt;T, U&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t, U u)</span>;<br><br>    <span class="hljs-keyword">default</span> BiConsumer&lt;T, U&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br><br>        <span class="hljs-keyword">return</span> (l, r) -&gt; &#123;<br>            accept(l, r);<br>            after.accept(l, r);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>whenComplete()</code> 使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;hello!&quot;</span>)<br>        .whenComplete((res, ex) -&gt; &#123;<br>            <span class="hljs-comment">// res 代表返回的结果</span><br>            <span class="hljs-comment">// ex 的类型为 Throwable ，代表抛出的异常</span><br>            System.out.println(res);<br>            <span class="hljs-comment">// 这里没有抛出异常所以为 null</span><br>            assertNull(ex);<br>        &#125;);<br>assertEquals(<span class="hljs-string">&quot;hello!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>你可以通过 <code>handle()</code> 方法来处理任务执行过程中可能出现的抛出异常的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniHandleStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handleAsync</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniHandleStage(defaultExecutor(), fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handleAsync</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniHandleStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Computation error!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello!&quot;</span>;<br>&#125;).handle((res, ex) -&gt; &#123;<br>    <span class="hljs-comment">// res 代表返回的结果</span><br>    <span class="hljs-comment">// ex 的类型为 Throwable ，代表抛出的异常</span><br>    <span class="hljs-keyword">return</span> res != <span class="hljs-literal">null</span> ? res : <span class="hljs-string">&quot;world!&quot;</span>;<br>&#125;);<br>assertEquals(<span class="hljs-string">&quot;world!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p>你还可以通过 <code>exceptionally()</code> 方法来处理异常情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future<br>        = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Computation error!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello!&quot;</span>;<br>&#125;).exceptionally(ex -&gt; &#123;<br>    System.out.println(ex.toString());<span class="hljs-comment">// CompletionException</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;world!&quot;</span>;<br>&#125;);<br>assertEquals(<span class="hljs-string">&quot;world!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p>如果你想让 <code>CompletableFuture</code> 的结果就是异常的话，可以使用 <code>completeExceptionally()</code> 方法为其赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; completableFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br><span class="hljs-comment">// ...</span><br>completableFuture.completeExceptionally(<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Calculation failed!&quot;</span>));<br><span class="hljs-comment">// ...</span><br>completableFuture.get(); <span class="hljs-comment">// ExecutionException</span><br></code></pre></td></tr></table></figure><h3 id="组合-CompletableFuture"><a href="#组合-CompletableFuture" class="headerlink" title="组合 CompletableFuture"></a>组合 CompletableFuture</h3><p>你可以使用 <code>thenCompose()</code> 按顺序链接两个 <code>CompletableFuture</code> 对象，实现异步的任务链。它的作用是将前一个任务的返回结果作为下一个任务的输入参数，从而形成一个依赖关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenCompose</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniComposeStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenComposeAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniComposeStage(defaultExecutor(), fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenComposeAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,</span><br><span class="hljs-params">    Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniComposeStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>thenCompose()</code> 方法会使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future<br>        = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>));<br>assertEquals(<span class="hljs-string">&quot;hello!world!&quot;</span>, future.get());<br></code></pre></td></tr></table></figure><p>在实际开发中，这个方法还是非常有用的。比如说，task1 和 task2 都是异步执行的，但 task1 必须执行完成后才能开始执行 task2（task2 依赖 task1 的执行结果）。</p><p>和 <code>thenCompose()</code> 方法类似的还有 <code>thenCombine()</code> 方法， 它同样可以组合两个 <code>CompletableFuture</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; completableFuture<br>        = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;hello!&quot;</span>)<br>        .thenCombine(CompletableFuture.supplyAsync(<br>                () -&gt; <span class="hljs-string">&quot;world!&quot;</span>), (s1, s2) -&gt; s1 + s2)<br>        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>));<br>assertEquals(<span class="hljs-string">&quot;hello!world!nice!&quot;</span>, completableFuture.get());<br></code></pre></td></tr></table></figure><p><strong>那 <code>thenCompose()</code> 和 <code>thenCombine()</code> 有什么区别呢？</strong></p><ul><li><code>thenCompose()</code> 可以链接两个 <code>CompletableFuture</code> 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</li><li><code>thenCombine()</code> 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</li></ul><p>除了 <code>thenCompose()</code> 和 <code>thenCombine()</code> 之外， 还有一些其他的组合 <code>CompletableFuture</code> 的方法用于实现不同的效果，满足不同的业务需求。</p><p>例如，如果我们想要实现 task1 和 task2 中的任意一个任务执行完后就执行 task3 的话，可以使用 <code>acceptEither()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">acceptEither</span><span class="hljs-params">(</span><br><span class="hljs-params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> orAcceptStage(<span class="hljs-literal">null</span>, other, action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">acceptEitherAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> orAcceptStage(asyncPool, other, action);<br>&#125;<br></code></pre></td></tr></table></figure><p>简单举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务1开始执行，当前时间：&quot;</span> + System.currentTimeMillis());<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;任务1执行完毕，当前时间：&quot;</span> + System.currentTimeMillis());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;task1&quot;</span>;<br>&#125;);<br><br>CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务2开始执行，当前时间：&quot;</span> + System.currentTimeMillis());<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;任务2执行完毕，当前时间：&quot;</span> + System.currentTimeMillis());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;task2&quot;</span>;<br>&#125;);<br><br>task.acceptEitherAsync(task2, (res) -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务3开始执行，当前时间：&quot;</span> + System.currentTimeMillis());<br>    System.out.println(<span class="hljs-string">&quot;上一个任务的结果为：&quot;</span> + res);<br>&#125;);<br><br><span class="hljs-comment">// 增加一些延迟时间，确保异步任务有足够的时间完成</span><br><span class="hljs-keyword">try</span> &#123;<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">任务1开始执行，当前时间：1695088058520<br>任务2开始执行，当前时间：1695088058521<br>任务1执行完毕，当前时间：1695088059023<br>任务3开始执行，当前时间：1695088059023<br>上一个任务的结果为：task1<br>任务2执行完毕，当前时间：1695088059523<br></code></pre></td></tr></table></figure><p>任务组合操作<code>acceptEitherAsync()</code>会在异步任务 1 和异步任务 2 中的任意一个完成时触发执行任务 3，但是需要注意，这个触发时机是不确定的。如果任务 1 和任务 2 都还未完成，那么任务 3 就不能被执行。</p><h3 id="并行运行多个-CompletableFuture"><a href="#并行运行多个-CompletableFuture" class="headerlink" title="并行运行多个 CompletableFuture"></a>并行运行多个 CompletableFuture</h3><p>你可以通过 <code>CompletableFuture</code> 的 <code>allOf()</code>这个静态方法来并行运行多个 <code>CompletableFuture</code> 。</p><p>实际项目中，我们经常需要并行运行多个互不相关的任务，这些任务之间没有依赖关系，可以互相独立地运行。</p><p>比说我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。像这种情况我们就可以使用并行运行多个 <code>CompletableFuture</code> 来处理。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Void&gt; task1 =<br>  CompletableFuture.supplyAsync(()-&gt;&#123;<br>    <span class="hljs-comment">//自定义业务操作</span><br>  &#125;);<br>......<br>CompletableFuture&lt;Void&gt; task6 =<br>  CompletableFuture.supplyAsync(()-&gt;&#123;<br>    <span class="hljs-comment">//自定义业务操作</span><br>  &#125;);<br>......<br> CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    headerFuture.join();<br>  &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    ......<br>  &#125;<br>System.out.println(<span class="hljs-string">&quot;all done. &quot;</span>);<br></code></pre></td></tr></table></figure><p>经常和 <code>allOf()</code> 方法拿来对比的是 <code>anyOf()</code> 方法。</p><p><strong><code>allOf()</code> 方法会等到所有的 <code>CompletableFuture</code> 都运行完成之后再返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span> + rand.nextInt(<span class="hljs-number">1000</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;future1 done...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;);<br>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span> + rand.nextInt(<span class="hljs-number">1000</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;future2 done...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;efg&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>调用 <code>join()</code> 可以让程序等<code>future1</code> 和 <code>future2</code> 都运行完了之后再继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.allOf(future1, future2);<br>completableFuture.join();<br>assertTrue(completableFuture.isDone());<br>System.out.println(<span class="hljs-string">&quot;all futures done...&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">future1 done...<br>future2 done...<br>all futures done...<br></code></pre></td></tr></table></figure><p><strong><code>anyOf()</code> 方法不会等待所有的 <code>CompletableFuture</code> 都运行完成之后再返回，只要有一个执行完成即可！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(future1, future2);<br>System.out.println(f.get());<br></code></pre></td></tr></table></figure><p>输出结果可能是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">future2 done...<br>efg<br></code></pre></td></tr></table></figure><p>也可能是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">future1 done...<br>abc<br></code></pre></td></tr></table></figure><h2 id="CompletableFuture-使用建议"><a href="#CompletableFuture-使用建议" class="headerlink" title="CompletableFuture 使用建议"></a>CompletableFuture 使用建议</h2><h3 id="使用自定义线程池"><a href="#使用自定义线程池" class="headerlink" title="使用自定义线程池"></a>使用自定义线程池</h3><p><code>CompletableFuture</code> 默认使用<code>ForkJoinPool.commonPool()</code> 作为执行器，这个线程池是全局共享的，可能会被其他任务占用，导致性能下降或者饥饿。因此，建议使用自定义的线程池来执行 <code>CompletableFuture</code> 的异步任务，可以提高并发度和灵活性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>,<br>        <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br><br>CompletableFuture.runAsync(() -&gt; &#123;<br> <span class="hljs-comment">//...</span><br>&#125;, executor);<br></code></pre></td></tr></table></figure><h3 id="尽量避免使用-get"><a href="#尽量避免使用-get" class="headerlink" title="尽量避免使用 get()"></a>尽量避免使用 get()</h3><p><code>CompletableFuture</code>的<code>get()</code>方法是阻塞的，尽量避免使用。如果必须要使用的话，需要添加超时时间，否则可能会导致主线程一直等待，无法执行其他任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10_000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-comment">// 获取异步任务的返回值，设置超时时间为 5 秒</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        System.out.println(result);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>        <span class="hljs-comment">// 处理异常</span><br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码在调用 <code>get()</code> 时抛出了 <code>TimeoutException</code> 异常。这样我们就可以在异常处理中进行相应的操作，比如取消任务、重试任务、记录日志等。</p><h3 id="正确进行异常处理"><a href="#正确进行异常处理" class="headerlink" title="正确进行异常处理"></a>正确进行异常处理</h3><ul><li>使用 <code>whenComplete</code> 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。</li><li>使用 <code>exceptionally</code> 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。</li><li>使用 <code>handle</code> 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。</li><li>使用 <code>CompletableFuture.allOf</code> 方法可以组合多个 <code>CompletableFuture</code>，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复。</li></ul><h3 id="合理组合多个异步任务"><a href="#合理组合多个异步任务" class="headerlink" title="合理组合多个异步任务"></a>合理组合多个异步任务</h3><p>正确使用 <code>thenCompose()</code> 、 <code>thenCombine()</code> 、<code>acceptEither()</code>、<code>allOf()</code>、<code>anyOf() </code>等方法来组合多个异步任务，以满足实际业务的需求，提高程序执行效率。</p><p><img src="C:\Users\69425\AppData\Roaming\Typora\typora-user-images\image-20231015211855815.png" alt="image-20231015211855815"></p><h4 id="Callable-和-Future-有什么关系？"><a href="#Callable-和-Future-有什么关系？" class="headerlink" title="Callable 和 Future 有什么关系？"></a>Callable 和 Future 有什么关系？</h4><p>我们可以通过 <code>FutureTask</code> 来理解 <code>Callable</code> 和 <code>Future</code> 之间的关系。</p><p><code>FutureTask</code> 提供了 <code>Future</code> 接口的基本实现，常用来封装 <code>Callable</code> 和 <code>Runnable</code>，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;T&gt;</span> Future<span class="hljs-attribute">&lt;T&gt;</span> submit(Callable<span class="hljs-attribute">&lt;T&gt;</span> task);<br>Future<span class="hljs-attribute">&lt;?&gt;</span> submit(Runnable task);<br></code></pre></td></tr></table></figure><p><code>FutureTask</code> 不光实现了 <code>Future</code>接口，还实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p><p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为<code>Callable</code> 对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> FutureTask(Callable&lt;V&gt; callable) &#123;<br>        <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">throw</span> new NullPointerException();<br>        <span class="hljs-keyword">this</span>.callable = callable;<br>        <span class="hljs-keyword">this</span>.state = NEW;<br>&#125;<br><span class="hljs-keyword">public</span> FutureTask(Runnable runnable, V result) &#123;<br>        <span class="hljs-comment">// 通过适配器RunnableAdapter来将Runnable对象runnable转换成Callable对象</span><br>        <span class="hljs-keyword">this</span>.callable = Executors.callable(runnable, result);<br>        <span class="hljs-keyword">this</span>.state = NEW;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FutureTask</code>相当于对<code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantLock</title>
    <link href="/2021/04/06/JUC/ReentrantLock/"/>
    <url>/2021/04/06/JUC/ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h3 id="ReentrantLock-是什么？"><a href="#ReentrantLock-是什么？" class="headerlink" title="ReentrantLock 是什么？"></a>ReentrantLock 是什么？</h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p><h3 id="公平锁和非公平锁有什么区别？"><a href="#公平锁和非公平锁有什么区别？" class="headerlink" title="公平锁和非公平锁有什么区别？"></a>公平锁和非公平锁有什么区别？</h3><ul><li><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h3 id="synchronized-和-ReentrantLock-有什么区别？"><a href="#synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="synchronized 和 ReentrantLock 有什么区别？"></a>synchronized 和 ReentrantLock 有什么区别？</h3><h4 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h4><p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p><p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p><p>在下面的代码中，<code>method1()</code> 和 <code>method2()</code>都被 <code>synchronized</code> 关键字修饰，<code>method1()</code>调用了<code>method2()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法1&quot;</span>);<br>        method2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>synchronized</code>锁是可重入的，同一个线程在调用<code>method1()</code> 时可以直接获得当前对象的锁，执行 <code>method2()</code> 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如<code>synchronized</code>是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 <code>method2()</code>时获取锁失败，会出现死锁问题。</p><h4 id="synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h4><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p><p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><h4 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h4><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><p>如果你想使用上述功能，那么选择 <code>ReentrantLock</code> 是一个不错的选择。</p><p>关于 <code>Condition</code>接口的补充：</p><blockquote><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p></blockquote><h3 id="可中断锁和不可中断锁有什么区别？"><a href="#可中断锁和不可中断锁有什么区别？" class="headerlink" title="可中断锁和不可中断锁有什么区别？"></a>可中断锁和不可中断锁有什么区别？</h3><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantReadWriteLock</title>
    <link href="/2021/04/06/JUC/ReentrantReadWriteLock/"/>
    <url>/2021/04/06/JUC/ReentrantReadWriteLock/</url>
    
    <content type="html"><![CDATA[<h3 id="ReentrantReadWriteLock-是什么？"><a href="#ReentrantReadWriteLock-是什么？" class="headerlink" title="ReentrantReadWriteLock 是什么？"></a>ReentrantReadWriteLock 是什么？</h3><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantReadWriteLock</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReadWriteLock</span>, java.io.Serializable&#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br>    Lock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>;<br>    Lock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</li><li>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</li></ul><p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p><p>和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。</p><p><code>ReentrantReadWriteLock</code> 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>    readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);<br>    writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReentrantReadWriteLock-适合什么场景？"><a href="#ReentrantReadWriteLock-适合什么场景？" class="headerlink" title="ReentrantReadWriteLock 适合什么场景？"></a>ReentrantReadWriteLock 适合什么场景？</h3><p>由于 <code>ReentrantReadWriteLock</code> 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能。</p><h3 id="线程持有读锁还能获取写锁吗？"><a href="#线程持有读锁还能获取写锁吗？" class="headerlink" title="线程持有读锁还能获取写锁吗？"></a>线程持有读锁还能获取写锁吗？</h3><ul><li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li><li>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</li></ul><h3 id="读锁为什么不能升级为写锁？"><a href="#读锁为什么不能升级为写锁？" class="headerlink" title="读锁为什么不能升级为写锁？"></a>读锁为什么不能升级为写锁？</h3><p>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</p><p>另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2021/04/06/JUC/ThreadLocal/"/>
    <url>/2021/04/06/JUC/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="ThreadLocal-有什么用？"><a href="#ThreadLocal-有什么用？" class="headerlink" title="ThreadLocal 有什么用？"></a>ThreadLocal 有什么用？</h4><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。</p><p><strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p><p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> SimpleDateFormat <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyyMMdd HHmm&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="ThreadLocal-原理了解吗？"><a href="#ThreadLocal-原理了解吗？" class="headerlink" title="ThreadLocal 原理了解吗？"></a>ThreadLocal 原理了解吗？</h4><p>从 <code>Thread</code>类源代码入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">//......</span><br>    <span class="hljs-comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p><p><code>ThreadLocal</code>类的<code>set()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//获取当前请求的线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 将需要存储的值放入到这个哈希表中</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p><p><code>ThreadLocal</code> 数据结构如下图所示：</p><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p><h4 id="ThreadLocal-内存泄露问题是怎么导致的？"><a href="#ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的？"></a>ThreadLocal 内存泄露问题是怎么导致的？</h4><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p><p><strong>弱引用介绍：</strong></p><blockquote><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2021/04/06/JUC/synchronized/"/>
    <url>/2021/04/06/JUC/synchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><blockquote><p>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</p></blockquote><blockquote><p>synchronized是非公平锁</p></blockquote><blockquote><p>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</p></blockquote><blockquote><p>锁对象不能为空，因为锁的信息都保存在对象头里</p></blockquote><h4 id="1-对象锁"><a href="#1-对象锁" class="headerlink" title="1. 对象锁"></a>1. 对象锁</h4><p>包括方法锁（默认锁对象为this，当前实例对象）和同步代码块锁（自己指定锁对象）</p><p><strong>代码块形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法锁形式</strong>：synchronized修饰普通方法，锁对象默认为this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-类锁"><a href="#2-类锁" class="headerlink" title="2. 类锁"></a>2. 类锁</h4><p>指的是修饰<strong>静态方法</strong>或指定锁对象为<strong>Class对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 所有线程需要的锁都是同一把</span><br>    <span class="hljs-keyword">synchronized</span>(类名.class)&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="synchronized加锁与释放锁的原理"><a href="#synchronized加锁与释放锁的原理" class="headerlink" title="synchronized加锁与释放锁的原理"></a>synchronized加锁与释放锁的原理</h3><p>每个对象拥有一个monitor计数器，使用指令控制锁计数器加1或者减1，每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候有三种情况：</p><ul><li><p>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</p></li><li><p>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加（退出时， 当计数器为0时，锁才会被释放）</p></li><li><p>这把锁已经被别的线程获取了，等待锁释放</p></li></ul><h3 id="synchronized缺陷"><a href="#synchronized缺陷" class="headerlink" title="synchronized缺陷"></a>synchronized缺陷</h3><ul><li><p>效率低： 锁的释放情况较少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设置超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时。</p></li><li><p>不够灵活：加锁和释放锁的时机单一，每个锁仅有一个单一的条件，相对而言，读写锁更加灵活</p></li><li><p>无法知道是否成功获得锁：Lock可以拿到状态</p></li></ul><p>Lock解决相应问题：</p><ul><li><code>lock()</code>: 加锁</li><li><code>unlock()</code>: 解锁</li><li><code>tryLock()</code>: 尝试获取锁，返回一个boolean值</li><li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li></ul><p>Synchronized加锁只与一个条件(是否获取锁)相关联，不灵活，后来<code>Condition与Lock的结合</code>解决了这个问题。</p><p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。</p><blockquote><p><code>ReentrantLock</code>为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。详细分析请看: <a href="">JUC锁: ReentrantLock详解</a></p></blockquote><p>synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛的使用。</p><ul><li><strong>使用Synchronized有哪些要注意的？</strong><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li></ul></li><li><strong>synchronized是公平锁吗？</strong></li></ul><p>synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="/2021/04/06/JUC/volatile/"/>
    <url>/2021/04/06/JUC/volatile/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-关键字volatile"><a href="#title-关键字volatile" class="headerlink" title="title: 关键字volatile"></a>title: 关键字volatile</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>多线程的环境下，操作系统对指令的重排序可能会导致将一个未初始化的对象引用暴露出来，为了防止实例化过程中的重排序，可以将这个对象设置为volatile类型的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数私有，禁止外部实例化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h3><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。</p><p>引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。</p><p>volatile关键字能有效的解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestVolatile</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// Thread-A</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;Thread A&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (!stop) &#123;<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; stopped&quot;</span>);<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-comment">// Thread-main</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; after 1 seconds&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        stop = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread[main,<span class="hljs-number">5</span>,main] after <span class="hljs-number">1</span> seconds<br><span class="hljs-comment">// Thread A一直在loop, 因为Thread A 由于可见性原因看不到Thread Main 已经修改stop的值</span><br></code></pre></td></tr></table></figure><p>可以看到 Thread-main 休眠1秒之后，设置 stop &#x3D; ture，但是Thread A根本没停下来，这就是可见性问题。</p><p>如果通过在stop变量前面加上volatile关键字则会真正stop。</p><p>volatile不能保证完全的原子性，只能保证单次的读&#x2F;写操作具有原子性。（本质上i++是读、写两次操作，通过AtomicInteger或者Synchronized来保证+1操作的原子性）</p><h4 id="共享的long和double变量的为什么要用volatile"><a href="#共享的long和double变量的为什么要用volatile" class="headerlink" title="共享的long和double变量的为什么要用volatile?"></a>共享的long和double变量的为什么要用volatile?</h4><p>因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读&#x2F;写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读&#x2F;写操作都具有原子性。</p><blockquote><p>目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。</p></blockquote><h3 id="volatile-的实现原理"><a href="#volatile-的实现原理" class="headerlink" title="volatile 的实现原理"></a>volatile 的实现原理</h3><h4 id="volatile-可见性实现"><a href="#volatile-可见性实现" class="headerlink" title="volatile 可见性实现"></a>volatile 可见性实现</h4><p>volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现：</p><ul><li><p>内存屏障，又称内存栅栏，是一个 CPU 指令。</p></li><li><p>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止将特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</p></li></ul><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。</p><p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，就会从内存中重读该变量数据到处理器缓存里。</p><p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p><p>总结：如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li><li>多核处理器发现本地缓存失效后，就会从内存中重读该变量数据到处理器缓存里。</li></ul><h5 id="缓存一致性之嗅探-snooping-”-协议："><a href="#缓存一致性之嗅探-snooping-”-协议：" class="headerlink" title="缓存一致性之嗅探(snooping)” 协议："></a>缓存一致性之嗅探(snooping)” 协议：</h5><p>所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是<strong>不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步</strong>。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效</p><h4 id="volatile-有序性实现"><a href="#volatile-有序性实现" class="headerlink" title="volatile 有序性实现"></a>volatile 有序性实现</h4><h5 id="volatile-的-happens-before-关系"><a href="#volatile-的-happens-before-关系" class="headerlink" title="volatile 的 happens-before 关系"></a>volatile 的 happens-before 关系</h5><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//假设线程A执行writer方法，线程B执行reader方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileExample</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        a = <span class="hljs-number">1</span>;              <span class="hljs-comment">// 1 线程A修改共享变量</span><br>        flag = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 2 线程A写volatile变量</span><br>    &#125; <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;         <span class="hljs-comment">// 3 线程B读同一个volatile变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a;          <span class="hljs-comment">// 4 线程B读共享变量</span><br>        ……<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p><ul><li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li><li>根据 volatile 规则：2 happens-before 3。</li><li>根据 happens-before 的传递性规则：1 happens-before 4。</li></ul><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img/notes/202403262054229.png" alt="image-20230922144410214"></p><p>因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。</p><h4 id="volatile-禁止重排序"><a href="#volatile-禁止重排序" class="headerlink" title="volatile 禁止重排序"></a>volatile 禁止重排序</h4><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读&#x2F;写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img/notes/202403262054230.png" alt="image-20230922151956654"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>使用 volatile 必须具备的条件</p><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>悲观锁与乐观锁</title>
    <link href="/2021/04/06/JUC/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <url>/2021/04/06/JUC/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h3><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些。</p><h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子</strong>：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code>&#x3D;1 ），连同帐户扣除后余额（ <code>balance</code>&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号（ <code>version</code>&#x3D;1 ）试图向数据库提交数据（ <code>balance</code>&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol><p>这样就避免了操作员 B 用基于 <code>version</code>&#x3D;1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p><h3 id="乐观锁存在哪些问题？"><a href="#乐观锁存在哪些问题？" class="headerlink" title="乐观锁存在哪些问题？"></a>乐观锁存在哪些问题？</h3><p><strong>ABA 问题</strong></p><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以<strong>原子方式</strong>将该引用和该标志的值设置为给定的更新值。</p><p><strong>循环时间长开销大</strong></p><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p><ol><li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li><li>可以避免在退出循环的时候因内存顺序冲突而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li></ol><p><strong>只能保证一个共享变量的原子操作</strong></p><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死锁</title>
    <link href="/2021/04/06/JUC/%E6%AD%BB%E9%94%81/"/>
    <url>/2021/04/06/JUC/%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>产生死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁?"></a>如何预防和避免线程死锁?</h3><h4 id="如何预防死锁？"><a href="#如何预防死锁？" class="headerlink" title="如何预防死锁？"></a><strong>如何预防死锁？</strong></h4><p> 破坏死锁的产生的必要条件即可：</p><ol><li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><h4 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a><strong>如何避免死锁？</strong></h4><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><blockquote><p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程线程协程</title>
    <link href="/2021/04/06/JUC/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/"/>
    <url>/2021/04/06/JUC/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2021/04/06/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2021/04/06/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池?"></a>什么是线程池?</h4><p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><p>线程池、数据库连接池、Http 连接池等等都是对池化思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p><strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h4><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为60秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li><li>**<code>ScheduledThreadPool</code>**：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h4 id="为什么不推荐使用内置线程池？"><a href="#为什么不推荐使用内置线程池？" class="headerlink" title="为什么不推荐使用内置线程池？"></a>为什么不推荐使用内置线程池？</h4><p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><p><strong>为什么呢？</strong></p><blockquote><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></blockquote><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式。</p><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li><p>**<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>**：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</p></li><li><p>**<code>CachedThreadPool</code>**：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</p></li><li><p><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</p></li></ul><h4 id="线程池常见参数有哪些？如何解释？"><a href="#线程池常见参数有哪些？如何解释？" class="headerlink" title="线程池常见参数有哪些？如何解释？"></a>线程池常见参数有哪些？如何解释？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行的任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理（队列放不下）时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池<strong>回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code></strong> ，回收过程才会停止。</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :创建新线程的时候会用到的线程工厂。</li><li><strong><code>handler</code></strong> :拒绝策略。关于拒绝策略下面单独介绍一下。</li></ul><h4 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h4><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子：Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 拒绝策略来配置线程池的时候，默认使用的是 <code>AbortPolicy</code>。在这种拒绝策略下，如果队列满了，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 异常来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。如果不想丢弃任务的话，可以使用<code>CallerRunsPolicy</code>。<code>CallerRunsPolicy</code> 和其他的几个策略不同，它既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>                <span class="hljs-comment">// 直接主线程执行，而不是线程池中的线程执行</span><br>                r.run();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="线程池常用的阻塞队列有哪些？"><a href="#线程池常用的阻塞队列有哪些？" class="headerlink" title="线程池常用的阻塞队列有哪些？"></a>线程池常用的阻塞队列有哪些？</h4><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li><li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li><li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><h4 id="线程池处理任务的流程了解吗？"><a href="#线程池处理任务的流程了解吗？" class="headerlink" title="线程池处理任务的流程了解吗？"></a>线程池处理任务的流程了解吗？</h4><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><h4 id="如何给线程池命名？"><a href="#如何给线程池命名？" class="headerlink" title="如何给线程池命名？"></a>如何给线程池命名？</h4><p>初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。</p><p>默认情况下创建的线程名字类似 <code>pool-1-thread-n</code> 这样的，没有业务含义，不利于我们定位问题。</p><p>给线程池里的线程命名通常有下面两种方式：</p><p><strong>1、利用 guava 的 <code>ThreadFactoryBuilder</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>                        .setNameFormat(threadNamePrefix + <span class="hljs-string">&quot;-%d&quot;</span>)<br>                        .setDaemon(<span class="hljs-literal">true</span>).build();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);<br></code></pre></td></tr></table></figure><p><strong>2、自己实现 <code>ThreadFactory</code>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory delegate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个带名字的线程池生产工厂</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NamingThreadFactory</span><span class="hljs-params">(ThreadFactory delegate, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.delegate = delegate;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// TODO consider uniquifying this</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> delegate.newThread(r);<br>        t.setName(name + <span class="hljs-string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="如何设定线程池的大小？"><a href="#如何设定线程池的大小？" class="headerlink" title="如何设定线程池的大小？"></a>如何设定线程池的大小？</h4><blockquote><p>上下文切换：</p><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p><ul><li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</li><li>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li></ul><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><blockquote><p>线程数更严谨的计算的方法应该是：<code>最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间））</code>，其中 <code>WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）</code>。</p><p>线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。</p><p>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）&#x3D; N，和我们上面说的 N（CPU 核心数）+1 差不多。</p><p>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT&#x2F;ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</p></blockquote><h4 id="如何动态修改线程池的参数？"><a href="#如何动态修改线程池的参数？" class="headerlink" title="如何动态修改线程池的参数？"></a>如何动态修改线程池的参数？</h4><p>美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><strong>为什么是这三个参数？</strong></p><p>这三个参数是 <code>ThreadPoolExecutor</code> 最重要的参数，它们基本决定了线程池对于任务的处理策略。</p><p><strong>如何支持参数动态配置？</strong> 且看 <code>ThreadPoolExecutor</code> 提供的方法。</p><p>格外需要注意的是<code>corePoolSize</code>， 程序运行期间的时候，我们调用 <code>setCorePoolSize（）</code>这个方法的话，线程池会首先判断当前工作线程数是否大于<code>corePoolSize</code>，如果大于的话就会回收工作线程。</p><p>另外，其中并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 <code>ResizableCapacityLinkedBlockIngQueue</code> 的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p><p>如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：</p><ul><li>**<a href="https://github.com/opengoofy/hippo4j">Hippo4jopen in new window</a>**：异步线程池框架，支持线程池动态变更&amp;监控&amp;报警，无需修改代码轻松引入。支持多种使用模式，轻松引入，致力于提高系统运行保障能力。</li><li>**<a href="https://github.com/dromara/dynamic-tp">Dynamic TPopen in new window</a>**：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持 Nacos、Apollo，Zookeeper、Consul、Etcd，可通过 SPI 自定义实现）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁的优化</title>
    <link href="/2021/04/06/JUC/%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <url>/2021/04/06/JUC/%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p><code>锁粗化</code>：就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</p><p><code>锁消除</code>：JVM会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</p><p><code>轻量级锁</code>：这种锁实现的背后基于这样一种假设，即：在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒 （执行CAS指令成功的线程执行完后，释放锁 唤醒被阻塞的线程）。</p><p><code>偏向锁</code>：是为了在无锁竞争的情况下，避免在重复的获取锁和释放锁过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在一定程度上的本地延迟。</p><p>​偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p><p><code>适应性自旋</code>：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入重量级锁前，会进入忙等待然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用互斥锁进入到阻塞状态。</p><blockquote><p>总结：</p><ul><li>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。</li><li>轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</li><li>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</li></ul></blockquote><h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><table><thead><tr><th>锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td align="center">加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td align="center">适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td align="center">竞争的线程不会阻塞，提高了响应速度</td><td align="center">始终得不到锁的线程，使用自旋会消耗CPU性能</td><td align="center">追求响应时间，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td align="center">线程竞争不适用自旋，不会消耗CPU</td><td align="center">线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td align="center">追求吞吐量，同步块执行时间较长</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁的定义</title>
    <link href="/2021/04/06/JUC/%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    <url>/2021/04/06/JUC/%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><ul><li>乐观锁、悲观锁</li><li>自旋锁、适应性自旋锁</li><li>无锁、偏向锁、轻量级锁、重量级锁</li><li>公平锁、非公平锁</li><li>可重入锁、非可重入锁</li><li>独享锁（排他锁）、共享锁</li></ul><blockquote><p>synchronized关键字和Lock的实现类都是悲观锁</p></blockquote><p><strong>悲观锁</strong>： 认为在使用数据的时候，一定会有别的线程来修改数据，因此在获取数据的时候先加锁，确保数据不会被其他的线程修改。<code>适合写操作多的场景</code>，先加锁可以保证写操作时的数据正确。</p><p><strong>乐观锁</strong>：认为不会有其他的线程修改数据，不会添加锁。但会在更新数据的时候去判断有没有别的线程更新了数据（具体方法可以使用版本号机制或 CAS 算法）。<code> 适合读操作多的场景</code>，不加锁可以使读的操作性能大幅提升。</p><p><strong>自旋锁</strong>： 挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。自旋可以使线程不必阻塞直接获取同步资源，避免切换线程的开销。</p><ul><li>应用场景：同步资源的锁定时间很短，为了一点时间去切换线程、线程挂起和恢复现场的花费可能会让系统得不偿失，所以在物理机器有多个处理器的时候，可以选择使得线程不放弃CPU，看持有锁的线程是否很快就会释放锁。</li><li>缺点：虽然避免了线程切换的开销，但要占用处理器的时间。<strong>如果锁被占用的时间很短，那么自旋锁的效果会非常好。但如果锁被占用的时间很长，那么自旋的线程会白白浪费处理器的资源。</strong>所以自旋等待的时间会有一定的限度。如果自旋超过限定次数（<strong>默认十次</strong>）还没有成功获得锁，线程就应该被挂起。</li></ul><p><strong>自适应自旋锁</strong>： 自旋的时间不再固定，由上一次在同一个锁上的自旋时间和锁的拥有者的状态来决定。如果某个锁对象自旋等待成功获取过锁，并且持有锁的线程正在运行，那么JVM会认为该锁自旋获取到锁的可能性更大，会自动增加等待时间（自旋次数）。如果某个线程自旋很少获得锁，那么以后可能就会直接挂起，省略掉自旋的过程，避免浪费处理器资源。自适应自旋会使JVM对程序的锁的状态预测越来越准确。</p><p><strong>公平锁</strong>：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，只有队列中的第一个线程才能获得锁。</p><ul><li>优点：等待锁的线程不会饿死。</li><li>缺点：整体的吞吐效率相对于非公平锁要低，等待队列中除了第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的总开销比非公平锁大。</li></ul><p><strong>非公平锁</strong>： 线程直接尝试获得锁，获取不到后才进入等待队列的队尾等待。（即如果此时锁刚好可用，那么这个线程就可以无需阻塞的直接获取到锁）会出现后申请锁的线程先获取锁的场景。</p><ul><li><p>优点：减少唤起线程的开销，整体的吞吐效率高。（因为线程有概率直接获得锁，所以CPU不需要每次都唤醒线程）</p></li><li><p>缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p></li></ul><p><strong>可重入锁</strong>：在同一个线程在外层方法已经获得锁的时候，再进入该线程的内部方法会<strong>自动获取锁</strong>，前提是锁对象是同一个对象或class，不会因为之前获取过锁但还没释放而阻塞。ReentrantLock和synchronized都是可重入锁。</p><ul><li>优点：一定程度上避免死锁</li></ul><p><strong>非可重入锁</strong>： 不允许同一个线程多次获取同一个锁</p><p><strong>独享锁（排他锁）</strong>：该锁一次只能被一个线程所持有。如果某线程对数据加上排他锁后，其它线程不能再对数据加任何类型的锁。<code>获得排他锁的线程既能读数据又能修改数据</code>。synchronize和Lock的实现类就是独享锁。</p><p><strong>共享锁</strong>：该锁可被多个线程所持有。如果某线程对数据加上共享锁之后，那么其它线程只能再对其加共享锁，不能加排他锁。<code>获得共享锁的线程只能读数据，不能修改数据</code>。（读完了才可以加排他锁去写）</p><blockquote><p>在ReentrantReadWriteLock里面，读锁和写锁的加锁的方式不一样，读锁是共享锁，写锁是独享锁。因为读写锁分离，所以ReentrantReadWriteLock的并发性相比一般的互斥锁有很大的提升。</p></blockquote><p><strong>偏向锁</strong>：是为了在无锁竞争的情况下，避免在重复的获取锁和释放锁过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在一定程度的本地延迟。</p><p>​偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题目</title>
    <link href="/2021/04/06/JUC/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <url>/2021/04/06/JUC/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器、虚拟机栈</strong>和<strong>本地方法栈</strong>。</p><p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p><h3 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h3><blockquote><p>程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p></blockquote><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><h3 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h3><blockquote><p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong></p></blockquote><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>堆和方法区是所有线程共享的资源</p><ul><li>堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)</li><li>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ul><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h3><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程?"></a>为什么要使用多线程?</h3><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li><li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）。</li></ul><h3 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h3><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p><h3 id="如何理解线程安全和不安全？"><a href="#如何理解线程安全和不安全？" class="headerlink" title="如何理解线程安全和不安全？"></a>如何理解线程安全和不安全？</h3><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。</p><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><h3 id="单核-CPU-上运行多个线程效率一定会高吗？"><a href="#单核-CPU-上运行多个线程效率一定会高吗？" class="headerlink" title="单核 CPU 上运行多个线程效率一定会高吗？"></a>单核 CPU 上运行多个线程效率一定会高吗？</h3><p>单核CPU同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。一般来说，有两种类型的线程：CPU密集型和IO密集型。CPU密集型的线程主要进行计算和逻辑处理，需要占用大量的CPU资源。IO密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待IO设备的响应，而不占用太多的CPU资源。</p><p>在单核CPU上，同一时刻只能有一个线程在运行，其他线程需要等待CPU的时间片分配。如果线程是CPU密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。如果线程是IO密集型的，那么多个线程同时运行可以利用CPU在等待IO时的空闲时间，提高了效率。</p><p>因此，对于单核CPU来说，如果任务是CPU密集型的，那么开很多线程会影响效率；如果任务是IO密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。</p><h3 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态?"></a>说说线程的生命周期和状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJavaopen in new window</a>：<a href="https://howtodoinjava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread Statesopen in new window</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p><p><strong>为什么 JVM 没有区分这两种状态呢？</strong> （摘自：<a href="https://www.zhihu.com/question/56494969/answer/154053599">Java 线程运行怎么有第六种状态？ - Dawell 的回答open in new window</a> ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p></blockquote><ul><li>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li><li><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li><li>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</li><li>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</li></ul><h3 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换?"></a>什么是线程上下文切换?</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h3 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h3><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>：</p><ul><li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？下一个问题就会聊到。</li></ul><h3 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a>为什么 wait() 方法不定义在 Thread 中？</h3><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p><p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p><p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p><h3 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a>可以直接调用 Thread 类的 run 方法吗？</h3><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h3 id="如何保证变量的可见性？"><a href="#如何保证变量的可见性？" class="headerlink" title="如何保证变量的可见性？"></a>如何保证变量的可见性？</h3><p>将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证.</p><h3 id="如何禁止指令重排序？"><a href="#如何禁止指令重排序？" class="headerlink" title="如何禁止指令重排序？"></a>如何禁止指令重排序？</h3><p><strong><code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><p><strong>双重校验锁实现对象单例（线程安全）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>uniqueInstance &#x3D; new Singleton(); </p><p>这段代码其实是分为三步执行：</p><ul><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ul><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p></blockquote><h3 id="构造方法可以用-synchronized-修饰么？"><a href="#构造方法可以用-synchronized-修饰么？" class="headerlink" title="构造方法可以用 synchronized 修饰么？"></a>构造方法可以用 synchronized 修饰么？</h3><p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><h3 id="synchronized-底层原理了解吗"><a href="#synchronized-底层原理了解吗" class="headerlink" title="synchronized 底层原理了解吗"></a>synchronized 底层原理了解吗</h3><p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p><p>字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p><blockquote><p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitoropen in new window</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p><p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p></blockquote><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><p><strong>总结</strong></p><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>两者的本质都是对对象监视器 monitor 的获取</strong>。</p><h3 id="JDK1-6-之后的-synchronized-底层做了哪些优化？"><a href="#JDK1-6-之后的-synchronized-底层做了哪些优化？" class="headerlink" title="JDK1.6 之后的 synchronized 底层做了哪些优化？"></a>JDK1.6 之后的 synchronized 底层做了哪些优化？</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h3 id="synchronized-和-volatile-有什么区别？"><a href="#synchronized-和-volatile-有什么区别？" class="headerlink" title="synchronized 和 volatile 有什么区别？"></a>synchronized 和 volatile 有什么区别？</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><p><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</p></li><li><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p></li><li><p><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2021/04/06/DB/MySQL/1.%20MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/06/DB/MySQL/1.%20MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h2><h3 id="什么是关系型数据库？"><a href="#什么是关系型数据库？" class="headerlink" title="什么是关系型数据库？"></a>什么是关系型数据库？</h3><p>关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><p><img src="https://oss.javaguide.cn/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="关系型数据库表关系"></p><center>关系型数据库表关系</center><p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</p><p><strong>有哪些常见的关系型数据库呢？</strong></p><p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ……。</p><h3 id="什么是-SQL？"><a href="#什么是-SQL？" class="headerlink" title="什么是 SQL？"></a>什么是 SQL？</h3><p>SQL 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。</p><p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，<strong>一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</strong></p><p>SQL 可以帮助我们：</p><ul><li>新建数据库、数据表、字段；</li><li>在数据库中增加，删除，修改，查询数据；</li><li>新建视图、函数、存储过程；</li><li>对数据库中的数据进行简单的数据分析；</li><li>搭配 Hive，Spark SQL 做大数据；</li><li>搭配 SQLFlow 做机器学习；</li><li>……</li></ul><h3 id="什么是-MySQL？"><a href="#什么是-MySQL？" class="headerlink" title="什么是 MySQL？"></a>什么是 MySQL？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/csdn/20210327143351823.png" alt="img"></p><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储数据。</strong></p><p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。MySQL 的默认端口号是<strong>3306</strong>。</p><h3 id="MySQL-有什么优点？MySQL-如此流行的原因"><a href="#MySQL-有什么优点？MySQL-如此流行的原因" class="headerlink" title="MySQL 有什么优点？MySQL 如此流行的原因"></a>MySQL 有什么优点？MySQL 如此流行的原因</h3><p>MySQL 主要具有下面这些优点：</p><ol><li>成熟稳定，功能完善。</li><li>开源免费。</li><li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li>开箱即用，操作简单，维护成本低。</li><li>兼容性好，支持常见的操作系统，支持多种开发语言。</li><li>社区活跃，生态完善。</li><li>事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li>支持分库分表、读写分离、高可用。</li></ol><h2 id="MySQL-字段类型"><a href="#MySQL-字段类型" class="headerlink" title="MySQL 字段类型"></a>MySQL 字段类型</h2><p>MySQL 字段类型可以简单分为三大类：</p><ul><li><strong>数值类型</strong>：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）</li><li><strong>字符串类型</strong>：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。</li><li><strong>日期时间类型</strong>：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。</li></ul><p>下面这张图不是我画的，忘记是从哪里保存下来的了，总结的还蛮不错的。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/image-20240228194855612.png" alt="image-20240228194855612"></p><center>MySQL 常见字段类型总结</center><h3 id="整数类型的-UNSIGNED-属性有什么用？"><a href="#整数类型的-UNSIGNED-属性有什么用？" class="headerlink" title="整数类型的 UNSIGNED 属性有什么用？"></a>整数类型的 UNSIGNED 属性有什么用？</h3><p>MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来表示不允许负值的无符号整数。使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p><p>例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 2,147,483,648 ~ 2,147,483,647。</p><p>对于从 0 开始递增的 ID 列，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p><h3 id="CHAR-和-VARCHAR-的区别是什么？"><a href="#CHAR-和-VARCHAR-的区别是什么？" class="headerlink" title="#CHAR 和 VARCHAR 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>CHAR 和 VARCHAR 的区别是什么？</h3><p>CHAR 和 VARCHAR 是最常用到的字符串类型，两者的主要区别在于：<strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p><p>CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</p><p>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</p><p>CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</p><h3 id="VARCHAR-100-和-VARCHAR-10-的区别是什么？"><a href="#VARCHAR-100-和-VARCHAR-10-的区别是什么？" class="headerlink" title="#VARCHAR(100)和 VARCHAR(10)的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#varchar-100-%E5%92%8C-varchar-10-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>VARCHAR(100)和 VARCHAR(10)的区别是什么？</h3><p>VARCHAR(100)和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，VARCHAR (100) 可以满足更大范围的字符存储需求，有更好的业务拓展性。而 VARCHAR(10)存储超过 10 个字符时，就需要修改表结构才可以。</p><p>虽说 VARCHAR(100)和 VARCHAR(10)能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p><p>不过，VARCHAR(100) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR(100)是按照 100 这个长度来进行的，也就会消耗更多内存。</p><h3 id="DECIMAL-和-FLOAT-DOUBLE-的区别是什么？"><a href="#DECIMAL-和-FLOAT-DOUBLE-的区别是什么？" class="headerlink" title="#DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#decimal-%E5%92%8C-float-double-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</h3><p>DECIMAL 和 FLOAT 的区别是：<strong>DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT&#x2F;DOUBLE 只能存储近似的小数值。</strong></p><p>DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。</p><p>在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类 <code>java.math.BigDecimal</code>。</p><h3 id="为什么不推荐使用-TEXT-和-BLOB？"><a href="#为什么不推荐使用-TEXT-和-BLOB？" class="headerlink" title="#为什么不推荐使用 TEXT 和 BLOB？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-text-%E5%92%8C-blob">#</a>为什么不推荐使用 TEXT 和 BLOB？</h3><p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据，例如博客内容。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>0-255 字节</td><td>一般文本字符串</td></tr><tr><td>TEXT</td><td>0-65,535 字节</td><td>长文本字符串</td></tr><tr><td>MEDIUMTEXT</td><td>0-16,772,150 字节</td><td>较大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4,294,967,295 字节</td><td>极大文本数据</td></tr></tbody></table><p>BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>0-255 字节</td><td>短文本二进制字符串</td></tr><tr><td>BLOB</td><td>0-65KB</td><td>二进制字符串</td></tr><tr><td>MEDIUMBLOB</td><td>0-16MB</td><td>二进制形式的长文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4GB</td><td>二进制形式的极大文本数据</td></tr></tbody></table><p>在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT。</p><p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p><ul><li>不能有默认值。</li><li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。</li><li>检索效率较低。</li><li>不能直接创建索引，需要指定前缀长度。</li><li>可能会消耗大量的网络和 IO 带宽。</li><li>可能导致表上的 DML 操作变慢。</li><li>……</li></ul><h3 id="DATETIME-和-TIMESTAMP-的区别是什么？"><a href="#DATETIME-和-TIMESTAMP-的区别是什么？" class="headerlink" title="#DATETIME 和 TIMESTAMP 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#datetime-%E5%92%8C-timestamp-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>DATETIME 和 TIMESTAMP 的区别是什么？</h3><p>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。</p><p>TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p><ul><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><p>关于两者的详细对比，请参考我写的<a href="https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html">MySQL 时间类型数据存储建议</a>。</p><h3 id="NULL-和-‘’-的区别是什么？"><a href="#NULL-和-‘’-的区别是什么？" class="headerlink" title="#NULL 和 ‘’ 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#null-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>NULL 和 ‘’ 的区别是什么？</h3><p><code>NULL</code> 跟 <code>&#39;&#39;</code>(空字符串)是两个完全不一样的值，区别如下：</p><ul><li><code>NULL</code> 代表一个不确定的值,就算是两个 <code>NULL</code>,它俩也不一定相等。例如，<code>SELECT NULL=NULL</code>的结果为 false，但是在我们使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时,<code>NULL</code>又被认为是相等的。</li><li><code>&#39;&#39;</code>的长度是 0，是不占用空间的，而<code>NULL</code> 是需要占用空间的。</li><li><code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li><li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li></ul><p>看了上面的介绍之后，相信你对另外一个高频面试题：“为什么 MySQL 不建议使用 <code>NULL</code> 作为列默认值？”也有了答案。</p><h3 id="Boolean-类型如何表示？"><a href="#Boolean-类型如何表示？" class="headerlink" title="#Boolean 类型如何表示？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#boolean-%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA">#</a>Boolean 类型如何表示？</h3><p>MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。</p><h2 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="#MySQL 基础架构"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84">#</a>MySQL 基础架构</h2><blockquote><p>  建议配合 <a href="https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。另外，“一个 SQL 语句在 MySQL 中的执行流程”也是面试中比较常问的一个问题。</p></blockquote><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p><p><img src="https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png" alt="img"></p><p>从上图可以看出， MySQL 主要由下面几部分构成：</p><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="#MySQL 存储引擎"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">#</a>MySQL 存储引擎</h2><p>MySQL 核心在于存储引擎，想要深入学习 MySQL，必定要深入研究 MySQL 存储引擎。</p><h3 id="MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="#MySQL 支持哪些存储引擎？默认使用哪个？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA">#</a>MySQL 支持哪些存储引擎？默认使用哪个？</h3><p>MySQL 支持多种存储引擎，你可以通过 <code>SHOW ENGINES</code> 命令来查看 MySQL 支持的所有存储引擎。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510105408703.png" alt="查看 MySQL 提供的所有存储引擎">查看 MySQL 提供的所有存储引擎</p><p>从上图我们可以查看出， MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p><p>我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。</p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>你可以通过 <code>SELECT VERSION()</code> 命令查看你的 MySQL 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; SELECT VERSION();<br>+-----------+<br>| VERSION() |<br>+-----------+<br>| 8.0.27    |<br>+-----------+<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><p>你也可以通过 <code>SHOW VARIABLES LIKE &#39;%storage_engine%&#39;</code> 命令直接查看 MySQL 当前默认的存储引擎。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; SHOW VARIABLES  LIKE <span class="hljs-string">&#x27;%storage_engine%&#x27;</span>;<br>+---------------------------------+-----------+<br>| Variable_name                   | Value     |<br>+---------------------------------+-----------+<br>| default_storage_engine          | InnoDB    |<br>| default_tmp_storage_engine      | InnoDB    |<br>| disabled_storage_engines        |           |<br>| internal_tmp_mem_storage_engine | TempTable |<br>+---------------------------------+-----------+<br>4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><p>如果你想要深入了解每个存储引擎以及它们之间的区别，推荐你去阅读以下 MySQL 官方文档对应的介绍(面试不会问这么细，了解即可)：</p><ul><li>InnoDB 存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.htmlopen in new window</a> 。</li><li>其他存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">https://dev.mysql.com/doc/refman/8.0/en/storage-engines.htmlopen in new window</a> 。</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510155143458.png" alt="img"></p><h3 id="MySQL-存储引擎架构了解吗？"><a href="#MySQL-存储引擎架构了解吗？" class="headerlink" title="#MySQL 存储引擎架构了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97">#</a>MySQL 存储引擎架构了解吗？</h3><p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><p>并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。</p><p>MySQL 官方文档也有介绍到如何编写一个自定义存储引擎，地址：<a href="https://dev.mysql.com/doc/internals/en/custom-engine.html">https://dev.mysql.com/doc/internals/en/custom-engine.htmlopen in new window</a> 。</p><h3 id="MyISAM-和-InnoDB-有什么区别？"><a href="#MyISAM-和-InnoDB-有什么区别？" class="headerlink" title="#MyISAM 和 InnoDB 有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#myisam-%E5%92%8C-innodb-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>MyISAM 和 InnoDB 有什么区别？</h3><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p><p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>言归正传！咱们下面还是来简单对比一下两者：</p><p><strong>1.是否支持行级锁</strong></p><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p><p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解</a>。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510090309427.png" alt="img"></p><p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p><p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p><p><strong>6.索引实现不一样。</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><p>详细区别，推荐你看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解</a>。</p><p><strong>7.性能有差别。</strong></p><p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/innodb-myisam-performance-comparison.png" alt="InnoDB 和 MyISAM 性能对比">InnoDB 和 MyISAM 性能对比</p><p><strong>总结</strong>：</p><ul><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大。</li></ul><p>最后，再分享一张图片给你，这张图片详细对比了常见的几种 MySQL 存储引擎。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/comparison-of-common-mysql-storage-engines.png" alt="常见的几种 MySQL 存储引擎对比">常见的几种 MySQL 存储引擎对比</p><h3 id="MyISAM-和-InnoDB-如何选择？"><a href="#MyISAM-和-InnoDB-如何选择？" class="headerlink" title="#MyISAM 和 InnoDB 如何选择？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#myisam-%E5%92%8C-innodb-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">#</a>MyISAM 和 InnoDB 如何选择？</h3><p>大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。</p><p>《MySQL 高性能》上面有一句话这样写到:</p><blockquote><p>  不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p></blockquote><p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p><p>因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。</p><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="#MySQL 索引"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%B4%A2%E5%BC%95">#</a>MySQL 索引</h2><p>MySQL 索引相关的问题比较多，对于面试和工作都比较重要，于是，我单独抽了一篇文章专门来总结 MySQL 索引相关的知识点和问题：<a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解</a> 。</p><h2 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="#MySQL 查询缓存"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98">#</a>MySQL 查询缓存</h2><p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p><p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">query_cache_type</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">query_cache_size</span>=<span class="hljs-string">600000</span><br></code></pre></td></tr></table></figure><p>MySQL 执行以下命令也可以开启查询缓存</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">set</span> <span class="hljs-string">global  query_cache_type=1;</span><br><span class="hljs-attr">set</span> <span class="hljs-string">global  query_cache_size=600000;</span><br></code></pre></td></tr></table></figure><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p><p><strong>查询缓存不命中的情况：</strong></p><ol><li>任何两个查询在任何字符上的不同都会导致缓存不命中。</li><li>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li><li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li></ol><p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 <code>sql_cache</code> 和 <code>sql_no_cache</code> 来控制某个查询语句是否需要缓存：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sql_no_cache <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> usr;<br></code></pre></td></tr></table></figure><h2 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="#MySQL 日志"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%97%A5%E5%BF%97">#</a>MySQL 日志</h2><p>MySQL 日志常见的面试题有：</p><ul><li>MySQL 中常见的日志有哪些？</li><li>慢查询日志有什么用？</li><li>binlog 主要记录了什么？</li><li>redo log 如何保证事务的持久性？</li><li>页修改之后为什么不直接刷盘呢？</li><li>binlog 和 redolog 有什么区别？</li><li>undo log 如何保证事务的原子性？</li><li>……</li></ul><p>上诉问题的答案可以在<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》(付费)</a> 的 <strong>「技术面试题篇」</strong> 中找到。</p><p><img src="https://oss.javaguide.cn/javamianshizhibei/technical-interview-questions.png" alt="《Java 面试指北》技术面试题篇">《Java 面试指北》技术面试题篇</p><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="#MySQL 事务"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E4%BA%8B%E5%8A%A1">#</a>MySQL 事务</h2><h3 id="何谓事务？"><a href="#何谓事务？" class="headerlink" title="#何谓事务？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%BD%95%E8%B0%93%E4%BA%8B%E5%8A%A1">#</a>何谓事务？</h3><p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p><ul><li>数据库中途突然因为某些原因挂掉了。</li><li>客户端突然因为网络原因连接不上数据库了。</li><li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li><li>……</li></ul><p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p><ol><li>将小明的余额减少 1000 元</li><li>将小红的余额增加 1000 元。</li></ol><p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="事务示意图">事务示意图</p><h3 id="何谓数据库事务？"><a href="#何谓数据库事务？" class="headerlink" title="#何谓数据库事务？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%BD%95%E8%B0%93%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1">#</a>何谓数据库事务？</h3><p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p><p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p><p><strong>那数据库事务有什么作用呢？</strong></p><p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 开启一个事务<br><span class="hljs-keyword">START</span> TRANSACTION;<br># 多条 <span class="hljs-keyword">SQL</span> 语句<br>SQL1,SQL2...<br>## 提交事务<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="数据库事务示意图">数据库事务示意图</p><p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/ACID.png" alt="ACID">ACID</p><ol><li><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong> 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课<a href="https://time.geekbang.org/opencourse/intro/100064201">《周志明的软件架构课》open in new window</a>才搞清楚的（多看好书！！！）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/AID-%3EC.png" alt="AID-&gt;C">AID-&gt;C</p><p>另外，DDIA 也就是 <a href="https://book.douban.com/subject/30329536/">《Designing Data-Intensive Application（数据密集型应用系统设计）》open in new window</a> 的作者在他的这本书中如是说：</p><blockquote><p>  Atomicity, isolation, and durability are properties of the database, whereas consis‐ tency (in the ACID sense) is a property of the application. The application may rely on the database’s atomicity and isolation properties in order to achieve consistency, but it’s not up to the database alone.</p><p>  翻译过来的意思是：原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。</p></blockquote><p>《Designing Data-Intensive Application（数据密集型应用系统设计）》这本书强推一波，值得读很多遍！豆瓣有接近 90% 的人看了这本书之后给了五星好评。另外，中文翻译版本已经在 GitHub 开源，地址：<a href="https://github.com/Vonng/ddia">https://github.com/Vonng/ddiaopen in new window</a> 。</p><p><img src="https://oss.javaguide.cn/github/javaguide/books/ddia.png" alt="img"></p><h3 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="#并发事务带来了哪些问题?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">#</a>并发事务带来了哪些问题?</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><h4 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="#脏读（Dirty read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%84%8F%E8%AF%BB-dirty-read">#</a>脏读（Dirty read）</h4><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 读取到 A &#x3D; 19,事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading-ee15b0b9.png" alt="脏读">脏读</p><h4 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="#丢失修改（Lost to modify）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9-lost-to-modify">#</a>丢失修改（Lost to modify）</h4><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 先修改 A&#x3D;A-1，事务 2 后来也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-missing-modifications-5b2e2bd8.png" alt="丢失修改">丢失修改</p><h4 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="#不可重复读（Unrepeatable read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-unrepeatable-read">#</a>不可重复读（Unrepeatable read）</h4><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 再次读取 A &#x3D;19，此时读取的结果和第一次读取的结果不同。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-unrepeatable-read-ff9186e1.png" alt="不可重复读">不可重复读</p><h4 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="#幻读（Phantom read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%BB%E8%AF%BB-phantom-read">#</a>幻读（Phantom read）</h4><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-phantom-read-7cba7a85.png" alt="幻读">幻读</p><h3 id="不可重复读和幻读有什么区别？"><a href="#不可重复读和幻读有什么区别？" class="headerlink" title="#不可重复读和幻读有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>不可重复读和幻读有什么区别？</h3><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h3 id="并发事务的控制方式有哪些？"><a href="#并发事务的控制方式有哪些？" class="headerlink" title="#并发事务的控制方式有哪些？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>并发事务的控制方式有哪些？</h3><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p><p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p><p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul><p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html">InnoDB 存储引擎对 MVCC 的实现</a> 。</p><h3 id="SQL-标准定义了哪些事务隔离级别"><a href="#SQL-标准定义了哪些事务隔离级别" class="headerlink" title="#SQL 标准定义了哪些事务隔离级别?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#sql-%E6%A0%87%E5%87%86%E5%AE%9A%E4%B9%89%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">#</a>SQL 标准定义了哪些事务隔离级别?</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h3 id="MySQL-的隔离级别是基于锁实现的吗？"><a href="#MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="#MySQL 的隔离级别是基于锁实现的吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97">#</a>MySQL 的隔离级别是基于锁实现的吗？</h3><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h3 id="MySQL-的默认隔离级别是什么"><a href="#MySQL-的默认隔离级别是什么" class="headerlink" title="#MySQL 的默认隔离级别是什么?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>MySQL 的默认隔离级别是什么?</h3><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@tx_isolation</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@tx_isolation</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br></code></pre></td></tr></table></figure><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解</a>。</p><h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="#MySQL 锁"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E9%94%81">#</a>MySQL 锁</h2><p>锁是一种常见的并发事务的控制方式。</p><h3 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="#表级锁和行级锁了解吗？有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>表级锁和行级锁了解吗？有什么区别？</h3><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p><p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p><p><strong>表级锁和行级锁对比</strong>：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li></ul><h3 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="#行级锁的使用有什么注意事项？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">#</a>行级锁的使用有什么注意事项？</h3><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p><p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p><h3 id="InnoDB-有哪几类行锁？"><a href="#InnoDB-有哪几类行锁？" class="headerlink" title="#InnoDB 有哪几类行锁？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#innodb-%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BB%E8%A1%8C%E9%94%81">#</a>InnoDB 有哪几类行锁？</h3><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p><p>一些大厂面试中可能会问到 Next-Key Lock 的加锁范围，这里推荐一篇文章：<a href="https://segmentfault.com/a/1190000040129107">MySQL next-key lock 加锁范围是什么？ - 程序员小航 - 2021open in new window</a> 。</p><h3 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="#共享锁和排他锁呢？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81%E5%91%A2">#</a>共享锁和排他锁呢？</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th align="left"></th><th align="left">S 锁</th><th align="left">X 锁</th></tr></thead><tbody><tr><td align="left">S 锁</td><td align="left">不冲突</td><td align="left">冲突</td></tr><tr><td align="left">X 锁</td><td align="left">冲突</td><td align="left">冲突</td></tr></tbody></table><p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 共享锁 可以在 MySQL <span class="hljs-number">5.7</span> 和 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 共享锁 可以在 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> SHARE;<br># 排他锁<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><h3 id="意向锁有什么作用？"><a href="#意向锁有什么作用？" class="headerlink" title="#意向锁有什么作用？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E6%84%8F%E5%90%91%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">#</a>意向锁有什么作用？</h3><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p><p>意向锁是表级锁，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><p>《MySQL 技术内幕 InnoDB 存储引擎》这本书对应的描述应该是笔误了。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220511171419081.png" alt="img"></p><h3 id="当前读和快照读有什么区别？"><a href="#当前读和快照读有什么区别？" class="headerlink" title="#当前读和快照读有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>当前读和快照读有什么区别？</h3><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span><br># 共享锁 可以在 MySQL <span class="hljs-number">5.7</span> 和 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 共享锁 可以在 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> SHARE;<br></code></pre></td></tr></table></figure><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p><p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p><p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><p>当前读的一些常见 SQL 语句类型如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 对读的记录加一个X锁<br>SELECT...FOR <span class="hljs-keyword">UPDATE</span><br># 对读的记录加一个S锁<br>SELECT...LOCK <span class="hljs-keyword">IN</span> SHARE MODE<br># 对读的记录加一个S锁<br>SELECT...FOR SHARE<br># 对修改的记录加一个X锁<br>INSERT...<br>UPDATE...<br>DELETE...<br></code></pre></td></tr></table></figure><h3 id="自增锁有了解吗？"><a href="#自增锁有了解吗？" class="headerlink" title="#自增锁有了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%87%AA%E5%A2%9E%E9%94%81%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97">#</a>自增锁有了解吗？</h3><blockquote><p>  不太重要的一个知识点，简单了解即可。</p></blockquote><p>关系型数据库设计表的时候，通常会有一列作为自增主键。InnoDB 中的自增主键会涉及一种比较特殊的表级锁— <strong>自增锁（AUTO-INC Locks）</strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `sequence_id` (<br>  `id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `stub` <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `stub` (`stub`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br></code></pre></td></tr></table></figure><p>更准确点来说，不仅仅是自增主键，<code>AUTO_INCREMENT</code>的列都会涉及到自增锁，毕竟非主键也可以设置自增长。</p><p>如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住。这里的阻塞行为只是自增锁行为的其中一种，可以理解为自增锁就是一个接口，其具体的实现有多种。具体的配置项为 <code>innodb_autoinc_lock_mode</code> （MySQL 5.1.22 引入），可以选择的值如下：</p><table><thead><tr><th align="left">innodb_autoinc_lock_mode</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">传统模式</td></tr><tr><td align="left">1</td><td align="left">连续模式（MySQL 8.0 之前默认）</td></tr><tr><td align="left">2</td><td align="left">交错模式(MySQL 8.0 之后默认)</td></tr></tbody></table><p>交错模式下，所有的“INSERT-LIKE”语句（所有的插入语句，包括：<code>INSERT</code>、<code>REPLACE</code>、<code>INSERT…SELECT</code>、<code>REPLACE…SELECT</code>、<code>LOAD DATA</code>等）都不使用表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行，速度更快，扩展性也更好。</p><p>不过，如果你的 MySQL 数据库有主从同步需求并且 Binlog 存储格式为 Statement 的话，不要将 InnoDB 自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序就无法得到保障。</p><blockquote><p>  如果 MySQL 采用的格式为 Statement ，那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。</p></blockquote><p>最后，再推荐一篇文章：<a href="https://draveness.me/whys-the-design-mysql-auto-increment/">为什么 MySQL 的自增主键不单调也不连续open in new window</a> 。</p><h2 id="MySQL-性能优化"><a href="#MySQL-性能优化" class="headerlink" title="#MySQL 性能优化"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">#</a>MySQL 性能优化</h2><p>关于 MySQL 性能优化的建议总结，请看这篇文章：<a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html">MySQL 高性能优化规范建议总结</a> 。</p><h3 id="能用-MySQL-直接存储文件（比如图片）吗？"><a href="#能用-MySQL-直接存储文件（比如图片）吗？" class="headerlink" title="#能用 MySQL 直接存储文件（比如图片）吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%83%BD%E7%94%A8-mysql-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6-%E6%AF%94%E5%A6%82%E5%9B%BE%E7%89%87-%E5%90%97">#</a>能用 MySQL 直接存储文件（比如图片）吗？</h3><p>可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。</p><p>可以选择使用云服务厂商提供的开箱即用的文件存储服务，成熟稳定，价格也比较低。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/oss-search.png" alt="img"></p><p>也可以选择自建文件存储服务，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。</p><p><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p><p>相关阅读：<a href="https://www.51cto.com/article/716978.html">Spring Boot 整合 MinIO 实现分布式文件服务open in new window</a> 。</p><h3 id="MySQL-如何存储-IP-地址？"><a href="#MySQL-如何存储-IP-地址？" class="headerlink" title="#MySQL 如何存储 IP 地址？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8-ip-%E5%9C%B0%E5%9D%80">#</a>MySQL 如何存储 IP 地址？</h3><p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li><li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><h3 id="有哪些常见的-SQL-优化手段？"><a href="#有哪些常见的-SQL-优化手段？" class="headerlink" title="#有哪些常见的 SQL 优化手段？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84-sql-%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5">#</a>有哪些常见的 SQL 优化手段？</h3><p><a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》(付费)</a> 的 <strong>「技术面试题篇」</strong> 有一篇文章详细介绍了常见的 SQL 优化手段，非常全面，清晰易懂！</p><p><img src="https://oss.javaguide.cn/javamianshizhibei/javamianshizhibei-sql-optimization.png" alt="常见的 SQL 优化手段">常见的 SQL 优化手段</p><h3 id="如何分析-SQL-的性能？"><a href="#如何分析-SQL-的性能？" class="headerlink" title="#如何分析 SQL 的性能？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-sql-%E7%9A%84%E6%80%A7%E8%83%BD">#</a>如何分析 SQL 的性能？</h3><p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 适用于 <code>SELECT</code>, <code>DELETE</code>, <code>INSERT</code>, <code>REPLACE</code>, 和 <code>UPDATE</code>语句，我们一般分析 <code>SELECT</code> 查询较多。</p><p>我们这里简单来演示一下 <code>EXPLAIN</code> 的使用。</p><p><code>EXPLAIN</code> 的输出格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> `score`,`name` <span class="hljs-keyword">FROM</span> `cus_order` <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `score` <span class="hljs-keyword">DESC</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>     <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>   <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> cus_order <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">997572</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> filesort <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>各个字段的含义如下：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的序列标识符</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询类型</td></tr><tr><td>table</td><td>用到的表名</td></tr><tr><td>partitions</td><td>匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td>type</td><td>表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际用到的索引</td></tr><tr><td>key_len</td><td>所选索引的长度</td></tr><tr><td>ref</td><td>当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><p>篇幅问题，我这里只是简单介绍了一下 MySQL 执行计划，详细介绍请看：<a href="https://javaguide.cn/database/mysql/mysql-query-execution-plan.html">SQL 的执行计划</a>这篇文章。</p><h3 id="读写分离和分库分表了解吗？"><a href="#读写分离和分库分表了解吗？" class="headerlink" title="#读写分离和分库分表了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%92%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BA%86%E8%A7%A3%E5%90%97">#</a>读写分离和分库分表了解吗？</h3><p>读写分离和分库分表相关的问题比较多，于是，我单独写了一篇文章来介绍：<a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html">读写分离和分库分表详解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2021/04/06/DB/MySQL/10.%20MYSQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2021/04/06/DB/MySQL/10.%20MYSQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-性能优化"><a href="#MySQL-性能优化" class="headerlink" title="MySQL 性能优化"></a>MySQL 性能优化</h2>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL高性能优化规范建议总结</title>
    <link href="/2021/04/06/DB/MySQL/11.%20MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/06/DB/MySQL/11.%20MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h2><ul><li>所有数据库对象名称必须使用小写字母并用下划线分割</li><li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li><li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li><li>临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀，备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀</li><li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li></ul><h2 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="#数据库基本设计规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">#</a>数据库基本设计规范</h2><h3 id="所有表必须使用-InnoDB-存储引擎"><a href="#所有表必须使用-InnoDB-存储引擎" class="headerlink" title="#所有表必须使用 InnoDB 存储引擎"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%89%80%E6%9C%89%E8%A1%A8%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">#</a>所有表必须使用 InnoDB 存储引擎</h3><p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。</p><p>InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p><h3 id="数据库和表的字符集统一使用-UTF8"><a href="#数据库和表的字符集统一使用-UTF8" class="headerlink" title="#数据库和表的字符集统一使用 UTF8"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8-utf8">#</a>数据库和表的字符集统一使用 UTF8</h3><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p><p>推荐阅读一下我写的这篇文章：<a href="https://javaguide.cn/database/character-set.html">MySQL 字符集详解</a> 。</p><h3 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="#所有表和字段都需要添加注释"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%89%80%E6%9C%89%E8%A1%A8%E5%92%8C%E5%AD%97%E6%AE%B5%E9%83%BD%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A">#</a>所有表和字段都需要添加注释</h3><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p><h3 id="尽量控制单表数据量的大小，建议控制在-500-万以内"><a href="#尽量控制单表数据量的大小，建议控制在-500-万以内" class="headerlink" title="#尽量控制单表数据量的大小，建议控制在 500 万以内"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%B0%BD%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E8%A1%A8%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%A4%A7%E5%B0%8F-%E5%BB%BA%E8%AE%AE%E6%8E%A7%E5%88%B6%E5%9C%A8-500-%E4%B8%87%E4%BB%A5%E5%86%85">#</a>尽量控制单表数据量的大小，建议控制在 500 万以内</h3><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p><h3 id="谨慎使用-MySQL-分区表"><a href="#谨慎使用-MySQL-分区表" class="headerlink" title="#谨慎使用 MySQL 分区表"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8-mysql-%E5%88%86%E5%8C%BA%E8%A1%A8">#</a>谨慎使用 MySQL 分区表</h3><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p><p>谨慎选择分区键，跨分区查询效率可能更低；</p><p>建议采用物理分表的方式管理大数据。</p><h3 id="经常一起使用的列放到一个表中"><a href="#经常一起使用的列放到一个表中" class="headerlink" title="#经常一起使用的列放到一个表中"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%BB%8F%E5%B8%B8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%97%E6%94%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%A1%A8%E4%B8%AD">#</a>经常一起使用的列放到一个表中</h3><p>避免更多的关联操作。</p><h3 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="#禁止在表中建立预留字段"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E5%9C%A8%E8%A1%A8%E4%B8%AD%E5%BB%BA%E7%AB%8B%E9%A2%84%E7%95%99%E5%AD%97%E6%AE%B5">#</a>禁止在表中建立预留字段</h3><ul><li>预留字段的命名很难做到见名识义。</li><li>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</li><li>对预留字段类型的修改，会对表进行锁定。</li></ul><h3 id="禁止在数据库中存储文件（比如图片）这类大的二进制数据"><a href="#禁止在数据库中存储文件（比如图片）这类大的二进制数据" class="headerlink" title="#禁止在数据库中存储文件（比如图片）这类大的二进制数据"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6-%E6%AF%94%E5%A6%82%E5%9B%BE%E7%89%87-%E8%BF%99%E7%B1%BB%E5%A4%A7%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE">#</a>禁止在数据库中存储文件（比如图片）这类大的二进制数据</h3><p>在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。</p><p>文件（比如图片）这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息。</p><h3 id="不要被数据库范式所束缚"><a href="#不要被数据库范式所束缚" class="headerlink" title="#不要被数据库范式所束缚"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E4%B8%8D%E8%A6%81%E8%A2%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E6%89%80%E6%9D%9F%E7%BC%9A">#</a>不要被数据库范式所束缚</h3><p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p><h3 id="禁止在线上做数据库压力测试"><a href="#禁止在线上做数据库压力测试" class="headerlink" title="#禁止在线上做数据库压力测试"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E5%9C%A8%E7%BA%BF%E4%B8%8A%E5%81%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95">#</a>禁止在线上做数据库压力测试</h3><h3 id="禁止从开发环境-测试环境直接连接生产环境数据库"><a href="#禁止从开发环境-测试环境直接连接生产环境数据库" class="headerlink" title="#禁止从开发环境,测试环境直接连接生产环境数据库"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%BB%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9B%B4%E6%8E%A5%E8%BF%9E%E6%8E%A5%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE%E5%BA%93">#</a>禁止从开发环境,测试环境直接连接生产环境数据库</h3><p>安全隐患极大，要对生产环境抱有敬畏之心！</p><h2 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="#数据库字段设计规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">#</a>数据库字段设计规范</h2><h3 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="#优先选择符合存储需要的最小的数据类型"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9%E7%AC%A6%E5%90%88%E5%AD%98%E5%82%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">#</a>优先选择符合存储需要的最小的数据类型</h3><p>存储字节越小，占用也就空间越小，性能也越好。</p><p><strong>a.某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据。</strong></p><p>数字是连续的，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li><li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。</strong></p><p>无符号相对于有符号可以多出一倍的存储空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">SIGNED <span class="hljs-type">INT</span> <span class="hljs-number">-2147483648</span><span class="hljs-operator">~</span><span class="hljs-number">2147483647</span><br>UNSIGNED <span class="hljs-type">INT</span> <span class="hljs-number">0</span><span class="hljs-operator">~</span><span class="hljs-number">4294967295</span><br></code></pre></td></tr></table></figure><p><strong>c.小数值类型（比如年龄、状态表示如 0&#x2F;1）优先使用 TINYINT 类型。</strong></p><h3 id="避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据"><a href="#避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据" class="headerlink" title="#避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-text-blob-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84-text-%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8-64k-%E7%9A%84%E6%95%B0%E6%8D%AE">#</a>避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h3><p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p><p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 <code>select *</code>而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p><p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p><p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p><h3 id="避免使用-ENUM-类型"><a href="#避免使用-ENUM-类型" class="headerlink" title="#避免使用 ENUM 类型"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-enum-%E7%B1%BB%E5%9E%8B">#</a>避免使用 ENUM 类型</h3><ul><li>修改 ENUM 值需要使用 ALTER 语句；</li><li>ENUM 类型的 ORDER BY 操作效率低，需要额外操作；</li><li>ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。</li></ul><p>相关阅读：<a href="https://www.zhihu.com/question/404422255/answer/1661698499">是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎open in new window</a> 。</p><h3 id="尽可能把所有列定义为-NOT-NULL"><a href="#尽可能把所有列定义为-NOT-NULL" class="headerlink" title="#尽可能把所有列定义为 NOT NULL"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%B0%BD%E5%8F%AF%E8%83%BD%E6%8A%8A%E6%89%80%E6%9C%89%E5%88%97%E5%AE%9A%E4%B9%89%E4%B8%BA-not-null">#</a>尽可能把所有列定义为 NOT NULL</h3><p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p><ul><li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li><li>进行比较和计算时要对 NULL 值做特别的处理。</li></ul><p>相关阅读：<a href="https://opensource.actionsky.com/20190710-mysql/">技术分享 | MySQL 默认值选型（是空，还是 NULL）open in new window</a> 。</p><h3 id="一定不要用字符串存储日期"><a href="#一定不要用字符串存储日期" class="headerlink" title="#一定不要用字符串存储日期"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E4%B8%80%E5%AE%9A%E4%B8%8D%E8%A6%81%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8%E6%97%A5%E6%9C%9F">#</a>一定不要用字符串存储日期</h3><p>对于日期类型来说， 一定不要用字符串存储日期。可以考虑 DATETIME、TIMESTAMP 和 数值型时间戳。</p><p>这三种种方式都有各自的优势，根据实际场景选择最合适的才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p><table><thead><tr><th>类型</th><th>存储空间</th><th>日期格式</th><th>日期范围</th><th>是否带时区信息</th></tr></thead><tbody><tr><td>DATETIME</td><td>5~8 字节</td><td>YYYY-MM-DD hh:mm:ss[.fraction]</td><td>1000-01-01 00:00:00[.000000] ～ 9999-12-31 23:59:59[.999999]</td><td>否</td></tr><tr><td>TIMESTAMP</td><td>4~7 字节</td><td>YYYY-MM-DD hh:mm:ss[.fraction]</td><td>1970-01-01 00:00:01[.000000] ～ 2038-01-19 03:14:07[.999999]</td><td>是</td></tr><tr><td>数值型时间戳</td><td>4 字节</td><td>全数字如 1578707612</td><td>1970-01-01 00:00:01 之后的时间</td><td>否</td></tr></tbody></table><p>MySQL 时间类型选择的详细介绍请看这篇：<a href="https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html">MySQL 时间类型数据存储建议open in new window</a>。</p><h3 id="同财务相关的金额类数据必须使用-decimal-类型"><a href="#同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="#同财务相关的金额类数据必须使用 decimal 类型"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%90%8C%E8%B4%A2%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E9%87%91%E9%A2%9D%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-decimal-%E7%B1%BB%E5%9E%8B">#</a>同财务相关的金额类数据必须使用 decimal 类型</h3><ul><li><strong>非精准浮点</strong>：float,double</li><li><strong>精准浮点</strong>：decimal</li></ul><p>decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据</p><p>不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p><h3 id="单表不要包含过多字段"><a href="#单表不要包含过多字段" class="headerlink" title="#单表不要包含过多字段"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%8D%95%E8%A1%A8%E4%B8%8D%E8%A6%81%E5%8C%85%E5%90%AB%E8%BF%87%E5%A4%9A%E5%AD%97%E6%AE%B5">#</a>单表不要包含过多字段</h3><p>如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。</p><h2 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="#索引设计规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">#</a>索引设计规范</h2><h3 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="#限制每张表上的索引数量,建议单张表索引不超过 5 个"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%99%90%E5%88%B6%E6%AF%8F%E5%BC%A0%E8%A1%A8%E4%B8%8A%E7%9A%84%E7%B4%A2%E5%BC%95%E6%95%B0%E9%87%8F-%E5%BB%BA%E8%AE%AE%E5%8D%95%E5%BC%A0%E8%A1%A8%E7%B4%A2%E5%BC%95%E4%B8%8D%E8%B6%85%E8%BF%87-5-%E4%B8%AA">#</a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h3><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h3 id="禁止使用全文索引"><a href="#禁止使用全文索引" class="headerlink" title="#禁止使用全文索引"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95">#</a>禁止使用全文索引</h3><p>全文索引不适用于 OLTP 场景。</p><h3 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="#禁止给表中的每一列都建立单独的索引"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E7%BB%99%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%88%97%E9%83%BD%E5%BB%BA%E7%AB%8B%E5%8D%95%E7%8B%AC%E7%9A%84%E7%B4%A2%E5%BC%95">#</a>禁止给表中的每一列都建立单独的索引</h3><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h3 id="每个-InnoDB-表必须有个主键"><a href="#每个-InnoDB-表必须有个主键" class="headerlink" title="#每个 InnoDB 表必须有个主键"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%AF%8F%E4%B8%AA-innodb-%E8%A1%A8%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%AA%E4%B8%BB%E9%94%AE">#</a>每个 InnoDB 表必须有个主键</h3><p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>InnoDB 是按照主键索引的顺序来组织表的</p><ul><li>不要使用更新频繁的列作为主键，不使用多列主键（相当于联合索引）</li><li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li><li>主键建议使用自增 ID 值</li></ul><h3 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="#常见索引列建议"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%88%97%E5%BB%BA%E8%AE%AE">#</a>常见索引列建议</h3><ul><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>多表 join 的关联列</li></ul><h3 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="#如何选择索引列的顺序"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F">#</a>如何选择索引列的顺序</h3><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li>区分度最高的放在联合索引的最左侧（区分度&#x3D;列中不同值的数量&#x2F;列的总行数）</li><li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li><li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><h3 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E5%BB%BA%E7%AB%8B%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95%E5%92%8C%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95-%E5%A2%9E%E5%8A%A0%E4%BA%86%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E6%97%B6%E9%97%B4">#</a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h3><ul><li>重复索引示例：primary key(id)、index(id)、unique index(id)</li><li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li></ul><h3 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="#对于频繁的查询优先考虑使用覆盖索引"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%AF%B9%E4%BA%8E%E9%A2%91%E7%B9%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">#</a>对于频繁的查询优先考虑使用覆盖索引</h3><blockquote><p>  覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p></blockquote><p><strong>覆盖索引的好处：</strong></p><ul><li><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li><li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><hr><h3 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="#索引 SET 规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%B4%A2%E5%BC%95-set-%E8%A7%84%E8%8C%83">#</a>索引 SET 规范</h3><p><strong>尽量避免使用外键约束</strong></p><ul><li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li><li>外键可用于保证数据的参照完整性，但建议在业务端实现</li><li>外键会影响父表和子表的写操作从而降低性能</li></ul><h2 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="#数据库 SQL 开发规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%95%B0%E6%8D%AE%E5%BA%93-sql-%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83">#</a>数据库 SQL 开发规范</h2><h3 id="尽量不在数据库做运算，复杂运算需移到业务应用里完成"><a href="#尽量不在数据库做运算，复杂运算需移到业务应用里完成" class="headerlink" title="#尽量不在数据库做运算，复杂运算需移到业务应用里完成"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%B0%BD%E9%87%8F%E4%B8%8D%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%81%9A%E8%BF%90%E7%AE%97-%E5%A4%8D%E6%9D%82%E8%BF%90%E7%AE%97%E9%9C%80%E7%A7%BB%E5%88%B0%E4%B8%9A%E5%8A%A1%E5%BA%94%E7%94%A8%E9%87%8C%E5%AE%8C%E6%88%90">#</a>尽量不在数据库做运算，复杂运算需移到业务应用里完成</h3><p>尽量不在数据库做运算，复杂运算需移到业务应用里完成。这样可以避免数据库的负担过重，影响数据库的性能和稳定性。数据库的主要作用是存储和管理数据，而不是处理数据。</p><h3 id="优化对性能影响较大的-SQL-语句"><a href="#优化对性能影响较大的-SQL-语句" class="headerlink" title="#优化对性能影响较大的 SQL 语句"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E4%BC%98%E5%8C%96%E5%AF%B9%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E8%BE%83%E5%A4%A7%E7%9A%84-sql-%E8%AF%AD%E5%8F%A5">#</a>优化对性能影响较大的 SQL 语句</h3><p>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句。</p><h3 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="#充分利用表上已经存在的索引"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E8%A1%A8%E4%B8%8A%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E7%B4%A2%E5%BC%95">#</a>充分利用表上已经存在的索引</h3><p>避免使用双%号的查询条件。如：<code>a like &#39;%123%&#39;</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p><p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p><p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p><h3 id="禁止使用-SELECT-必须使用-SELECT-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-查询" class="headerlink" title="#禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8-select-%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-select-%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8-%E6%9F%A5%E8%AF%A2">#</a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h3><ul><li><code>SELECT *</code> 会消耗更多的 CPU。</li><li><code>SELECT *</code> 无用字段增加网络带宽资源消耗，增加数据传输时间，尤其是大字段（如 varchar、blob、text）。</li><li><code>SELECT *</code> 无法使用 MySQL 优化器覆盖索引的优化（基于 MySQL 优化器的“覆盖索引”策略又是速度极快，效率极高，业界极为推荐的查询优化方式）</li><li><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响、</li></ul><h3 id="禁止使用不含字段列表的-INSERT-语句"><a href="#禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="#禁止使用不含字段列表的 INSERT 语句"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%AB%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8%E7%9A%84-insert-%E8%AF%AD%E5%8F%A5">#</a>禁止使用不含字段列表的 INSERT 语句</h3><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure><p>应使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t(c1,c2,c3) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="#建议使用预编译语句进行数据库操作"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C">#</a>建议使用预编译语句进行数据库操作</h3><ul><li>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li><li>只传参数，比传递 SQL 语句更高效。</li><li>相同语句可以一次解析，多次使用，提高处理效率。</li></ul><h3 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="#避免数据类型的隐式转换"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2">#</a>避免数据类型的隐式转换</h3><p>隐式转换会导致索引失效如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name,phone <span class="hljs-keyword">from</span> customer <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;111&#x27;</span>;<br></code></pre></td></tr></table></figure><p>详细解读可以看：<a href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html">MySQL 中的隐式转换造成的索引失效</a> 这篇文章。</p><h3 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="#避免使用子查询，可以把子查询优化为 join 操作"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2-%E5%8F%AF%E4%BB%A5%E6%8A%8A%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%BA-join-%E6%93%8D%E4%BD%9C">#</a>避免使用子查询，可以把子查询优化为 join 操作</h3><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p><strong>子查询性能差的原因：</strong> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><h3 id="避免使用-JOIN-关联太多的表"><a href="#避免使用-JOIN-关联太多的表" class="headerlink" title="#避免使用 JOIN 关联太多的表"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-join-%E5%85%B3%E8%81%94%E5%A4%AA%E5%A4%9A%E7%9A%84%E8%A1%A8">#</a>避免使用 JOIN 关联太多的表</h3><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p><p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p><p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p><p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p><h3 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="#减少同数据库的交互次数"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%87%8F%E5%B0%91%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0">#</a>减少同数据库的交互次数</h3><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p><h3 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="#对应同一列进行 or 判断时，使用 in 代替 or"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%AF%B9%E5%BA%94%E5%90%8C%E4%B8%80%E5%88%97%E8%BF%9B%E8%A1%8C-or-%E5%88%A4%E6%96%AD%E6%97%B6-%E4%BD%BF%E7%94%A8-in-%E4%BB%A3%E6%9B%BF-or">#</a>对应同一列进行 or 判断时，使用 in 代替 or</h3><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p><h3 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="#禁止使用 order by rand() 进行随机排序"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8-order-by-rand-%E8%BF%9B%E8%A1%8C%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F">#</a>禁止使用 order by rand() 进行随机排序</h3><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p><p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h3 id="WHERE-从句中禁止对列进行函数转换和计算"><a href="#WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="#WHERE 从句中禁止对列进行函数转换和计算"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#where-%E4%BB%8E%E5%8F%A5%E4%B8%AD%E7%A6%81%E6%AD%A2%E5%AF%B9%E5%88%97%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%AE%A1%E7%AE%97">#</a>WHERE 从句中禁止对列进行函数转换和计算</h3><p>对列进行函数转换或计算时会导致无法使用索引</p><p><strong>不推荐：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> <span class="hljs-type">date</span>(create_time)<span class="hljs-operator">=</span><span class="hljs-string">&#x27;20190101&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>推荐：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> create_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;20190101&#x27;</span> <span class="hljs-keyword">and</span> create_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;20190102&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="#在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%9C%A8%E6%98%8E%E6%98%BE%E4%B8%8D%E4%BC%9A%E6%9C%89%E9%87%8D%E5%A4%8D%E5%80%BC%E6%97%B6%E4%BD%BF%E7%94%A8-union-all-%E8%80%8C%E4%B8%8D%E6%98%AF-union">#</a>在明显不会有重复值时使用 UNION ALL 而不是 UNION</h3><ul><li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>UNION ALL 不会再对结果集进行去重操作</li></ul><h3 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="#拆分复杂的大 SQL 为多个小 SQL"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%8B%86%E5%88%86%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A4%A7-sql-%E4%B8%BA%E5%A4%9A%E4%B8%AA%E5%B0%8F-sql">#</a>拆分复杂的大 SQL 为多个小 SQL</h3><ul><li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li><li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li><li>SQL 拆分后可以通过并行执行来提高处理效率</li></ul><h3 id="程序连接不同的数据库使用不同的账号，禁止跨库查询"><a href="#程序连接不同的数据库使用不同的账号，禁止跨库查询" class="headerlink" title="#程序连接不同的数据库使用不同的账号，禁止跨库查询"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B4%A6%E5%8F%B7-%E7%A6%81%E6%AD%A2%E8%B7%A8%E5%BA%93%E6%9F%A5%E8%AF%A2">#</a>程序连接不同的数据库使用不同的账号，禁止跨库查询</h3><ul><li>为数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免权限过大而产生的安全风险</li></ul><h2 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="#数据库操作行为规范"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E8%A1%8C%E4%B8%BA%E8%A7%84%E8%8C%83">#</a>数据库操作行为规范</h2><h3 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="#超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E8%B6%85-100-%E4%B8%87%E8%A1%8C%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99-update-delete-insert-%E6%93%8D%E4%BD%9C-%E8%A6%81%E5%88%86%E6%89%B9%E5%A4%9A%E6%AC%A1%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">#</a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h3><p><strong>大批量操作可能会造成严重的主从延迟</strong></p><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p><p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p><p><strong>避免产生大事务操作</strong></p><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p><h3 id="对于大表使用-pt-online-schema-change-修改表结构"><a href="#对于大表使用-pt-online-schema-change-修改表结构" class="headerlink" title="#对于大表使用 pt-online-schema-change 修改表结构"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%AF%B9%E4%BA%8E%E5%A4%A7%E8%A1%A8%E4%BD%BF%E7%94%A8-pt-online-schema-change-%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84">#</a>对于大表使用 pt-online-schema-change 修改表结构</h3><ul><li>避免大表修改产生的主从延迟</li><li>避免在对表字段进行修改时进行锁表</li></ul><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p><p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p><h3 id="禁止为程序使用的账号赋予-super-权限"><a href="#禁止为程序使用的账号赋予-super-权限" class="headerlink" title="#禁止为程序使用的账号赋予 super 权限"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E7%A6%81%E6%AD%A2%E4%B8%BA%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B4%A6%E5%8F%B7%E8%B5%8B%E4%BA%88-super-%E6%9D%83%E9%99%90">#</a>禁止为程序使用的账号赋予 super 权限</h3><ul><li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li><li>super 权限只能留给 DBA 处理问题的账号使用</li></ul><h3 id="对于程序连接数据库账号-遵循权限最小原则"><a href="#对于程序连接数据库账号-遵循权限最小原则" class="headerlink" title="#对于程序连接数据库账号,遵循权限最小原则"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E5%AF%B9%E4%BA%8E%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B4%A6%E5%8F%B7-%E9%81%B5%E5%BE%AA%E6%9D%83%E9%99%90%E6%9C%80%E5%B0%8F%E5%8E%9F%E5%88%99">#</a>对于程序连接数据库账号,遵循权限最小原则</h3><ul><li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li><li>程序使用的账号原则上不准有 drop 权限</li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="#推荐阅读"></a><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">#</a>推荐阅读</h2>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL字段类型</title>
    <link href="/2021/04/06/DB/MySQL/2.%20MySQL%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/06/DB/MySQL/2.%20MySQL%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-字段类型"><a href="#MySQL-字段类型" class="headerlink" title="MySQL 字段类型"></a>MySQL 字段类型</h2>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础架构</title>
    <link href="/2021/04/06/DB/MySQL/3.%20MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    <url>/2021/04/06/DB/MySQL/3.%20MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL存储引擎</title>
    <link href="/2021/04/06/DB/MySQL/4.%20MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2021/04/06/DB/MySQL/4.%20MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2021/04/06/DB/MySQL/5.%20MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/04/06/DB/MySQL/5.%20MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL查询缓存</title>
    <link href="/2021/04/06/DB/MySQL/6.%20MySQL%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/"/>
    <url>/2021/04/06/DB/MySQL/6.%20MySQL%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL日志</title>
    <link href="/2021/04/06/DB/MySQL/7.%20MYSQL%E6%97%A5%E5%BF%97/"/>
    <url>/2021/04/06/DB/MySQL/7.%20MYSQL%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL事务</title>
    <link href="/2021/04/06/DB/MySQL/8.%20MYSQL%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/04/06/DB/MySQL/8.%20MYSQL%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL锁</title>
    <link href="/2021/04/06/DB/MySQL/9.%20MYSQL%E9%94%81/"/>
    <url>/2021/04/06/DB/MySQL/9.%20MYSQL%E9%94%81/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2021/04/06/DB/MySQL/MySQL%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/06/DB/MySQL/MySQL%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h2><h3 id="什么是关系型数据库？"><a href="#什么是关系型数据库？" class="headerlink" title="什么是关系型数据库？"></a>什么是关系型数据库？</h3><p>关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><p><img src="https://oss.javaguide.cn/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="关系型数据库表关系"></p><center>关系型数据库表关系</center><p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</p><p><strong>有哪些常见的关系型数据库呢？</strong></p><p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ……。</p><h3 id="什么是-SQL？"><a href="#什么是-SQL？" class="headerlink" title="#什么是 SQL？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF-sql">#</a>什么是 SQL？</h3><p>SQL 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。</p><p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p><p>SQL 可以帮助我们：</p><ul><li>新建数据库、数据表、字段；</li><li>在数据库中增加，删除，修改，查询数据；</li><li>新建视图、函数、存储过程；</li><li>对数据库中的数据进行简单的数据分析；</li><li>搭配 Hive，Spark SQL 做大数据；</li><li>搭配 SQLFlow 做机器学习；</li><li>……</li></ul><h3 id="什么是-MySQL？"><a href="#什么是-MySQL？" class="headerlink" title="什么是 MySQL？"></a>什么是 MySQL？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/csdn/20210327143351823.png" alt="img"></p><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p><p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong>3306</strong>。</p><h3 id="MySQL-有什么优点？"><a href="#MySQL-有什么优点？" class="headerlink" title="#MySQL 有什么优点？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9">#</a>MySQL 有什么优点？</h3><p>这个问题本质上是在问 MySQL 如此流行的原因。</p><p>MySQL 主要具有下面这些优点：</p><ol><li>成熟稳定，功能完善。</li><li>开源免费。</li><li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li>开箱即用，操作简单，维护成本低。</li><li>兼容性好，支持常见的操作系统，支持多种开发语言。</li><li>社区活跃，生态完善。</li><li>事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li>支持分库分表、读写分离、高可用。</li></ol><h2 id="MySQL-字段类型"><a href="#MySQL-字段类型" class="headerlink" title="#MySQL 字段类型"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B">#</a>MySQL 字段类型</h2><p>MySQL 字段类型可以简单分为三大类：</p><ul><li><strong>数值类型</strong>：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）</li><li><strong>字符串类型</strong>：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。</li><li><strong>日期时间类型</strong>：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。</li></ul><p>下面这张图不是我画的，忘记是从哪里保存下来的了，总结的还蛮不错的。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/summary-of-mysql-field-types.png" alt="MySQL 常见字段类型总结">MySQL 常见字段类型总结</p><p>MySQL 字段类型比较多，我这里会挑选一些日常开发使用很频繁且面试常问的字段类型，以面试问题的形式来详细介绍。如无特殊说明，针对的都是 InnoDB 存储引擎。</p><p>另外，推荐阅读一下《高性能 MySQL(第三版)》的第四章，有详细介绍 MySQL 字段类型优化。</p><h3 id="整数类型的-UNSIGNED-属性有什么用？"><a href="#整数类型的-UNSIGNED-属性有什么用？" class="headerlink" title="#整数类型的 UNSIGNED 属性有什么用？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84-unsigned-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">#</a>整数类型的 UNSIGNED 属性有什么用？</h3><p>MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来表示不允许负值的无符号整数。使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p><p>例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 2,147,483,648 ~ 2,147,483,647。</p><p>对于从 0 开始递增的 ID 列，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p><h3 id="CHAR-和-VARCHAR-的区别是什么？"><a href="#CHAR-和-VARCHAR-的区别是什么？" class="headerlink" title="#CHAR 和 VARCHAR 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>CHAR 和 VARCHAR 的区别是什么？</h3><p>CHAR 和 VARCHAR 是最常用到的字符串类型，两者的主要区别在于：<strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p><p>CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</p><p>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</p><p>CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</p><h3 id="VARCHAR-100-和-VARCHAR-10-的区别是什么？"><a href="#VARCHAR-100-和-VARCHAR-10-的区别是什么？" class="headerlink" title="#VARCHAR(100)和 VARCHAR(10)的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#varchar-100-%E5%92%8C-varchar-10-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>VARCHAR(100)和 VARCHAR(10)的区别是什么？</h3><p>VARCHAR(100)和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，VARCHAR (100) 可以满足更大范围的字符存储需求，有更好的业务拓展性。而 VARCHAR(10)存储超过 10 个字符时，就需要修改表结构才可以。</p><p>虽说 VARCHAR(100)和 VARCHAR(10)能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p><p>不过，VARCHAR(100) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR(100)是按照 100 这个长度来进行的，也就会消耗更多内存。</p><h3 id="DECIMAL-和-FLOAT-DOUBLE-的区别是什么？"><a href="#DECIMAL-和-FLOAT-DOUBLE-的区别是什么？" class="headerlink" title="#DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#decimal-%E5%92%8C-float-double-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</h3><p>DECIMAL 和 FLOAT 的区别是：<strong>DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT&#x2F;DOUBLE 只能存储近似的小数值。</strong></p><p>DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。</p><p>在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类 <code>java.math.BigDecimal</code>。</p><h3 id="为什么不推荐使用-TEXT-和-BLOB？"><a href="#为什么不推荐使用-TEXT-和-BLOB？" class="headerlink" title="#为什么不推荐使用 TEXT 和 BLOB？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-text-%E5%92%8C-blob">#</a>为什么不推荐使用 TEXT 和 BLOB？</h3><p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据，例如博客内容。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>0-255 字节</td><td>一般文本字符串</td></tr><tr><td>TEXT</td><td>0-65,535 字节</td><td>长文本字符串</td></tr><tr><td>MEDIUMTEXT</td><td>0-16,772,150 字节</td><td>较大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4,294,967,295 字节</td><td>极大文本数据</td></tr></tbody></table><p>BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。</p><table><thead><tr><th>类型</th><th>可存储大小</th><th>用途</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>0-255 字节</td><td>短文本二进制字符串</td></tr><tr><td>BLOB</td><td>0-65KB</td><td>二进制字符串</td></tr><tr><td>MEDIUMBLOB</td><td>0-16MB</td><td>二进制形式的长文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4GB</td><td>二进制形式的极大文本数据</td></tr></tbody></table><p>在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT。</p><p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p><ul><li>不能有默认值。</li><li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。</li><li>检索效率较低。</li><li>不能直接创建索引，需要指定前缀长度。</li><li>可能会消耗大量的网络和 IO 带宽。</li><li>可能导致表上的 DML 操作变慢。</li><li>……</li></ul><h3 id="DATETIME-和-TIMESTAMP-的区别是什么？"><a href="#DATETIME-和-TIMESTAMP-的区别是什么？" class="headerlink" title="#DATETIME 和 TIMESTAMP 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#datetime-%E5%92%8C-timestamp-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>DATETIME 和 TIMESTAMP 的区别是什么？</h3><p>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。</p><p>TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p><ul><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><p>关于两者的详细对比，请参考我写的<a href="https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html">MySQL 时间类型数据存储建议</a>。</p><h3 id="NULL-和-‘’-的区别是什么？"><a href="#NULL-和-‘’-的区别是什么？" class="headerlink" title="#NULL 和 ‘’ 的区别是什么？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#null-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>NULL 和 ‘’ 的区别是什么？</h3><p><code>NULL</code> 跟 <code>&#39;&#39;</code>(空字符串)是两个完全不一样的值，区别如下：</p><ul><li><code>NULL</code> 代表一个不确定的值,就算是两个 <code>NULL</code>,它俩也不一定相等。例如，<code>SELECT NULL=NULL</code>的结果为 false，但是在我们使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时,<code>NULL</code>又被认为是相等的。</li><li><code>&#39;&#39;</code>的长度是 0，是不占用空间的，而<code>NULL</code> 是需要占用空间的。</li><li><code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li><li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li></ul><p>看了上面的介绍之后，相信你对另外一个高频面试题：“为什么 MySQL 不建议使用 <code>NULL</code> 作为列默认值？”也有了答案。</p><h3 id="Boolean-类型如何表示？"><a href="#Boolean-类型如何表示？" class="headerlink" title="#Boolean 类型如何表示？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#boolean-%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA">#</a>Boolean 类型如何表示？</h3><p>MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。</p><h2 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="#MySQL 基础架构"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84">#</a>MySQL 基础架构</h2><blockquote><p>  建议配合 <a href="https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。另外，“一个 SQL 语句在 MySQL 中的执行流程”也是面试中比较常问的一个问题。</p></blockquote><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p><p><img src="https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png" alt="img"></p><p>从上图可以看出， MySQL 主要由下面几部分构成：</p><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="#MySQL 存储引擎"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">#</a>MySQL 存储引擎</h2><p>MySQL 核心在于存储引擎，想要深入学习 MySQL，必定要深入研究 MySQL 存储引擎。</p><h3 id="MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="#MySQL 支持哪些存储引擎？默认使用哪个？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA">#</a>MySQL 支持哪些存储引擎？默认使用哪个？</h3><p>MySQL 支持多种存储引擎，你可以通过 <code>SHOW ENGINES</code> 命令来查看 MySQL 支持的所有存储引擎。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510105408703.png" alt="查看 MySQL 提供的所有存储引擎">查看 MySQL 提供的所有存储引擎</p><p>从上图我们可以查看出， MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p><p>我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。</p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>你可以通过 <code>SELECT VERSION()</code> 命令查看你的 MySQL 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; SELECT VERSION();<br>+-----------+<br>| VERSION() |<br>+-----------+<br>| 8.0.27    |<br>+-----------+<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><p>你也可以通过 <code>SHOW VARIABLES LIKE &#39;%storage_engine%&#39;</code> 命令直接查看 MySQL 当前默认的存储引擎。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; SHOW VARIABLES  LIKE <span class="hljs-string">&#x27;%storage_engine%&#x27;</span>;<br>+---------------------------------+-----------+<br>| Variable_name                   | Value     |<br>+---------------------------------+-----------+<br>| default_storage_engine          | InnoDB    |<br>| default_tmp_storage_engine      | InnoDB    |<br>| disabled_storage_engines        |           |<br>| internal_tmp_mem_storage_engine | TempTable |<br>+---------------------------------+-----------+<br>4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><p>如果你想要深入了解每个存储引擎以及它们之间的区别，推荐你去阅读以下 MySQL 官方文档对应的介绍(面试不会问这么细，了解即可)：</p><ul><li>InnoDB 存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.htmlopen in new window</a> 。</li><li>其他存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">https://dev.mysql.com/doc/refman/8.0/en/storage-engines.htmlopen in new window</a> 。</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510155143458.png" alt="img"></p><h3 id="MySQL-存储引擎架构了解吗？"><a href="#MySQL-存储引擎架构了解吗？" class="headerlink" title="#MySQL 存储引擎架构了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97">#</a>MySQL 存储引擎架构了解吗？</h3><p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><p>并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。</p><p>MySQL 官方文档也有介绍到如何编写一个自定义存储引擎，地址：<a href="https://dev.mysql.com/doc/internals/en/custom-engine.html">https://dev.mysql.com/doc/internals/en/custom-engine.htmlopen in new window</a> 。</p><h3 id="MyISAM-和-InnoDB-有什么区别？"><a href="#MyISAM-和-InnoDB-有什么区别？" class="headerlink" title="#MyISAM 和 InnoDB 有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#myisam-%E5%92%8C-innodb-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>MyISAM 和 InnoDB 有什么区别？</h3><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p><p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>言归正传！咱们下面还是来简单对比一下两者：</p><p><strong>1.是否支持行级锁</strong></p><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p><p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解</a>。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510090309427.png" alt="img"></p><p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p><p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p><p><strong>6.索引实现不一样。</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><p>详细区别，推荐你看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解</a>。</p><p><strong>7.性能有差别。</strong></p><p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/innodb-myisam-performance-comparison.png" alt="InnoDB 和 MyISAM 性能对比">InnoDB 和 MyISAM 性能对比</p><p><strong>总结</strong>：</p><ul><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大。</li></ul><p>最后，再分享一张图片给你，这张图片详细对比了常见的几种 MySQL 存储引擎。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/comparison-of-common-mysql-storage-engines.png" alt="常见的几种 MySQL 存储引擎对比">常见的几种 MySQL 存储引擎对比</p><h3 id="MyISAM-和-InnoDB-如何选择？"><a href="#MyISAM-和-InnoDB-如何选择？" class="headerlink" title="#MyISAM 和 InnoDB 如何选择？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#myisam-%E5%92%8C-innodb-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">#</a>MyISAM 和 InnoDB 如何选择？</h3><p>大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。</p><p>《MySQL 高性能》上面有一句话这样写到:</p><blockquote><p>  不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p></blockquote><p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p><p>因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。</p><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="#MySQL 索引"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%B4%A2%E5%BC%95">#</a>MySQL 索引</h2><p>MySQL 索引相关的问题比较多，对于面试和工作都比较重要，于是，我单独抽了一篇文章专门来总结 MySQL 索引相关的知识点和问题：<a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解</a> 。</p><h2 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="#MySQL 查询缓存"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98">#</a>MySQL 查询缓存</h2><p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p><p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">query_cache_type</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">query_cache_size</span>=<span class="hljs-string">600000</span><br></code></pre></td></tr></table></figure><p>MySQL 执行以下命令也可以开启查询缓存</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">set</span> <span class="hljs-string">global  query_cache_type=1;</span><br><span class="hljs-attr">set</span> <span class="hljs-string">global  query_cache_size=600000;</span><br></code></pre></td></tr></table></figure><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p><p><strong>查询缓存不命中的情况：</strong></p><ol><li>任何两个查询在任何字符上的不同都会导致缓存不命中。</li><li>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li><li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li></ol><p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 <code>sql_cache</code> 和 <code>sql_no_cache</code> 来控制某个查询语句是否需要缓存：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sql_no_cache <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> usr;<br></code></pre></td></tr></table></figure><h2 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="#MySQL 日志"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%97%A5%E5%BF%97">#</a>MySQL 日志</h2><p>MySQL 日志常见的面试题有：</p><ul><li>MySQL 中常见的日志有哪些？</li><li>慢查询日志有什么用？</li><li>binlog 主要记录了什么？</li><li>redo log 如何保证事务的持久性？</li><li>页修改之后为什么不直接刷盘呢？</li><li>binlog 和 redolog 有什么区别？</li><li>undo log 如何保证事务的原子性？</li><li>……</li></ul><p>上诉问题的答案可以在<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》(付费)</a> 的 <strong>「技术面试题篇」</strong> 中找到。</p><p><img src="https://oss.javaguide.cn/javamianshizhibei/technical-interview-questions.png" alt="《Java 面试指北》技术面试题篇">《Java 面试指北》技术面试题篇</p><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="#MySQL 事务"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E4%BA%8B%E5%8A%A1">#</a>MySQL 事务</h2><h3 id="何谓事务？"><a href="#何谓事务？" class="headerlink" title="#何谓事务？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%BD%95%E8%B0%93%E4%BA%8B%E5%8A%A1">#</a>何谓事务？</h3><p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p><ul><li>数据库中途突然因为某些原因挂掉了。</li><li>客户端突然因为网络原因连接不上数据库了。</li><li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li><li>……</li></ul><p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p><ol><li>将小明的余额减少 1000 元</li><li>将小红的余额增加 1000 元。</li></ol><p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="事务示意图">事务示意图</p><h3 id="何谓数据库事务？"><a href="#何谓数据库事务？" class="headerlink" title="#何谓数据库事务？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%BD%95%E8%B0%93%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1">#</a>何谓数据库事务？</h3><p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p><p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p><p><strong>那数据库事务有什么作用呢？</strong></p><p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 开启一个事务<br><span class="hljs-keyword">START</span> TRANSACTION;<br># 多条 <span class="hljs-keyword">SQL</span> 语句<br>SQL1,SQL2...<br>## 提交事务<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="数据库事务示意图">数据库事务示意图</p><p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/ACID.png" alt="ACID">ACID</p><ol><li><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong> 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课<a href="https://time.geekbang.org/opencourse/intro/100064201">《周志明的软件架构课》open in new window</a>才搞清楚的（多看好书！！！）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/AID-%3EC.png" alt="AID-&gt;C">AID-&gt;C</p><p>另外，DDIA 也就是 <a href="https://book.douban.com/subject/30329536/">《Designing Data-Intensive Application（数据密集型应用系统设计）》open in new window</a> 的作者在他的这本书中如是说：</p><blockquote><p>  Atomicity, isolation, and durability are properties of the database, whereas consis‐ tency (in the ACID sense) is a property of the application. The application may rely on the database’s atomicity and isolation properties in order to achieve consistency, but it’s not up to the database alone.</p><p>  翻译过来的意思是：原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。</p></blockquote><p>《Designing Data-Intensive Application（数据密集型应用系统设计）》这本书强推一波，值得读很多遍！豆瓣有接近 90% 的人看了这本书之后给了五星好评。另外，中文翻译版本已经在 GitHub 开源，地址：<a href="https://github.com/Vonng/ddia">https://github.com/Vonng/ddiaopen in new window</a> 。</p><p><img src="https://oss.javaguide.cn/github/javaguide/books/ddia.png" alt="img"></p><h3 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="#并发事务带来了哪些问题?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">#</a>并发事务带来了哪些问题?</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><h4 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="#脏读（Dirty read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%84%8F%E8%AF%BB-dirty-read">#</a>脏读（Dirty read）</h4><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 读取到 A &#x3D; 19,事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading-ee15b0b9.png" alt="脏读">脏读</p><h4 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="#丢失修改（Lost to modify）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9-lost-to-modify">#</a>丢失修改（Lost to modify）</h4><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 先修改 A&#x3D;A-1，事务 2 后来也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-missing-modifications-5b2e2bd8.png" alt="丢失修改">丢失修改</p><h4 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="#不可重复读（Unrepeatable read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-unrepeatable-read">#</a>不可重复读（Unrepeatable read）</h4><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 再次读取 A &#x3D;19，此时读取的结果和第一次读取的结果不同。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-unrepeatable-read-ff9186e1.png" alt="不可重复读">不可重复读</p><h4 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="#幻读（Phantom read）"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%BB%E8%AF%BB-phantom-read">#</a>幻读（Phantom read）</h4><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><p><img src="https://javaguide.cn/assets/concurrency-consistency-issues-phantom-read-7cba7a85.png" alt="幻读">幻读</p><h3 id="不可重复读和幻读有什么区别？"><a href="#不可重复读和幻读有什么区别？" class="headerlink" title="#不可重复读和幻读有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>不可重复读和幻读有什么区别？</h3><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h3 id="并发事务的控制方式有哪些？"><a href="#并发事务的控制方式有哪些？" class="headerlink" title="#并发事务的控制方式有哪些？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>并发事务的控制方式有哪些？</h3><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p><p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p><p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul><p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html">InnoDB 存储引擎对 MVCC 的实现</a> 。</p><h3 id="SQL-标准定义了哪些事务隔离级别"><a href="#SQL-标准定义了哪些事务隔离级别" class="headerlink" title="#SQL 标准定义了哪些事务隔离级别?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#sql-%E6%A0%87%E5%87%86%E5%AE%9A%E4%B9%89%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">#</a>SQL 标准定义了哪些事务隔离级别?</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h3 id="MySQL-的隔离级别是基于锁实现的吗？"><a href="#MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="#MySQL 的隔离级别是基于锁实现的吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97">#</a>MySQL 的隔离级别是基于锁实现的吗？</h3><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h3 id="MySQL-的默认隔离级别是什么"><a href="#MySQL-的默认隔离级别是什么" class="headerlink" title="#MySQL 的默认隔离级别是什么?"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>MySQL 的默认隔离级别是什么?</h3><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@tx_isolation</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@tx_isolation</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br></code></pre></td></tr></table></figure><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解</a>。</p><h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="#MySQL 锁"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E9%94%81">#</a>MySQL 锁</h2><p>锁是一种常见的并发事务的控制方式。</p><h3 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="#表级锁和行级锁了解吗？有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>表级锁和行级锁了解吗？有什么区别？</h3><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p><p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p><p><strong>表级锁和行级锁对比</strong>：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li></ul><h3 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="#行级锁的使用有什么注意事项？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">#</a>行级锁的使用有什么注意事项？</h3><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p><p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p><h3 id="InnoDB-有哪几类行锁？"><a href="#InnoDB-有哪几类行锁？" class="headerlink" title="#InnoDB 有哪几类行锁？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#innodb-%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BB%E8%A1%8C%E9%94%81">#</a>InnoDB 有哪几类行锁？</h3><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p><p>一些大厂面试中可能会问到 Next-Key Lock 的加锁范围，这里推荐一篇文章：<a href="https://segmentfault.com/a/1190000040129107">MySQL next-key lock 加锁范围是什么？ - 程序员小航 - 2021open in new window</a> 。</p><h3 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="#共享锁和排他锁呢？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81%E5%91%A2">#</a>共享锁和排他锁呢？</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th align="left"></th><th align="left">S 锁</th><th align="left">X 锁</th></tr></thead><tbody><tr><td align="left">S 锁</td><td align="left">不冲突</td><td align="left">冲突</td></tr><tr><td align="left">X 锁</td><td align="left">冲突</td><td align="left">冲突</td></tr></tbody></table><p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 共享锁 可以在 MySQL <span class="hljs-number">5.7</span> 和 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 共享锁 可以在 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> SHARE;<br># 排他锁<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><h3 id="意向锁有什么作用？"><a href="#意向锁有什么作用？" class="headerlink" title="#意向锁有什么作用？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E6%84%8F%E5%90%91%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">#</a>意向锁有什么作用？</h3><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p><p>意向锁是表级锁，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><p>《MySQL 技术内幕 InnoDB 存储引擎》这本书对应的描述应该是笔误了。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220511171419081.png" alt="img"></p><h3 id="当前读和快照读有什么区别？"><a href="#当前读和快照读有什么区别？" class="headerlink" title="#当前读和快照读有什么区别？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>当前读和快照读有什么区别？</h3><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span><br># 共享锁 可以在 MySQL <span class="hljs-number">5.7</span> 和 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 共享锁 可以在 MySQL <span class="hljs-number">8.0</span> 中使用<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> SHARE;<br></code></pre></td></tr></table></figure><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p><p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p><p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><p>当前读的一些常见 SQL 语句类型如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 对读的记录加一个X锁<br>SELECT...FOR <span class="hljs-keyword">UPDATE</span><br># 对读的记录加一个S锁<br>SELECT...LOCK <span class="hljs-keyword">IN</span> SHARE MODE<br># 对读的记录加一个S锁<br>SELECT...FOR SHARE<br># 对修改的记录加一个X锁<br>INSERT...<br>UPDATE...<br>DELETE...<br></code></pre></td></tr></table></figure><h3 id="自增锁有了解吗？"><a href="#自增锁有了解吗？" class="headerlink" title="#自增锁有了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%87%AA%E5%A2%9E%E9%94%81%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97">#</a>自增锁有了解吗？</h3><blockquote><p>  不太重要的一个知识点，简单了解即可。</p></blockquote><p>关系型数据库设计表的时候，通常会有一列作为自增主键。InnoDB 中的自增主键会涉及一种比较特殊的表级锁— <strong>自增锁（AUTO-INC Locks）</strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `sequence_id` (<br>  `id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `stub` <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `stub` (`stub`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br></code></pre></td></tr></table></figure><p>更准确点来说，不仅仅是自增主键，<code>AUTO_INCREMENT</code>的列都会涉及到自增锁，毕竟非主键也可以设置自增长。</p><p>如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住。这里的阻塞行为只是自增锁行为的其中一种，可以理解为自增锁就是一个接口，其具体的实现有多种。具体的配置项为 <code>innodb_autoinc_lock_mode</code> （MySQL 5.1.22 引入），可以选择的值如下：</p><table><thead><tr><th align="left">innodb_autoinc_lock_mode</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">传统模式</td></tr><tr><td align="left">1</td><td align="left">连续模式（MySQL 8.0 之前默认）</td></tr><tr><td align="left">2</td><td align="left">交错模式(MySQL 8.0 之后默认)</td></tr></tbody></table><p>交错模式下，所有的“INSERT-LIKE”语句（所有的插入语句，包括：<code>INSERT</code>、<code>REPLACE</code>、<code>INSERT…SELECT</code>、<code>REPLACE…SELECT</code>、<code>LOAD DATA</code>等）都不使用表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行，速度更快，扩展性也更好。</p><p>不过，如果你的 MySQL 数据库有主从同步需求并且 Binlog 存储格式为 Statement 的话，不要将 InnoDB 自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序就无法得到保障。</p><blockquote><p>  如果 MySQL 采用的格式为 Statement ，那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。</p></blockquote><p>最后，再推荐一篇文章：<a href="https://draveness.me/whys-the-design-mysql-auto-increment/">为什么 MySQL 的自增主键不单调也不连续open in new window</a> 。</p><h2 id="MySQL-性能优化"><a href="#MySQL-性能优化" class="headerlink" title="#MySQL 性能优化"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">#</a>MySQL 性能优化</h2><p>关于 MySQL 性能优化的建议总结，请看这篇文章：<a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html">MySQL 高性能优化规范建议总结</a> 。</p><h3 id="能用-MySQL-直接存储文件（比如图片）吗？"><a href="#能用-MySQL-直接存储文件（比如图片）吗？" class="headerlink" title="#能用 MySQL 直接存储文件（比如图片）吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%83%BD%E7%94%A8-mysql-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6-%E6%AF%94%E5%A6%82%E5%9B%BE%E7%89%87-%E5%90%97">#</a>能用 MySQL 直接存储文件（比如图片）吗？</h3><p>可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。</p><p>可以选择使用云服务厂商提供的开箱即用的文件存储服务，成熟稳定，价格也比较低。</p><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/oss-search.png" alt="img"></p><p>也可以选择自建文件存储服务，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。</p><p><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p><p>相关阅读：<a href="https://www.51cto.com/article/716978.html">Spring Boot 整合 MinIO 实现分布式文件服务open in new window</a> 。</p><h3 id="MySQL-如何存储-IP-地址？"><a href="#MySQL-如何存储-IP-地址？" class="headerlink" title="#MySQL 如何存储 IP 地址？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8-ip-%E5%9C%B0%E5%9D%80">#</a>MySQL 如何存储 IP 地址？</h3><p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li><li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><h3 id="有哪些常见的-SQL-优化手段？"><a href="#有哪些常见的-SQL-优化手段？" class="headerlink" title="#有哪些常见的 SQL 优化手段？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84-sql-%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5">#</a>有哪些常见的 SQL 优化手段？</h3><p><a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》(付费)</a> 的 <strong>「技术面试题篇」</strong> 有一篇文章详细介绍了常见的 SQL 优化手段，非常全面，清晰易懂！</p><p><img src="https://oss.javaguide.cn/javamianshizhibei/javamianshizhibei-sql-optimization.png" alt="常见的 SQL 优化手段">常见的 SQL 优化手段</p><h3 id="如何分析-SQL-的性能？"><a href="#如何分析-SQL-的性能？" class="headerlink" title="#如何分析 SQL 的性能？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-sql-%E7%9A%84%E6%80%A7%E8%83%BD">#</a>如何分析 SQL 的性能？</h3><p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 适用于 <code>SELECT</code>, <code>DELETE</code>, <code>INSERT</code>, <code>REPLACE</code>, 和 <code>UPDATE</code>语句，我们一般分析 <code>SELECT</code> 查询较多。</p><p>我们这里简单来演示一下 <code>EXPLAIN</code> 的使用。</p><p><code>EXPLAIN</code> 的输出格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> `score`,`name` <span class="hljs-keyword">FROM</span> `cus_order` <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `score` <span class="hljs-keyword">DESC</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>     <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>   <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> cus_order <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">997572</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> filesort <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>各个字段的含义如下：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的序列标识符</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询类型</td></tr><tr><td>table</td><td>用到的表名</td></tr><tr><td>partitions</td><td>匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td>type</td><td>表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际用到的索引</td></tr><tr><td>key_len</td><td>所选索引的长度</td></tr><tr><td>ref</td><td>当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><p>篇幅问题，我这里只是简单介绍了一下 MySQL 执行计划，详细介绍请看：<a href="https://javaguide.cn/database/mysql/mysql-query-execution-plan.html">SQL 的执行计划</a>这篇文章。</p><h3 id="读写分离和分库分表了解吗？"><a href="#读写分离和分库分表了解吗？" class="headerlink" title="#读写分离和分库分表了解吗？"></a><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%92%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BA%86%E8%A7%A3%E5%90%97">#</a>读写分离和分库分表了解吗？</h3><p>读写分离和分库分表相关的问题比较多，于是，我单独写了一篇文章来介绍：<a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html">读写分离和分库分表详解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/2021/04/06/DB/Redis/1.%20Redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/06/DB/Redis/1.%20Redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><h3 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="#什么是 Redis？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF-redis">#</a>什么是 Redis？</h3><p><a href="https://redis.io/">Redisopen in new window</a> （<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-overview-of-data-types-2023-09-28.jpg" alt="Redis 数据类型概览">Redis 数据类型概览</p><p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</p><p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的<a href="https://try.redis.io/">在线 Redis 环境open in new window</a>（少部分命令无法使用）来实际体验 Redis。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/try.redis.io.png" alt="try-redis">try-redis</p><p>全世界有非常多的网站使用到了 Redis ，<a href="https://techstacks.io/">techstacks.ioopen in new window</a> 专门维护了一个<a href="https://techstacks.io/tech/redis">使用 Redis 的热门站点列表open in new window</a> ，感兴趣的话可以看看。</p><h3 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="#Redis 为什么这么快？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB">#</a>Redis 为什么这么快？</h3><p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：</p><ol><li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li><li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li><li>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</li></ol><blockquote><p>  下面这张图片总结的挺不错的，分享一下，出自 <a href="https://twitter.com/alexxubyte/status/1498703822528544770">Why is Redis so fast?open in new window</a> 。</p></blockquote><p><img src="https://javaguide.cn/assets/why-redis-so-fast-d3507ae8.png" alt="why-redis-so-fast">why-redis-so-fast</p><h3 id="分布式缓存常见的技术选型方案有哪些？"><a href="#分布式缓存常见的技术选型方案有哪些？" class="headerlink" title="#分布式缓存常见的技术选型方案有哪些？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>分布式缓存常见的技术选型方案有哪些？</h3><p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p><p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p><p>另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 <a href="https://github.com/facebook/rocksdb">RocksDBopen in new window</a> 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 <a href="https://github.com/Tencent/Tendis">Tendisopen in new window</a>。</p><p>关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：<a href="https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ">Redis vs Tendis：冷热混合存储版架构揭秘open in new window</a> ，可以简单参考一下。</p><p>从这个项目的 GitHub 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。</p><h3 id="说一下-Redis-和-Memcached-的区别和共同点"><a href="#说一下-Redis-和-Memcached-的区别和共同点" class="headerlink" title="#说一下 Redis 和 Memcached 的区别和共同点"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E8%AF%B4%E4%B8%80%E4%B8%8B-redis-%E5%92%8C-memcached-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9">#</a>说一下 Redis 和 Memcached 的区别和共同点</h3><p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p><p><strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别</strong>：</p><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 针对网络数据的读写引入了多线程）</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p><h3 id="为什么要用-Redis-为什么要用缓存？"><a href="#为什么要用-Redis-为什么要用缓存？" class="headerlink" title="#为什么要用 Redis&#x2F;为什么要用缓存？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98">#</a>为什么要用 Redis&#x2F;为什么要用缓存？</h3><p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p><p><strong>1、高性能</strong></p><p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p><p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p><p><strong>2、高并发</strong></p><p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p><blockquote><p>  QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p></blockquote><p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p><h3 id="常见的缓存读写策略有哪些？"><a href="#常见的缓存读写策略有哪些？" class="headerlink" title="#常见的缓存读写策略有哪些？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>常见的缓存读写策略有哪些？</h3><p>关于常见的缓存读写策略的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html">3 种常用的缓存读写策略详解open in new window</a> 。</p><h2 id="Redis-应用"><a href="#Redis-应用" class="headerlink" title="#Redis 应用"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%BA%94%E7%94%A8">#</a>Redis 应用</h2><h3 id="Redis-除了做缓存，还能做什么？"><a href="#Redis-除了做缓存，还能做什么？" class="headerlink" title="#Redis 除了做缓存，还能做什么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98-%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88">#</a>Redis 除了做缓存，还能做什么？</h3><ul><li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解open in new window</a> 。</li><li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window</a>。</li><li><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</li><li><strong>分布式 Session</strong> ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</li><li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。</li><li>……</li></ul><h3 id="如何基于-Redis-实现分布式锁？"><a href="#如何基于-Redis-实现分布式锁？" class="headerlink" title="#如何基于 Redis 实现分布式锁？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E-redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">#</a>如何基于 Redis 实现分布式锁？</h3><p>关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解open in new window</a> 。</p><h3 id="Redis-可以做消息队列么？"><a href="#Redis-可以做消息队列么？" class="headerlink" title="#Redis 可以做消息队列么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%88">#</a>Redis 可以做消息队列么？</h3><blockquote><p>  实际项目中也没见谁使用 Redis 来做消息队列，对于这部分知识点大家了解就好了。</p></blockquote><p>先说结论：<strong>可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</strong></p><p><strong>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。</strong></p><p>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>即可实现简易版消息队列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生产者生产消息</span><br>&gt; RPUSH myList msg1 msg2<br>(<span class="hljs-built_in">integer</span>) 2<br>&gt; RPUSH myList msg3<br>(<span class="hljs-built_in">integer</span>) 3<br><span class="hljs-comment"># 消费者消费消息</span><br>&gt; LPOP myList<br><span class="hljs-string">&quot;msg1&quot;</span><br></code></pre></td></tr></table></figure><p>不过，通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>这样的方式存在性能问题，我们需要不断轮询去调用 <code>RPOP</code> 或 <code>LPOP</code> 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p><p>因此，Redis 还提供了 <code>BLPOP</code>、<code>BRPOP</code> 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 超时时间为 10s</span><br><span class="hljs-comment"># 如果有数据立刻返回，否则最多等待10秒</span><br>&gt; BRPOP myList 10<br>null<br></code></pre></td></tr></table></figure><p><strong>List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。</strong></p><p><strong>Redis 2.0 引入了发布订阅 (pub&#x2F;sub) 功能，解决了 List 实现消息队列没有广播机制的问题。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-pub-sub.png" alt="Redis 发布订阅 (pub/sub) 功能">Redis 发布订阅 (pub&#x2F;sub) 功能</p><p>pub&#x2F;sub 中引入了一个概念叫 <strong>channel（频道）</strong>，发布订阅机制的实现就是基于这个 channel 来做的。</p><p>pub&#x2F;sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：</p><ul><li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li><li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li></ul><p>我们这里启动 3 个 Redis 客户端来简单演示一下：</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-pubsub-message-queue.png" alt="pub/sub 实现消息队列演示">pub&#x2F;sub 实现消息队列演示</p><p>pub&#x2F;sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。</p><p>为此，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。<code>Stream</code> 支持：</p><ul><li>发布 &#x2F; 订阅模式</li><li>按照消费者组进行消费</li><li>消息持久化（ RDB 和 AOF）</li></ul><p><code>Stream</code> 使用起来相对要麻烦一些，这里就不演示了。而且，<code>Stream</code> 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p><p>综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p><p>相关阅读：<a href="https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw">Redis 消息队列发展历程 - 阿里开发者 - 2022open in new window</a>。</p><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="#Redis 数据类型"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">#</a>Redis 数据类型</h2><p>关于 Redis 5 种基础数据类型和 3 种特殊数据类型的详细介绍请看下面这两篇文章以及 <a href="https://redis.io/docs/data-types/">Redis 官方文档open in new window</a> ：</p><ul><li><a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据类型详解open in new window</a></li><li><a href="https://javaguide.cn/database/redis/redis-data-structures-02.html">Redis 3 种特殊数据类型详解open in new window</a></li></ul><h3 id="Redis-常用的数据类型有哪些？"><a href="#Redis-常用的数据类型有哪些？" class="headerlink" title="#Redis 常用的数据类型有哪些？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>Redis 常用的数据类型有哪些？</h3><p>Redis 中比较常见的数据类型有下面这些：</p><ul><li><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。</li></ul><p>除了上面提到的之外，还有一些其他的比如 <a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter.html">Bloom filter（布隆过滤器）open in new window</a>、Bitfield（位域）。</p><h3 id="String-的应用场景有哪些？"><a href="#String-的应用场景有哪些？" class="headerlink" title="#String 的应用场景有哪些？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#string-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>String 的应用场景有哪些？</h3><p>String 是 Redis 中最简单同时也是最常用的一个数据类型。它是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p><p>String 的常见应用场景如下：</p><ul><li>常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；</li><li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li><li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li><li>……</li></ul><p>关于 String 的详细介绍请看这篇文章：<a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据类型详解open in new window</a>。</p><h3 id="String-还是-Hash-存储对象数据更好呢？"><a href="#String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="#String 还是 Hash 存储对象数据更好呢？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#string-%E8%BF%98%E6%98%AF-hash-%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%9B%B4%E5%A5%BD%E5%91%A2">#</a>String 还是 Hash 存储对象数据更好呢？</h3><ul><li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li><li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li></ul><p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p><h3 id="String-的底层实现是什么？"><a href="#String-的底层实现是什么？" class="headerlink" title="#String 的底层实现是什么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#string-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88">#</a>String 的底层实现是什么？</h3><p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是自己编写了 <a href="https://github.com/antirez/sds">SDSopen in new window</a>（Simple Dynamic String，简单动态字符串） 来作为底层实现。</p><p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p><p>Redis7.0 的 SDS 的部分源码如下（<a href="https://github.com/redis/redis/blob/7.0/src/sds.h%EF%BC%89%EF%BC%9A">https://github.com/redis/redis/blob/7.0/src/sds.h）：</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span><br><span class="hljs-comment"> * However is here to document the layout of type 5 SDS strings. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr5</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, and 5 msb of string length */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint16_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint32_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr64</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint64_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p><table><thead><tr><th>类型</th><th>字节</th><th>位</th></tr></thead><tbody><tr><td>sdshdr5</td><td>&lt; 1</td><td>&lt;8</td></tr><tr><td>sdshdr8</td><td>1</td><td>8</td></tr><tr><td>sdshdr16</td><td>2</td><td>16</td></tr><tr><td>sdshdr32</td><td>4</td><td>32</td></tr><tr><td>sdshdr64</td><td>8</td><td>64</td></tr></tbody></table><p>对于后四种实现都包含了下面这 4 个属性：</p><ul><li><code>len</code>：字符串的长度也就是已经使用的字节数</li><li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li><li><code>buf[]</code>：实际存储字符串的数组</li><li><code>flags</code>：低三位保存类型标志</li></ul><p>SDS 相比于 C 语言中的字符串有如下提升：</p><ol><li><strong>可以避免缓冲区溢出</strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li><li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li><li><strong>减少内存分配次数</strong>：为了避免修改（增加&#x2F;减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li><li><strong>二进制安全</strong>：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li></ol><p>🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code> 和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p><h3 id="购物车信息用-String-还是-Hash-存储更好呢"><a href="#购物车信息用-String-还是-Hash-存储更好呢" class="headerlink" title="#购物车信息用 String 还是 Hash 存储更好呢?"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%94%A8-string-%E8%BF%98%E6%98%AF-hash-%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A5%BD%E5%91%A2">#</a>购物车信息用 String 还是 Hash 存储更好呢?</h3><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p><ul><li>用户 id 为 key</li><li>商品 id 为 field，商品数量为 value</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/hash-shopping-cart.png" alt="Hash维护简单的购物车信息">Hash维护简单的购物车信息</p><p>那用户购物车信息的维护具体应该怎么操作呢？</p><ul><li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li><li>查询购物车信息就是遍历对应的 Hash；</li><li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li><li>删除商品就是删除 Hash 中对应的 field；</li><li>清空购物车直接删除对应的 key 即可。</li></ul><p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p><h3 id="使用-Redis-实现一个排行榜怎么做？"><a href="#使用-Redis-实现一个排行榜怎么做？" class="headerlink" title="#使用 Redis 实现一个排行榜怎么做？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BD%BF%E7%94%A8-redis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%80%8E%E4%B9%88%E5%81%9A">#</a>使用 Redis 实现一个排行榜怎么做？</h3><p>Redis 中有一个叫做 <code>Sorted Set</code> 的数据类型经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p><p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/2021060714195385.png" alt="img"></p><p><a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》open in new window</a> 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜，感兴趣的小伙伴可以看看。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719071115140.png" alt="img"></p><h3 id="Set-的应用场景是什么？"><a href="#Set-的应用场景是什么？" class="headerlink" title="#Set 的应用场景是什么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#set-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88">#</a>Set 的应用场景是什么？</h3><p>Redis 中 <code>Set</code> 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</p><p><code>Set</code> 的常见应用场景如下：</p><ul><li>存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等等。</li><li>需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。</li><li>需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。</li></ul><h3 id="使用-Set-实现抽奖系统怎么做？"><a href="#使用-Set-实现抽奖系统怎么做？" class="headerlink" title="#使用 Set 实现抽奖系统怎么做？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BD%BF%E7%94%A8-set-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F%E6%80%8E%E4%B9%88%E5%81%9A">#</a>使用 Set 实现抽奖系统怎么做？</h3><p>如果想要使用 <code>Set</code> 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p><ul><li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li><li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><h3 id="使用-Bitmap-统计活跃用户怎么做？"><a href="#使用-Bitmap-统计活跃用户怎么做？" class="headerlink" title="#使用 Bitmap 统计活跃用户怎么做？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BD%BF%E7%94%A8-bitmap-%E7%BB%9F%E8%AE%A1%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E6%80%8E%E4%B9%88%E5%81%9A">#</a>使用 Bitmap 统计活跃用户怎么做？</h3><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p><p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png" alt="img">img</p><p>如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p><p>初始化数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; SETBIT 20210308 1 1<br>(<span class="hljs-built_in">integer</span>) 0<br>&gt; SETBIT 20210308 2 1<br>(<span class="hljs-built_in">integer</span>) 0<br>&gt; SETBIT 20210309 1 1<br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></table></figure><p>统计 20210308~20210309 总活跃用户数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; BITOP and desk1 20210308 20210309<br>(<span class="hljs-built_in">integer</span>) 1<br>&gt; BITCOUNT desk1<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><p>统计 20210308~20210309 在线活跃用户数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; BITOP or desk2 20210308 20210309<br>(<span class="hljs-built_in">integer</span>) 1<br>&gt; BITCOUNT desk2<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><h3 id="使用-HyperLogLog-统计页面-UV-怎么做？"><a href="#使用-HyperLogLog-统计页面-UV-怎么做？" class="headerlink" title="#使用 HyperLogLog 统计页面 UV 怎么做？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BD%BF%E7%94%A8-hyperloglog-%E7%BB%9F%E8%AE%A1%E9%A1%B5%E9%9D%A2-uv-%E6%80%8E%E4%B9%88%E5%81%9A">#</a>使用 HyperLogLog 统计页面 UV 怎么做？</h3><p>使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：</p><ul><li><code>PFADD key element1 element2 ...</code>：添加一个或多个元素到 HyperLogLog 中。</li><li><code>PFCOUNT key1 key2</code>：获取一个或者多个 HyperLogLog 的唯一计数。</li></ul><p>1、将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PFADD PAGE_1:UV USER1 USER2 ...... USERn<br></code></pre></td></tr></table></figure><p>2、统计指定页面的 UV。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PFCOUNT PAGE_1:UV<br></code></pre></td></tr></table></figure><h2 id="Redis-持久化机制（重要）"><a href="#Redis-持久化机制（重要）" class="headerlink" title="#Redis 持久化机制（重要）"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6-%E9%87%8D%E8%A6%81">#</a>Redis 持久化机制（重要）</h2><p>Redis 持久化机制（RDB 持久化、AOF 持久化、RDB 和 AOF 的混合持久化） 相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 Redis 持久化机制相关的知识点和问题：<a href="https://javaguide.cn/database/redis/redis-persistence.html">Redis 持久化机制详解open in new window</a> 。</p><h2 id="Redis-线程模型（重要）"><a href="#Redis-线程模型（重要）" class="headerlink" title="#Redis 线程模型（重要）"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-%E9%87%8D%E8%A6%81">#</a>Redis 线程模型（重要）</h2><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p><h3 id="Redis-单线程模型了解吗？"><a href="#Redis-单线程模型了解吗？" class="headerlink" title="#Redis 单线程模型了解吗？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BA%86%E8%A7%A3%E5%90%97">#</a>Redis 单线程模型了解吗？</h3><p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><p>《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。</p><blockquote><p>  Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p><ul><li>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>  <strong>虽然文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显：<strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-event-handler.png" alt="文件事件处理器（file event handler）">文件事件处理器（file event handler）</p><p>相关阅读：<a href="http://remcarpediem.net/article/1aa2da89/">Redis 事件机制详解open in new window</a> 。</p><h3 id="Redis6-0-之前为什么不使用多线程？"><a href="#Redis6-0-之前为什么不使用多线程？" class="headerlink" title="#Redis6.0 之前为什么不使用多线程？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis6-0-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B">#</a>Redis6.0 之前为什么不使用多线程？</h3><p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p><p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</p><p>为此，Redis 4.0 之后新增了<code>UNLINK</code>（可以看作是 <code>DEL</code> 的异步版本）、<code>FLUSHALL ASYNC</code>（清空所有数据库的所有 key，不仅仅是当前 <code>SELECT</code> 的数据库）、<code>FLUSHDB ASYNC</code>（清空当前 <code>SELECT</code> 数据库中的所有 key）等异步命令。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-more-thread.png" alt="redis4.0 more thread">redis4.0 more thread</p><p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p><p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p><ul><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ul><p>相关阅读：<a href="https://draveness.me/whys-the-design-redis-single-thread/">为什么 Redis 选择单线程模型？open in new window</a> 。</p><h3 id="Redis6-0-之后为何引入了多线程？"><a href="#Redis6-0-之后为何引入了多线程？" class="headerlink" title="#Redis6.0 之后为何引入了多线程？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B">#</a>Redis6.0 之后为何引入了多线程？</h3><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p><p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">io-threads 4 <span class="hljs-comment">#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span><br></code></pre></td></tr></table></figure><p>另外：</p><ul><li>io-threads 的个数一旦设置，不能通过 config 动态设置。</li><li>当设置 ssl 后，io-threads 将不工作。</li></ul><p>开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 <code>redis.conf</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">io-threads-do-reads <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p><p>相关阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw">Redis 6.0 新特性-多线程连环 13 问！open in new window</a></li><li><a href="https://segmentfault.com/a/1190000039223696">Redis 多线程网络模型全面揭秘open in new window</a>（推荐）</li></ul><h3 id="Redis-后台线程了解吗？"><a href="#Redis-后台线程了解吗？" class="headerlink" title="#Redis 后台线程了解吗？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97">#</a>Redis 后台线程了解吗？</h3><p>我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：</p><ul><li>通过 <code>bio_close_file</code> 后台线程来释放 AOF &#x2F; RDB 等过程中产生的临时文件资源。</li><li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li><li>通过 <code>bio_lazy_free</code>后台线程释放大对象（已删除）占用的内存空间.</li></ul><p>在<code>bio.h</code> 文件中有定义（Redis 6.0 版本，源码地址：<a href="https://github.com/redis/redis/blob/6.0/src/bio.h%EF%BC%89%EF%BC%9A">https://github.com/redis/redis/blob/6.0/src/bio.h）：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">#ifndef __BIO_H<br>#define __BIO_H<br><br><span class="hljs-comment">/* Exported API */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">bioInit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">bioCreateBackgroundJob</span><span class="hljs-params">(<span class="hljs-type">int</span> type, <span class="hljs-keyword">void</span> *arg1, <span class="hljs-keyword">void</span> *arg2, <span class="hljs-keyword">void</span> *arg3)</span>;<br>unsigned <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">bioPendingJobsOfType</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span>;<br>unsigned <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">bioWaitStepOfType</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span>;<br>time_t <span class="hljs-title function_">bioOlderJobOfType</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">bioKillThreads</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>;<br><br><span class="hljs-comment">/* Background job opcodes */</span><br>#define BIO_CLOSE_FILE    <span class="hljs-number">0</span> <span class="hljs-comment">/* Deferred close(2) syscall. */</span><br>#define BIO_AOF_FSYNC     <span class="hljs-number">1</span> <span class="hljs-comment">/* Deferred AOF fsync. */</span><br>#define BIO_LAZY_FREE     <span class="hljs-number">2</span> <span class="hljs-comment">/* Deferred objects freeing. */</span><br>#define BIO_NUM_OPS       <span class="hljs-number">3</span><br><br>#endif<br></code></pre></td></tr></table></figure><p>关于 Redis 后台线程的详细介绍可以查看 <a href="https://juejin.cn/post/7102780434739626014">Redis 6.0 后台线程有哪些？open in new window</a> 这篇就文章。</p><h2 id="Redis-内存管理"><a href="#Redis-内存管理" class="headerlink" title="#Redis 内存管理"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">#</a>Redis 内存管理</h2><h3 id="Redis-给缓存数据设置过期时间有啥用？"><a href="#Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="#Redis 给缓存数据设置过期时间有啥用？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E5%95%A5%E7%94%A8">#</a>Redis 给缓存数据设置过期时间有啥用？</h3><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p><p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; expire key 60 <span class="hljs-comment"># 数据在 60s 后过期</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; setex key 60 value <span class="hljs-comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span><br>OK<br>127.0.0.1:6379&gt; ttl key <span class="hljs-comment"># 查看数据还有多久过期</span><br>(<span class="hljs-built_in">integer</span>) 56<br></code></pre></td></tr></table></figure><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p><p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p><p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 Token 可能只在 1 天内有效。</p><p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p><h3 id="Redis-是如何判断数据是否过期的呢？"><a href="#Redis-是如何判断数据是否过期的呢？" class="headerlink" title="#Redis 是如何判断数据是否过期的呢？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84%E5%91%A2">#</a>Redis 是如何判断数据是否过期的呢？</h3><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-expired-dictionary.png" alt="redis过期字典">redis过期字典</p><p>过期字典是存储在 redisDb 这个结构里的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br>    ...<br><br>    dict *dict;     <span class="hljs-comment">//数据库键空间,保存着数据库中所有键值对</span><br>    dict *expires   <span class="hljs-comment">// 过期字典,保存着键的过期时间</span><br>    ...<br>&#125; redisDb;<br></code></pre></td></tr></table></figure><h3 id="过期的数据的删除策略了解么？"><a href="#过期的数据的删除策略了解么？" class="headerlink" title="#过期的数据的删除策略了解么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E4%B9%88">#</a>过期的数据的删除策略了解么？</h3><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p><p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p><ol><li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p><h3 id="Redis-内存淘汰机制了解么？"><a href="#Redis-内存淘汰机制了解么？" class="headerlink" title="#Redis 内存淘汰机制了解么？"></a><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88">#</a>Redis 内存淘汰机制了解么？</h3><blockquote><p>  相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p></blockquote><p>Redis 提供 6 种数据淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li><li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis集群</title>
    <link href="/2021/04/06/DB/Redis/10.%20Redis%E9%9B%86%E7%BE%A4/"/>
    <url>/2021/04/06/DB/Redis/10.%20Redis%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis使用规范</title>
    <link href="/2021/04/06/DB/Redis/11.%20Redis%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <url>/2021/04/06/DB/Redis/11.%20Redis%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis应用</title>
    <link href="/2021/04/06/DB/Redis/2.%20Redis%E5%BA%94%E7%94%A8/"/>
    <url>/2021/04/06/DB/Redis/2.%20Redis%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis数据类型</title>
    <link href="/2021/04/06/DB/Redis/3.%20Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/06/DB/Redis/3.%20Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化机制</title>
    <link href="/2021/04/06/DB/Redis/4.%20Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E2%98%85%E2%98%85%E2%98%85/"/>
    <url>/2021/04/06/DB/Redis/4.%20Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E2%98%85%E2%98%85%E2%98%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis线程模型</title>
    <link href="/2021/04/06/DB/Redis/5.%20Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E2%98%85%E2%98%85%E2%98%85/"/>
    <url>/2021/04/06/DB/Redis/5.%20Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E2%98%85%E2%98%85%E2%98%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis内存管理</title>
    <link href="/2021/04/06/DB/Redis/6.%20Redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/04/06/DB/Redis/6.%20Redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis事务</title>
    <link href="/2021/04/06/DB/Redis/7.%20Redis%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/04/06/DB/Redis/7.%20Redis%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><h3 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="#什么是 Redis 事务？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF-redis-%E4%BA%8B%E5%8A%A1">#</a>什么是 Redis 事务？</h3><p>你可以将 Redis 中的事务理解为：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><p>Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。</p><p>除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p><p>因此，Redis 事务是不建议在日常开发中使用的。</p><h3 id="如何使用-Redis-事务？"><a href="#如何使用-Redis-事务？" class="headerlink" title="#如何使用 Redis 事务？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-redis-%E4%BA%8B%E5%8A%A1">#</a>如何使用 Redis 事务？</h3><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(Transaction)功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br>&gt; GET PROJECT<br>QUEUED<br>&gt; EXEC<br>1) OK<br>2) <span class="hljs-string">&quot;JavaGuide&quot;</span><br></code></pre></td></tr></table></figure><p><a href="https://redis.io/commands/multi"><code>MULTI</code>open in new window</a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec"><code>EXEC</code>open in new window</a> 命令后，再执行所有的命令。</p><p>这个过程是这样的：</p><ol><li>开始事务（<code>MULTI</code>）；</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li><li>执行事务(<code>EXEC</code>)。</li></ol><p>你也可以通过 <a href="https://redis.io/commands/discard"><code>DISCARD</code>open in new window</a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br>&gt; GET PROJECT<br>QUEUED<br>&gt; DISCARD<br>OK<br></code></pre></td></tr></table></figure><p>你可以通过<a href="https://redis.io/commands/watch"><code>WATCH</code>open in new window</a> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端&#x2F;Session</strong> 修改的话，整个事务都不会被执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 客户端 1</span><br>&gt; SET PROJECT <span class="hljs-string">&quot;RustGuide&quot;</span><br>OK<br>&gt; WATCH PROJECT<br>OK<br>&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br><br><span class="hljs-comment"># 客户端 2</span><br><span class="hljs-comment"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span><br>&gt; SET PROJECT <span class="hljs-string">&quot;GoGuide&quot;</span><br><br><span class="hljs-comment"># 客户端 1</span><br><span class="hljs-comment"># 修改失败，因为 PROJECT 的值被客户端2修改了</span><br>&gt; EXEC<br>(nil)<br>&gt; GET PROJECT<br><span class="hljs-string">&quot;GoGuide&quot;</span><br></code></pre></td></tr></table></figure><p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：<a href="https://github.com/Snailclimb/JavaGuide/issues/1714">WATCH 命令碰到 MULTI 命令时的不同效果open in new window</a>）。</p><p>事务内部修改 WATCH 监视的 Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>OK<br>&gt; WATCH PROJECT<br>OK<br>&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide1&quot;</span><br>QUEUED<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide2&quot;</span><br>QUEUED<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide3&quot;</span><br>QUEUED<br>&gt; EXEC<br>1) OK<br>2) OK<br>3) OK<br>127.0.0.1:6379&gt; GET PROJECT<br><span class="hljs-string">&quot;JavaGuide3&quot;</span><br></code></pre></td></tr></table></figure><p>事务外部修改 WATCH 监视的 Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>OK<br>&gt; WATCH PROJECT<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide2&quot;</span><br>OK<br>&gt; MULTI<br>OK<br>&gt; GET USER<br>QUEUED<br>&gt; EXEC<br>(nil)<br></code></pre></td></tr></table></figure><p>Redis 官网相关介绍 <a href="https://redis.io/topics/transactions">https://redis.io/topics/transactionsopen in new window</a> 如下：</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-transactions.png" alt="Redis 事务">Redis 事务</p><h3 id="Redis-事务支持原子性吗？"><a href="#Redis-事务支持原子性吗？" class="headerlink" title="#Redis 事务支持原子性吗？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97">#</a>Redis 事务支持原子性吗？</h3><p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：<strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p><ol><li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li><li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li></ol><p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。</p><p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-rollback.png" alt="Redis 为什么不支持回滚">Redis 为什么不支持回滚</p><p><strong>相关 issue</strong> :</p><ul><li><a href="https://github.com/Snailclimb/JavaGuide/issues/452">issue#452: 关于 Redis 事务不满足原子性的问题open in new window</a> 。</li><li><a href="https://github.com/Snailclimb/JavaGuide/issues/491">Issue#491:关于 Redis 没有事务回滚？open in new window</a></li></ul><h3 id="Redis-事务支持持久性吗？"><a href="#Redis-事务支持持久性吗？" class="headerlink" title="#Redis 事务支持持久性吗？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E6%8C%81%E4%B9%85%E6%80%A7%E5%90%97">#</a>Redis 事务支持持久性吗？</h3><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p><ul><li>快照（snapshotting，RDB）</li><li>只追加文件（append-only file, AOF）</li><li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li></ul><p>与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendfsync always    <span class="hljs-comment">#每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度</span><br>appendfsync everysec  <span class="hljs-comment">#每秒钟调用fsync函数同步一次AOF文件</span><br>appendfsync no        <span class="hljs-comment">#让操作系统决定何时进行同步，一般为30秒一次</span><br></code></pre></td></tr></table></figure><p>AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p><p>因此，Redis 事务的持久性也是没办法保证的。</p><h3 id="如何解决-Redis-事务的缺陷？"><a href="#如何解决-Redis-事务的缺陷？" class="headerlink" title="#如何解决 Redis 事务的缺陷？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-redis-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%BC%BA%E9%99%B7">#</a>如何解决 Redis 事务的缺陷？</h3><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p><p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p><p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p><p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p><p>另外，Redis 7.0 新增了 <a href="https://redis.io/docs/manual/programmability/functions-intro/">Redis functionsopen in new window</a> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p><h2 id="Redis-性能优化（重要）"><a href="#Redis-性能优化（重要）" class="headerlink" title="#Redis 性能优化（重要）"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%87%8D%E8%A6%81">#</a>Redis 性能优化（重要）</h2><p>除了下面介绍的内容之外，再推荐两篇不错的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ">你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者open in new window</a></li><li><a href="https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html">Redis 常见阻塞原因总结 - JavaGuideopen in new window</a></li></ul><h3 id="使用批量操作减少网络传输"><a href="#使用批量操作减少网络传输" class="headerlink" title="#使用批量操作减少网络传输"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BD%BF%E7%94%A8%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93">#</a>使用批量操作减少网络传输</h3><p>一个 Redis 命令的执行可以简化为以下 4 步：</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果</li></ol><p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p><p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p><p>另外，除了能减少 RTT 之外，发送一次命令的 socket I&#x2F;O 成本也比较高（涉及上下文切换，存在<code>read()</code>和<code>write()</code>系统调用），批量操作还可以减少 socket I&#x2F;O 成本。这个在官方对 pipeline 的介绍中有提到：<a href="https://redis.io/docs/manual/pipelining/">https://redis.io/docs/manual/pipelining/</a> 。</p><h4 id="原生批量操作命令"><a href="#原生批量操作命令" class="headerlink" title="#原生批量操作命令"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">#</a>原生批量操作命令</h4><p>Redis 中有一些原生支持批量操作的命令，比如：</p><ul><li><code>MGET</code>(获取一个或多个指定 key 的值)、<code>MSET</code>(设置一个或多个指定 key 的值)、</li><li><code>HMGET</code>(获取指定哈希表中一个或者多个指定字段的值)、<code>HMSET</code>(同时将一个或多个 field-value 对设置到指定哈希表中)、</li><li><code>SADD</code>（向指定集合添加一个或多个元素）</li><li>……</li></ul><p>不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 <code>MGET</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>MGET</code>可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p><p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p><ol><li>找到 key 对应的所有 hash slot；</li><li>分别向对应的 Redis 节点发起 <code>MGET</code> 请求获取数据；</li><li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li></ol><p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p><blockquote><p>  Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p><p>  我在 <a href="https://javaguide.cn/database/redis/redis-cluster.html">Redis 集群详解（付费）open in new window</a> 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。</p></blockquote><h4 id="pipeline"><a href="#pipeline" class="headerlink" title="#pipeline"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#pipeline">#</a>pipeline</h4><p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p><p>与<code>MGET</code>、<code>MSET</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p><p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p><ul><li>原生批量操作命令是原子操作，pipeline 是非原子操作。</li><li>pipeline 可以打包不同的命令，原生批量操作命令不可以。</li><li>原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li></ul><p>顺带补充一下 pipeline 和 Redis 事务的对比：</p><ul><li>事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。</li><li>Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。</li></ul><blockquote><p>  事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。</p></blockquote><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-pipeline-vs-transaction.png" alt="img"></p><p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p><h4 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="#Lua 脚本"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#lua-%E8%84%9A%E6%9C%AC">#</a>Lua 脚本</h4><p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 <strong>原子操作</strong> 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p><p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p><p>不过， Lua 脚本依然存在下面这些缺陷：</p><ul><li>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li><li>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</li></ul><h3 id="大量-key-集中过期问题"><a href="#大量-key-集中过期问题" class="headerlink" title="#大量 key 集中过期问题"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A4%A7%E9%87%8F-key-%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98">#</a>大量 key 集中过期问题</h3><p>我在前面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 策略。</p><p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p><p><strong>如何解决呢？</strong> 下面是两种常见的方法：</p><ol><li>给 key 设置随机过期时间。</li><li>开启 lazy-free（惰性删除&#x2F;延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ol><p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p><h3 id="Redis-bigkey（大-Key）"><a href="#Redis-bigkey（大-Key）" class="headerlink" title="#Redis bigkey（大 Key）"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-bigkey-%E5%A4%A7-key">#</a>Redis bigkey（大 Key）</h3><h4 id="什么是-bigkey？"><a href="#什么是-bigkey？" class="headerlink" title="#什么是 bigkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF-bigkey">#</a>什么是 bigkey？</h4><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p><h4 id="bigkey-有什么危害？"><a href="#bigkey-有什么危害？" class="headerlink" title="#bigkey 有什么危害？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#bigkey-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3">#</a>bigkey 有什么危害？</h4><p>bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。因此，我们应该尽量避免 Redis 中存在 bigkey。</p><h4 id="如何发现-bigkey？"><a href="#如何发现-bigkey？" class="headerlink" title="#如何发现 bigkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0-bigkey">#</a>如何发现 bigkey？</h4><p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># redis-cli -p 6379 --bigkeys</span><br><br><span class="hljs-comment"># Scanning the entire keyspace to find biggest keys as well as</span><br><span class="hljs-comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span><br><span class="hljs-comment"># per 100 SCAN commands (not usually needed).</span><br><br>[00.00%] Biggest string found so far <span class="hljs-string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> with 4437 bytes<br>[00.00%] Biggest list   found so far <span class="hljs-string">&#x27;&quot;my-list&quot;&#x27;</span> with 17 items<br><br>-------- summary -------<br><br>Sampled 5 keys <span class="hljs-keyword">in</span> the keyspace!<br>Total key length <span class="hljs-keyword">in</span> bytes is 264 (avg len 52.80)<br><br>Biggest   list found <span class="hljs-string">&#x27;&quot;my-list&quot;&#x27;</span> has 17 items<br>Biggest string found <span class="hljs-string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> has 4437 bytes<br><br>1 lists with 17 items (20.00% of keys, avg size 17.00)<br>0 hashs with 0 fields (00.00% of keys, avg size 0.00)<br>4 strings with 4831 bytes (80.00% of keys, avg size 1207.75)<br>0 streams with 0 entries (00.00% of keys, avg size 0.00)<br>0 sets with 0 members (00.00% of keys, avg size 0.00)<br>0 zsets with 0 members (00.00% of keys, avg size 0.00<br></code></pre></td></tr></table></figure><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。然而，一个 key 的元素多并不代表占用内存也多，需要我们根据具体的业务情况来进一步判断。</p><p>在线上执行该命令时，为了降低对 Redis 的影响，需要指定 <code>-i</code> 参数控制扫描的频率。<code>redis-cli -p 6379 --bigkeys -i 3</code> 表示扫描过程中每次扫描后休息的时间间隔为 3 秒。</p><p><strong>2、借助开源工具分析 RDB 文件。</strong></p><p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p><p>网上有现成的代码&#x2F;工具可以直接拿来使用：</p><ul><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools">redis-rdb-toolsopen in new window</a>：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li><li><a href="https://github.com/weiyanwei412/rdb_bigkeys">rdb_bigkeysopen in new window</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li></ul><p><strong>3、借助公有云的 Redis 分析服务。</strong></p><p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p><p>这里以阿里云 Redis 为例说明，它支持 bigkey 实时分析、发现，文档地址：<a href="https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-featureopen in new window</a> 。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/aliyun-key-analysis.png" alt="阿里云Key分析">阿里云Key分析</p><h4 id="如何处理-bigkey？"><a href="#如何处理-bigkey？" class="headerlink" title="#如何处理 bigkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-bigkey">#</a>如何处理 bigkey？</h4><p>bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p><ul><li><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。这种方式需要修改业务层的代码，一般不推荐这样做。</li><li><strong>手动清理</strong>：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li><li><strong>采用合适的数据结构</strong>：比如使用 HyperLogLog 统计页面 UV。</li><li><strong>开启 lazy-free（惰性删除&#x2F;延迟释放）</strong> ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ul><h3 id="Redis-hotkey（热-Key）"><a href="#Redis-hotkey（热-Key）" class="headerlink" title="#Redis hotkey（热 Key）"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-hotkey-%E7%83%AD-key">#</a>Redis hotkey（热 Key）</h3><h4 id="什么是-hotkey？"><a href="#什么是-hotkey？" class="headerlink" title="#什么是 hotkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF-hotkey">#</a>什么是 hotkey？</h4><p>如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 <strong>hotkey（热 Key）</strong>。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。</p><p>hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p><h4 id="hotkey-有什么危害？"><a href="#hotkey-有什么危害？" class="headerlink" title="#hotkey 有什么危害？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#hotkey-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3">#</a>hotkey 有什么危害？</h4><p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</p><p>因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p><h4 id="如何发现-hotkey？"><a href="#如何发现-hotkey？" class="headerlink" title="#如何发现 hotkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0-hotkey">#</a>如何发现 hotkey？</h4><p><strong>1、使用 Redis 自带的 <code>--hotkeys</code> 参数来查找。</strong></p><p>Redis 4.0.3 版本中新增了 <code>hotkeys</code> 参数，该参数能够返回所有 key 的被访问次数。</p><p>使用该方案的前提条件是 Redis Server 的 <code>maxmemory-policy</code> 参数设置为 LFU 算法，不然就会出现如下所示的错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># redis-cli -p 6379 --hotkeys</span><br><br><span class="hljs-comment"># Scanning the entire keyspace to find hot keys as well as</span><br><span class="hljs-comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span><br><span class="hljs-comment"># per 100 SCAN commands (not usually needed).</span><br><br>Error: ERR An LFU maxmemory policy is not selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust.<br></code></pre></td></tr></table></figure><p>Redis 中有两种 LFU 算法：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li></ol><p>以下是配置文件 <code>redis.conf</code> 中的示例：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 使用 volatile-lfu 策略</span><br><span class="hljs-attr">maxmemory-policy</span> <span class="hljs-string">volatile-lfu</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 或者使用 allkeys-lfu 策略</span><br><span class="hljs-attr">maxmemory-policy</span> <span class="hljs-string">allkeys-lfu</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>hotkeys</code> 参数命令也会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。</p><p><strong>2、使用<code>MONITOR</code> 命令。</strong></p><p><code>MONITOR</code> 命令是 Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。</p><p>由于该命令对 Redis 性能的影响比较大，因此禁止长时间开启 <code>MONITOR</code>（生产环境中建议谨慎使用该命令）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"># redis-cli<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; MONITOR<br>OK<br><span class="hljs-number">1683638260.637378</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61516</span>] <span class="hljs-string">&quot;ping&quot;</span><br><span class="hljs-number">1683638267.144236</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br><span class="hljs-number">1683638268.941863</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br><span class="hljs-number">1683638269.551671</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br><span class="hljs-number">1683638270.646256</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61516</span>] <span class="hljs-string">&quot;ping&quot;</span><br><span class="hljs-number">1683638270.849551</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br><span class="hljs-number">1683638271.926945</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br><span class="hljs-number">1683638274.276599</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet2&quot;</span><br><span class="hljs-number">1683638276.327234</span> [<span class="hljs-number">0</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">61518</span>] <span class="hljs-string">&quot;smembers&quot;</span> <span class="hljs-string">&quot;mySet&quot;</span><br></code></pre></td></tr></table></figure><p>在发生紧急情况时，我们可以选择在合适的时机短暂执行 <code>MONITOR</code> 命令并将输出重定向至文件，在关闭 <code>MONITOR</code> 命令后通过对文件中请求进行归类分析即可找出这段时间中的 hotkey。</p><p><strong>3、借助开源项目。</strong></p><p>京东零售的 <a href="https://gitee.com/jd-platform-opensource/hotkey">hotkeyopen in new window</a> 这个项目不光支持 hotkey 的发现，还支持 hotkey 的处理。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/jd-hotkey.png" alt="京东零售开源的 hotkey">京东零售开源的 hotkey</p><p><strong>4、根据业务情况提前预估。</strong></p><p>可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。</p><p><strong>5、业务代码中记录分析。</strong></p><p>在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。</p><p><strong>6、借助公有云的 Redis 分析服务。</strong></p><p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p><p>这里以阿里云 Redis 为例说明，它支持 hotkey 实时分析、发现，文档地址：<a href="https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-featureopen in new window</a> 。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/aliyun-key-analysis.png" alt="阿里云Key分析">阿里云Key分析</p><h4 id="如何解决-hotkey？"><a href="#如何解决-hotkey？" class="headerlink" title="#如何解决 hotkey？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-hotkey">#</a>如何解决 hotkey？</h4><p>hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p><ul><li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</li><li><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</li><li><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</li></ul><p>除了这些方法之外，如果你使用的公有云的 Redis 服务话，还可以留意其提供的开箱即用的解决方案。</p><p>这里以阿里云 Redis 为例说明，它支持通过代理查询缓存功能（Proxy Query Cache）优化热点 Key 问题。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/aliyun-hotkey-proxy-query-cache.png" alt="通过阿里云的Proxy Query Cache优化热点Key问题">通过阿里云的Proxy Query Cache优化热点Key问题</p><h3 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="#慢查询命令"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4">#</a>慢查询命令</h3><h4 id="为什么会有慢查询命令？"><a href="#为什么会有慢查询命令？" class="headerlink" title="#为什么会有慢查询命令？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4">#</a>为什么会有慢查询命令？</h4><p>我们知道一个 Redis 命令的执行可以简化为以下 4 步：</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果</li></ol><p>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</p><p>Redis 为什么会有慢查询命令呢？</p><p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p><ul><li><code>KEYS *</code>：会返回所有符合规则的 key。</li><li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li><li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li><li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li><li><code>SINTER</code>&#x2F;<code>SUNION</code>&#x2F;<code>SDIFF</code>：计算多个 Set 的交集&#x2F;并集&#x2F;差集。</li><li>……</li></ul><p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p><p>除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p><ul><li><code>ZRANGE</code>&#x2F;<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li><li><code>ZREMRANGEBYRANK</code>&#x2F;<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围&#x2F;指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li><li>……</li></ul><h4 id="如何找到慢查询命令？"><a href="#如何找到慢查询命令？" class="headerlink" title="#如何找到慢查询命令？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4">#</a>如何找到慢查询命令？</h4><p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。</p><p>当 Redis 服务器检测到执行时间超过 <code>slowlog-log-slower-than</code>阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。</p><p>⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</p><p><code>slowlog-log-slower-than</code>和<code>slowlog-max-len</code>的默认配置如下(可以自行修改)：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="hljs-comment"># to one second. Note that a negative number disables the slow log, while</span><br><span class="hljs-comment"># a value of zero forces the logging of every command.</span><br>slowlog-log-slower-<span class="hljs-attribute">than</span> <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="hljs-comment"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br>slowlog-max-len <span class="hljs-number">128</span><br></code></pre></td></tr></table></figure><p>除了修改配置文件之外，你也可以直接通过 <code>CONFIG</code> 命令直接设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令执行耗时超过 10000 微妙（即10毫秒）就会被记录</span><br>CONFIG SET slowlog-log-slower-than 10000<br><span class="hljs-comment"># 只保留最近 128 条耗时命令</span><br>CONFIG SET slowlog-max-len 128<br></code></pre></td></tr></table></figure><p>获取慢查询日志的内容很简单，直接使用<code>SLOWLOG GET</code> 命令即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SLOWLOG GET #慢日志查询<br> <span class="hljs-number">1</span>) <span class="hljs-number">1</span>) (integer) <span class="hljs-number">5</span><br>   <span class="hljs-number">2</span>) (integer) <span class="hljs-number">1684326682</span><br>   <span class="hljs-number">3</span>) (integer) <span class="hljs-number">12000</span><br>   <span class="hljs-number">4</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;KEYS&quot;</span><br>      <span class="hljs-number">2</span>) <span class="hljs-string">&quot;*&quot;</span><br>   <span class="hljs-number">5</span>) <span class="hljs-string">&quot;172.17.0.1:61152&quot;</span><br>   <span class="hljs-number">6</span>) <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>慢查询日志中的每个条目都由以下六个值组成：</p><ol><li>唯一渐进的日志标识符。</li><li>处理记录命令的 Unix 时间戳。</li><li>执行所需的时间量，以微秒为单位。</li><li>组成命令参数的数组。</li><li>客户端 IP 地址和端口。</li><li>客户端名称。</li></ol><p><code>SLOWLOG GET</code> 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 <code>SLOWLOG GET N</code>。</p><p>下面是其他比较常用的慢查询相关的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 返回慢查询命令的数量</span><br>127.0.0.1:6379&gt; SLOWLOG LEN<br>(<span class="hljs-built_in">integer</span>) 128<br><span class="hljs-comment"># 清空慢查询命令</span><br>127.0.0.1:6379&gt; SLOWLOG RESET<br>OK<br></code></pre></td></tr></table></figure><h3 id="Redis-内存碎片"><a href="#Redis-内存碎片" class="headerlink" title="#Redis 内存碎片"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87">#</a>Redis 内存碎片</h3><p><strong>相关问题</strong>：</p><ol><li>什么是内存碎片?为什么会有 Redis 内存碎片?</li><li>如何清理 Redis 内存碎片？</li></ol><p><strong>参考答案</strong>：<a href="https://javaguide.cn/database/redis/redis-memory-fragmentation.html">Redis 内存碎片详解open in new window</a>。</p><h2 id="Redis-生产问题（重要）"><a href="#Redis-生产问题（重要）" class="headerlink" title="#Redis 生产问题（重要）"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-%E9%87%8D%E8%A6%81">#</a>Redis 生产问题（重要）</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="#缓存穿透"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">#</a>缓存穿透</h3><h4 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="#什么是缓存穿透？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">#</a>什么是缓存穿透？</h4><p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-penetration.png" alt="缓存穿透">缓存穿透</p><p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p><h4 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="#有哪些解决办法？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">#</a>有哪些解决办法？</h4><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的：<code>表名:列名:主键名:主键值</code> 。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObjectInclNullById</span><span class="hljs-params">(Integer id)</span> &#123;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheValue</span> <span class="hljs-operator">=</span> cache.get(id);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (cacheValue == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 从数据库中获取</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">storageValue</span> <span class="hljs-operator">=</span> storage.get(key);<br>        <span class="hljs-comment">// 缓存空对象</span><br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span><br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 必须设置过期时间，否则有被攻击的风险</span><br>            cache.expire(key, <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cacheValue;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-penetration-bloom-filter.png" alt="加入布隆过滤器之后的缓存处理流程图">加入布隆过滤器之后的缓存处理流程图</p><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter/">《不了解布隆过滤器？一文给你整的明明白白！》open in new window</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="#缓存击穿"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">#</a>缓存击穿</h3><h4 id="什么是缓存击穿？"><a href="#什么是缓存击穿？" class="headerlink" title="#什么是缓存击穿？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">#</a>什么是缓存击穿？</h4><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-breakdown.png" alt="缓存击穿">缓存击穿</p><p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h4 id="有哪些解决办法？-1"><a href="#有哪些解决办法？-1" class="headerlink" title="#有哪些解决办法？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-1">#</a>有哪些解决办法？</h4><ul><li>设置热点数据永不过期或者过期时间比较长。</li><li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li></ul><h4 id="缓存穿透和缓存击穿有什么区别？"><a href="#缓存穿透和缓存击穿有什么区别？" class="headerlink" title="#缓存穿透和缓存击穿有什么区别？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>缓存穿透和缓存击穿有什么区别？</h4><p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="#缓存雪崩"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">#</a>缓存雪崩</h3><h4 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="#什么是缓存雪崩？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">#</a>什么是缓存雪崩？</h4><p>我发现缓存雪崩这名字起的有点意思，哈哈。</p><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-avalanche.png" alt="缓存雪崩">缓存雪崩</p><p>举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h4 id="有哪些解决办法？-2"><a href="#有哪些解决办法？-2" class="headerlink" title="#有哪些解决办法？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-2">#</a>有哪些解决办法？</h4><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效（不太推荐，实用性太差）。</li><li>设置二级缓存。</li></ol><h4 id="缓存雪崩和缓存击穿有什么区别？"><a href="#缓存雪崩和缓存击穿有什么区别？" class="headerlink" title="#缓存雪崩和缓存击穿有什么区别？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>缓存雪崩和缓存击穿有什么区别？</h4><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p><h3 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="#如何保证缓存和数据库数据的一致性？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7">#</a>如何保证缓存和数据库数据的一致性？</h3><p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p><p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p><p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加 cache 更新重试机制（常用）</strong>：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li></ol><p>相关文章推荐：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹open in new window</a>。</p><h3 id="哪些情况可能会导致-Redis-阻塞？"><a href="#哪些情况可能会导致-Redis-阻塞？" class="headerlink" title="#哪些情况可能会导致 Redis 阻塞？"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4-redis-%E9%98%BB%E5%A1%9E">#</a>哪些情况可能会导致 Redis 阻塞？</h3><p>单独抽了一篇文章来总结可能会导致 Redis 阻塞的情况：<a href="https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html">Redis 常见阻塞原因总结open in new window</a>。</p><h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="#Redis 集群"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E9%9B%86%E7%BE%A4">#</a>Redis 集群</h2><p><strong>Redis Sentinel</strong>：</p><ol><li>什么是 Sentinel？ 有什么用？</li><li>Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</li><li>Sentinel 是如何实现故障转移的？</li><li>为什么建议部署多个 sentinel 节点（哨兵集群）？</li><li>Sentinel 如何选择出新的 master（选举机制）?</li><li>如何从 Sentinel 集群中选择出 Leader ？</li><li>Sentinel 可以防止脑裂吗？</li></ol><p><strong>Redis Cluster</strong>：</p><ol><li>为什么需要 Redis Cluster？解决了什么问题？有什么优势？</li><li>Redis Cluster 是如何分片的？</li><li>为什么 Redis Cluster 的哈希槽是 16384 个?</li><li>如何确定给定 key 的应该分布到哪个哈希槽中？</li><li>Redis Cluster 支持重新分配哈希槽吗？</li><li>Redis Cluster 扩容缩容期间可以提供服务吗？</li><li>Redis Cluster 中的节点是怎么进行通信的？</li></ol><p><strong>参考答案</strong>：<a href="https://javaguide.cn/database/redis/redis-cluster.html">Redis 集群详解（付费）open in new window</a>。</p><h2 id="Redis-使用规范"><a href="#Redis-使用规范" class="headerlink" title="#Redis 使用规范"></a><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83">#</a>Redis 使用规范</h2><p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p><ol><li>使用连接池：避免频繁创建关闭客户端连接。</li><li>尽量不使用 O(n)指令，使用 O(n) 命令时要关注 n 的数量：像 <code>KEYS *</code>、<code>HGETALL</code>、<code>LRANGE</code>、<code>SMEMBERS</code>、<code>SINTER</code>&#x2F;<code>SUNION</code>&#x2F;<code>SDIFF</code>等 O(n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</li><li>使用批量操作减少网络传输：原生批量操作命令（比如 <code>MGET</code>、<code>MSET</code>等等）、pipeline、Lua 脚本。</li><li>尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li><li>禁止长时间开启 monitor：对性能影响比较大。</li><li>控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。</li><li>……</li></ol><p>相关文章推荐：<a href="https://developer.aliyun.com/article/531067">阿里云 Redis 开发规范open in new window</a> </p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis性能优化</title>
    <link href="/2021/04/06/DB/Redis/8.%20Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%98%85%E2%98%85%E2%98%85/"/>
    <url>/2021/04/06/DB/Redis/8.%20Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%98%85%E2%98%85%E2%98%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis生产问题</title>
    <link href="/2021/04/06/DB/Redis/9.%20Redis%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E2%98%85%E2%98%85%E2%98%85/"/>
    <url>/2021/04/06/DB/Redis/9.%20Redis%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E2%98%85%E2%98%85%E2%98%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis缓存</title>
    <link href="/2021/04/06/DB/Redis/%E7%BC%93%E5%AD%98/"/>
    <url>/2021/04/06/DB/Redis/%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><ol><li>导入依赖</li><li>配置redis主机地址</li><li>自动注入RedisTemplate</li><li>使用RedisTemplate的方法将缓存放到数据库</li></ol><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><ul><li>缓存穿透：缓存和数据库都没有的数据被大量请求，导致数据库压力过大<ul><li>解决方案：缓存空对象、布隆过滤器</li></ul></li><li>缓存雪崩：缓存在某一时刻大量失效，请求全部转发到数据库，导致数据库压力过大<ul><li>解决方案：过期时间设置随机部分、设置热点数据永不过期、降级熔断</li></ul></li><li>缓存击穿：并发的查询同一条  缓存中没有（缓存到期）但数据库中有 的数据，同时查询数据库导致击穿<ul><li>解决方案：设置热点数据永不过期、互斥锁</li><li>可以选择加锁，竞争到锁后，确认缓存中是否有数据，没有的情况下再查数据库，然后加入缓存，解锁。</li></ul></li></ul><blockquote><p>雪崩是：不同数据过期</p><p>击穿是：某条热点数据过期</p></blockquote><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><blockquote><p>本地缓存的问题所在：每个微服务都要有缓存，然而缓存的数据可能不一致</p></blockquote><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式的项目，本地锁只能锁住当前服务，所以需要分布式锁。</p><blockquote><p>分布式锁的过程：</p><ul><li>没获得锁 -&gt; 阻塞或者sleep一会   （或者自旋？）</li><li>加锁，但解锁之前服务挂掉，没有执行解锁的逻辑，造成死锁<ul><li>解决方法：设置过期时间，时间到了自动解锁</li></ul></li><li>业务没有执行完的时候锁过期了，其它线程拿到了锁，本进程执行完之后，将其他进程的锁删了<ul><li>解决方法：锁续期（Redisson有看门狗），删锁的时候确认是自己的锁（对锁加上UUID）</li></ul></li><li>确认是自己的锁，但在将要删除的时候锁过期了换了别人的锁，即想要删除的时候锁被掉包了<ul><li>解决方法：删除锁的时候必须保证原子性（判断锁和删锁是原子的），使用redis+Lua脚本完成，脚本是原子的。但比较麻烦，所以可以考虑使用现有框架，比如Redisson。</li></ul></li></ul></blockquote><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;!- 练习使用，更推荐使用redisson-spring-boot-starter -&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>开启配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRedisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;ipAddr&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String ipAddr;<br><br>    <span class="hljs-comment">// redission通过redissonClient对象使用 // 如果是多个redis集群，可以配置</span><br>    <span class="hljs-meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redisson</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        <span class="hljs-comment">// 创建单例模式的配置</span><br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://&quot;</span> + ipAddr + <span class="hljs-string">&quot;:6379&quot;</span>);<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注入RedissonClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br></code></pre></td></tr></table></figure></li><li><p>使用方法进行加锁、解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;锁名称，尽量保持唯一性，所以可以写的具体一点&quot;</span>)；<br>lock.lock(); <span class="hljs-comment">//阻塞等待，内为死循环</span><br>lock.unlock();<span class="hljs-comment">//推荐放入到finally。如果解锁之前，程序宕机也没关系，因为Redisson有看门狗</span><br></code></pre></td></tr></table></figure><blockquote><p>看门狗：在业务执行完之前，不断延长锁的有效期。默认情况下，锁的超时时间是30s，而看门狗会在时间过去三分之一的时候，即剩余20s的时候将锁的有效期延长成为30s。这个期限可以通过Config.lockWatchdoyTimeout来另行修改。</p></blockquote></li><li><p><code>推荐用法</code>：自己指定锁时间，时间长点即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">lock.lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<span class="hljs-comment">//指定过期时间后，超时自动解锁，看门狗不会延长锁的有效期。</span><br>lock.tryLock(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<span class="hljs-comment">//尝试加锁，不会阻塞等待。最多等待100秒，10秒后自动解锁</span><br><span class="hljs-comment">//内部逻辑：</span><br><span class="hljs-comment">//如果设置了锁的超时时间，就执行脚本占锁，</span><br><span class="hljs-comment">//如果没设置锁的超时时间，使用开门狗的时间去占锁，然后根据进程id判断线程没结束？就调用看门狗的定时任务，重新给锁设置过期时间。</span><br><span class="hljs-comment">//定时任务的周期为：锁时间 / 3 </span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*基于Redis的Redisson分布式可重入读写锁RReadWriteLock Java对象实现了java.util.concurrent.locks.ReadWriteLock接口。其中读锁和写锁都继承了RLock接口。</span><br><span class="hljs-comment">分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">RReadWriteLock</span> <span class="hljs-variable">rwlock</span> <span class="hljs-operator">=</span> redisson.getReadWriteLock(<span class="hljs-string">&quot;anyRWLock&quot;</span>);<br><span class="hljs-comment">// 最常见的使用方法</span><br>rwlock.readLock().lock();<br><span class="hljs-comment">// 或</span><br>rwlock.writeLock().lock();<br><span class="hljs-comment">// 10秒钟以后自动解锁</span><br><span class="hljs-comment">// 无需调用unlock方法手动解锁</span><br>rwlock.readLock().lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br><span class="hljs-comment">// 或</span><br>rwlock.writeLock().lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> rwlock.readLock().tryLock(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br><span class="hljs-comment">// 或</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> rwlock.writeLock().tryLock(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure></li></ol><h3 id="分布式信号量Semaphore"><a href="#分布式信号量Semaphore" class="headerlink" title="分布式信号量Semaphore"></a>分布式信号量Semaphore</h3><blockquote><p>RLock对象完全符合Java的Lock规范，即只有拥有锁的进程才能解锁，如果其他进程尝试解锁会抛出IllegalMonitorStateException的异常。如果需要其他进程也能解锁，可以使用分布式信号量Semaphore。</p></blockquote><blockquote><p>信号量为存储在redis中的一个数字，当这个数字大于0时，即可以调用<code>acquire()</code>方法减少数量，也可以调用<code>release()</code>方法增加数量，但是当调用<code>release()</code>之后小于0的话方法就会阻塞，直到数字大于0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RSemaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> redisson.getSemaphore(<span class="hljs-string">&quot;semaphore&quot;</span>);<br>semaphore.acquire();<br><span class="hljs-comment">//或</span><br>semaphore.acquireAsync();<br>semaphore.acquire(<span class="hljs-number">23</span>);<br>semaphore.tryAcquire();<br><span class="hljs-comment">//或</span><br>semaphore.tryAcquireAsync();<br>semaphore.tryAcquire(<span class="hljs-number">23</span>, TimeUnit.SECONDS);<br><span class="hljs-comment">//或</span><br>semaphore.tryAcquireAsync(<span class="hljs-number">23</span>, TimeUnit.SECONDS);<br>semaphore.release(<span class="hljs-number">10</span>);<br>semaphore.release();<br><span class="hljs-comment">//或</span><br>semaphore.releaseAsync();<br></code></pre></td></tr></table></figure><h3 id="闭锁（CountDownLatch）"><a href="#闭锁（CountDownLatch）" class="headerlink" title="闭锁（CountDownLatch）"></a>闭锁（CountDownLatch）</h3><blockquote><p>基于Redisson的Redisson分布式闭锁CountDownLatch，Java对象<code>RCountDownLatch</code>采用了与<code>java.util.concurrent.CountDownLatch</code>相似的接口和用法。</p></blockquote><blockquote><p>只有在某个方法调用了n次之后，另一个方法才能执行。比如商品被卖了100次，调用卖完了这个方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockDoor</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">RCountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> redisson.getCountDownLatch(<span class="hljs-string">&quot;anyCountDownLatch&quot;</span>);<br>    latch.trySetCount(<span class="hljs-number">10</span>);<br>    latch.await();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gogo</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">RCountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> redisson.getCountDownLatch(<span class="hljs-string">&quot;anyCountDownLatch&quot;</span>);<br>    latch.countDown();<span class="hljs-comment">//只有lockDoor被调用了10次，这个gogo方法才能执行完</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缓存和数据库一致性问题"><a href="#缓存和数据库一致性问题" class="headerlink" title="缓存和数据库一致性问题"></a>缓存和数据库一致性问题</h3><ul><li>双写模式：写数据库后，写缓存<ul><li>问题：并发时，2写进入，写完DB后都写缓存，1写完库，2写完库，2写缓存，1写缓存，有暂时的脏数据</li></ul></li><li>失效模式：写完数据库后，删缓存<ul><li>问题：1写完删完，2正在写，此时3开始读，只能读到1，而3读到1之后，2把缓存删了，3把1更新到缓存</li><li>解决：缓存设置过期时间，定期更新</li><li>解决：写数据写时，加分布式的读写锁。</li></ul></li></ul><blockquote><p>解决方案：</p><ul><li>如果是用户纬度数据（订单数据、用户数据），这种并发几率非常小，不用考虑这个问题，缓存数据加上过期时间，每隔一段时间触发读的主动更新即可</li><li>如果是菜单，商品介绍等基础数据，也可以去使用canal订阅binlog的方式（数据更新后canal得到日志的消息去更新缓存）<br>缓存数据+过期时间也足够解决大部分业务对于缓存的要求。</li><li>通过加锁保证并发读写，写写的时候按顺序排好队。读读无所谓。所以适合使用读写锁。（业务不关心脏数据，允许临时脏数据可忽略）</li></ul><p>总结：我们<code>能放入缓存的数据本就不应该是实时性、一致性要求超高的</code>。所以缓存数据的时候加上过期时间，保证每天拿到当前最新数据即可。我们<code>不应该过度设计，增加系统的复杂性</code>。遇到<code>实时性、一致性要求高的数据，就应该查数据库</code>，即使慢点。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CountDownLatch</title>
    <link href="/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/CountDownLatch/"/>
    <url>/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/CountDownLatch/</url>
    
    <content type="html"><![CDATA[<h3 id="CountDownLatch-倒计时器"><a href="#CountDownLatch-倒计时器" class="headerlink" title="CountDownLatch 倒计时器"></a>CountDownLatch 倒计时器</h3><h4 id="CountDownLatch-有什么用？"><a href="#CountDownLatch-有什么用？" class="headerlink" title="CountDownLatch 有什么用？"></a>CountDownLatch 有什么用？</h4><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><h4 id="CountDownLatch-的原理是什么？"><a href="#CountDownLatch-的原理是什么？" class="headerlink" title="CountDownLatch 的原理是什么？"></a>CountDownLatch 的原理是什么？</h4><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到<code>count</code> 个线程调用了<code>countDown()</code>使state值被减为0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</p><h4 id="CountDownLatch-是在什么场景下用的？"><a href="#CountDownLatch-是在什么场景下用的？" class="headerlink" title="CountDownLatch 是在什么场景下用的？"></a>CountDownLatch 是在什么场景下用的？</h4><p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p><p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p><p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CyclicBarrier</title>
    <link href="/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/CyclicBarrier/"/>
    <url>/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/CyclicBarrier/</url>
    
    <content type="html"><![CDATA[<h3 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier 循环栅栏"></a>CyclicBarrier 循环栅栏</h3><h4 id="CyclicBarrier-有什么用？"><a href="#CyclicBarrier-有什么用？" class="headerlink" title="CyclicBarrier 有什么用？"></a>CyclicBarrier 有什么用？</h4><p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p><blockquote><p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p></blockquote><p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><blockquote><p>  2023.10.17补充：当所有线程都通过了屏障后，屏障会重新关闭，并且计数器也会被重置为初始化值。</p><p>  可以理解为，循环栅栏始终为某批线程服务，线程运行的中间有一些需要等待所有线程都抵达才能执行下一段任务的点。</p></blockquote><h4 id="CyclicBarrier-的原理是什么？"><a href="#CyclicBarrier-的原理是什么？" class="headerlink" title="CyclicBarrier 的原理是什么？"></a>CyclicBarrier 的原理是什么？</h4><p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//每次拦截的线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;<br><span class="hljs-comment">//计数器</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br></code></pre></td></tr></table></figure><p>1、<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p><p>2、当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Semaphore</title>
    <link href="/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/Semaphore/"/>
    <url>/2021/04/06/JUC/%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/Semaphore/</url>
    
    <content type="html"><![CDATA[<h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h3><h4 id="Semaphore（信号量）有什么用？"><a href="#Semaphore（信号量）有什么用？" class="headerlink" title="Semaphore（信号量）有什么用？"></a>Semaphore（信号量）有什么用？</h4><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p><p>Semaphore 的使用简单，我们这里假设有 N(N&gt;5) 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始共享资源数量</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 获取1个许可</span><br>semaphore.acquire();<br><span class="hljs-comment">// 释放1个许可</span><br>semaphore.release();<br></code></pre></td></tr></table></figure><p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p><p><code>Semaphore</code> 有两种模式：。</p><ul><li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li><li><strong>非公平模式：</strong> 抢占式的。</li></ul><p><code>Semaphore</code> 对应的两个构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>  sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>  sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p><p><code>Semaphore</code> 通常用于那些资源有明确访问数量限制的场景比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）。</p><p>Semaphore 的原理是什么？</p><p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p><p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt; 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state &lt;= 0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  获取1个许可证</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 共享模式下获取许可证，获取成功则返回，失败则加入阻塞队列，挂起线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <span class="hljs-comment">// 尝试获取许可证，arg为获取许可证个数，当可用许可证数减当前获取的许可证数结果小于0,则创建一个节点加入阻塞队列，挂起当前线程。</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>      doAcquireSharedInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 释放一个许可证</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>  sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 释放共享锁，同时会唤醒同步队列中的一个线程。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">//释放共享锁</span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>      <span class="hljs-comment">//唤醒同步队列中的一个线程</span><br>      doReleaseShared();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentHashMap/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ConcurrentHashMap-1-7"><a href="#1-ConcurrentHashMap-1-7" class="headerlink" title="1. ConcurrentHashMap 1.7"></a>1. ConcurrentHashMap 1.7</h2><p><code>HashMap</code> 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 <code>Collections.synchronizedMap()</code> 方法来包装我们的 <code>HashMap</code>。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p><p>所以就有了 <code>HashMap</code> 的线程安全版本—— <code>ConcurrentHashMap</code> 的诞生。</p><p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p><p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p><h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img/notes/202403262053961.png" alt="image-20231011160536836"></p><p>Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code> 组合，而每一个 <code>Segment</code> 是一个类似于 <code>HashMap</code> 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p><blockquote><p>个人理解：将一个map分割为N块，最多允许N个线程分别访问每块的数据</p></blockquote><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h3><p>通过 <code>ConcurrentHashMap</code> 的无参构造探寻 <code>ConcurrentHashMap</code> 的初始化流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new, empty map with a default initial capacity (16),</span><br><span class="hljs-comment"> * load factor (0.75) and concurrencyLevel (16).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);<br>&#125;<br></code></pre></td></tr></table></figure><p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认初始化容量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认负载因子</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认并发级别</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure><p>接着看下这个有参构造函数的内部实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,<span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>    <span class="hljs-comment">// 参数校验</span><br>    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span><br>    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)<br>        concurrencyLevel = MAX_SEGMENTS;<br>    <span class="hljs-comment">// Find power-of-two sizes best matching arguments</span><br>    <span class="hljs-comment">// 2的多少次方</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sshift</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ssize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span><br>    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;<br>        ++sshift;<br>        ssize &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 记录段偏移量</span><br>    <span class="hljs-built_in">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;<br>    <span class="hljs-comment">// 记录段掩码</span><br>    <span class="hljs-built_in">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 设置容量</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> initialCapacity / ssize;<br>    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)<br>        ++c;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;<br>    <span class="hljs-comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span><br>    <span class="hljs-keyword">while</span> (cap &lt; c)<br>        cap &lt;&lt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// create segments and segments[0]</span><br>    <span class="hljs-comment">// 创建 Segment 数组，设置 segments[0]</span><br>    Segment&lt;K,V&gt; s0 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="hljs-type">int</span>)(cap * loadFactor),<br>                         (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap]);<br>    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>[ssize];<br>    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span><br>    <span class="hljs-built_in">this</span>.segments = ss;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下在 Java 7 中 ConcurrentHashMap 的初始化逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 <code>concurrencyLevel</code> 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li><li>寻找并发级别 <code>concurrencyLevel</code> 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 <code>segmentShift</code> 偏移量，这个值为【容量 &#x3D; 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift &#x3D; 28</strong>.</li><li>记录 <code>segmentMask</code>，默认是 ssize - 1 &#x3D; 16 -1 &#x3D; 15.</li><li><strong>初始化 <code>segments[0]</code><strong>，</strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75&#x3D;1.5</strong>，插入第二个值时才会进行扩容。</li></ol><h3 id="3-put"><a href="#3-put" class="headerlink" title="3. put"></a>3. put</h3><p>接着上面的初始化参数继续查看 put 方法源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Maps the specified key to the specified value in this table.</span><br><span class="hljs-comment"> * Neither the key nor the value can be null.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span><br><span class="hljs-comment"> * with a key that is equal to the original key.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key key with which the specified value is to be associated</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value value to be associated with the specified key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br><span class="hljs-comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified key or value is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    Segment&lt;K,V&gt; s;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span><br>    <span class="hljs-comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="hljs-comment">// nonvolatile; recheck</span><br>         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-literal">null</span>) <span class="hljs-comment">//  in ensureSegment</span><br>        <span class="hljs-comment">// 如果查找到的 Segment 为空，初始化</span><br>        s = ensureSegment(j);<br>    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the segment for the given index, creating it and</span><br><span class="hljs-comment"> * recording in segment table (via CAS) if not already present.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k the index</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the segment</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">private</span> Segment&lt;K,V&gt; <span class="hljs-title function_">ensureSegment</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="hljs-built_in">this</span>.segments;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="hljs-comment">// raw offset</span><br>    Segment&lt;K,V&gt; seg;<br>    <span class="hljs-comment">// 判断 u 位置的 Segment 是否为null</span><br>    <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="hljs-literal">null</span>) &#123;<br>        Segment&lt;K,V&gt; proto = ss[<span class="hljs-number">0</span>]; <span class="hljs-comment">// use segment 0 as prototype</span><br>        <span class="hljs-comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> proto.table.length;<br>        <span class="hljs-comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> proto.loadFactor;<br>        <span class="hljs-comment">// 计算扩容阀值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(cap * lf);<br>        <span class="hljs-comment">// 创建一个 cap 容量的 HashEntry 数组</span><br>        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap];<br>        <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// recheck</span><br>            <span class="hljs-comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span><br>            Segment&lt;K,V&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);<br>            <span class="hljs-comment">// 自旋检查 u 位置的 Segment 是否为null</span><br>            <span class="hljs-keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                   == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 使用CAS 赋值，只会成功一次</span><br>                <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="hljs-literal">null</span>, seg = s))<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> seg;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的源码分析了 <code>ConcurrentHashMap</code> 在 put 一个数据时的处理流程，下面梳理下具体流程。</p><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 <code>Segment</code>。</p></li><li><p>如果指定位置的 <code>Segment</code> 为空，则初始化这个 <code>Segment</code>.</p><p><strong>初始化 Segment 流程：</strong></p><ol><li>检查计算得到的位置的 <code>Segment</code> 是否为 null.</li><li>为 null 继续初始化，使用 <code>Segment[0]</code> 的容量和负载因子创建一个 <code>HashEntry</code> 数组。</li><li>再次检查计算得到的指定位置的 <code>Segment</code> 是否为 null.</li><li>使用创建的 <code>HashEntry</code> 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 <code>Segment</code> 是否为 null，使用 CAS 在这个位置赋值为 <code>Segment</code>.</li></ol></li><li><p><code>Segment.put</code> 插入 key,value 值。</p></li></ol><p>上面探究了获取 <code>Segment</code> 段和初始化 <code>Segment</code> 段的操作。最后一行的 <code>Segment</code> 的 put 方法还没有查看，继续分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span><br>    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-literal">null</span> : scanAndLockForPut(key, hash, value);<br>    V oldValue;<br>    <span class="hljs-keyword">try</span> &#123;<br>        HashEntry&lt;K,V&gt;[] tab = table;<br>        <span class="hljs-comment">// 计算要put的数据位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (tab.length - <span class="hljs-number">1</span>) &amp; hash;<br>        <span class="hljs-comment">// CAS 获取 index 坐标的值</span><br>        HashEntry&lt;K,V&gt; first = entryAt(tab, index);<br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span><br>                K k;<br>                <span class="hljs-keyword">if</span> ((k = e.key) == key ||<br>                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;<br>                    oldValue = e.value;<br>                    <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                        e.value = value;<br>                        ++modCount;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                e = e.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span><br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>                    node.setNext(first);<br>                <span class="hljs-keyword">else</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span><br>                <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)<br>                    rehash(node);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span><br>                    setEntryAt(tab, index, node);<br>                ++modCount;<br>                count = c;<br>                oldValue = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>Segment</code> 继承了 <code>ReentrantLock</code>，所以 <code>Segment</code> 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p><code>tryLock()</code> 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p></li><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 <code>HashEntry</code> 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 <code>HashEntry</code> 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p><p>如果这个位置上的 <strong><code>HashEntry</code> 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接头插法插入。</li></ol><p>如果这个位置上的 <strong><code>HashEntry</code> 存在</strong>：</p><ol><li>判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li><li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表头插法插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p></li></ol><p>这里面的第一步中的 <code>scanAndLockForPut</code> 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 <code>HashEntry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashEntry&lt;K,V&gt; <span class="hljs-title function_">scanAndLockForPut</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value)</span> &#123;<br>    HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-built_in">this</span>, hash);<br>    HashEntry&lt;K,V&gt; e = first;<br>    HashEntry&lt;K,V&gt; node = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">retries</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// negative while locating node</span><br>    <span class="hljs-comment">// 自旋获取锁</span><br>    <span class="hljs-keyword">while</span> (!tryLock()) &#123;<br>        HashEntry&lt;K,V&gt; f; <span class="hljs-comment">// to recheck first below</span><br>        <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-comment">// speculatively create node</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>);<br>                retries = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.equals(e.key))<br>                retries = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                e = e.next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;<br>            <span class="hljs-comment">// 自旋达到指定次数后，阻塞等到只到获取到锁</span><br>            lock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp;<br>                 (f = entryForHash(<span class="hljs-built_in">this</span>, hash)) != first) &#123;<br>            e = first = f; <span class="hljs-comment">// re-traverse if entry changed</span><br>            retries = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-扩容-rehash"><a href="#4-扩容-rehash" class="headerlink" title="4. 扩容 rehash"></a>4. 扩容 rehash</h3><p><code>ConcurrentHashMap</code> 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 <code>index+ oldSize</code>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">(HashEntry&lt;K,V&gt; node)</span> &#123;<br>    HashEntry&lt;K,V&gt;[] oldTable = table;<br>    <span class="hljs-comment">// 老容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-comment">// 新容量，扩大两倍</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 新的扩容阀值</span><br>    threshold = (<span class="hljs-type">int</span>)(newCapacity * loadFactor);<br>    <span class="hljs-comment">// 创建新的数组</span><br>    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[newCapacity];<br>    <span class="hljs-comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sizeMask</span> <span class="hljs-operator">=</span> newCapacity - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; oldCapacity ; i++) &#123;<br>        <span class="hljs-comment">// 遍历老数组</span><br>        HashEntry&lt;K,V&gt; e = oldTable[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            HashEntry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-comment">// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> e.hash &amp; sizeMask;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)   <span class="hljs-comment">//  Single node on list</span><br>                <span class="hljs-comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span><br>                newTable[idx] = e;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Reuse consecutive sequence at same slot</span><br>                <span class="hljs-comment">// 如果是链表了</span><br>                HashEntry&lt;K,V&gt; lastRun = e;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">lastIdx</span> <span class="hljs-operator">=</span> idx;<br>                <span class="hljs-comment">// 新的位置只可能是不便或者是老的位置+老的容量。</span><br>                <span class="hljs-comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="hljs-literal">null</span>; last = last.next) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> last.hash &amp; sizeMask;<br>                    <span class="hljs-keyword">if</span> (k != lastIdx) &#123;<br>                        lastIdx = k;<br>                        lastRun = last;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span><br>                newTable[lastIdx] = lastRun;<br>                <span class="hljs-comment">// Clone remaining nodes</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;<br>                    <span class="hljs-comment">// 遍历剩余元素，头插法到指定 k 位置。</span><br>                    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> p.value;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> p.hash;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> h &amp; sizeMask;<br>                    HashEntry&lt;K,V&gt; n = newTable[k];<br>                    newTable[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 头插法插入新的节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nodeIndex</span> <span class="hljs-operator">=</span> node.hash &amp; sizeMask; <span class="hljs-comment">// add the new node</span><br>    node.setNext(newTable[nodeIndex]);<br>    newTable[nodeIndex] = node;<br>    table = newTable;<br>&#125;<br></code></pre></td></tr></table></figure><p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p><h3 id="5-get"><a href="#5-get" class="headerlink" title="5. get"></a>5. get</h3><p>到这里就很简单了，get 方法只需要两步即可。</p><ol><li>计算得到 key 的存放位置。</li><li>遍历指定位置查找相同 key 的 value 值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Segment&lt;K,V&gt; s; <span class="hljs-comment">// manually integrate access methods to reduce overhead</span><br>    HashEntry&lt;K,V&gt;[] tab;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;<br>    <span class="hljs-comment">// 计算得到 key 的存放位置</span><br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-literal">null</span> &amp;&amp;<br>        (tab = s.table) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile<br>                 (tab, ((<span class="hljs-type">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);<br>             e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>            <span class="hljs-comment">// 如果是链表，遍历查找到相同 key 的 value。</span><br>            K k;<br>            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))<br>                <span class="hljs-keyword">return</span> e.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-ConcurrentHashMap-1-8"><a href="#2-ConcurrentHashMap-1-8" class="headerlink" title="2. ConcurrentHashMap 1.8"></a>2. ConcurrentHashMap 1.8</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img/notes/202403262053962.png" alt="image-20231011161137885"></p><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h3 id="2-初始化-initTable"><a href="#2-初始化-initTable" class="headerlink" title="2. 初始化 initTable"></a>2. 初始化 initTable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initializes table, using the size recorded in sizeCtl.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//正在初始化或者正在扩容</span><br>            <span class="hljs-comment">//使当前线程从执行状态变为可执行状态（就绪状态）即自旋</span><br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//sc没变置为-1返回true,否则直接false</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从源码中可以发现 <code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化</li><li>-N 说明有 N-1 个线程正在进行扩容</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</li></ol><h3 id="3-put-1"><a href="#3-put-1" class="headerlink" title="3. put"></a>3. put</h3><p>直接过一遍 put 源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// key 和 value 不能为空</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        <span class="hljs-comment">// f = 目标位置元素</span><br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<span class="hljs-comment">// fh 后面存放目标位置的元素 hash 值</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span><br>            tab = initTable();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 使用 synchronized 加锁加入节点</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">// 说明是链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">// 循环加入新的或者覆盖节点</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        <span class="hljs-comment">// 红黑树</span><br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>根据 key 计算出 hashcode 。</p></li><li><p>判断是否需要进行初始化。</p></li><li><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p></li><li><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据。</p></li><li><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</p></li></ol><h3 id="4-get"><a href="#4-get" class="headerlink" title="4. get"></a>4. get</h3><p>get 流程比较简单，直接过一遍源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br>    <span class="hljs-comment">// key 所在的 hash 位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果指定位置元素存在，头结点hash值相同</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-comment">// key hash 值相等，key值相同，直接返回元素 value</span><br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span><br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 是链表，遍历查找</span><br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下 get 过程：</p><ol><li>根据 hash 值计算位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li><li>如果是链表，遍历查找之。</li></ol><p>总结：</p><p>总的来说 <code>ConcurrentHashMap</code> 在 Java8 中相对于 Java7 来说变化还是挺大的。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Java7 中 <code>ConcurrentHashMap</code> 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 <code>Segment</code> 都是一个类似 <code>HashMap</code> 数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code>Segment</code> 的个数一但初始化就不能改变。</p><p>Java8 中的 <code>ConcurrentHashMap</code> 使用的 <code>Synchronized</code> 锁加 CAS 的机制。结构也由 Java7 中的 <strong><code>Segment</code> 数组 + <code>HashEntry</code> 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突在达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><p><code>Synchronized</code> 锁自从引入锁升级策略后，性能不再是问题</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentLinkedQueue</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentLinkedQueue/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentLinkedQueue/</url>
    
    <content type="html"><![CDATA[<p>Java 提供的线程安全的 <code>Queue</code> 可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，其中阻塞队列的典型例子是 <code>BlockingQueue</code>，非阻塞队列的典型例子是 <code>ConcurrentLinkedQueue</code>，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 <strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p><p>从名字可以看出，<code>ConcurrentLinkedQueue</code>这个队列使用链表作为其数据结构．<code>ConcurrentLinkedQueue</code> 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p><p><code>ConcurrentLinkedQueue</code> 内部代码我们就不分析了，大家知道 <code>ConcurrentLinkedQueue</code> 主要使用 CAS 非阻塞算法来实现线程安全就好了。</p><p><code>ConcurrentLinkedQueue</code> 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 <code>ConcurrentLinkedQueue</code> 来替代。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentSkipListMap</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentSkipListMap/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ConcurrentSkipListMap/</url>
    
    <content type="html"><![CDATA[<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p>跳表：是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 <strong>O(logn)</strong> 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p><p>跳表的本质是同时维护了多个链表，并且链表是分层的，</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img/notes/202403262053191.png" alt="image-20231015200039484">2级索引跳表</p><p>最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</p><p>跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素 18。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img/notes/202403262053192.png" alt="image-20231015200136478">在跳表中查找元素18</p><p>查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</p><p>从上面很容易看出，<strong>跳表是一种利用空间换时间的算法。</strong></p><p>使用跳表实现 <code>Map</code> 和使用哈希算法实现 <code>Map</code> 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。</p><p>所以当需要有序的结果时，使用ConcurrentSkipListMap。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CopyOnWriteArrayList</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/CopyOnWriteArrayList/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/CopyOnWriteArrayList/</url>
    
    <content type="html"><![CDATA[<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>JDK1.5之前，线程安全的List只有Vector，但是Vector过于老旧（CRUD都加了synchronized，性能非常低）。</p><p>JDK1.5 引入了 JUC，其中唯一的线程安全List实现就是 <code>CopyOnWriteArrayList</code> 。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>对于大部分业务场景而言，读的操作都是多于写的操作的，而对读的操作加锁其实就是浪费资源（读操作不会更改数据），所以我们应该允许多个线程同时访问 <code>List</code> 的内部数据（对读操作是安全的）。</p><p>为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。</p><p><code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，从 <code>CopyOnWriteArrayList</code> 的名字就能看出了。</p><h3 id="Copy-On-Write-的思想是什么？"><a href="#Copy-On-Write-的思想是什么？" class="headerlink" title="Copy-On-Write 的思想是什么？"></a>Copy-On-Write 的思想是什么？</h3><p><code>CopyOnWriteArrayList</code>名字中的“Copy-On-Write”即写时复制，简称 COW。</p><p>核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p><blockquote><p>写的时候，写线程写自己的，读线程读原数组，等待写线程修改完数据副本后，再将数据赋值回原数据。</p></blockquote><p>可以看出，写时复制机制非常适合读多写少的并发场景，能够极大地提高系统的并发性能。</p><p>COW 的缺点：</p><ol><li>写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。</li><li>内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。</li><li>数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。</li></ol><h2 id="CopyOnWriteArrayList-源码分析"><a href="#CopyOnWriteArrayList-源码分析" class="headerlink" title="CopyOnWriteArrayList 源码分析"></a>CopyOnWriteArrayList 源码分析</h2><p>JDK1.8 为例，CopyOnWriteArrayList 的底层核心源码。</p><p><code>CopyOnWriteArrayList</code> 实现了以下接口：</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>RandomAccess</code> ：这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li></ul><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img/notes/202403262053988.png" alt="image-20231015184956043"></p><p>CopyOnWriteArrayList 类图</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>CopyOnWriteArrayList</code> 中有一个无参构造函数和两个有参构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个空的 CopyOnWriteArrayList</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArrayList</span><span class="hljs-params">()</span> &#123;<br>    setArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-comment">// 按照集合的迭代器返回的顺序创建一个包含指定集合元素的 CopyOnWriteArrayList</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    Object[] elements;<br>    <span class="hljs-keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)<br>        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();<br>    <span class="hljs-keyword">else</span> &#123;<br>        elements = c.toArray();<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elements.getClass() != Object[].class)<br>            elements = Arrays.copyOf(elements, elements.length, Object[].class);<br>    &#125;<br>    setArray(elements);<br>&#125;<br><br><span class="hljs-comment">// 创建一个包含指定数组的副本的列表</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArrayList</span><span class="hljs-params">(E[] toCopyIn)</span> &#123;<br>    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p><code>CopyOnWriteArrayList</code> 的 <code>add()</code>方法有三个版本：</p><ul><li><code>add(E e)</code>：在 <code>CopyOnWriteArrayList</code> 的尾部插入元素。</li><li><code>add(int index, E element)</code>：在 <code>CopyOnWriteArrayList</code> 的指定位置插入元素。</li><li><code>addIfAbsent(E e)</code>：如果指定元素不存在，那么添加该元素。如果成功添加元素则返回 true。</li></ul><p>这里以<code>add(E e)</code>为例进行介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 加锁</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取原来的数组</span><br>        Object[] elements = getArray();<br>        <span class="hljs-comment">// 原来数组的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 元素放在新数组末尾</span><br>        newElements[len] = e;<br>        <span class="hljs-comment">// array指向新数组</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的源码可以看出：</p><ul><li><code>add</code>方法内部用到了 <code>ReentrantLock</code> 加锁，保证了同步，避免了多线程写的时候会复制出多个副本出来。锁被修饰保证了锁的内存地址肯定不会被修改，并且，释放锁的逻辑放在 finally 中，可以保证锁能被释放。</li><li><code>CopyOnWriteArrayList</code> 通过复制底层数组的方式实现写操作。</li><li>每次写操作都需要通过 <code>Arrays.copyOf</code> 复制底层数组，时间复杂度是 O(n) 的，且会占用额外的内存空间。因此，CopyOnWriteArrayList 适用于读多写少的场景，在写操作不频繁且内存资源充足的情况下，可以提升系统的性能表现（更适用）。</li><li><code>CopyOnWriteArrayList</code> 中并没有类似于 <code>ArrayList</code> 的 <code>grow()</code> 方法扩容的操作。</li></ul><blockquote><p><code>Arrays.copyOf</code> 方法的时间复杂度是 O(n)，其中 n 表示需要复制的数组长度。因为这个方法的实现原理是先创建一个新的数组，然后将源数组中的数据复制到新数组中，最后返回新数组。这个方法会复制整个数组，因此其时间复杂度与数组长度成正比，即 O(n)。值得注意的是，由于底层调用了系统级别的拷贝指令，因此在实际应用中这个方法的性能表现比较优秀，但是也需要注意控制复制的数据量，避免出现内存占用过高的情况。</p></blockquote><h3 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h3><p><code>CopyOnWriteArrayList</code> 的读取操作是基于内部数组 <code>array</code> ，并不会发生实际的修改。（因此在读取操作时不需要进行同步控制和锁操作，可以保证数据的安全性。这种机制下，多个线程可以同时读取列表中的元素）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 底层数组，只能通过getArray和setArray方法访问</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br><br><span class="hljs-keyword">final</span> Object[] getArray() &#123;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(Object[] a, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，<code>get</code>方法是弱一致性的，在某些情况下可能读到旧的元素值。</p><blockquote><p><code>get(int index)</code>方法是分两步进行的：</p><ol><li>通过<code>getArray()</code>获取当前数组的引用；</li><li>直接从数组中获取下标为 index 的元素。</li></ol><p>这个过程并没有加锁，所以在并发环境下可能出现如下情况：</p><ol><li>线程 1 调用<code>get(int index)</code>方法获取值，内部通过<code>getArray()</code>方法获取到了 array 属性值；</li><li>线程 2 调用<code>CopyOnWriteArrayList</code>的<code>add</code>、<code>set</code>、<code>remove</code> 等修改方法时，内部通过<code>setArray</code>方法修改了<code>array</code>属性的值；</li><li>线程 1 还是从旧的 <code>array</code> 数组中取值。</li></ol></blockquote><h3 id="获取列表中元素的个数"><a href="#获取列表中元素的个数" class="headerlink" title="获取列表中元素的个数"></a>获取列表中元素的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getArray().length;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CopyOnWriteArrayList</code>中的<code>array</code>数组每次复制都刚好能够容纳下所有元素，并不像<code>ArrayList</code>那样会预留一定的空间，因此 CopyOnWriteArrayList 中并没有<code>size</code>属性。CopyOnWriteArrayList 的底层数组的长度就是元素个数，因此<code>size()</code>方法只要返回数组长度就可以了。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><code>CopyOnWriteArrayList</code>删除元素相关的方法一共有 4 个：</p><ol><li><code>remove(int index)</code>：移除此列表中指定位置上的元素。将任何后续元素向左移动（从它们的索引中减去 1）。</li><li><code>boolean remove(Object o)</code>：删除此列表中首次出现的指定元素，如果不存在该元素则返回 false。</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>：从此列表中删除指定集合中包含的所有元素。</li><li><code>void clear()</code>：移除此列表中的所有元素。</li></ol><p>这里以<code>remove(int index)</code>为例进行介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 获取可重入锁</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 加锁</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取当前array数组</span><br>        Object[] elements = getArray();<br>        <span class="hljs-comment">// 获取当前array长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">//获取指定索引的元素(旧值)</span><br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> get(elements, index);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> len - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 判断删除的是否是最后一个元素</span><br>        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 如果删除的是最后一个元素，直接复制该元素前的所有元素到新的数组</span><br>            setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 分段复制，将index前的元素和index+1后的元素复制到新数组</span><br>            <span class="hljs-comment">// 新数组长度为旧数组长度-1</span><br>            Object[] newElements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[len - <span class="hljs-number">1</span>];<br>            System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);<br>            System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,<br>                             numMoved);<br>            <span class="hljs-comment">//将新数组赋值给array引用</span><br>            setArray(newElements);<br>        &#125;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>       <span class="hljs-comment">// 解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h3><p><code>CopyOnWriteArrayList</code>提供了两个用于判断指定元素是否在列表中的方法：</p><ul><li><code>contains(Object o)</code>：判断是否包含指定元素。</li><li><code>containsAll(Collection&lt;?&gt; c)</code>：判断是否保证指定集合的全部元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否包含指定元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">//获取当前array数组</span><br>    Object[] elements = getArray();<br>    <span class="hljs-comment">//调用index尝试查找指定元素，如果返回值大于等于0，则返回true，否则返回false</span><br>    <span class="hljs-keyword">return</span> indexOf(o, elements, <span class="hljs-number">0</span>, elements.length) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断是否保证指定集合的全部元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>    <span class="hljs-comment">//获取当前array数组</span><br>    Object[] elements = getArray();<br>    <span class="hljs-comment">//获取数组长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>    <span class="hljs-comment">//遍历指定集合</span><br>    <span class="hljs-keyword">for</span> (Object e : c) &#123;<br>        <span class="hljs-comment">//循环调用indexOf方法判断，只要有一个没有包含就直接返回false</span><br>        <span class="hljs-keyword">if</span> (indexOf(e, elements, <span class="hljs-number">0</span>, len) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//最后表示全部包含或者制定集合为空集合，那么返回true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CopyOnWriteArrayList-常用方法测试"><a href="#CopyOnWriteArrayList-常用方法测试" class="headerlink" title="CopyOnWriteArrayList 常用方法测试"></a>CopyOnWriteArrayList 常用方法测试</h2><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个 CopyOnWriteArrayList 对象</span><br>CopyOnWriteArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 向列表中添加元素</span><br>list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;初始列表：&quot;</span> + list);<br><br><span class="hljs-comment">// 使用 get 方法获取指定位置的元素</span><br>System.out.println(<span class="hljs-string">&quot;列表第二个元素为：&quot;</span> + list.get(<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">// 使用 remove 方法删除指定元素</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-string">&quot;C++&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;删除结果：&quot;</span> + result);<br>System.out.println(<span class="hljs-string">&quot;列表删除元素后为：&quot;</span> + list);<br><br><span class="hljs-comment">// 使用 set 方法更新指定位置的元素</span><br>list.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Golang&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;列表更新后为：&quot;</span> + list);<br><br><span class="hljs-comment">// 使用 add 方法在指定位置插入元素</span><br>list.add(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;PHP&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;列表插入元素后为：&quot;</span> + list);<br><br><span class="hljs-comment">// 使用 size 方法获取列表大小</span><br>System.out.println(<span class="hljs-string">&quot;列表大小为：&quot;</span> + list.size());<br><br><span class="hljs-comment">// 使用 removeAll 方法删除指定集合中所有出现的元素</span><br>result = list.removeAll(List.of(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Golang&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;批量删除结果：&quot;</span> + result);<br>System.out.println(<span class="hljs-string">&quot;列表批量删除元素后为：&quot;</span> + list);<br><br><span class="hljs-comment">// 使用 clear 方法清空列表中所有元素</span><br>list.clear();<br>System.out.println(<span class="hljs-string">&quot;列表清空后为：&quot;</span> + list);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">列表更新后为：[Java, Golang]<br>列表插入元素后为：[PHP, Java, Golang]<br>列表大小为：3<br>批量删除结果：true<br>列表批量删除元素后为：[PHP]<br>列表清空后为：[]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayBlockingQueue</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/ArrayBlockingQueue/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/ArrayBlockingQueue/</url>
    
    <content type="html"><![CDATA[<p>阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><p><code>BlockingQueue</code> 是一个接口，继承自 <code>Queue</code>，所以其实现类也可以作为 <code>Queue</code> 的实现来使用，而 <code>Queue</code> 又继承自 <code>Collection</code> 接口。下面是 <code>BlockingQueue</code> 的相关实现类。</p><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img/notes/202403262052693.png" alt="image-20231015192213401"></p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p> <code>BlockingQueue</code> 接口的有界队列实现类，底层采用数组来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;E&gt;<br><span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, Serializable&#123;&#125;<br></code></pre></td></tr></table></figure><p><code>ArrayBlockingQueue</code> 一旦创建，容量不能改变。其并发控制采用可重入锁 <code>ReentrantLock</code> ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p><p>当队列容量满时，尝试将元素放入队列将导致操作阻塞; 尝试从一个空队列中取一个元素也会同样阻塞。</p><p><code>ArrayBlockingQueue</code> 默认情况下不能保证线程访问队列的公平性(即最先等待的线程能够最先访问到)。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置公平性d</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="hljs-number">10</span>,<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedBlockingQueue</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/LinkedBlockingQueue/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/LinkedBlockingQueue/</url>
    
    <content type="html"><![CDATA[<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p><code>LinkedBlockingQueue</code> 底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，满足 FIFO 的特性.</p><p>与 <code>ArrayBlockingQueue</code> 相比起来具有更高的吞吐量。</p><blockquote><p><strong>在大部分并发场景下，LinkedBlockingQueue的吞吐量比ArrayBlockingQueue更高</strong>。这主要是因为LinkedBlockingQueue使用双锁可并行读写，而ArrayBlockingQueue在插入或删除元素时需要直接操作数组，可能会产生额外的开销。</p></blockquote><p>通常在创建 <code>LinkedBlockingQueue</code> 对象时，会指定其大小，如果未指定，容量等于 <code>Integer.MAX_VALUE</code> (可能会导致损耗大量内存，所以一般都会初始化大小)。</p><p><strong>相关构造方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *某种意义上的无界队列</span><br><span class="hljs-comment"> * Creates a &#123;<span class="hljs-doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Integer#MAX_VALUE&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(Integer.MAX_VALUE);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *有界队列</span><br><span class="hljs-comment"> * Creates a &#123;<span class="hljs-doctag">@code</span> LinkedBlockingQueue&#125; with the given (fixed) capacity.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> capacity the capacity of this queue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if &#123;<span class="hljs-doctag">@code</span> capacity&#125; is not greater</span><br><span class="hljs-comment"> *         than zero</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.capacity = capacity;<br>    last = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PriorityBlockingQueue</title>
    <link href="/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/PriorityBlockingQueue/"/>
    <url>/2021/04/06/JUC/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/BlockingQueue/PriorityBlockingQueue/</url>
    
    <content type="html"><![CDATA[<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。</p><p><code>PriorityBlockingQueue</code> 并发控制采用的是可重入锁 <code>ReentrantLock</code>，队列为无界队列（<code>ArrayBlockingQueue</code> 是有界队列，<code>LinkedBlockingQueue</code> 也可以通过在构造函数中传入 <code>capacity</code> 指定队列最大的容量，但是 <code>PriorityBlockingQueue</code> 只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>，即无界队列）。</p><p>简单地说，它就是 <code>PriorityQueue</code> 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 <code>ClassCastException</code> 异常。</p><p>它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL命令</title>
    <link href="/2021/04/06/DB/SQL%E8%AF%AD%E5%8F%A5/"/>
    <url>/2021/04/06/DB/SQL%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>限制结果数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">.limit(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>根据条件排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">.sort(&#123;send_date: <span class="hljs-number">-1</span>&#125;)<br></code></pre></td></tr></table></figure><p>执行详情</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">.explain(<span class="hljs-string">&#x27;executionStats&#x27;</span>)<br></code></pre></td></tr></table></figure><p>多条件取交集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;$<span class="hljs-keyword">and</span>:[&#123;&#125;,&#123;&#125;]&#125;<br></code></pre></td></tr></table></figure><p>存在某属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;GPSX0:&#123;$<span class="hljs-keyword">exists</span>:<span class="hljs-literal">true</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>指定字段是否显示(默认0，_id默认为1)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find(<br>    &#123;&#125;,<br>    &#123; user_id: <span class="hljs-number">1</span>, status: <span class="hljs-number">1</span> &#125;<br>) <br></code></pre></td></tr></table></figure><p>曾用命令记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.result_msgv1.find(&#123;GLIDERID_IRID:<span class="hljs-number">162</span>&#125;).sort(&#123;send_date: <span class="hljs-number">-1</span>&#125;).limit(<span class="hljs-number">1</span>).explain(<span class="hljs-string">&#x27;executionStats&#x27;</span>);<br><br>db.result_msgv1.find(&#123;$<span class="hljs-keyword">and</span>:[&#123;GLIDERID_IRID:<span class="hljs-number">162</span>&#125;,&#123;GPSX0:&#123;$<span class="hljs-keyword">exists</span>:<span class="hljs-literal">true</span>&#125;&#125;,&#123;GPSY0:&#123;$<span class="hljs-keyword">exists</span>:<span class="hljs-literal">true</span>&#125;&#125;]&#125;).sort(&#123;send_date: <span class="hljs-number">-1</span>&#125;).limit(<span class="hljs-number">1</span>).explain(<span class="hljs-string">&#x27;executionStats&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>StampedLock</title>
    <link href="/2021/04/06/JUC/StampedLock/"/>
    <url>/2021/04/06/JUC/StampedLock/</url>
    
    <content type="html"><![CDATA[<h4 id="StampedLock-是什么？"><a href="#StampedLock-是什么？" class="headerlink" title="StampedLock 是什么？"></a>StampedLock 是什么？</h4><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 <code>Conditon</code>。</p><p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StampedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>StampedLock</code> 提供了三种模式的读写控制模式：读锁、写锁和乐观读。</p><ul><li><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是不可重入的。</li><li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</li><li><strong>乐观读</strong>：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</li></ul><p>另外，<code>StampedLock</code> 还支持这三种锁在一定条件下进行相互转换 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToWriteLock</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToReadLock</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToOptimisticRead</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p><code>StampedLock</code> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是<code>StampedLock</code>不可重入的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> s, next;  <span class="hljs-comment">// bypass acquireWrite in fully unlocked case only</span><br>    <span class="hljs-keyword">return</span> ((((s = state) &amp; ABITS) == <span class="hljs-number">0L</span> &amp;&amp;<br>             U.compareAndSwapLong(<span class="hljs-built_in">this</span>, STATE, s, next = s + WBIT)) ?<br>            next : acquireWrite(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>));<br>&#125;<br><span class="hljs-comment">// 读锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state, next;  <span class="hljs-comment">// bypass acquireRead on common uncontended case</span><br>    <span class="hljs-keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;<br>             U.compareAndSwapLong(<span class="hljs-built_in">this</span>, STATE, s, next = s + RUNIT)) ?<br>            next : acquireRead(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>));<br>&#125;<br><span class="hljs-comment">// 乐观读</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">tryOptimisticRead</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> s;<br>    <span class="hljs-keyword">return</span> (((s = state) &amp; WBIT) == <span class="hljs-number">0L</span>) ? (s &amp; SBITS) : <span class="hljs-number">0L</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="StampedLock-的性能为什么更好？"><a href="#StampedLock-的性能为什么更好？" class="headerlink" title="StampedLock 的性能为什么更好？"></a>StampedLock 的性能为什么更好？</h4><p>相比于传统读写锁多出来的乐观读是<code>StampedLock</code>比 <code>ReadWriteLock</code> 性能更好的关键原因。<code>StampedLock</code> 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。</p><h4 id="StampedLock-适合什么场景？"><a href="#StampedLock-适合什么场景？" class="headerlink" title="StampedLock 适合什么场景？"></a>StampedLock 适合什么场景？</h4><p>和 <code>ReentrantReadWriteLock</code> 一样，<code>StampedLock</code> 同样适合读多写少的业务场景，可以作为 <code>ReentrantReadWriteLock</code>的替代品，性能更好。</p><p>不过，需要注意的是<code>StampedLock</code>不可重入，不支持条件变量 <code>Conditon</code>，对中断操作支持也不友好（使用不当容易导致 CPU 飙升）。如果你需要用到 <code>ReentrantLock</code> 的一些高级性能，就不太建议使用 <code>StampedLock</code> 了。</p><p>另外，<code>StampedLock</code> 性能虽好，但使用起来相对比较麻烦，一旦使用不当，就会出现生产问题。强烈建议你在使用<code>StampedLock</code> 之前，看看 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html">StampedLock 官方文档中的案例open in new window</a>。</p><h4 id="StampedLock-的底层原理了解吗？"><a href="#StampedLock-的底层原理了解吗？" class="headerlink" title="StampedLock 的底层原理了解吗？"></a>StampedLock 的底层原理了解吗？</h4><p><code>StampedLock</code> 不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。<code>StampedLock</code> 通过 CLH 队列进行线程的管理，通过同步状态值 <code>state</code> 来表示锁的状态和类型。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据处理之Matplotlib-入门篇</title>
    <link href="/2021/04/06/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BMatplotlib-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <url>/2021/04/06/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BMatplotlib-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="实验二、数据处理之Matplotlib"><a href="#实验二、数据处理之Matplotlib" class="headerlink" title="实验二、数据处理之Matplotlib"></a>实验二、数据处理之Matplotlib</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><h4 id="1-了解matplotlib库的基本功能"><a href="#1-了解matplotlib库的基本功能" class="headerlink" title="1. 了解matplotlib库的基本功能"></a>1. 了解matplotlib库的基本功能</h4><h4 id="2-掌握matplotlib库的使用方法"><a href="#2-掌握matplotlib库的使用方法" class="headerlink" title="2. 掌握matplotlib库的使用方法"></a>2. 掌握matplotlib库的使用方法</h4><h3 id="二、实验工具："><a href="#二、实验工具：" class="headerlink" title="二、实验工具："></a>二、实验工具：</h3><h4 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h4><h4 id="2-Numpy，matplotlib"><a href="#2-Numpy，matplotlib" class="headerlink" title="2. Numpy，matplotlib"></a>2. Numpy，matplotlib</h4><h3 id="三、Matplotlib简介"><a href="#三、Matplotlib简介" class="headerlink" title="三、Matplotlib简介"></a>三、Matplotlib简介</h3><p>Matplotlib 包含了几十个不同的模块， 如 matlab、mathtext、finance、dates 等，而 pylot 则是我们最常用的绘图模块</p><h3 id="四、实验内容"><a href="#四、实验内容" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-绘制正弦曲线，并设置标题、坐标轴名称、坐标轴范围"><a href="#1-绘制正弦曲线，并设置标题、坐标轴名称、坐标轴范围" class="headerlink" title="1.绘制正弦曲线，并设置标题、坐标轴名称、坐标轴范围"></a>1.绘制正弦曲线，并设置标题、坐标轴名称、坐标轴范围</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> mpl<br>mpl.<span class="hljs-property">rcParams</span>[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;FangSong&#x27;</span>]<br>mpl.<span class="hljs-property">rcParams</span>[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-title class_">False</span><br>x=np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>*np.<span class="hljs-property">pi</span>, <span class="hljs-number">0.01</span>)<br>y=np.<span class="hljs-title function_">sin</span>(x)<br>plt.<span class="hljs-title function_">plot</span>(x, y)<br>plt.<span class="hljs-title function_">title</span>(u<span class="hljs-string">&#x27;正弦曲线&#x27;</span>, fontdict=&#123;<span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">20</span>&#125;)<br>plt.<span class="hljs-title function_">xlabel</span>(u<span class="hljs-string">&#x27;弧度&#x27;</span>, fontdict=&#123;<span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">16</span>&#125;)<br>plt.<span class="hljs-title function_">ylabel</span>(u<span class="hljs-string">&#x27;正弦值&#x27;</span>, fontdict=&#123;<span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">16</span>&#125;)<br>plt.<span class="hljs-title function_">axis</span>([-<span class="hljs-number">0.1</span>*np.<span class="hljs-property">pi</span>, <span class="hljs-number">2.1</span>*np.<span class="hljs-property">pi</span>, -<span class="hljs-number">1.1</span>, <span class="hljs-number">1.1</span>])<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/743812c8-1d7b-47e0-9c35-d998c65ed92c.png" alt="在这里插入图片描述"></p><h4 id="2-同一坐标系中绘制多种曲线并通过样式、宽度、颜色加以区分"><a href="#2-同一坐标系中绘制多种曲线并通过样式、宽度、颜色加以区分" class="headerlink" title="2. 同一坐标系中绘制多种曲线并通过样式、宽度、颜色加以区分"></a>2. 同一坐标系中绘制多种曲线并通过样式、宽度、颜色加以区分</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> mpl<br>mpl.<span class="hljs-property">rcParams</span>[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;FangSong&#x27;</span>]<br>mpl.<span class="hljs-property">rcParams</span>[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-title class_">False</span><br>x = np.<span class="hljs-title function_">linspace</span>(-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">200</span>)<br>f1 =  np.<span class="hljs-title function_">power</span>(<span class="hljs-number">10</span>, x)<br>f2 = np.<span class="hljs-title function_">power</span>(np.<span class="hljs-property">e</span>, x)<br>f3 = np.<span class="hljs-title function_">power</span>(<span class="hljs-number">2</span>, x)<br>plt.<span class="hljs-title function_">plot</span>(x, f1, <span class="hljs-string">&#x27;r&#x27;</span>, ls=<span class="hljs-string">&#x27;-&#x27;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;$10^x$&#x27;</span>)<br>plt.<span class="hljs-title function_">plot</span>(x, f2, <span class="hljs-string">&#x27;b&#x27;</span>, ls=<span class="hljs-string">&#x27;--&#x27;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;$e^x$&#x27;</span>)<br>plt.<span class="hljs-title function_">plot</span>(x, f3, <span class="hljs-string">&#x27;g&#x27;</span>, ls=<span class="hljs-string">&#x27;:&#x27;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;$2^x$&#x27;</span>)<br>plt.<span class="hljs-title function_">axis</span>([-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">0.5</span>, <span class="hljs-number">8</span>])<br>plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">&#x27;幂函数曲线&#x27;</span>, fontsize=<span class="hljs-number">16</span>)<br>plt.<span class="hljs-title function_">legend</span>(loc=<span class="hljs-string">&#x27;lower right&#x27;</span>)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/4ddd2da8-542b-492f-86a7-abd2f7a137f5.png" alt="在这里插入图片描述"></p><h4 id="3-绘制多轴图，即将多幅子图绘制在同一画板。"><a href="#3-绘制多轴图，即将多幅子图绘制在同一画板。" class="headerlink" title="3.绘制多轴图，即将多幅子图绘制在同一画板。"></a>3.绘制多轴图，即将多幅子图绘制在同一画板。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br>plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">221</span>)<br>x = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>*np.<span class="hljs-property">pi</span>, <span class="hljs-number">0.01</span>)<br>y = np.<span class="hljs-title function_">cos</span>(x)<br>plt.<span class="hljs-title function_">plot</span>(x, y)<br>plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">222</span>)<br>plt.<span class="hljs-title function_">axis</span>([-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>plt.<span class="hljs-title function_">axvline</span>(x=<span class="hljs-number">0</span>, ymin=<span class="hljs-number">0</span>, linewidth=<span class="hljs-number">4</span>, color=<span class="hljs-string">&#x27;g&#x27;</span>)<br>plt.<span class="hljs-title function_">axvline</span>(x=<span class="hljs-number">1.0</span>, ymin=-<span class="hljs-number">0.5</span>, ymax=<span class="hljs-number">0.5</span>, linewidth=<span class="hljs-number">4</span>, color=<span class="hljs-string">&#x27;y&#x27;</span>)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/27a39cd0-9e1c-49a0-bbca-24a6e89f8112.png" alt="image.png"></p><h4 id="4-直方图的绘制-数据自己定义）"><a href="#4-直方图的绘制-数据自己定义）" class="headerlink" title="4.直方图的绘制(数据自己定义）"></a>4.直方图的绘制(数据自己定义）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br>bins = np.<span class="hljs-title function_">arange</span>(-<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)<br>plt.<span class="hljs-title function_">hist</span>(bins)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/5e0672f1-e3a7-421e-a7a5-da23eca2efc2.png" alt="image.png"></p><h4 id="5-绘制散点图"><a href="#5-绘制散点图" class="headerlink" title="5.绘制散点图"></a>5.绘制散点图</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br>x = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">rand</span>(<span class="hljs-number">30</span>)<br>y = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">rand</span>(<span class="hljs-number">30</span>)<br>area = np.<span class="hljs-property">pi</span>*(<span class="hljs-number">15</span>*np.<span class="hljs-property">random</span>.<span class="hljs-title function_">rand</span>(<span class="hljs-number">30</span>))**<span class="hljs-number">2</span><br>color = <span class="hljs-number">2</span>*np.<span class="hljs-property">pi</span>*np.<span class="hljs-property">random</span>.<span class="hljs-title function_">rand</span>(<span class="hljs-number">30</span>)<br>plt.<span class="hljs-title function_">scatter</span>(x, y, s=area, c=color, alpha=<span class="hljs-number">0.5</span>, cmap=plt.<span class="hljs-property">cm</span>.<span class="hljs-property">hsv</span>)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/9e0e5204-ce44-4e69-8735-4034466896be.png" alt="在这里插入图片描述"></p><h4 id="6-绘制盒状图"><a href="#6-绘制盒状图" class="headerlink" title="6.绘制盒状图"></a>6.绘制盒状图</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br>data = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randn</span>(<span class="hljs-number">200</span>)<br>fig, (ax2) = plt.<span class="hljs-title function_">subplots</span>(<span class="hljs-number">1</span>, figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>))<br>ax2.<span class="hljs-title function_">boxplot</span>(data)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/099c75eb-f805-4e69-9a76-62a8fcf6afcc.png" alt="在这里插入图片描述"></p><h4 id="7-尝试matplotlib库的其它功能，如2D-3D等"><a href="#7-尝试matplotlib库的其它功能，如2D-3D等" class="headerlink" title="7.尝试matplotlib库的其它功能，如2D,3D等"></a>7.尝试matplotlib库的其它功能，如2D,3D等</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt<br>y,x = np.<span class="hljs-property">ogrid</span>[-<span class="hljs-number">2</span>:<span class="hljs-number">2</span>:200j, -<span class="hljs-number">3</span>:<span class="hljs-number">3</span>:300j]<br>z = x*np.<span class="hljs-title function_">exp</span>(-x**<span class="hljs-number">2</span> - y**<span class="hljs-number">2</span>)<br>extent = [np.<span class="hljs-title function_">min</span>(x), np.<span class="hljs-title function_">max</span>(x), np.<span class="hljs-title function_">min</span>(y), np.<span class="hljs-title function_">max</span>(y)]<br>plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">211</span>)<br>cs = plt.<span class="hljs-title function_">contour</span>(z, <span class="hljs-number">10</span>, extent=extent)<br>plt.<span class="hljs-title function_">clabel</span>(cs)<br>plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">111</span>)<br>plt.<span class="hljs-title function_">contourf</span>(x.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>), y.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>), z, <span class="hljs-number">20</span>)<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/../images/1a7561d1-dfa9-4595-9ec1-1fd8c97edec9.png" alt="在这里插入图片描述"></p><h3 id="五、实验总结（写出本次实验的收获，遇到的问题等"><a href="#五、实验总结（写出本次实验的收获，遇到的问题等" class="headerlink" title="五、实验总结（写出本次实验的收获，遇到的问题等)"></a>五、实验总结（写出本次实验的收获，遇到的问题等)</h3><p>了解到matplotlib库不是只要你安装了numpy就有了这个库，刚开始做的时候因为没有导入matplotlib库而频频报错。在网上搜索了简易的安装matplotlib库的办法，直接在电脑cmd里面敲两行命令安装即可，不用再很繁琐的在电脑上还要配置环境变量。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据处理之Numpy-入门篇</title>
    <link href="/2021/04/06/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BNumpy-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <url>/2021/04/06/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BNumpy-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="实验一、数据处理之Numpy"><a href="#实验一、数据处理之Numpy" class="headerlink" title="实验一、数据处理之Numpy"></a>实验一、数据处理之Numpy</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><h4 id="1-了解numpy库的基本功能"><a href="#1-了解numpy库的基本功能" class="headerlink" title="1. 了解numpy库的基本功能"></a>1. 了解numpy库的基本功能</h4><h4 id="2-掌握Numpy库的对数组的操作与运算"><a href="#2-掌握Numpy库的对数组的操作与运算" class="headerlink" title="2. 掌握Numpy库的对数组的操作与运算"></a>2. 掌握Numpy库的对数组的操作与运算</h4><h3 id="二、实验工具："><a href="#二、实验工具：" class="headerlink" title="二、实验工具："></a>二、实验工具：</h3><h4 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h4><h4 id="2-Numpy"><a href="#2-Numpy" class="headerlink" title="2. Numpy"></a>2. Numpy</h4><h3 id="三、Numpy简介"><a href="#三、Numpy简介" class="headerlink" title="三、Numpy简介"></a>三、Numpy简介</h3><p>Numpy 的英文全称为 Numerical Python，指Python 面向数值计算的第三方库。Numpy 的特点在于，针对 Python 内建的数组类型做了扩充，支持更高维度的数组和矩阵运算，以及更丰富的数学函数。Numpy 是 Scipy.org 中最重要的库之一，它同时也被 Pandas，Matplotlib 等我们熟知的第三方库作为核心计算库。<br>NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库。专为进行严格的数字处理而产生。多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence Livermore，NASA用其处理一些本来使用C++，Fortran或Matlab等所做的任务。<br>Numpy包括了：1、一个强大的N维数组对象Array；2、比较成熟的（广播）函数库；3、用于整合C&#x2F;C++和Fortran代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数。Numpy和稀疏矩阵运算包scipy配合使用更加方便。</p><h3 id="四、实验内容"><a href="#四、实验内容" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-数组的创建（创建全0数组，全1数组，随机数数组）"><a href="#1-数组的创建（创建全0数组，全1数组，随机数数组）" class="headerlink" title="1. 数组的创建（创建全0数组，全1数组，随机数数组）"></a>1. 数组的创建（创建全0数组，全1数组，随机数数组）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.<span class="hljs-title function_">ones</span>(<span class="hljs-number">5</span>, int)<br><br>b = np.<span class="hljs-title function_">zeros</span>(<span class="hljs-number">5</span>, int)<br><br>f = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;全1数组：\n&quot;</span>, a)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;全0数组:\n&quot;</span>, b)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;随机数数组:\n&quot;</span>, f)<br></code></pre></td></tr></table></figure><p><img src="/../images/87f3125a-a033-417d-bb13-21c84bfcee11.png" alt="image.png"></p><h4 id="2-数组的属性（查看数组的维度，数组元素的个数）"><a href="#2-数组的属性（查看数组的维度，数组元素的个数）" class="headerlink" title="2. 数组的属性（查看数组的维度，数组元素的个数）"></a>2. 数组的属性（查看数组的维度，数组元素的个数）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.<span class="hljs-title function_">ones</span>(<span class="hljs-number">5</span>, int)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;全1数组维度：\n&quot;</span>, a.<span class="hljs-property">ndim</span>)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;全1数组元素个数：\n&quot;</span>, a.<span class="hljs-property">shape</span>)<br></code></pre></td></tr></table></figure><p><img src="/../images/ca928bd1-73d5-47e1-9176-b6f79ad795ad.png" alt="image.png"></p><h4 id="3-数组的维度操作（将数组的行变列，返回最后一个元素，返回第2到第4个元素，返回逆序的数组）"><a href="#3-数组的维度操作（将数组的行变列，返回最后一个元素，返回第2到第4个元素，返回逆序的数组）" class="headerlink" title="3. 数组的维度操作（将数组的行变列，返回最后一个元素，返回第2到第4个元素，返回逆序的数组）"></a>3. 数组的维度操作（将数组的行变列，返回最后一个元素，返回第2到第4个元素，返回逆序的数组）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>c = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">reshape</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;转置前：\n&quot;</span>, c)<br>d = c.<span class="hljs-property">T</span><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;转置后：\n&quot;</span>, d)<br><br>e = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">10</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组为：\n&quot;</span>, e)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;最后一个元素为：\n&quot;</span>, e[-<span class="hljs-number">1</span>])<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;第2到第4元素为：\n&quot;</span>, e[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;逆序数组为：\n&quot;</span>, e[::-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p><img src="/../images/2ae999a3-1cf1-45ff-82ba-e568181a191b.png" alt="image.png"></p><h4 id="4-数组的合并（数组的水平合并，垂直合并，深度合并）"><a href="#4-数组的合并（数组的水平合并，垂直合并，深度合并）" class="headerlink" title="4. 数组的合并（数组的水平合并，垂直合并，深度合并）"></a>4. 数组的合并（数组的水平合并，垂直合并，深度合并）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>c = np.<span class="hljs-title function_">arange</span>(-<span class="hljs-number">9</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_">reshape</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>d = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>).<span class="hljs-title function_">reshape</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;第一个数组为：\n&quot;</span>, c)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;第二个数组为：\n&quot;</span>, d)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;水平合并：\n&quot;</span>, np.<span class="hljs-title function_">hstack</span>((c, d)))<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;垂直合并：\n&quot;</span>, np.<span class="hljs-title function_">hstack</span>((c, d)))<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;深度合并：\n&quot;</span>, np.<span class="hljs-title function_">hstack</span>((c, d)))<br></code></pre></td></tr></table></figure><p><img src="/../images/ae93e798-4d4b-4c8e-9ddf-7d62545b91ab.png" alt="image.png"></p><h4 id="5-数组的拆分（数组的水平拆分，垂直拆分，深度拆分）"><a href="#5-数组的拆分（数组的水平拆分，垂直拆分，深度拆分）" class="headerlink" title="5. 数组的拆分（数组的水平拆分，垂直拆分，深度拆分）"></a>5. 数组的拆分（数组的水平拆分，垂直拆分，深度拆分）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>c = np.<span class="hljs-title function_">arange</span>(-<span class="hljs-number">9</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_">reshape</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组为：\n&quot;</span>, c)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;水平拆分为：\n&quot;</span>, np.<span class="hljs-title function_">hsplit</span>(c, <span class="hljs-number">3</span>))<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;垂直拆分为：\n&quot;</span>, np.<span class="hljs-title function_">vsplit</span>(c, <span class="hljs-number">3</span>))<br><br>d = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">8</span>).<span class="hljs-title function_">reshape</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;待深度拆分数组为：\n&quot;</span>, d)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;深度拆分为：\n&quot;</span>, np.<span class="hljs-title function_">dsplit</span>(d, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p><img src="/../images/fae48d94-2ad6-43c8-aa72-0aed94a6e4bc.png" alt="image.png"><br><img src="/../images/d26678d3-6653-4773-9861-0f972849d3a8.png" alt="image.png"><br><img src="/../images/5fa351ca-284e-4e2c-a03e-bceaebee7270.png" alt="image.png"></p><h4 id="6-数组运算（与常的四则运算，与数组的四则运算，判断数组是否相等）"><a href="#6-数组运算（与常的四则运算，与数组的四则运算，判断数组是否相等）" class="headerlink" title="6. 数组运算（与常的四则运算，与数组的四则运算，判断数组是否相等）"></a>6. 数组运算（与常的四则运算，与数组的四则运算，判断数组是否相等）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">4</span>)<br>b = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;两个数组分别为：\n&quot;</span>, a, b)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;a+2为：\n&quot;</span>, a + <span class="hljs-number">2</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;a+b为：\n&quot;</span>, a+b)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;a-b为：\n&quot;</span>, a-b)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;a*b为：\n&quot;</span>, a*b)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;a/b为：\n&quot;</span>, a/b)<br></code></pre></td></tr></table></figure><p><img src="/../images/ede66728-e054-4b2d-b5ec-ad2353f92c68.png" alt="image.png"></p><h4 id="7-数组的常用函数（数组所有元素的和、积、平均值、最大值、最小值、元素替换、方差、标准差）"><a href="#7-数组的常用函数（数组所有元素的和、积、平均值、最大值、最小值、元素替换、方差、标准差）" class="headerlink" title="7. 数组的常用函数（数组所有元素的和、积、平均值、最大值、最小值、元素替换、方差、标准差）"></a>7. 数组的常用函数（数组所有元素的和、积、平均值、最大值、最小值、元素替换、方差、标准差）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">7</span>)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组为：&quot;</span>, a)<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的和为：&quot;</span>, a.<span class="hljs-title function_">sum</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的积为：&quot;</span>, a.<span class="hljs-title function_">prod</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的平均值为：&quot;</span>, a.<span class="hljs-title function_">mean</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的最大值为：&quot;</span>, a.<span class="hljs-title function_">max</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的最小值为：&quot;</span>, a.<span class="hljs-title function_">min</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的元素小于3的元素替换为3，大于4的元素替换为4：&quot;</span>, a.<span class="hljs-title function_">clip</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的方差为：&quot;</span>, a.<span class="hljs-title function_">var</span>())<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;数组所有元素的标准差为：&quot;</span>, a.<span class="hljs-title function_">std</span>())<br></code></pre></td></tr></table></figure><p><img src="/../images/8d128c0a-6c80-423b-8092-c2ef51f7dd5f.png" alt="image.png"></p><h3 id="五、实验总结（写出本次实验的收获，遇到的问题等）"><a href="#五、实验总结（写出本次实验的收获，遇到的问题等）" class="headerlink" title="五、实验总结（写出本次实验的收获，遇到的问题等）"></a>五、实验总结（写出本次实验的收获，遇到的问题等）</h3><p>学习到了numpy库中的一些函数的使用方法。受益良多，感觉到python库的强大之处，日后一定多加练习，以求对python的常用库的使用更加熟练。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 316. 去除重复字母</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20316.%20%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20316.%20%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="题目-去除重复字母"><a href="#题目-去除重复字母" class="headerlink" title="题目 去除重复字母"></a>题目 去除重复字母</h3><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p>输入：s &#x3D; “bcabc”<br>输出：“abc”</p><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><p>输入：s &#x3D; “cbacdcbc”<br>输出：“acdb”</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s 由小写英文字母组成</p><p>来源：力扣（LeetCode）<br><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">https://leetcode-cn.com/problems/remove-duplicate-letters/</a></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 算法思想</span><br><span class="hljs-comment"> * 当字典序最小时，即12341 12351 主要看4，5的位置</span><br><span class="hljs-comment"> * 用栈存储，当栈空时直接入栈</span><br><span class="hljs-comment"> * 栈不为空时，</span><br><span class="hljs-comment"> * 若栈中包含当前要入栈的元素直接跳到下一次循环。（结果字符串每个字符只含有一次）</span><br><span class="hljs-comment"> * 若当前要入栈的字母比栈顶字母大时，考虑是否栈顶元素出栈</span><br><span class="hljs-comment"> * 若栈顶元素在剩余字符串中仍然存在，那么就可以出栈，出栈后继续判断新的栈顶元素是否出栈。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Stack</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveDuplicateLetters</span> &#123;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">removeDuplicateLetters</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)&#123;<br>        <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-title class_">Character</span>&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-title class_">Character</span>&gt;();<br>            <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-title function_">length</span>(); i++) &#123;<br>                char c=s.<span class="hljs-title function_">charAt</span>(i);<br>                <span class="hljs-keyword">if</span>(stack.<span class="hljs-title function_">contains</span>(c))<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">while</span>(!stack.<span class="hljs-title function_">isEmpty</span>() &amp;&amp; stack.<span class="hljs-title function_">peek</span>()&gt;c &amp;&amp; s.<span class="hljs-title function_">indexOf</span>(stack.<span class="hljs-title function_">peek</span>(),i)!=-<span class="hljs-number">1</span>)<br>                    stack.<span class="hljs-title function_">pop</span>();<br>                stack.<span class="hljs-title function_">push</span>(c);<br>            &#125;<br>            char chars[]=<span class="hljs-keyword">new</span> char[stack.<span class="hljs-title function_">size</span>()];<br>            <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; stack.<span class="hljs-title function_">size</span>(); i++) &#123;<br>                chars[i]=stack.<span class="hljs-title function_">get</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">String</span> string = <span class="hljs-string">&quot;bbcaac&quot;</span>;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-title function_">removeDuplicateLetters</span>(string));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeeCode 103. 二叉树的锯齿形层序遍历</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br>&#x2F;#&#x2F;#&#x2F;#示例<br>给定二叉树 [3,9,20,null,null,15,7],<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161542127.png"></p><p>返回锯齿形层序遍历如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/</a></p><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">ArrayDeque</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">ArrayList</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">List</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    int val;<br>    <span class="hljs-title class_">TreeNode</span> left;<br>    <span class="hljs-title class_">TreeNode</span> right;<br>    <span class="hljs-title class_">TreeNode</span>(int x) &#123; val = x; &#125;<br>&#125;<br> <br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span>(<span class="hljs-params">TreeNode root</span>) &#123;<br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt;&gt;();<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//二叉树为空，直接返回空结果</span><br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-title class_">TreeNode</span>&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-title class_">TreeNode</span>&gt;();<br>    deque.<span class="hljs-title function_">add</span>(root);<br>    <span class="hljs-title function_">leverOrder</span>(res, deque, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 参数列表说明：</span><br><span class="hljs-comment">     * res 结果集</span><br><span class="hljs-comment">     * deque 双向队列存储当前层次遍历的结点</span><br><span class="hljs-comment">     * flag 记录当前遍历的层数，用来控制层序遍历的方向</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">leverOrder</span>(<span class="hljs-params">List&lt;List&lt;Integer&gt;&gt; res,ArrayDeque&lt;TreeNode&gt; deque,int flag</span>) &#123;<br>    int size = deque.<span class="hljs-title function_">size</span>();<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">Integer</span>&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">Integer</span>&gt;(); <br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">while</span>(size-- != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title class_">TreeNode</span> root = deque.<span class="hljs-title function_">pollFirst</span>();<br>    arrayList.<span class="hljs-title function_">add</span>(root.<span class="hljs-property">val</span>);<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">left</span> != <span class="hljs-literal">null</span>) &#123;<br>    deque.<span class="hljs-title function_">offer</span>(root.<span class="hljs-property">left</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">right</span> != <span class="hljs-literal">null</span>) &#123;<br>    deque.<span class="hljs-title function_">offer</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>    &#125;<br>    <span class="hljs-comment">//加入结果集，递归下一层</span><br>    res.<span class="hljs-title function_">add</span>(arrayList);<br>    <span class="hljs-title function_">leverOrder</span>(res, deque, <span class="hljs-number">2</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">while</span>(size-- != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title class_">TreeNode</span> root = deque.<span class="hljs-title function_">pollLast</span>();<br>    arrayList.<span class="hljs-title function_">add</span>(root.<span class="hljs-property">val</span>);<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">right</span> != <span class="hljs-literal">null</span>) &#123;<br>    deque.<span class="hljs-title function_">offerFirst</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">left</span> != <span class="hljs-literal">null</span>) &#123;<br>    deque.<span class="hljs-title function_">offerFirst</span>(root.<span class="hljs-property">left</span>);<br>    &#125;<br>    &#125;<br>    <span class="hljs-comment">//加入结果集，//递归下一层</span><br>    res.<span class="hljs-title function_">add</span>(arrayList);<br>    <span class="hljs-title function_">leverOrder</span>(res, deque, <span class="hljs-number">1</span>);<br>&#125;<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 135. 分发糖果</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20135.%20%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20135.%20%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/candy">https://leetcode-cn.com/problems/candy</a></p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入: [1,0,2]<br>输出: 5<br>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入: [1,2,2]<br>输出: 4<br>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>第三个孩子只得到 1 颗糖果，这已满足上述两个条件</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>两个数组left和right分别记录从左向右规则和从右向左规则时，每个孩子应该分的糖果数。<br>题目要求即为同时满足两个方向的规则，即两个数组按位取max。<br>最终结果要加上每个孩子至少一个糖果。（或者left，right数组初始化为1）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">candy</span>(<span class="hljs-params">int[] ratings</span>) &#123;<br>        int len = ratings.<span class="hljs-property">length</span>;<br>    int sum = len;<br>    int[] left = <span class="hljs-keyword">new</span> int[len];<br>    int[] right = <span class="hljs-keyword">new</span> int[len];<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i-<span class="hljs-number">1</span>]) &#123;<br>                left[i] = left[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">for</span> (int i = len-<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]) &#123;<br>                right[i] = right[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    <br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            sum += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left[i], right[i]);<br>        &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>识别图中模糊的手写数字</title>
    <link href="/2020/11/29/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%AF%86%E5%88%AB%E5%9B%BE%E4%B8%AD%E6%A8%A1%E7%B3%8A%E7%9A%84%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/"/>
    <url>/2020/11/29/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%AF%86%E5%88%AB%E5%9B%BE%E4%B8%AD%E6%A8%A1%E7%B3%8A%E7%9A%84%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>python语言基础</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>导入图片数据集，分析图片的特点、定义变量，构建模型，训练模型并输出中间状态参数，测试、保存、读取模型</p><h4 id="如何搞定它"><a href="#如何搞定它" class="headerlink" title="如何搞定它"></a>如何搞定它</h4><h5 id="1-1导入图片数据集"><a href="#1-1导入图片数据集" class="headerlink" title="1.1导入图片数据集"></a>1.1导入图片数据集</h5><p>首先来看看数据集是什么样的。<br>MNIST是一个入门级的计算机视觉数据集。当我们开始学习编程时，第一件事往往是学习打印Hello World。在机器学习入门的领域里，我们会用MNIST数据集来实验各种模型。</p><p>1.1.1数据集介绍</p><p>MNIST里包含各种手写数字图片，如图所示。<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546895.png" alt="在这里插入图片描述"><br>它也包含每一张图片对应的标签，告诉我们这个是数字几。例如，上面这4张图片的标签分别是5、0、4、1。</p><p>1.1.2下载并安装MNIST数据集</p><p>介绍完MNIST数据集后，下面来演示一下如何通过代码来对其操作。</p><p>（1）利用TensorFlow代码下载MNIST</p><p>TensorFlow提供了一个库，可以直接用来自动下载与安装MNIST，见如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>数据集<br><span class="hljs-keyword">from</span> tensorflow.<span class="hljs-property">examples</span>.<span class="hljs-property">tutorials</span>.<span class="hljs-property">mnist</span> <span class="hljs-keyword">import</span> input_data<br>mnist=input_data.<span class="hljs-title function_">read_data_sets</span>(<span class="hljs-string">&quot;MNIST_data/&quot;</span>,one_hot=<span class="hljs-title class_">True</span>))<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">运行上面的代码，会自动下载数据集并将文件解压到当前代码所在同级目录下的MNIST_data文件夹下。<br>注意：代码中的one_hot=<span class="hljs-title class_">True</span>，表示将样本标签转化为one_hot编码。<br></code></pre></td></tr></table></figure><p>举例来解释one_hot编码：<br>假如一共10类。0的one_hot为1000000000，1的one_hot为0100000000，2的one_hot为0010000000，3的one_hot为0001000000……依此类推。只有一个位为1，1所在的位置就代表着第几类。</p><p>MNIST数据集中的图片是28×28像素，所以，每一幅图就是1行784（28×28）列的数据，括号中的每一个值代表一个像素。</p><ul><li>如果是黑白的图片，图片中黑色的地方数值为0；有图案的地方，数值为0～255之间的数字，代表其颜色的深度。</li><li>如果是彩色的图片，一个像素会由3个值来表示RGB（红、黄、蓝）。在后面讲解其他数据集时会具体讲到。</li></ul><p>接下来通过几行代码将MNIST里面的信息打印出来，看看它的具体内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>数据集（续）<br>print (<span class="hljs-string">&#x27;输入数据:&#x27;</span>,mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>)<br>print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br><span class="hljs-keyword">import</span> pylab<br>im = mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>[<span class="hljs-number">1</span>]<br>im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>pylab.<span class="hljs-title function_">imshow</span>(im)<br>pylab.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p>运行上面的代码，输出信息如下：</p><p>输出结果如图所示<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546896.png" alt="在这里插入图片描述"><br>刚开始的打印信息是解压数据集的意思。如果是第一次运行，还会显示下载数据的相关信息。<br>接着打印出来的是训练集的图片信息，是一个55000行、784列的矩阵。即，训练集里有55000张图片。</p><p>（2）MNIST数据集组成</p><p>在MNIST训练数据集中，mnist.train.images是一个形状为[55000，784]的张量。其中，第1个维度数字用来索引图片，第2个维度数字用来索引每张图片中的像素点。此张量里的每一个元素，都表示某张图片里的某个像素的强度值，值介于0～255之间。<br>MNIST里包含3个数据集：第一个是训练数据集，另外两个分别是测试数据集（mnist.test）和验证数据集（mnist.validation）。可使用如下命令查看里面的数据信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">MNIST</span>数据集（续）<br>print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br>print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">validation</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br></code></pre></td></tr></table></figure><p>运行完上面的命令，可以发现在测试数据集里有10000条样本图片，验证数据集里有5000个图片。</p><p>在实际的机器学习模型设计时，样本一般分为3部分：</p><ul><li>一部分用于训练；</li><li>一部分用于评估训练过程中的准确度（测试数据集）；</li><li>一部分用于评估最终模型的准确度（验证数据集）。</li></ul><p>训练过程中，模型并没有遇到过验证数据集中的数据，所以利用验证数据集可以评估出模型的准确度。这个准确度越高，代表模型的泛化能力越强。</p><p>另外，这3个数据集还有分别对应的3个文件（标签文件），用来标注每个图片上的数字是几。把图片和标签放在一起，称为“样本”。通过样本来就可以实现一个有监督信号的深度学习模型。</p><p>相对应的，MNIST数据集的标签是介于0～9之间的数字，用来描述给定图片里表示的数字。标签数据是“one-hot vectors”：一个one-hot向量，除了某一位的数字是1外，其余各维度数字都是0。例如，标签0将表示为（[1，0，0，0，0，0，0，0，0，0，0]）。因此，mnist.train.labels是一个[55000，10]的数字矩阵。</p><h5 id="1-2分析图片的特点，定义变量"><a href="#1-2分析图片的特点，定义变量" class="headerlink" title="1.2分析图片的特点，定义变量"></a>1.2分析图片的特点，定义变量</h5><p>由于输入图片是个55000×784的矩阵，所以先创建一个[None，784]的占位符x和一个[None，10]的占位符y，然后使用feed机制将图片和标签输入进去。具体代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>分类<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf  # 导入tensorflow库<br><span class="hljs-keyword">from</span> tensorflow.<span class="hljs-property">examples</span>.<span class="hljs-property">tutorials</span>.<span class="hljs-property">mnist</span> <span class="hljs-keyword">import</span> input_data<br>mnist = input_data.<span class="hljs-title function_">read_data_sets</span>(<span class="hljs-string">&quot;MNIST_data/&quot;</span>,one_hot=<span class="hljs-title class_">True</span>)<br><span class="hljs-keyword">import</span> pylab <br>tf.<span class="hljs-title function_">reset_default_graph</span>()<br># 定义占位符<br>x = tf.<span class="hljs-title function_">placeholder</span>(tf.<span class="hljs-property">float32</span>, [<span class="hljs-title class_">None</span>, <span class="hljs-number">784</span>]) # <span class="hljs-variable constant_">MNIST</span>数据集的维度是  <span class="hljs-number">28</span>×<span class="hljs-number">28</span>=<span class="hljs-number">784</span><br>y = tf.<span class="hljs-title function_">placeholder</span>(tf.<span class="hljs-property">float32</span>, [<span class="hljs-title class_">None</span>, <span class="hljs-number">10</span>])  # 数字<span class="hljs-number">0</span>～<span class="hljs-number">9</span> ，共<span class="hljs-number">10</span>个类别<br>#代码中第<span class="hljs-number">8</span>行的<span class="hljs-title class_">None</span>，表示此张量的第一个维度可以是任何长度的。x就代表能够输入任意数量的<span class="hljs-variable constant_">MNIST</span>图像，每一张图展平成<span class="hljs-number">784</span>维的向量。<br></code></pre></td></tr></table></figure><h5 id="1-3构建模型"><a href="#1-3构建模型" class="headerlink" title="1.3构建模型"></a>1.3构建模型</h5><p>样本完成后就可以构建模型了。下面列出了构建模型的相关步骤。</p><p>1.3.1　定义学习参数</p><p>模型也需要权重值和偏置量，它们被统一叫做学习参数。在TensorFlow里，使用Variable来定义学习参数。<br>一个Variable代表一个可修改的张量，定义在TensorFlow的图（一个执行任务）中，其本身也是一种变量。使用Variable定义的学习参数可以用于计算输入值，也可以在计算中被修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>分类（续）<br>W = tf.<span class="hljs-title class_">Variable</span>(tf.<span class="hljs-title function_">random_normal</span>(([<span class="hljs-number">784</span>,<span class="hljs-number">10</span>]))<br>b = tf.<span class="hljs-title class_">Variable</span>(tf.<span class="hljs-title function_">zeros</span>([<span class="hljs-number">10</span>]))<br></code></pre></td></tr></table></figure><p>在这里赋予tf.Variable不同的初值来创建不同的参数。一般将W设为一个随机值，将b设为0。<br>注意：W的维度是[784，10]，因为想要用784维的图片向量乘以它，以得到一个10维的证据值向量，每一位对应不同数字类。b的形状是[10]，所以可以直接把它加到输出上面。</p><p>1.3.2　定义输出节点</p><p>有了输入和模型参数，接着便可以将它们串起来构建成真正的模型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>分类（续）<br>pred = tf.<span class="hljs-property">nn</span>.<span class="hljs-title function_">softmax</span>(tf.<span class="hljs-title function_">matmul</span>(x, W) + b) # <span class="hljs-title class_">Softmax</span>分类<br></code></pre></td></tr></table></figure><p>首先，用tf.matmul（x，W）表示x乘以W，这里x是一个二维张量，拥有多个输入。然后再加上b，把它们的和输入到tf.nn.softmax函数里。<br>至此就构建好了正向传播的结构。也就是表明，只要模型中的参数合适，通过具体的数据输入，就能得到我们想要的分类。</p><p>1.3.3　定义反向传播的结构</p><p>下面定义一个反向传播的结构，编译训练模型，以得到合适的参数。<br>这里涉及一个“学习率”的概念。学习率，是指每次改变学习参数的大小。在这里读者只要先有个概念即可，后面章节还会详细介绍。<br>先看下面代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">代码<span class="hljs-number">1</span>-<span class="hljs-number">2</span>　<span class="hljs-variable constant_">MNIST</span>分类（续）<br># 损失函数<br>cost=tf.<span class="hljs-title function_">reduce_mean</span>(-tf.<span class="hljs-title function_">reduce_sum</span>(y*tf.<span class="hljs-title function_">log</span>(pred),reduction_indices=<span class="hljs-number">1</span>))<br>  <br># 定义参数<br>learning_rate = <span class="hljs-number">0.01</span><br># 使用梯度下降优化器<br>optimizer=tf.<span class="hljs-property">train</span>.<span class="hljs-title class_">GradientDescentOptimizer</span>(learning_rate).<span class="hljs-title function_">minimize</span>(cost)<br></code></pre></td></tr></table></figure><p>上面的代码可以这样来理解：<br>（1）将生成的pred与样本标签y进行一次交叉熵的运算，然后取平均值。<br>（2）将这个结果作为一次正向传播的误差，通过梯度下降的优化方法找到能够使这个误差最小化的b和W的偏移量。<br>（3）更新b和W，使其调整为合适的参数。<br>整个过程就是不断地让损失值（误差值cost）变小。因为损失值越小，才能表明输出的结果跟标签数据越相近。当cost小到我们的需求时，这时的b和W就是训练出来的合适值。</p><h5 id="1-4-训练模型并输出中间状态参数"><a href="#1-4-训练模型并输出中间状态参数" class="headerlink" title="1.4　训练模型并输出中间状态参数"></a>1.4　训练模型并输出中间状态参数</h5><p>现在开始真正地训练模型了，先定义训练相关的参数。<br>下面代码中</p><ul><li>第1行中，training_epochs代表要把整个训练样本集迭代25次；</li><li>第2行中，batch_size代表在训练过程中一次取100条数据进行训练</li><li>第3行中，display_step代表每训练一次就把具体的中间状态显示出来。</li></ul><p>注意：batch_size参数代表的意义很关键，在深度学习中，都是将数据按批次地向里面放的。在后面章节中还会详细介绍这么做的目的。<br>参数定义好后，启动一个session就可以开始训练过程了。session中有两个run，第一个run是运行初始化，第二个run是运行具体的运算模型。模型运算之后便将里面的状态打印出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">training_epochs = <span class="hljs-number">25</span><br>batch_size = <span class="hljs-number">100</span><br>display_step = <span class="hljs-number">1</span><br><br>saver = tf.<span class="hljs-property">train</span>.<span class="hljs-title class_">Saver</span>()<br>model_path = <span class="hljs-string">&quot;log/521model.ckpt&quot;</span><br><br># 启动session<br><span class="hljs-keyword">with</span> tf.<span class="hljs-title class_">Session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">sess</span>:<br>    sess.<span class="hljs-title function_">run</span>(tf.<span class="hljs-title function_">global_variables_initializer</span>())# <span class="hljs-title class_">Initializing</span> <span class="hljs-variable constant_">OP</span><br>    # 启动循环开始训练<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(training_epochs):<br>        avg_cost = <span class="hljs-number">0.</span><br>        total_batch = <span class="hljs-title function_">int</span>(mnist.<span class="hljs-property">train</span>.<span class="hljs-property">num_examples</span>/batch_size)<br>        # 循环所有数据集<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(total_batch):<br>            batch_xs, batch_ys = mnist.<span class="hljs-property">train</span>.<span class="hljs-title function_">next_batch</span>(batch_size)<br>            # 运行优化器<br>            _, c = sess.<span class="hljs-title function_">run</span>([optimizer, cost], feed_dict=&#123;<br>    <span class="hljs-attr">x</span>: batch_xs,<br>                                                       <span class="hljs-attr">y</span>: batch_ys&#125;)<br>            # 计算平均loss值<br>            avg_cost += c / total_batch<br>        # 显示训练中的详细信息<br>        <span class="hljs-keyword">if</span> (epoch+<span class="hljs-number">1</span>) % display_step == <span class="hljs-number">0</span>:<br>           print (<span class="hljs-string">&quot;Epoch:&quot;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;cost=&quot;</span>, <span class="hljs-string">&quot;&#123;:.9f&#125;&quot;</span>.            <span class="hljs-title function_">format</span>(avg_cost))<br><br>    <span class="hljs-title function_">print</span>( <span class="hljs-string">&quot; Finished!&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行上面的代码，会输出如下信息：<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546897.png" alt="在这里插入图片描述"></p><p>这里输出的中间状态是cost损失值。读者也可以把自己关心的内容打印出来。可以看到，从第1次迭代到第25次迭代的损失值在逐渐减小，最终的误差只有0.8。</p><h5 id="1-5-测试模型"><a href="#1-5-测试模型" class="headerlink" title="1.5　测试模型"></a>1.5　测试模型</h5><p>还记得MNIST里面有测试数据吗？现在我们使用测试数据来测试一下训练完的模型吧。<br>与前面的过程类似，也是先将计算测试的网络结构建立起来，然后通过最终节点的eval将测试值运算出来。<br>注意：这个过程仍然是在session里进行的。<br>测试错误率的算法是：直接判断预测的结果与真实的标签是否相同，如是相同的就表明是正确的，如是不相同的就表示是错误的。然后将正确的个数除以总个数，得到的值即为正确率。由于是onehot编码，这里使用了tf.argmax函数返回onehot编码中数值为1的那个元素的下标。下面是具体代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">#<span class="hljs-variable constant_">MNIST</span>分类（续）<br>    correct_prediction = tf.<span class="hljs-title function_">equal</span>(tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>), tf.<span class="hljs-title function_">argmax</span>(y, <span class="hljs-number">1</span>))<br>    # 计算准确率<br>    accuracy = tf.<span class="hljs-title function_">reduce_mean</span>(tf.<span class="hljs-title function_">cast</span>(correct_prediction, tf.<span class="hljs-property">float32</span>))<br>    print (<span class="hljs-string">&quot;Accuracy:&quot;</span>, accuracy.<span class="hljs-built_in">eval</span>(&#123;<br>    <span class="hljs-attr">x</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>, <span class="hljs-attr">y</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">labels</span>&#125;))<br></code></pre></td></tr></table></figure><p>上面代码执行后，显示信息如下：<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546898.png" alt="在这里插入图片描述"></p><p>测试正确率的算法与损失值的算法略有差别，但代表的意义却很类似。当然，也可以直接拿计算损失值的交叉熵结果来代表模型测试的错误率。<br>注意：<br>（1）并不是所有模型的测试错误率和训练时的最后一次损失值都很接近，这取决于训练样本和测试样本的分布情况，也取决于模型本身的拟合质量。关于拟合质量问题，将在后面章节详细介绍。<br>（2）读者自己运行时，得到的值可能和本书中的值不一样。甚至每次运行时，得到的值也不一样。原因是每次初始的权重w都是随机的。由于初始权重不同，而且每次训练的批次数据也不同，所以最终生成的模型也不会完全相同。但如果核心算法保持一致，则会保证最终的结果不会有太大的偏差。</p><h5 id="1-6-保存模型"><a href="#1-6-保存模型" class="headerlink" title="1.6　保存模型"></a>1.6　保存模型</h5><p>下面开始讲解如何保存模型。<br>首先要建立一个saver和一个路径，然后通过调用save，自动将session中的参数保存起来，见如下代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>分类（续）   <br># 保存模型<br>    save_path = saver.<span class="hljs-title function_">save</span>(sess, model_path)<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;Model saved in file: %s&quot;</span> % save_path)<br></code></pre></td></tr></table></figure><p>上面代码的作用是保存模型，并将模型保存的路径打印出来。当然，在这段代码运行之前，需要添加saver和model_path的定义。来到前面session创建之前添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-variable constant_">MNIST</span>分类（续）<br>saver = tf.<span class="hljs-property">train</span>.<span class="hljs-title class_">Saver</span>()<br>model_path = <span class="hljs-string">&quot;log/521model.ckpt&quot;</span><br></code></pre></td></tr></table></figure><p>执行上述的全部代码后，会打印出存储位置<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546899.png" alt="在这里插入图片描述"></p><h5 id="1-7-读取模型"><a href="#1-7-读取模型" class="headerlink" title="1.7　读取模型"></a>1.7　读取模型</h5><p>将模型存储好后，下面来做一个实验：读取模型并将两张图片放进去让模型预测结果，然后将两张图片极其对应的标签一并显示出来。<br>在整个代码执行过程中，对于网络模型的定义不变，只是重新建立一个session而已，所有的操作都在这个新的session中完成。具体细节见代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">#　<span class="hljs-variable constant_">MNIST</span>分类（续）<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;Starting 2nd session...&quot;</span>)<br><span class="hljs-keyword">with</span> tf.<span class="hljs-title class_">Session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">sess</span>:<br>    # 初始化变量<br>    sess.<span class="hljs-title function_">run</span>(tf.<span class="hljs-title function_">global_variables_initializer</span>())<br>    # 恢复模型变量<br>    saver.<span class="hljs-title function_">restore</span>(sess, model_path)<br><br>    # 测试 model<br>    correct_prediction = tf.<span class="hljs-title function_">equal</span>(tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>), tf.<span class="hljs-title function_">argmax</span>(y, <span class="hljs-number">1</span>))<br>    # 计算准确率<br>    accuracy = tf.<span class="hljs-title function_">reduce_mean</span>(tf.<span class="hljs-title function_">cast</span>(correct_prediction, tf.<span class="hljs-property">float32</span>))<br>    print (<span class="hljs-string">&quot;Accuracy:&quot;</span>, accuracy.<span class="hljs-built_in">eval</span>(&#123;<br>    <span class="hljs-attr">x</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>, <span class="hljs-attr">y</span>: mnist.      test.<span class="hljs-property">labels</span>&#125;))<br><br>    output = tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>)<br>    batch_xs, batch_ys = mnist.<span class="hljs-property">train</span>.<span class="hljs-title function_">next_batch</span>(<span class="hljs-number">2</span>)<br>    outputval,predv = sess.<span class="hljs-title function_">run</span>([output,pred], feed_dict=&#123;<br>    <span class="hljs-attr">x</span>: batch_xs&#125;)<br>    <span class="hljs-title function_">print</span>(outputval,predv,batch_ys)<br>    im = batch_xs[<span class="hljs-number">0</span>]<br>    im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.<span class="hljs-title function_">imshow</span>(im)<br>    pylab.<span class="hljs-title function_">show</span>()<br><br>    im = batch_xs[<span class="hljs-number">1</span>]<br>    im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.<span class="hljs-title function_">imshow</span>(im)<br>    pylab.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p>以上代码可以替代原来的session，也可以直接放到代码后面，将前面的session注释掉。<br>输出结果<br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161546900.png" alt="在这里插入图片描述"></p><ul><li>第一行是模型的准确率，接下来是3个数组。</li><li>第一个数组是输出的预测结果[3,6]</li><li>第二个大的数组比较大，是预测出来的真实输出值，哪一项数值越大，代表对应的概率越大.</li><li>第三个大的数组元素都是0和1，是图片实际的标签值onehot编码表示的数字</li></ul><p>完整代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> tensorflow.<span class="hljs-property">compat</span>.<span class="hljs-property">v1</span> <span class="hljs-keyword">as</span> tf  # 导入tensorflow库#<br>tf.<span class="hljs-title function_">disable_v2_behavior</span>()<br><br><span class="hljs-keyword">from</span> tensorflow.<span class="hljs-property">examples</span>.<span class="hljs-property">tutorials</span>.<span class="hljs-property">mnist</span> <span class="hljs-keyword">import</span> input_data<br>mnist = input_data.<span class="hljs-title function_">read_data_sets</span>(<span class="hljs-string">&quot;MNIST_data/&quot;</span>, one_hot=<span class="hljs-title class_">True</span>)<br><br># print (<span class="hljs-string">&#x27;输入数据:&#x27;</span>,mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>)<br># print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br><br><span class="hljs-keyword">import</span> pylab<br>im = mnist.<span class="hljs-property">train</span>.<span class="hljs-property">images</span>[<span class="hljs-number">1</span>]<br>im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>pylab.<span class="hljs-title function_">imshow</span>(im)<br>pylab.<span class="hljs-title function_">show</span>()<br># print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br># print (<span class="hljs-string">&#x27;输入数据打印shape:&#x27;</span>,mnist.<span class="hljs-property">validation</span>.<span class="hljs-property">images</span>.<span class="hljs-property">shape</span>)<br><br>tf.<span class="hljs-title function_">reset_default_graph</span>()<br># 定义占位符<br>x = tf.<span class="hljs-title function_">placeholder</span>(tf.<span class="hljs-property">float32</span>, [<span class="hljs-title class_">None</span>, <span class="hljs-number">784</span>]) # <span class="hljs-variable constant_">MNIST</span>数据集的维度是  <span class="hljs-number">28</span>×<span class="hljs-number">28</span>=<span class="hljs-number">784</span><br>y = tf.<span class="hljs-title function_">placeholder</span>(tf.<span class="hljs-property">float32</span>, [<span class="hljs-title class_">None</span>, <span class="hljs-number">10</span>])  # 数字<span class="hljs-number">0</span>～<span class="hljs-number">9</span> ，共<span class="hljs-number">10</span>个类别<br>W = tf.<span class="hljs-title class_">Variable</span>(tf.<span class="hljs-title function_">random_normal</span>([<span class="hljs-number">784</span>,<span class="hljs-number">10</span>]))<br>b = tf.<span class="hljs-title class_">Variable</span>(tf.<span class="hljs-title function_">zeros</span>([<span class="hljs-number">10</span>]))<br>pred = tf.<span class="hljs-property">nn</span>.<span class="hljs-title function_">softmax</span>(tf.<span class="hljs-title function_">matmul</span>(x, W) + b) # <span class="hljs-title class_">Softmax</span>分类<br><br># 损失函数<br>cost=tf.<span class="hljs-title function_">reduce_mean</span>(-tf.<span class="hljs-title function_">reduce_sum</span>(y*tf.<span class="hljs-title function_">log</span>(pred),reduction_indices=<span class="hljs-number">1</span>))<br><br># 定义参数<br>learning_rate = <span class="hljs-number">0.01</span><br># 使用梯度下降优化器<br>optimizer=tf.<span class="hljs-property">train</span>.<span class="hljs-title class_">GradientDescentOptimizer</span>(learning_rate).<span class="hljs-title function_">minimize</span>(cost)<br>training_epochs = <span class="hljs-number">25</span><br>batch_size = <span class="hljs-number">100</span><br>display_step = <span class="hljs-number">1</span><br><br>saver = tf.<span class="hljs-property">train</span>.<span class="hljs-title class_">Saver</span>()<br>model_path = <span class="hljs-string">&quot;log/521model.ckpt&quot;</span><br><br># 启动session<br><span class="hljs-keyword">with</span> tf.<span class="hljs-title class_">Session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">sess</span>:<br>    sess.<span class="hljs-title function_">run</span>(tf.<span class="hljs-title function_">global_variables_initializer</span>())# <span class="hljs-title class_">Initializing</span> <span class="hljs-variable constant_">OP</span><br>    # 启动循环开始训练<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(training_epochs):<br>        avg_cost = <span class="hljs-number">0.</span><br>        total_batch = <span class="hljs-title function_">int</span>(mnist.<span class="hljs-property">train</span>.<span class="hljs-property">num_examples</span>/batch_size)<br>        # 循环所有数据集<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(total_batch):<br>            batch_xs, batch_ys = mnist.<span class="hljs-property">train</span>.<span class="hljs-title function_">next_batch</span>(batch_size)<br>            # 运行优化器<br>            _, c = sess.<span class="hljs-title function_">run</span>([optimizer, cost], feed_dict=&#123;<br>    <span class="hljs-attr">x</span>: batch_xs,<br>                                                       <span class="hljs-attr">y</span>: batch_ys&#125;)<br>            # 计算平均loss值<br>            avg_cost += c / total_batch<br>        # 显示训练中的详细信息<br>        <span class="hljs-keyword">if</span> (epoch+<span class="hljs-number">1</span>) % display_step == <span class="hljs-number">0</span>:<br>           print (<span class="hljs-string">&quot;Epoch:&quot;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;cost=&quot;</span>, <span class="hljs-string">&quot;&#123;:.9f&#125;&quot;</span>.            <span class="hljs-title function_">format</span>(avg_cost))<br><br>    <span class="hljs-title function_">print</span>( <span class="hljs-string">&quot; Finished!&quot;</span>)<br>    # 测试 model<br>    correct_prediction = tf.<span class="hljs-title function_">equal</span>(tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>), tf.<span class="hljs-title function_">argmax</span>(y, <span class="hljs-number">1</span>))<br>    # 计算准确率<br>    accuracy = tf.<span class="hljs-title function_">reduce_mean</span>(tf.<span class="hljs-title function_">cast</span>(correct_prediction, tf.<span class="hljs-property">float32</span>))<br>    print (<span class="hljs-string">&quot;Accuracy:&quot;</span>, accuracy.<span class="hljs-built_in">eval</span>(&#123;<br>    <span class="hljs-attr">x</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>, <span class="hljs-attr">y</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">labels</span>&#125;))<br><br>    #     # 保存模型<br>    save_path = saver.<span class="hljs-title function_">save</span>(sess, model_path)<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;Model saved in file: %s&quot;</span> % save_path)<br><br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;Starting 2nd session...&quot;</span>)<br><span class="hljs-keyword">with</span> tf.<span class="hljs-title class_">Session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">sess</span>:<br>    # 初始化变量<br>    sess.<span class="hljs-title function_">run</span>(tf.<span class="hljs-title function_">global_variables_initializer</span>())<br>    # 恢复模型变量<br>    saver.<span class="hljs-title function_">restore</span>(sess, model_path)<br><br>    # 测试 model<br>    correct_prediction = tf.<span class="hljs-title function_">equal</span>(tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>), tf.<span class="hljs-title function_">argmax</span>(y, <span class="hljs-number">1</span>))<br>    # 计算准确率<br>    accuracy = tf.<span class="hljs-title function_">reduce_mean</span>(tf.<span class="hljs-title function_">cast</span>(correct_prediction, tf.<span class="hljs-property">float32</span>))<br>    print (<span class="hljs-string">&quot;Accuracy:&quot;</span>, accuracy.<span class="hljs-built_in">eval</span>(&#123;<br>    <span class="hljs-attr">x</span>: mnist.<span class="hljs-property">test</span>.<span class="hljs-property">images</span>, <span class="hljs-attr">y</span>: mnist.      test.<span class="hljs-property">labels</span>&#125;))<br><br>    output = tf.<span class="hljs-title function_">argmax</span>(pred, <span class="hljs-number">1</span>)<br>    batch_xs, batch_ys = mnist.<span class="hljs-property">train</span>.<span class="hljs-title function_">next_batch</span>(<span class="hljs-number">2</span>)<br>    outputval,predv = sess.<span class="hljs-title function_">run</span>([output,pred], feed_dict=&#123;<br>    <span class="hljs-attr">x</span>: batch_xs&#125;)<br>    <span class="hljs-title function_">print</span>(outputval,predv,batch_ys)<br>    im = batch_xs[<span class="hljs-number">0</span>]<br>    im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.<span class="hljs-title function_">imshow</span>(im)<br>    pylab.<span class="hljs-title function_">show</span>()<br><br>    im = batch_xs[<span class="hljs-number">1</span>]<br>    im = im.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.<span class="hljs-title function_">imshow</span>(im)<br>    pylab.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 463. 岛屿的周长</title>
    <link href="/2020/11/01/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20463.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <url>/2020/11/01/%E7%AE%97%E6%B3%95/LeetCode/LeetCode%20463.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p><strong>来源：力扣（LeetCode）</strong><br><strong>输入:</strong><br>[[0,1,0,0],<br>[1,1,1,0],<br>[0,1,0,0],<br>[1,1,0,0]]</p><p><strong>输出: 16</strong></p><p>解释: 它的周长是下面图片中的 16 个黄色的边：</p><p><img src="/../images/93d311ab-1d1d-4d82-90cd-729bdfe3b289.png" alt="在这里插入图片描述"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">islandPerimeter</span>(<span class="hljs-params">int[][] grid</span>) &#123;<br>    <br>        int m = grid.<span class="hljs-property">length</span>;<br>        int n = grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>        int res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>    <br>            <span class="hljs-keyword">for</span>(int j=<span class="hljs-number">0</span>; j&lt;n;j++)&#123;<br>    <br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>    <br>                <span class="hljs-comment">//如果是岛屿，判断其四个方向有没有岛屿，没有周长++</span><br>                    <span class="hljs-keyword">if</span>(i-<span class="hljs-number">1</span>&lt;<span class="hljs-number">0</span>)&#123;<br>    <br>                        res++;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>                        <span class="hljs-keyword">if</span>(grid[i-<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>)&#123;<br>    <br>                            res++;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(j-<span class="hljs-number">1</span>&lt;<span class="hljs-number">0</span>)&#123;<br>    <br>                        res++;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>                        <span class="hljs-keyword">if</span>(grid[i][j-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>    <br>                            res++;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&gt;=m)&#123;<br>    <br>                        res++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>    <br>                        <span class="hljs-keyword">if</span>(grid[i+<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>)&#123;<br>    <br>                            res++;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&gt;=n)&#123;<br>    <br>                        res++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>    <br>                        <span class="hljs-keyword">if</span>(grid[i][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>    <br>                            res++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写的时候直接暴力统计每一个岛屿的四个方向是否与其他岛屿相连，<br>使用了一堆的if…；<br>看到别人的题解是先统计周长为有几块岛屿&#x2F;*4，再判断如果岛屿两两相连，那么周长-2；</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬取51job的招聘信息</title>
    <link href="/2020/04/29/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/python%E7%88%AC%E5%8F%9651job%E7%9A%84%E6%8B%9B%E8%81%98%E4%BF%A1%E6%81%AF/"/>
    <url>/2020/04/29/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/python%E7%88%AC%E5%8F%9651job%E7%9A%84%E6%8B%9B%E8%81%98%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong><br>最近的脚本课程有了新的作业。爬取51job上的一些招聘信息，包括城市 薪资最大最小值等。</p><p>这里示例的是 济南、北京、上海、广州、深圳的招聘信息<br><strong>求助</strong><br>薪资有些招聘信息并没有填写，也就是说薪资所在标签的值为空值，这些空值无法在集合中占位，进而导致薪资和招聘信息不匹配，如果有大佬会，能不能指点一下啊 ，555 -.-||</p><p>招聘信息包括<br>职位 公司 工作地点 薪水 发布时间 最低薪资 最高薪资 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> xlwt<br><span class="hljs-keyword">import</span> string<br>#workbook = xlwt.<span class="hljs-title class_">Workbook</span>(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)#创建 workbook 即新建 excel 文件/工作簿，<br>myxls = xlwt.<span class="hljs-title class_">Workbook</span>()<br>#worksheet = workbook.<span class="hljs-title function_">add_sheet</span>(<span class="hljs-string">&#x27;my_worksheet&#x27;</span>) #创建工作表，如果想创建多个工作表，直接在后面再 add_sheet<br>sheet1 = myxls.<span class="hljs-title function_">add_sheet</span>(u<span class="hljs-string">&#x27;top250&#x27;</span>, cell_overwrite_ok=<span class="hljs-title class_">True</span>)<br><br>#请求头<br><span class="hljs-variable constant_">HEADERS</span> = &#123;<br>    <br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&#x27;</span>,<br>&#125;<br><br>base_urls = <span class="hljs-string">&#x27;https://search.51job.com/list/120200%252C010000%252C020000%252C030200%252C040000,000000,0000,00,9,99,python,2,&#123;&#125;.html&#x27;</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">51</span>):<br>    url = base_urls.<span class="hljs-title function_">format</span>(x)<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;第%s页爬取完成&#x27;</span> % x)<br>    response = requests.<span class="hljs-title function_">get</span>(url,<span class="hljs-variable constant_">HEADERS</span>)<br>    text = response.<span class="hljs-property">content</span>.<span class="hljs-title function_">decode</span>(<span class="hljs-string">&#x27;gbk&#x27;</span>)<br>    tree = etree.<span class="hljs-title function_">HTML</span>(text)<br><br>    <span class="hljs-title class_">PositionAndCompany</span> = tree.<span class="hljs-title function_">xpath</span>(<span class="hljs-string">&quot;//div[@class=&#x27;el&#x27;]//span/a/@title&quot;</span>)<br>    positions = <span class="hljs-title class_">PositionAndCompany</span>[::<span class="hljs-number">2</span>]<br>    companys = <span class="hljs-title class_">PositionAndCompany</span>[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]<br>    workplaces = tree.<span class="hljs-title function_">xpath</span>(<span class="hljs-string">&#x27;//div[@class=&quot;el&quot;]//span[@class=&quot;t3&quot;]/text()&#x27;</span>)<br>    salarys = tree.<span class="hljs-title function_">xpath</span>(<span class="hljs-string">&#x27;//div[@class=&quot;el&quot;]/span[@class=&quot;t4&quot;]/text()&#x27;</span>)<br>    times = tree.<span class="hljs-title function_">xpath</span>(<span class="hljs-string">&#x27;//div[@class=&quot;el&quot;]/span[@class=&quot;t5&quot;]/text()&#x27;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;职位&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;公司&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&quot;工作地方&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;薪水&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;时间&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;最低薪水&quot;</span>)<br>    sheet1.<span class="hljs-title function_">write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;最高薪水&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>,<span class="hljs-title function_">len</span>(salarys)):<br>        pos = positions[i].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;\t&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        sheet1.<span class="hljs-title function_">write</span>((x-<span class="hljs-number">1</span>)*<span class="hljs-number">50</span> + i, <span class="hljs-number">1</span>, pos)<br>        com = companys[i]<br>        sheet1.<span class="hljs-title function_">write</span>((x-<span class="hljs-number">1</span>)*<span class="hljs-number">50</span> +i, <span class="hljs-number">5</span>, com)<br>        workplace = workplaces[i]<br>        sheet1.<span class="hljs-title function_">write</span>((x-<span class="hljs-number">1</span>)*<span class="hljs-number">50</span> +i, <span class="hljs-number">8</span>, workplace)<br>        salary = salarys[i]<br>        sheet1.<span class="hljs-title function_">write</span>((x-<span class="hljs-number">1</span>)*<span class="hljs-number">50</span> +i, <span class="hljs-number">10</span>, salary)<br>        time = times[i]<br>        sheet1.<span class="hljs-title function_">write</span>((x-<span class="hljs-number">1</span>)*<span class="hljs-number">50</span> +i,<span class="hljs-number">12</span>,time)<br>        peace = salary.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>        #将数值与单位分离<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_">len</span>(peace)&gt; <span class="hljs-number">1</span>):<br>            peace[<span class="hljs-number">0</span>] = <span class="hljs-title function_">float</span>(peace[<span class="hljs-number">0</span>])<br>            #unit 是薪资的单位<br>            unit = peace[<span class="hljs-number">1</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>            data1 = peace[<span class="hljs-number">1</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;元&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;千&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;万&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;小时&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;天&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;月&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;年&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;以上&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>            num = <span class="hljs-title function_">float</span>(data1)<br>            #这里是将薪资的单位统一为 万/月<br>            <span class="hljs-keyword">if</span> (unit == <span class="hljs-string">&quot;元/小时&quot;</span>):<br>                salary_1 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((data2 * <span class="hljs-number">24</span> * <span class="hljs-number">30</span> / <span class="hljs-number">10000</span>),<span class="hljs-number">2</span>))<br>                salary_2 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((num * <span class="hljs-number">24</span> * <span class="hljs-number">30</span> / <span class="hljs-number">10000</span>),<span class="hljs-number">2</span>))<br>            elif (unit == <span class="hljs-string">&quot;元/天&quot;</span>):<br>                salary_1 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((peace[<span class="hljs-number">0</span>] * <span class="hljs-number">30</span> / <span class="hljs-number">10000</span>),<span class="hljs-number">2</span>))<br>                salary_2 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((num *<span class="hljs-number">30</span> / <span class="hljs-number">10000</span>),<span class="hljs-number">2</span>))<br>            <span class="hljs-title function_">elif</span>(unit == <span class="hljs-string">&quot;千/月&quot;</span>):<br>                salary_1 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((peace[<span class="hljs-number">0</span>]/<span class="hljs-number">10</span>),<span class="hljs-number">2</span>))<br>                salary_2 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((num/<span class="hljs-number">10</span>),<span class="hljs-number">2</span>))<br>            elif (unit == <span class="hljs-string">&quot;万/年&quot;</span>):<br>                salary_1 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((peace[<span class="hljs-number">0</span>] / <span class="hljs-number">12</span>),<span class="hljs-number">2</span>))<br>                salary_2 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((num / <span class="hljs-number">12</span>),<span class="hljs-number">2</span>))<br>            <span class="hljs-attr">else</span>:<br>                salary_1 = <span class="hljs-title function_">str</span>(peace[<span class="hljs-number">0</span>])<br>                salary_2 = <span class="hljs-title function_">str</span>(num)<br>            sheet1.<span class="hljs-title function_">write</span>((x - <span class="hljs-number">1</span>) * <span class="hljs-number">50</span> + i, <span class="hljs-number">14</span>, salary_1 + <span class="hljs-string">&quot;万/月&quot;</span>)<br>            sheet1.<span class="hljs-title function_">write</span>((x - <span class="hljs-number">1</span>) * <span class="hljs-number">50</span> + i, <span class="hljs-number">16</span>, salary_2 + <span class="hljs-string">&quot;万/月&quot;</span>)<br>        <span class="hljs-attr">else</span>:<br>            #unit 是薪资的单位<br>            unit = peace[<span class="hljs-number">0</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>            data2 = peace[<span class="hljs-number">0</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;元&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;千&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;万&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;小时&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;天&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;月&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;年&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;以上&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>            num = <span class="hljs-title function_">float</span>(data2)<br>            <span class="hljs-keyword">if</span> (unit == <span class="hljs-string">&quot;元/小时&quot;</span>):<br>                salary_3 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>((num * <span class="hljs-number">24</span> * <span class="hljs-number">30</span> / <span class="hljs-number">10000</span>),<span class="hljs-number">2</span>))<br><br>            <span class="hljs-title function_">elif</span>(unit == <span class="hljs-string">&quot;元/天&quot;</span>):<br>                salary_3 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>(num * <span class="hljs-number">30</span> / <span class="hljs-number">10000</span>))<br><br>            elif (unit == <span class="hljs-string">&quot;千/月&quot;</span>):<br>                salary_3 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>(num/<span class="hljs-number">10</span>))<br><br>            <span class="hljs-title function_">elif</span>(unit == <span class="hljs-string">&quot;万/年&quot;</span> or unit == <span class="hljs-string">&quot;万以上/年&quot;</span>):<br>                salary_3 = <span class="hljs-title function_">str</span>(<span class="hljs-title function_">round</span>(num / <span class="hljs-number">12</span>))<br><br>            elif (unit == <span class="hljs-string">&quot;万/月&quot;</span>):<br>                salary_3 = <span class="hljs-title function_">str</span>(num)<br>#如果提供的单位不是这几个中的一个，输出标记可自行查看！哈哈哈哈<br>            <span class="hljs-attr">else</span>:<br>                <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;我也没辙了&quot;</span>)<br>            sheet1.<span class="hljs-title function_">write</span>((x - <span class="hljs-number">1</span>) * <span class="hljs-number">50</span> + i, <span class="hljs-number">14</span>, salary_3 + <span class="hljs-string">&quot;万/月&quot;</span>)<br>            sheet1.<span class="hljs-title function_">write</span>((x - <span class="hljs-number">1</span>) * <span class="hljs-number">50</span> + i, <span class="hljs-number">16</span>, salary_3 + <span class="hljs-string">&quot;万/月&quot;</span>)<br><br>        #<span class="hljs-title function_">print</span>(<span class="hljs-title function_">len</span>(pos),<span class="hljs-title function_">len</span>(com),<span class="hljs-title function_">len</span>(workplace),<span class="hljs-title function_">len</span>(salary),<span class="hljs-title function_">len</span>(time))<br>    myxls.<span class="hljs-title function_">save</span>(<span class="hljs-string">&#x27;爬取结果.xls&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的创建与撤销 c++</title>
    <link href="/2020/04/18/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%92%A4%E9%94%80%20c++/"/>
    <url>/2020/04/18/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%92%A4%E9%94%80%20c++/</url>
    
    <content type="html"><![CDATA[<h2 id="实验一-线程的创建与撤销"><a href="#实验一-线程的创建与撤销" class="headerlink" title="实验一: 线程的创建与撤销"></a>实验一: 线程的创建与撤销</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><h3 id="一、实"><a href="#一、实" class="headerlink" title="一、实"></a>一、实</h3><p>(1)熟悉windows系统提供的线程创建与撤销系统调用.<br>(2)掌握windows系统环境下线程的创建与撤销方法.</p><h3 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h3><h5 id="1-线程的创建"><a href="#1-线程的创建" class="headerlink" title="1. 线程的创建"></a>1. 线程的创建</h5><p>CeateThread()完成线程的创建.它在调用进程的地址空间上创建一个线程,执行指定的函数,并返回新建立的线程的句柄.<br>原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">HANDLE</span> <span class="hljs-title class_">CeateThread</span>(<br><span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span> lpThreadAttributes,<br><span class="hljs-variable constant_">DWORD</span> dwStackSize,<br><span class="hljs-variable constant_">LPSECURITY_START_ROUTINE</span> lpStartAddress,<br><span class="hljs-variable constant_">LPVOID</span> lpparameter,<br><span class="hljs-variable constant_">DWORD</span> dwCreationFlags,<br><span class="hljs-variable constant_">LPDWORD</span> lpThreadId<br>);<br></code></pre></td></tr></table></figure><p>参数说明:</p><ol><li>lpThreadAttributes:为线程指定安全属性.为NULL时,线程得到一个默认的安全描述符.</li><li>dwStackSize:线程堆栈的大小.其值为0时,其大小与调用该线程的线程堆栈大小相同.</li><li>lpStartAddress:指定线程要执行的函数.</li><li>lpparameter:函数中要传递的参数.</li><li>dwCreationFlags:指定线程创建后所处的状态.若为CRRATE_SUSPENDED,表示创建后出于挂起状态,用ResumeThread()激活线程才可以执行.若该值为0，表示线程创建后立即执行.</li><li>lpThreadId:用一个32位的变量接受系统返回的线程标识符.若该值设为NULL,系统不返回线程标识符.<br>返回值:<br>如果线程创建成功,将返回线程的句柄;如果失败,系统返回NULL,可以调用函数GetLastError查询失败的原因.<br>用法举例:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">static</span> <span class="hljs-variable constant_">HANDLE</span> hHandle1=<span class="hljs-variable constant_">NULL</span>; <span class="hljs-comment">//用于存储线程返回句柄的变量</span><br><span class="hljs-variable constant_">DWORD</span> dwThreadID1;           <span class="hljs-comment">//用于存储线程标识符的变量</span><br><span class="hljs-comment">//创建一个名为ThreadName1的线程</span><br>hHandle1=<span class="hljs-title class_">CeateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>)) <span class="hljs-variable constant_">NULL</span><br>                     <span class="hljs-number">0</span>,<br> (<span class="hljs-variable constant_">LPSECURITY_START_ROUTINE</span>)<span class="hljs-title class_">ThreadName1</span>,<br> (<span class="hljs-variable constant_">LPDWORD</span>)<span class="hljs-variable constant_">NULL</span>,<br> <span class="hljs-number">0</span>,&amp;dwThreadID1);<br></code></pre></td></tr></table></figure></li></ol><h5 id="2-撤销线程"><a href="#2-撤销线程" class="headerlink" title="2. 撤销线程"></a>2. 撤销线程</h5><p>ExitThread()用于撤销当前进程.<br>原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">VOID</span> <span class="hljs-title class_">ExitThread</span>(<br><span class="hljs-variable constant_">DWORD</span> dwExitCode);   <span class="hljs-comment">//线程返回码</span><br></code></pre></td></tr></table></figure><p>参数说明:<br>dwExitCode:指定线程返回码,可以调用GetExitCodeThread()查询返回码的含义.<br>返回值:<br>该函数没有返回值.<br>用法举例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">ExitThread</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h5 id="3-终止线程"><a href="#3-终止线程" class="headerlink" title="3.终止线程"></a>3.终止线程</h5><p>TerminateThread()用于终止当前线程.该函数与ExitThread()的区别在于,ExitThread()在撤销线程时将该线程所拥有的资源全部归还给系统,而TerminateThread()不归还资源.<br>原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">BOOL</span> <span class="hljs-title class_">TerminateThread</span>(<br><span class="hljs-variable constant_">HANDLE</span> hHandle,       <span class="hljs-comment">//线程句柄</span><br><span class="hljs-variable constant_">DWORD</span> dwExitCode);    <span class="hljs-comment">//线程返回码</span><br></code></pre></td></tr></table></figure><p>参数说明:<br>(1)hThread:要终止线程的线程句柄.<br>(2)dwExitCode:指定线程返回码,可以调用GetExitCodeThread()查询返回码的含义.<br>返回值:<br>函数调用成功,将返回一个非0值;若失败,返回0，可以调用函数GetLastError()查询失败的原因.</p><h5 id="4-挂起线程"><a href="#4-挂起线程" class="headerlink" title="4.挂起线程"></a>4.挂起线程</h5><p>Sleep()用于挂起当前正在执行的线程.<br>原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">VOID</span> <span class="hljs-title class_">Sleep</span>(<span class="hljs-variable constant_">DWORD</span> dwMilliseconds);<br></code></pre></td></tr></table></figure><p>参数说明:<br>dwMilliseconds;指定挂起时间,单位为ms(毫秒).<br>返回值:<br>该函数没有返回值.</p><h5 id="5-关闭句柄"><a href="#5-关闭句柄" class="headerlink" title="5.关闭句柄"></a>5.关闭句柄</h5><p>函数CloseHandle()用于关闭已打开的对象的句柄,其作用与释放动态申请的内存空间类似,这样可以释放系统资源,使线程安全运行.<br>原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">BOOL</span> <span class="hljs-title class_">CloseHandle</span>(<span class="hljs-variable constant_">HANDLE</span> hObject);<br></code></pre></td></tr></table></figure><p>参数说明:<br>hObject:已打开对象的句柄.<br>返回值:<br>如果函数调用成功,则返回值为非0值;如果函数调用失败,则返回值为0.若要得到更多的错误信息,调用函数GetLastError()查询.</p><h3 id="三、内容"><a href="#三、内容" class="headerlink" title="三、内容"></a>三、内容</h3><p>使用系统调用CreatThread()创建一个子线程,并在子线程中显示;Thread is Running!.为了能让用户清楚地看到线程的运行情况,使用Sleep()使线程挂起5s,之后使用ExitThread(0)撤销进程.</p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>能正确使用CreatThread(),ExitThread()及Sleep()等系统调用,进一步理解进程与线程理论.</p><h4 id="指导"><a href="#指导" class="headerlink" title="指导"></a>指导</h4><p>本实验在WindowsXP,Microsoft Visual C++ 6.0环境下实现,利用Windows SDK提供的API完成程序的功能.实验在Windows XP环境下安装由于WindowsXP,Microsoft Visual C++ 6.0是一个集成开发环境,其中包含了Windows SDK 所有工具和定义,所以安装了WindowsXP,Microsoft Visual C++ 6.0后不用特意安装SDK.试验中所有的API是操作系统提供的用来进行应用程序开发的系统功能接口.</p><ol><li>首先启动安装好的,Microsoft Visual C++ 6.0.</li><li>在,Microsoft Visual C++ 6.0环境下选择File-&gt;new命令,然后在Project选项卡中选择Win32 Console Application建立一个控制台工程文件.</li><li>由于CreatThread()等函数是Microsoft Windows操作系统的系统调用,因此,在下图中选择An application that supports MFC,之后单击Finish按钮.</li></ol><p><img src="/../images/3a56ea2c-e9ac-4e39-8510-a4bf2277cdac.png" alt="在这里插入图片描述"></p><ol><li>创建一个单线程操作并观看结果<br><img src="/../images/8b825336-db16-432a-af97-2a961f3c9dfc.png" alt="在这里插入图片描述"><br><img src="/../images/a38b8e46-8195-4b9c-97a0-5476671a1daa.png" alt="在这里插入图片描述"></li><li>创建一个多线程操作，并观看结果<br><img src="/../images/3febb261-ea76-43e1-8974-57491f16d10f.png" alt="在这里插入图片描述"><br><img src="/../images/a2173715-7f80-4543-97a3-75fa46bb6377.png" alt="在这里插入图片描述"></li></ol><h4 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// test1.cpp : Defines the entry point for the console application.</span><br><span class="hljs-comment">//</span><br><br>#include <span class="hljs-string">&quot;stdafx.h&quot;</span><br>#include <span class="hljs-string">&quot;test1.h&quot;</span><br><br>#ifdef _DEBUG<br>#define <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">DEBUG_NEW</span><br>#undef <span class="hljs-variable constant_">THIS_FILE</span><br><span class="hljs-keyword">static</span> char <span class="hljs-variable constant_">THIS_FILE</span>[] = __FILE__;<br>#endif<br><br>/<br><span class="hljs-comment">// The one and only application object</span><br><br><span class="hljs-title class_">CWinApp</span> theApp;<br><br>using namespace std;<br><br><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">eatApple</span>(<span class="hljs-params">int apple_number</span>)<br>&#123;<br>    <br><span class="hljs-title class_">Sleep</span>((<span class="hljs-number">3</span>-apple_number)*<span class="hljs-number">1000</span>);<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;i&#x27;m eating apple #%d.\n&quot;</span>, apple_number);<br>&#125;<br><br><br>int <span class="hljs-title function_">_tmain</span>(<span class="hljs-params">int argc, TCHAR* argv[], TCHAR* envp[]</span>)<br>&#123;<br>    <br><span class="hljs-variable constant_">HANDLE</span> handle1 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">HANDLE</span> handle2 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">HANDLE</span> handle3 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID1</span> = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID2</span> = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID3</span> = <span class="hljs-variable constant_">NULL</span>;<br><br>int nRetCode;<br><br>int a = <span class="hljs-number">0</span>;<br>int b = <span class="hljs-number">1</span>;<br>int c = <span class="hljs-number">2</span>;<br><br>handle1 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) eatApple,<br>(<span class="hljs-variable constant_">LPVOID</span>) a,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID1</span>);<br><br>handle2 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) eatApple,<br>(<span class="hljs-variable constant_">LPVOID</span>) b,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID2</span>);<br><br>handle3 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) eatApple,<br>(<span class="hljs-variable constant_">LPVOID</span>) c,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID3</span>);<br><span class="hljs-title class_">Sleep</span>(<span class="hljs-number">10000</span>);<br><span class="hljs-keyword">return</span> nRetCode;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>在Windows系统中进程是资源的拥有者,线程是系统调用的单位.进程创建后,其主线程也随即被创建.但是单线程只能执行完一个之后再执行另外一个线程，而多线程在一定程度上是多个线程一起执行的。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的同步 c++</title>
    <link href="/2020/04/18/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/"/>
    <url>/2020/04/18/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="实验二-线程的同步"><a href="#实验二-线程的同步" class="headerlink" title="实验二: 线程的同步"></a>实验二: 线程的同步</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>1）进一步掌握windows系统环境下线程的创建和撤销<br>2）熟悉windows系统提供的线程同步API（是WINDOWS提供给应用程序与操作系统的接口）<br>3）使用windows系统提供的线程同步API解决实际问题</p><h3 id="二、实验准备"><a href="#二、实验准备" class="headerlink" title="二、实验准备"></a>二、实验准备</h3><h5 id="1-进程同步机制的主要任务："><a href="#1-进程同步机制的主要任务：" class="headerlink" title="1. 进程同步机制的主要任务："></a>1. 进程同步机制的主要任务：</h5><p>对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能够按照一定的规则（或时序）共享系统资源，并能很好地相互合作，从而使程序执行具有可再现性。</p><h5 id="2-线程和进程的发展历程"><a href="#2-线程和进程的发展历程" class="headerlink" title="2. 线程和进程的发展历程"></a>2. 线程和进程的发展历程</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">在<span class="hljs-number">20</span>世纪<span class="hljs-number">60</span>年代中期，人们在设计多道程序<span class="hljs-variable constant_">OS</span>时，引入了进程的概念，从而解决了在单处理机环境下的程序并发执行问题。此后在长达<span class="hljs-number">20</span>年的时间里，在多道程序<span class="hljs-variable constant_">OS</span>中一直以进程作为能拥有资源和独立调度的（运行）的基本单位。<br><br>直到<span class="hljs-number">80</span>年代中期，人们又提出了比进程更小的基本单位 线程 的概念，试图用它来提高程序并发执行的程度，以进一步改善系统的服务质量。特别是在进入<span class="hljs-number">20</span>世纪<span class="hljs-number">90</span>年代后，多处理机系统得到迅速发展，由于线程能更好的提高程序的并发执行程度，因而近几年推出的多处理机<span class="hljs-variable constant_">OS</span>无一例外地都引入了进程，用以改善<span class="hljs-variable constant_">OS</span>的性能。<br></code></pre></td></tr></table></figure><p>由于<strong>线程具有许多传统进程所具有的特征</strong>，所以又称之为轻型进程或进程元，相应的，把传统进程称之为重型进程。传统进程相当于只有一个线程的任务，</p><h5 id="3-等待对象函数"><a href="#3-等待对象函数" class="headerlink" title="3. 等待对象函数"></a>3. 等待对象函数</h5><p>等待一个对象 等待多个对象 WaitForSingleObject() WaitForMultipleObjects() 在指定时间内等待一个对象 在指定时间内等待多个对象</p><p><strong>原型：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">WaitForSingleObject</span>(<br><span class="hljs-variable constant_">HANDLE</span> hHandle,<span class="hljs-comment">//对象句柄</span><br><span class="hljs-variable constant_">DWORD</span> dwMilliseconds <span class="hljs-comment">//等待时间，以毫秒为单位</span><br>);<br></code></pre></td></tr></table></figure><p><strong>原型：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">WaitForMultipleObjects</span>(<br><span class="hljs-variable constant_">DWORD</span> nCount,<span class="hljs-comment">//句柄数组中的句柄数</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">HANDLE</span> *lpHandles,<span class="hljs-comment">//指向对象句柄数组的指针</span><br><span class="hljs-variable constant_">BOOL</span> fWaitAll<span class="hljs-comment">//等待类型 1/true表示等待所有的任务完成后进行下一个操作，0/flase 只等待任何一个的完成</span><br><span class="hljs-variable constant_">DWORD</span> dwMilliseconds <span class="hljs-comment">//等待时间，以毫秒为单位</span><br>);<br></code></pre></td></tr></table></figure><p><strong>可等待的对象列表</strong></p><ul><li>Change notification：变化通知</li><li>Console input：控制台输入</li><li>Events：事件</li><li>Job：作业</li><li>Mutex：互斥信号量</li><li>Process：进程</li><li><strong>Semaphore：计数信号量</strong> （<em>本次主要用到）</em></li><li><strong>Thread：线程</strong> <em>（本次主要用到）</em></li><li>Wait-able timer：定时器</li></ul><h4 id="如何去等待一个对象"><a href="#如何去等待一个对象" class="headerlink" title="如何去等待一个对象"></a>如何去等待一个对象</h4><ol><li><p>我们需要立一个Flag，用于在主子线程之间相互告知运行状态。</p></li><li><p>Flag &#x3D; 信号量</p></li><li><p>创建一个信号量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hHandle1 = <span class="hljs-title class_">CreateSemaphore</span>(<span class="hljs-variable constant_">NULL</span>, <span class="hljs-number">0</span>，<span class="hljs-number">1</span>, <span class="hljs-string">&quot;SemaphoreName1&quot;</span>);<span class="hljs-comment">//创建一个信号量（安全标识符，信号量初始态，信号量最大值，信号量名称）</span><br></code></pre></td></tr></table></figure></li><li><p>打开一个信号量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hHandle1 = <span class="hljs-title class_">OpenSemaphore</span>( <span class="hljs-variable constant_">SYNCHRONIZE</span> <span class="hljs-variable constant_">ISEMAPHORE_</span> <span class="hljs-variable constant_">MODIFY_</span> <span class="hljs-variable constant_">STATE</span>, <span class="hljs-variable constant_">NULL</span>,<span class="hljs-string">&quot;SemaphoreName1&quot;</span> );<span class="hljs-comment">//（访问标志，继承标志，信号量名）</span><br></code></pre></td></tr></table></figure></li><li><p>释放信号量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">rc = <span class="hljs-title class_">ReleaseSemaphore</span> (hHandle1, <span class="hljs-number">1</span>, <span class="hljs-variable constant_">NULL</span>)（我们需要释放哪一个信号量，对信号量进行增几的操作，信号量要增加数值地址）;<br></code></pre></td></tr></table></figure></li><li><p>等待单个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dRes = <span class="hljs-title class_">WaitForSingleObject</span>(hHandle1 , <span class="hljs-variable constant_">INFINITE</span>); <span class="hljs-comment">// 主线程无限期地等待子线程结束（信号量的句柄，如果没有释放无限运行）  如果对操作时长有限制，可在第二个参数设置等待的最大值</span><br></code></pre></td></tr></table></figure></li><li><p>等待多个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dRes = <span class="hljs-title class_">WaitForMultiple0</span>bjects(<span class="hljs-number">3</span>, hHandles, <span class="hljs-number">1</span>, <span class="hljs-variable constant_">INFINITE</span>); <span class="hljs-comment">//第三个参数为1或true时，等待数组中所有对象完成，为0或者false时满足一个任务结束就可继续执行</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h3><p><strong>实验一 线程的同步之等待单个对象</strong><br>子线程 主线程 用于制作麻辣香锅，制作用时5秒 等待子线程执行完毕，打印“麻辣香锅上菜完毕，请开动吧！”</p><p><strong>实验二 线程的同步之等待多个对象</strong></p><p>子线程1 子线程2 子线程3 主线程 用于制作麻辣香锅，制作用时5秒 用于制作什锦菇，制作用时3秒 用于制作米饭，制作用时6秒 等待多个子线程执行完毕，打印”所有菜品上菜完毕，请开动吧！“</p><h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><p>能正确使用等待对象、WaitForSingleObject（）或WaitForMultipleObject（)及信号量对象CreateSemaphore（）、OpenSemaphore（）、ReleaseSemaphore（）等系统调用，进一步理解线程的同步。</p><h4 id="实验指导"><a href="#实验指导" class="headerlink" title="实验指导"></a>实验指导</h4><p>1.在Microsoft visual C++6.0环境下建立一个MFC支持的控制台文件，编写C程序。<br>2.在程序中使用CreateSemaphore（NULL，0，1，”SemaphoreName1”）创建一个名为“SemaphoreName1”的信号量，信号量的初始值为0。<br>之后使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">OpenSemaphore</span>（<span class="hljs-variable constant_">SYNCHRONIZE</span>|<span class="hljs-variable constant_">SEMAPHORE_MODIFY_STARTE</span>,<span class="hljs-variable constant_">NULL</span>, ”<span class="hljs-title class_">SemaphoreName1</span>）<br></code></pre></td></tr></table></figure><p>打开该信号量，这里访问标志使用“SYNCHRONIZE|SEMAPHORE_MODIFY_STARTE”，<br>以便之后可以使用WaitForSingleObject（）等待该信号量及使用ReleaseSemaphore（）释放该信号量，然后创建一个子线程。</p><p>3.主线程创建子线程后调用WaitForSingleObject（hHandle1，INFINITE），这里等待时间设置为INFINITE表示一直等待下去，直到该信号量被唤醒为止。</p><p>4.子线程结束，调用ReleaseSemaphore（hHandle1，1，NULL）释放信号量，使信号量的值加1。</p><h4 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h4><p><strong>实验一主要内容及代码</strong></p><ul><li>创建一个信号量并打开，创建一个线程，主线程等待子线程结束，释放信号量。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">static</span> <span class="hljs-variable constant_">HANDLE</span> hHandle1 = <span class="hljs-variable constant_">NULL</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">chef</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;麻辣香锅开始制作，预计等待时间5秒。\n&quot;</span>);<br><span class="hljs-title class_">Sleep</span>(<span class="hljs-number">5000</span>);<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;麻辣香锅制作完成！\n&quot;</span>);<br><br><span class="hljs-variable constant_">BOOL</span> rc;<br><span class="hljs-variable constant_">DWORD</span> err;<br><br>rc = <span class="hljs-title class_">ReleaseSemaphore</span>(hHandle1,<span class="hljs-number">1</span>,<span class="hljs-variable constant_">NULL</span>);<br>err = <span class="hljs-title class_">GetLastError</span>();<br><br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;ReleaseSemaphore err=%d\n&quot;</span>,err);<br><span class="hljs-keyword">if</span>(rc == <span class="hljs-number">0</span>)&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphore Release Fail!\n&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphore Release Success! rc=%d\n&quot;</span>,rc);<br>&#125;<br>&#125;<br><br><br>int <span class="hljs-title function_">_tmain</span>(<span class="hljs-params">int argc, TCHAR* argv[], TCHAR* envp[]</span>)<br>&#123;<br>    <br><br>int nRetCode = <span class="hljs-number">0</span>;<br><br><span class="hljs-variable constant_">DWORD</span> dRes,err;<br><br>hHandle1 = <span class="hljs-title class_">CreateSemaphore</span>(<span class="hljs-variable constant_">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;SemaphoreName1&quot;</span>);<span class="hljs-comment">//创建一个信号量</span><br><span class="hljs-keyword">if</span>(hHandle1 == <span class="hljs-variable constant_">NULL</span>)&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphore Create Fail!\n&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphore Create Success!\n&quot;</span>);<br>&#125;<br><br>hHandle1 = <span class="hljs-title class_">OpenSemaphore</span>(<span class="hljs-variable constant_">SYNCHRONIZE</span>|<span class="hljs-variable constant_">SEMAPHORE_MODIFY_STATE</span>,<br><span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-string">&quot;SemaphoreName1&quot;</span>);<br><span class="hljs-keyword">if</span>(hHandle1 == <span class="hljs-variable constant_">NULL</span>)&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphor Open Fail!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Semaphor Open Success!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-variable constant_">HANDLE</span> handle1 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID1</span> = <span class="hljs-variable constant_">NULL</span>;<br><br>handle1 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) chef,<br>(<span class="hljs-variable constant_">LPVOID</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID1</span>);<br><br>dRes = <span class="hljs-title class_">WaitForSingleObject</span>(hHandle1,<span class="hljs-variable constant_">INFINITE</span>);<br><br>err = <span class="hljs-title class_">GetLastError</span>();<br><br><span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>)&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;麻辣香锅上菜完毕，请开动吧。\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;WaitForSingleObject err = %d\n&quot;</span>,err);<br>&#125;<br><br><span class="hljs-keyword">return</span> nRetCode;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>效果图</strong><br><img src="/../images/56e1d34c-0c4a-4f71-907f-71ca2ee11143.png" alt="在这里插入图片描述"></p><p><strong>实验二主要内容及代码</strong></p><ul><li>创建三个线程，当三个线程都执行完毕时，执行主线程<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">chef</span>(<span class="hljs-params">int meal_code</span>)<br>&#123;<br>    <br><br><span class="hljs-keyword">if</span>(meal_code == <span class="hljs-number">0</span>)&#123;<br>    <br><span class="hljs-title class_">Sleep</span>(<span class="hljs-number">5000</span>);<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;麻辣香锅制作完成！\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(meal_code == <span class="hljs-number">1</span>)&#123;<br>    <br><span class="hljs-title class_">Sleep</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;什锦菇制作完成！\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(meal_code == <span class="hljs-number">2</span>)&#123;<br>    <br><span class="hljs-title class_">Sleep</span>(<span class="hljs-number">6000</span>);<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;米饭制作完成！\n&quot;</span>);<br>&#125;<br><br>&#125;<br><br><br>int <span class="hljs-title function_">_tmain</span>(<span class="hljs-params">int argc, TCHAR* argv[], TCHAR* envp[]</span>)<br>&#123;<br>    <br><br>int nRetCode = <span class="hljs-number">0</span>;<br><br><span class="hljs-variable constant_">DWORD</span> dRes,err;<br><br><span class="hljs-variable constant_">HANDLE</span> handle1 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">HANDLE</span> handle2 = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">HANDLE</span> handle3 = <span class="hljs-variable constant_">NULL</span>;<br><br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID1</span> = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID2</span> = <span class="hljs-variable constant_">NULL</span>;<br><span class="hljs-variable constant_">DWORD</span> <span class="hljs-title class_">ThreadID3</span> = <span class="hljs-variable constant_">NULL</span>;<br><br>int a = <span class="hljs-number">0</span>;<br>int b = <span class="hljs-number">1</span>;<br>int c = <span class="hljs-number">2</span>;<br><br>handle1 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) chef,<br>(<span class="hljs-variable constant_">LPVOID</span>) a,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID1</span>);<br><br>handle2 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) chef,<br>(<span class="hljs-variable constant_">LPVOID</span>) b,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID2</span>);<br><br>handle3 = <span class="hljs-title class_">CreateThread</span>((<span class="hljs-variable constant_">LPSECURITY_ATTRIBUTES</span>) <span class="hljs-variable constant_">NULL</span>,<br><span class="hljs-number">0</span>,<br>(<span class="hljs-variable constant_">LPTHREAD_START_ROUTINE</span>) chef,<br>(<span class="hljs-variable constant_">LPVOID</span>) c,<br><span class="hljs-number">0</span>,<br>&amp;<span class="hljs-title class_">ThreadID3</span>);<br><br><span class="hljs-variable constant_">HANDLE</span> hHandles[<span class="hljs-number">3</span>];<br>hHandles[<span class="hljs-number">0</span>] = handle1;<br>hHandles[<span class="hljs-number">1</span>] = handle2;<br>hHandles[<span class="hljs-number">2</span>] = handle3;<br><br>dRes = <span class="hljs-title class_">WaitForMultipleObjects</span>(<span class="hljs-number">3</span>,hHandles,<span class="hljs-number">0</span>,<span class="hljs-variable constant_">INFINITE</span>);<br><br>err = <span class="hljs-title class_">GetLastError</span>();<br><br><span class="hljs-keyword">if</span>(err == <span class="hljs-number">0</span>)&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;所有菜品上菜完毕，请开动吧。\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;WaitForSingleObject err = %d\n&quot;</span>,err);<br>&#125;<br><br><span class="hljs-keyword">return</span> nRetCode;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>效果图</strong><br><img src="/../images/b98bdea7-4a78-4795-a55d-49ff2e963d84.png" alt="在这里插入图片描述"><br>但是当我们的选择等待的对象为任意一个，即第三个参数为0时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dRes = <span class="hljs-title class_">WaitForMultipleObjects</span>(<span class="hljs-number">3</span>,hHandles,<span class="hljs-number">0</span>,<span class="hljs-variable constant_">INFINITE</span>);<br></code></pre></td></tr></table></figure><p><strong>效果图为：</strong><br><img src="/../images/d1b0d65d-7900-46f6-94db-c01fa5a0b819.png" alt="在这里插入图片描述"></p><h3 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h3><p>实验完成了主、子线程的同步，主线程创建子线程后，主线程塞，让子线程先执行，等子线程执行完后，由子线程唤醒主线程。是使我们了解如何使用使用等待对象WaitForSingleObject（）或WaitForMultipleObjects（)及信号量对象CreateSemaphore（）、OpenSemaphore（）、ReleaseSemaphore（）等系统调用，进一步理解线程的同步。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】三角形最大周长算法</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF%E7%AE%97%E6%B3%95/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161542552.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161542553.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161542554.png" alt="在这里插入图片描述"></p><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    public int <span class="hljs-title function_">largestPerimeter</span>(<span class="hljs-params">int[] A</span>) &#123;<br>    <br>        int len = A.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">3</span>)&#123;<br>    <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">sort</span>(A);<br>        <span class="hljs-keyword">while</span>(len-<span class="hljs-number">3</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>    <br>            <span class="hljs-keyword">if</span>(A[len-<span class="hljs-number">1</span>]-A[len-<span class="hljs-number">2</span>] &lt; A[len-<span class="hljs-number">3</span>])&#123;<br>    <br>                <span class="hljs-keyword">return</span> A[len-<span class="hljs-number">1</span>]+A[len-<span class="hljs-number">2</span>]+A[len-<span class="hljs-number">3</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>    <br>                len = len-<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】变进制数</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%8F%98%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%8F%98%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161542724.png" alt="在这里插入图片描述"></p><p>答案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br>int[] jinzhi = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>&#125;;<br><span class="hljs-title class_">String</span> string = scanner.<span class="hljs-title function_">next</span>();<br>int len = string.<span class="hljs-title function_">length</span>();<br>int res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;<br>    <br>char ch = string.<span class="hljs-title function_">charAt</span>(i);<br>int x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(ch &lt;= <span class="hljs-number">57</span>) &#123;<br>    <br>x = ch-<span class="hljs-number">48</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <br>x = ch-<span class="hljs-number">97</span>;<br>&#125;<br>res = (res+x) * jinzhi[len-i-<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(res);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】回溯算法之八皇后问题</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B9%8B%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B9%8B%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="要求用回溯法求解-8-皇后问题"><a href="#要求用回溯法求解-8-皇后问题" class="headerlink" title="要求用回溯法求解 8-皇后问题"></a>要求用回溯法求解 8-皇后问题</h4><p>八皇后问题：使放置在 8&#x2F;*8 棋盘上的 8 个皇后彼此不受攻击。</p><p>即：任何两个皇后都不在同一行、同一列或同一斜线上。</p><p>请输出 8 皇后问题的所有可行解的总数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">EightQueen</span> &#123;<br><br>    public <span class="hljs-keyword">static</span> int[][] array = <span class="hljs-keyword">new</span> int[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br>    public <span class="hljs-keyword">static</span> int sum;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br><br>        <span class="hljs-title function_">search</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(sum);<br><br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">int i</span>)&#123;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">7</span>)&#123;<br>            sum++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-title function_">check</span>(i, j))&#123;<br>                array[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-title function_">search</span>(i+<span class="hljs-number">1</span>);<br>                array[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> boolean <span class="hljs-title function_">check</span>(<span class="hljs-params">int i, int j</span>)&#123;<br>        <span class="hljs-keyword">for</span>(int k = <span class="hljs-number">0</span>; k &lt; i; k++)&#123;<br>            <span class="hljs-keyword">if</span>(array[k][j] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(int m = i-<span class="hljs-number">1</span>, n = j-<span class="hljs-number">1</span>; m&gt;=<span class="hljs-number">0</span>&amp;&amp; n&gt;=<span class="hljs-number">0</span>; m--, n--)&#123;<br>            <span class="hljs-keyword">if</span>(array[m][n] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(int m = i-<span class="hljs-number">1</span>, n = j+<span class="hljs-number">1</span>; m&gt;=<span class="hljs-number">0</span>&amp;&amp; n&lt;=<span class="hljs-number">7</span>; m--, n++)&#123;<br>            <span class="hljs-keyword">if</span>(array[m][n] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】 回溯算法之装载问题</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B9%8B%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B9%8B%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>用回溯法编写一个递归程序解决如下装载问题：<br>有 n 个集装箱要装上 2 艘载重分别为 c1 和 c2的轮船，其中集装箱 i 的<br>重量为 wi（1≤ i ≤ n），且∑ 𝑤𝑖 ≤ 𝑐1 + 𝑐2 。<br>问是否有一个合理的装载方案可以将这 n 个集装箱装上这 2 艘轮船？如果有，请给出装载方案。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>当 n&#x3D;3，c1&#x3D;c2&#x3D;50，且 w&#x3D;[10,40,40]时，可以将集装箱 1 和 2 装到第一艘轮船上，集装箱3装到第二艘轮船上；<br>如果 w&#x3D;[20,40,40]时，无法将这 3 个集装箱都装上轮船。</p><p>Java代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">ArrayList</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">List</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Load</span> &#123;<br><br>    public <span class="hljs-keyword">static</span> int weight1;  <span class="hljs-comment">//记录第一艘船的载重能力</span><br>    public <span class="hljs-keyword">static</span> int weight2;  <span class="hljs-comment">//记录第二艘船的载重能力</span><br><br>    public <span class="hljs-keyword">static</span> int sum1 = <span class="hljs-number">0</span>,sum2 = <span class="hljs-number">0</span>;        <span class="hljs-comment">//分别代表此时第一艘船的载重和所有集装箱的总重量</span><br>    public <span class="hljs-keyword">static</span> int[] arr;                    <span class="hljs-comment">//记录集装箱的重量</span><br>    public <span class="hljs-keyword">static</span> int n;                        <span class="hljs-comment">//集装箱的个数</span><br>    public <span class="hljs-keyword">static</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">Integer</span>&gt;(); <span class="hljs-comment">//第一艘船的集装箱的装载的重量</span><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br>        n = scanner.<span class="hljs-title function_">nextInt</span>();<br>        arr = <span class="hljs-keyword">new</span> int[n];<br>        weight1 = scanner.<span class="hljs-title function_">nextInt</span>();<br>        weight2 = scanner.<span class="hljs-title function_">nextInt</span>();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            arr[i] = scanner.<span class="hljs-title function_">nextInt</span>();<br>            sum2 += arr[i];<br>        &#125;<br>        scanner.<span class="hljs-title function_">close</span>();<br>        <span class="hljs-title function_">backtrack</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">int i</span>) &#123;<br>        <span class="hljs-keyword">if</span>(sum1 &gt; weight1) &#123;   <span class="hljs-comment">// 如若超载，则回溯</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == n) &#123;<br>            <span class="hljs-keyword">if</span>(sum2 - sum1 &lt; weight2) &#123;      <br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(list);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        sum1 += arr[i];<br>        list.<span class="hljs-title function_">add</span>(arr[i]);<br>        <span class="hljs-title function_">backtrack</span>(i+<span class="hljs-number">1</span>);<br>        sum1 -= arr[i];<br>        list.<span class="hljs-title function_">remove</span>(list.<span class="hljs-title function_">size</span>()-<span class="hljs-number">1</span>);<br>        <span class="hljs-title function_">backtrack</span>(i+<span class="hljs-number">1</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】完美的代价</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="试题-基础练习-完美的代价"><a href="#试题-基础练习-完美的代价" class="headerlink" title="试题 基础练习 完美的代价"></a>试题 基础练习 完美的代价</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><strong>问题描述</strong><br>回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。<br>交换的定义是：交换两个相邻的字符<br>例如mamad<br>第一次交换 ad : mamda<br>第二次交换 md : madma<br>第三次交换 ma : madam (回文！完美！)</p><p><strong>输入格式</strong><br>第一行是一个整数N，表示接下来的字符串的长度(N &lt;&#x3D; 8000)<br>第二行是一个字符串，长度为N.只包含小写字母<br><strong>输出格式</strong><br>如果可能，输出最少的交换次数。<br>否则输出Impossible<br><strong>样例输入</strong><br>5<br>mamad</p><p><strong>样例输出</strong><br>3</p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>字符串的长度有奇数和偶数两种可能。</p><p>Impossible有两种可能：<br>1，字符串长度为奇数，且至少含有两个只出现一次的字符<br>2，字符串长度为偶数，且含有一个或多个只出现一次的字符</p><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><p>-》从字符数组的第一个位置开始，从后向前遍历寻找与其相同的字符。<br>-》》》如果出现该字符，且并不是本身位置，那么将字符移到回文相对应的位置。<br>-》》》如果找到该字符，且为本身位置，那么这个字符只出现了一次<br>-》》》》》如若数组长度为偶数或曾经出现过单个字符，则打印impossible<br>-》》》》》如若数组长度为奇数，记录曾出现过单个字符，并且该字符移向字符数组中间</p><h5 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br><br>int n;<br>n = scanner.<span class="hljs-title function_">nextInt</span>();<br><span class="hljs-title class_">String</span> str;<br>str = scanner.<span class="hljs-title function_">next</span>();<br>scanner.<span class="hljs-title function_">close</span>();<br>char[] chs = str.<span class="hljs-title function_">toCharArray</span>();<br>int j = n-<span class="hljs-number">1</span>,count=<span class="hljs-number">0</span>,flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>    <br><span class="hljs-keyword">for</span>(int k=j; k &gt;= i; k--) &#123;<br>    <br><span class="hljs-keyword">if</span>(i==k) &#123;<br>    <br><span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> || flag==<span class="hljs-number">1</span>) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Impossible&quot;</span>);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>flag = <span class="hljs-number">1</span>;<br>count += n / <span class="hljs-number">2</span> - i;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(chs[i] == chs[k])&#123;<br>    <br><span class="hljs-keyword">for</span>(int l = k; l &lt; j; l++)&#123;<br>    <br><span class="hljs-title function_">swap</span>(chs,l,l+<span class="hljs-number">1</span>);<br>count++;<span class="hljs-comment">//统计交换次数</span><br>            &#125;<br>            j--;<br>            <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(count);<br>&#125;<br><br>private <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">char chs[],int i,int j</span>) &#123;<br>    <br>char temp = chs[i];<br>chs[i] = chs[j];<br>chs[j] = temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】报数问题</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E6%8A%A5%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E6%8A%A5%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>哈哈哈，决定9月份考一下CCF认证，不知道能考50分还是100分，开始练习啦。</p><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543913.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/fuyingyou/picgo/raw/master/img_algorithm/202403161543914.png" alt="在这里插入图片描述"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>题目中说了不计入被跳过的数，也就是虽然你要报n个数，但是你最后报的数一定是大于等于n的。比如题目说明n小于等于666，但加上跳过的数字，其实报的数已经超过了700。所以我们需要考虑到百位甚至千位为7的情况。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br>int n;<br>n = scanner.<span class="hljs-title function_">nextInt</span>();<br>scanner.<span class="hljs-title function_">close</span>();<br><br>int[] arr = <span class="hljs-keyword">new</span> int[<span class="hljs-number">5</span>];<span class="hljs-comment">//用来记录四个人跳过的次数</span><br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">//初始化为0</span><br>arr[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>,flag=<span class="hljs-number">0</span>; flag &lt;n; i++) &#123;<br>    <span class="hljs-comment">//flag记录有效报数，即没有跳过的个数</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title class_">ContainSeven</span>(i)) &#123;<br>    <span class="hljs-comment">//如果跳过</span><br>arr[i%<span class="hljs-number">4</span>]++;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//如果不跳过，那么有效报数次数加一</span><br>flag++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-comment">//打印甲乙丙丁</span><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(arr[i]);<br>&#125;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br>public <span class="hljs-keyword">static</span> <span class="hljs-title class_">Boolean</span> <span class="hljs-title class_">ContainSeven</span>(int num)&#123;<br>    <span class="hljs-comment">//判断是否需要跳过函数，参数为当前数字</span><br>    <span class="hljs-keyword">if</span>(num%<span class="hljs-number">7</span>==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>    <br>    int t=num;<br>    <span class="hljs-keyword">while</span>(t&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>    <br>    <span class="hljs-keyword">if</span>(t%<span class="hljs-number">10</span>==<span class="hljs-number">7</span>)<span class="hljs-comment">//含有数字7</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】矩形面积重叠</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E9%87%8D%E5%8F%A0/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E9%87%8D%E5%8F%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="试题-基础练习-矩形面积交"><a href="#试题-基础练习-矩形面积交" class="headerlink" title="试题 基础练习 矩形面积交"></a>试题 基础练习 矩形面积交</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><strong>资源限制</strong><br>时间限制：1.0s 内存限制：512.0MB</p><p><strong>问题描述</strong><br>平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。<br><strong>输入格式</strong><br>输入仅包含两行，每行描述一个矩形。<br>在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。<br><strong>输出格式</strong><br>输出仅包含一个实数，为交的面积，保留到小数后两位。<br><strong>样例输入</strong><br>1 1 3 3<br>2 2 4 4</p><p><strong>样例输出</strong><br>1.00</p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p><img src="/../images/fbdb7a27-da62-45ca-b71d-dfb50755060e.png" alt="在这里插入图片描述"><br><img src="/../images/f1a01d92-4921-431b-942e-8f0f48b74711.png" alt="在这里插入图片描述"></p><p>经过简单的画图我们可以得知，我们需要的其实至少两个五角星位置的坐标。</p><p>那么这两个五角星的位置是什么呢？</p><p>其实就是两个矩形各自靠左的x坐标里面的右边的那一个，<br>俩矩形各自靠右的x坐标的左边那一个。<br>俩矩形各自靠上的y坐标的下面那一个，<br>俩矩形各自靠下的y坐标的上面那一个。</p><h5 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br>double x1 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double y1 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double x2 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double y2 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double x3 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double y3 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double x4 = scanner.<span class="hljs-title function_">nextDouble</span>();<br>double y4 = scanner.<span class="hljs-title function_">nextDouble</span>();<br><br>double a1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(x1, x2), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(x3, x4));<br>double b1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(y1, y2), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(y3, y4));<br>double a2 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(x1, x2), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(x3, x4));<br>double b2 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(y1, y2), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(y3, y4));<br><br><span class="hljs-keyword">if</span>((a1 &lt; a2) &amp;&amp; (b1 &lt; b2)) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%.2f&quot;</span>,(b2-b1)*(a2-a1));<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;0.00&quot;</span>);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】矩阵的幂运算</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E7%9F%A9%E9%98%B5%E7%9A%84%E5%B9%82%E8%BF%90%E7%AE%97/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E7%9F%A9%E9%98%B5%E7%9A%84%E5%B9%82%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="试题-基础练习-矩阵乘法"><a href="#试题-基础练习-矩阵乘法" class="headerlink" title="试题 基础练习 矩阵乘法"></a>试题 基础练习 矩阵乘法</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><strong>资源限制</strong><br>时间限制：1.0s 内存限制：512.0MB<br><strong>问题描述</strong><br>给定一个N阶矩阵A，输出A的M次幂（M是非负整数）<br>例如：<br>A &#x3D;<br>1 2<br>3 4<br>A的2次幂<br>7 10<br>15 22<br><strong>输入格式</strong><br>第一行是一个正整数N、M（1&lt;&#x3D;N&lt;&#x3D;30, 0&lt;&#x3D;M&lt;&#x3D;5），表示矩阵A的阶数和要求的幂数<br>接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值<br><strong>输出格式</strong><br>输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开<br><strong>样例输入</strong><br>2 2<br>1 2<br>3 4<br><strong>样例输出</strong><br>7 10<br>15 22</p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>这里我们需要注意，矩阵的幂可能为0，也就是说，我们需要考虑到输出01对角矩阵的情况。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>-》建立三个矩阵的二维数组，<br>-》如果幂为0，打印01对角矩阵<br>-》否则<br>-》》》循环<br>-》》》》》第一，二个矩阵相乘得第三个矩阵，而后将第三个矩阵赋值给第二个矩阵<br>-》》》打印输出第二个矩阵</p><h3 id="Java实现代码"><a href="#Java实现代码" class="headerlink" title="Java实现代码"></a>Java实现代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br>int n = scanner.<span class="hljs-title function_">nextInt</span>();<br>int m = scanner.<span class="hljs-title function_">nextInt</span>();<br>int[][] arr1 = <span class="hljs-keyword">new</span> int[n][n];<br>int[][] arr2 = <span class="hljs-keyword">new</span> int[n][n];<br>int[][] arr3 = <span class="hljs-keyword">new</span> int[n][n];<br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <br>arr1[i][j] = scanner.<span class="hljs-title function_">nextInt</span>();<br>arr2[i][j] = arr1[i][j];<br>&#125;<br>&#125;<br>scanner.<span class="hljs-title function_">close</span>();<br><br><span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) &#123;<br>    <br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <br><span class="hljs-keyword">if</span>( i == j ) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;1 &quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;0 &quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>();<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (int h = <span class="hljs-number">1</span>; h &lt; m; h++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <br>arr3[i][j] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (int k = <span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>; k &lt; n &amp;&amp; t&lt;n; k++,t++) &#123;<br>    <br>arr3[i][j] += arr1[i][t] * arr2[k][j];  <br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <br>arr2[i][j] = arr3[i][j];<br>&#125;<br>&#125;<br>&#125; <br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <br><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(arr2[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】螺旋矩阵</title>
    <link href="/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>问题描述</p><p>对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。<br>例如，一个 4 行 5 列的螺旋矩阵如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">6</span><br><span class="hljs-number">13</span> <span class="hljs-number">20</span> <span class="hljs-number">19</span> <span class="hljs-number">18</span> <span class="hljs-number">7</span><br><span class="hljs-number">12</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span>  <span class="hljs-number">9</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>输入格式</p><p>输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。<br>第二行包含两个整数 r, c，表示要求的行号和列号。</p><p>输出格式</p><p>输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。</p><p>样例输入</p><p>4 5<br>2 2</p><p>样例输出</p><p>15</p><p>评测用例规模与约定</p><p>对于 30% 的评测用例，2 &lt;&#x3D; n, m &lt;&#x3D; 20。<br>对于 70% 的评测用例，2 &lt;&#x3D; n, m &lt;&#x3D; 100。<br>对于所有评测用例，2 &lt;&#x3D; n, m &lt;&#x3D; 1000，1 &lt;&#x3D; r &lt;&#x3D; n，1 &lt;&#x3D; c &lt;&#x3D; m。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们只需要知道某个特定位置的值，所以我们并不需要建立二维数组去存储每一个值。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>按照矩阵螺旋的方向去遍历每一个行列的坐标，直到找到我们想要的坐标，然后输出相对应的值。</p><p>利用for循环遍历行，列，行，列，并且使用 k 表示当前位置的值。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <br><br><span class="hljs-title class_">Scanner</span> scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br><br>int n,m,r,c;  <br>int i,j,k;<br>int flag1,flag2;<br>n = scanner.<span class="hljs-title function_">nextInt</span>();<br>m = scanner.<span class="hljs-title function_">nextInt</span>();<br>r = scanner.<span class="hljs-title function_">nextInt</span>();<br>c = scanner.<span class="hljs-title function_">nextInt</span>();<br>scanner.<span class="hljs-title function_">close</span>();<br><br>flag1 = n;<span class="hljs-comment">//flag1用来控制行数范围</span><br>flag2 = m;<span class="hljs-comment">//flag2用来控制列数范围</span><br><br><br><span class="hljs-comment">//k表示当前位置的值</span><br><span class="hljs-comment">//i表示当前所在行</span><br><span class="hljs-comment">//j表示当前所在列</span><br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>, i=<span class="hljs-number">1</span>, j=<span class="hljs-number">1</span>; k &lt;= n*m ; ) &#123;<br>    <br><span class="hljs-keyword">for</span>( ; j &lt;= flag2; j++) &#123;<br>       <span class="hljs-comment">//行从左向右开始遍历</span><br><span class="hljs-keyword">if</span>( (i == r) &amp;&amp; (j == c)) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(k);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>k++;<br>&#125;<br>j--;<br><span class="hljs-keyword">for</span>(i = i+<span class="hljs-number">1</span> ; i &lt;= flag1; i++) &#123;<br>    <span class="hljs-comment">//列从上向下开始遍历</span><br><span class="hljs-keyword">if</span>( (i == r) &amp;&amp; (j == c)) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(k);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>k++;<br>&#125;<br>i--;<br><span class="hljs-keyword">for</span>(j = j-<span class="hljs-number">1</span>; j &gt; m-flag2 ; j--) &#123;<br>    <span class="hljs-comment">//行从右向左开始遍历</span><br><span class="hljs-keyword">if</span>( (i == r) &amp;&amp; (j == c)) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(k);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>k++;<br>&#125;<br>j++;<br><span class="hljs-keyword">for</span>(i = i-<span class="hljs-number">1</span>; i &gt; n-flag1+<span class="hljs-number">1</span>; i--) &#123;<br>    <span class="hljs-comment">//列从下向上开始遍历</span><br><span class="hljs-keyword">if</span>( (i == r) &amp;&amp; (j == c)) &#123;<br>    <br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(k);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>k++;<br>&#125;<br>i++;<br>j++;<br>flag1--;<br>flag2--;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>因为写这篇博客的时候还不知道这题过没过，仅测试了部分数据，如果问题，call me</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
